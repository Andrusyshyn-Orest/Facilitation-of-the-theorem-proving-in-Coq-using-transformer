{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 4,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "d6ca15d94f30cb6c9419c7b69673b5d38d203572",
        "torch_seed": 7
    },

    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 440,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      apply (wf_ind (A:=X) (Red (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos (clos_clos (clos (clos (clos (clos_clos (clos (clos_env x))) (clos (clos (clos_env x)))))\n                      (clos (clos (clos (clos (clos (clos (clos (clos_env x)))))\n                    (clos (clos (clos (clos (clos (clos (clos_env x)))) (clos (clos (clos (clos_env x)))))\n                      (clos (clos (clos (clos (clos_env x)))))\n                    (clos (clos (clos (clos (clos (clos_env x))) (clos (clos (clos (clos_env x))))\n                    (clos (clos (clos_env x)))\n                    (clos (clos (clos (clos_env x))) (clos (clos (clos (clos_env x))) (clos (clos (clos_env x)))))\n                      (clos (clos (clos (clos_env x))) (clos (clos (clos (clos_envQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      simple induction x; intros.\n      apply L.\n      apply L.\n      apply L.\n      apply R2.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      induction l.\n      simpl.\n      apply H0.\n      simpl.\n      apply H1.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      apply L.\n      apply L.\n      apply L.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Weak.  intros.\n      apply L.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n      intros.\n      apply (H (L a)).\n      apply (H0 (L a)).\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n      Proof.\n        unfold not.\n        apply comp.\n        intros. simpl in H.\n        destruct (X H).\n        destruct (X H).\n        left. assumption.\n      right. assumption.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Weak.\n      simple induction x; intros.\n      inversion H0.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      apply IHAbs.\n      applyQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros x.\n      apply L; assumption.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      induction l as [|l IHl]; intros; auto.\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H1).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H2).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H1).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H1).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H).\n      simpl.\n      intros.\n      destruct (IHll H1).\n      simpl.\n      intros.\n      destruct (IHll H0).\n      simpl.\n      intros.\n      destruct (IHll H).\n      simpl.\n      intros.\n      destruct (IHll H).\n      simpl.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 473,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      simple induction l.\n      simpl; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro y; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros y l x z H; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros y l x z H.  unfold Weak in *. apply X. assumption. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 561,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; generalize y; simpl; intros x z Der YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z Fl YWZ.\n      apply S_star with y; assumption.\n      destruct y as [ w YWZ].\n      exists w; auto.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H H0; elim H0; intros.\n      apply S_star with y; assumption.\n      apply R_trans with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; destruct l; simpl; intros x z Ru YWZ.\n      apply S_star with y; assumption.\n      destruct YWZ as [w YWZ].\n      exists w; auto.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; simpl; auto.\n      intros y l z H; simpl; auto.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; simpl; auto. Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; simpl; auto.\n      apply R_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; simpl; auto.\n      intros H1 H2; apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; destruct l; simpl; intros x z Fl YWZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z l; destruct l; simpl; intros x z Der YZ.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 633,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; generalize x; simpl; auto.\n      generalize y; simpl; auto.\n      destruct y; simpl; intros x z eg; destruct y; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z Hex; apply YWZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z Lex YZ.\n      apply S_star with y; assumption.\n      exists y; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros y l x z H; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z HBMA YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y.\n      generalize (inf_step x y); generalize (inf_step x y); generalize (inf_step x y); generalize (inf_step y x); generalize (inf_step y y);\n      generalize (inf_step y y); generalize (inf_step y x); generalize (inf_step y x);\n        generalize (inf_step y x); generalize (inf_step y y);\n        generalize (inf_step y x); generalize (inf_step y x);\n          generalize (inf_step y x); generalize (inf_step y x); generalize (inf_step y x);\n          generalize (inf_step y x); generalize (inf_step y x);\n            generalize (inf_step y x); generalize (inf_step y x);\n            generalize (inf_step y x); generalize (inf_step y x);\n            generalize (inf_step y x); generalize (inf_step y x); generalize (inf_step y x);\n            generalize (inf_step y x); generalize (inf_step y x);\n            generalize (inf_step y x); generalize (inf_step y x);\n            generalize (inf_step y x); generalize (infQed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x y; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x y; apply L; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 677,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (weak_refl (weak_refl (weak_refl (weak_refl (weak_refl (weak_refl (weak_refl (weak_refl (weak_refl _)))))));\n      [ apply lt_trans with y; assumption | apply gt_trans with y; assumption ].\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H H0.\n      apply (wf_ind_inv _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (well_founded_ind_rec _ _ _ H H); trivial.\n      apply T.\n      exists y; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (well_founded_ind (HA:=H)).\n      apply H.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply Rus_weak; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply H.\n      intros H H.\n      apply L; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (well_founded_induction_wf_ind H H0); assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 718,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (well_founded_ind_induction _ _ _ H); auto.\n      apply IH; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_refl.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; elim H; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (well_founded_ind _ _ _ H).\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply H; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_trans with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H H0.\n      apply H0 with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_star with y; assumption.\n    Qed."
                ]
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nunfold ex.\nintros.\ninduction xs as [ | x xs H].\n simpl in |- *.\nauto.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n simple induction 2; simpl in |- *; intros a H; elim H.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f a.\nelim (f a).\nintros a' H.\napply H.\nintros H0 H1.\napply H.\nintros a' H1.\napply H1.\nintros a' H2.\napply H1.\nintros a' H3.\napply H2.\nintros a' H3.\napply H2.\nintros a' H3.\napply H1.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros a' H3.\napply H3.\nintros aQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n simple induction xs as [ | a xs IH].\n simpl in |- *.\n intros a l.\n rewrite <- H.\n rewrite <- (plus_n_O_n (a :: l) a).\n simpl in |- *.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n reflexivity.\n intros a l.\n rewrite <- H.\n rewrite (plus_n_O (a :: l) a).\n simpl in |- *.\n rewrite <- plus_n_O.\n reflexivity.\n intros a l.\n rewrite <- H.\n rewrite (plus_n_O (a :: l) a).\n simpl in |- *.\n rewrite <- plus_n_O.\n reflexivity.\n intros a l.\n rewrite <- H.\n rewrite (plus_n_O (a :: l) a).\n simpl in |- *.\n rewrite <- plus_n_O.\n reflexivity.\n intros a l.\n rewrite <- H.\n rewrite (plus_n_O (a :: l) a).\n simpl in |- *.\n rewrite <- plus_n_O.\n reflexivity.\n intros a l.\n rewrite <- (plus_n_O (Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\ninduction A.\n simpl in |- *.\n tauto.\n simpl in |- *.\n intros.\n rewrite H0 in H.\n discriminate H.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs H.\nelim (f (fun a : A => b = f a /\\ In a xs)).\nelim H.\nintros H0 H1.\nrewrite <- H1.\nauto with arith.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\ninduction A as [ | A B f ] using A_ind_ind_ind.\n\n(* case where a is a tree *)\n simpl.\n intros.\n inversion H.\n intros.\n inversion H.\n intros.\n inversion H.\n intros.\n inversion H.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H0.\n intros.\n inversion H0.\n intros.\n inversion H0.\n intros.\n inversion H0.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H0.\n intros.\n inversion H1.\n intros.\n inversion H1.\n intros.\n inversion H1.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\ninduction xs as [ | x xs H ].\n simpl in |- *.\n trivial.\n intros.\n simpl in |- *.\n apply map_in.\n apply H.\n apply H.\n apply H0.\n apply map_in.\n apply H1.\n apply map_in.\n apply H0.\n apply map_in.\n apply H1.\n apply map_in.\n apply H1.\n apply map_in.\n apply H0.\n apply map_in.\n apply H1.\n apply map_in.\n apply H0.\n apply map_in.\n apply H1.\n apply map_in.\n apply H0.\n apply map_in.\n apply H1.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H0.\n apply map_in.\n apply H1Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n intros A B f a.\n case (A_eq_dec (f a) (f a)); intro H1.\n apply H1; auto.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\ninduction n.\n simpl in |- *.\n tauto.\n simpl in |- *.\n intros.\n rewrite <- H0.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n apply map_in.\n simpl in |- *.\n applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 214,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a l1 l2 H'0; elim H'0; auto.\nintros a0 l2 H'0; elim H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H'; elim H'; auto.\nintros a l1 H'0 H'1; elim H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H'0.\nrewrite <- (rev_involutive (f a)).\nrewrite <- (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (f a)).\nrewrite (rev_involutive (fQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' H'0; elim H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H' H'0; elim H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H' H'0; elim H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' H'0; elim H'0; auto.\nintros a l1 H'0; elim H'0; auto.\nintros a l1 H'1 H'2; elim H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 414,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l H; elim H; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0 H'1; elim H';\n [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; \n auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nsimple induction 1; simpl in |- *; auto.\nintros a l H'; elim H'; auto.\nintros a0 l H'; elim H'; auto.\nintros a0 l H'; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l H; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H; elim H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 524,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nunfold rev; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H'; elim H'; simpl in |- *; auto.\nintros a l H'0; elim H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 163,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition zeroP : Term -> Prop.\n  exact (fun m => forall x, m x = x)).\nDefined.",
                    "Definition zeroP : Term -> Prop.\n  exact (fun x => 0 = 0) _.\nDefined.",
                    "Definition zeroP : Term -> Prop.\n  unfold oneP.\n  simpl.\n  exact (A:=fun x => x).\n  Defined.",
                    "Definition zeroP : Term -> Prop.\n  exact (fun m => m = 0) -> forall n, m = 0.\nDefined.",
                    "Definition zeroP : Term -> Prop.\n  elim: forall x, x = 0.\n  intros; exact 0.\n  Defined.",
                    "Definition zeroP : Term -> Prop.\nAdmitted.\nEnd Term.\n\nTheorem add_ext : forall (A : Type) (R : A -> A -> Prop),\n  (forall x y : A, R x y -> R x y) ->\n  forall x y z : A, R x y -> R x z -> R y z.\nProof.\n  intros A R R x y z H.\n  split; intros H; apply H.\nDefined.",
                    "Definition zeroP : Term -> Prop.\n  (* 0 *)\n  let fix loop (n : nat) : Prop := n with\n  | O => fun _ => True\n  | S n => fun _ => n\n  end.\nEnd Term.\n\nDefinition oneP : Term -> Prop :=\n  fun x => (forall y, x = y -> P y) -> P x.\n\nDefinition sumM2 (R : Term -> Prop) :=\n  fun x y => (forall y, R y y -> P y) -> R y x.\n\nDefinition sumM2 (R : Term -> Prop) :=\n  fun x y => (forall y, R y y -> P y) -> R y x.\n\nDefinition sumM2 (R : Term -> Prop) :=\n  forall x y, R y x -> R y x.\n\nDefinition sumM2 (R : Term -> Prop) :=\n  forall x y, R x y -> R y x.\n\nDefinition sumM2 (R : Term -> Prop) :=\n  forall x y z, R y x -> R y z -> R x z.\n\nDefinition sumM2 (R : Term -> Prop) :=\n  forall x y z, R y x -> R y z -> RDefined.",
                    "Definition zeroP : Term -> Prop.\n  refine (fun m n => (forall x, m x -> n x) m).\n  (* The following lemma should be a workaround for Coq *)\n  let rec := match m with O => 0 | S n => S (succ n) end in\n  let rec := match m with O => 0 | S n => S (succ n) end in\n  let rec := match m with O => 1 | S n => S (succ n) end in\n  let rec := match m with O => 1 | S n => S (succ n) end in\n  let rec := match m with O => 1 | S n => S (succ n) end in\n  match n return (m x -> m x -> m x -> m x -> m x -> m x -> m x -> m x -> m x -> m x with\n  | O => 0\n  end.\nEnd Term.\n\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.\nArguments add [A] _ _.Defined.",
                    "Definition zeroP : Term -> Prop.\nProof.\n  split; [ exact (fun x => 0 = 0) | exact (fun x => 0 = 0) ].\n  exact (fun x => 0 = 0).\nDefined.",
                    "Definition zeroP : Term -> Prop.\nProof.\nunfold zeroP; intros h h; case h; case h; simpl;\n unfold oneP in *; unfold oneP in *;\n unfold oneP in *; unfold oneP in *;\n unfold oneP in *; unfold oneP in *; simpl in |- *.\nintros h h; case h; simpl in |- *; unfold oneP in |- *;\n unfold oneP in |- *; unfold oneP in |- *; simpl in |- *;\n unfold oneP in |- *; unfold oneP in |- *; simpl in |- *;\n unfold oneP in |- *; simpl in |- *; unfold oneP in |- *;\n unfold oneP in |- *; simpl in |- *; unfold oneP in |- *;\n unfold oneP in |- *; simpl in |- *; unfold oneP in |- *;\n unfold oneP in |- *; simpl in |- *; unfold oneP in |- *;\n unfold oneP in |- *; simpl in |- *; unfold oneP in |- *;\n unfold oneP in |- *; simpl in |- *;\n unfold oneP in |- *; ring.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 197,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1 H'2; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros x y H' H'0; case H'0; auto.\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nexact (H' a).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros H'2; exact (H'2 a H'1).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'; intros H'2.\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros.\napply (Build_Setoid (A:=A) (B:=A) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C)).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros H'; case H'.\ncase H'.\nintros H'0 H'1; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'; simpl in |- *; intros.\nexact (H a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; elim H'.\nintros a H'2 H'3 H'4; elim H'4; intros H'5 H'6; clear H'4 H'5.\nintros a H'1 H'4 H'6 H'7.\ngeneralize (H'1 a H'1 H'3); clear H' H' H'0 H'1 H'3 H'4 H'5 H'6.\ncase (H'0 a H'1 H'4); intros H'5 H'6; clear H' H'5.\ncase (H'0 a H'1 H'4); intros H'6 H'7; clear H' H'3 H'7.\nexists (comp (A:=A) a (comp_map (A:=A) a) (comp_map (A:=A) a) (comp_map a) (comp_map a) (comp_map a) H')).\napply\n Trans\n  with\n    (comp_map (A:=A) a (comp_map (A:=A) a) (comp_map a) H')).\napply Trans with (comp_map (A:=ADefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros H'; case H'; intros H'0 H'2.\napply H'; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 259,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; intros x y H'0; case H'.\nintros a b H'0; case H'0; auto.\nintros a b H'1; case H'1; auto.\nintros a' b' H'2; case H'1; auto.\nintros a' b' H'3; case H'3; auto.\nintros H'3 b' H'4; case H'3; auto.\nintros a' b' H'4; case H'4; auto.\nintros a' b' H'5; case H'5; auto.\nintros a' b' H'6; case H'5; auto.\nintros a' b' H'6; case H'6; auto.\nintros a' b' H'7; case H'6; auto.\nintros a' b' H'8; case H'6; auto.\nintros a' b' H'8; case H'7; auto.\nintros a' b' H'8; case H'7; auto.\nintros a' b' H'9; case H'7; auto.\nintros a' b'Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nintros a b H'; case H'; auto.\nintros a' H'0; case H'0; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; intros x y H'0.\nexact (eqA_trans b x y H' H'0).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros x y; elim x; intros y z H'1 H'2; exact (eqA a' H'1).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nunfold eqTerm.\nintros H'; case H'.\nintros x y H'0; exact (H'0 H'0).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\n  red; intros a a' H'0; elim H'.\nintros a' b' H'1 H'2; red in |- *; intros H'3; elim H'3;\n auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nunfold eqTerm; unfold eqTerm; unfold eqTerm; unfold eqTerm; unfold eqTerm;\n unfold eqTerm; unfold eqTerm; unfold eqsort; unfold eqTerm;\n unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n case compare_sort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n case compare_sort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort;\n case compare_sort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; simplsort;\n unfold eqsort; unfold eqsort;\n case compare_sort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqsort;\n unfold eqsort; unfold eqsort; unfold eqQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred; red; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nintros H'; case H'.\nintros a' b b'; exact (eqA a' b' H'1).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred; red; intros.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 293,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nauto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nunfold eqTerm in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nunfold eqTerm in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 350,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case y; simpl in |- *; auto.\napply (H x y); auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 435,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition T2M : Term -> mon n.\n  exact (eq_Term_trans _ _ _ _ _ _ _ _ cs).\n  Defined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Setoid (A:=M1) (B:=A) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C)).\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Setoid (A:=A) (B:=A) (B:=A) (B:=B)).\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\napply (eqA_trans _ _ _ _ _ _ cs); auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Map (A:=A) (B:=B)).\napply (Build_Map (A:=A) (B:=B)).\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nintros a b H'0; elim H'0; simpl in |- *; auto.\nintros a' b' H'1; elim H'0; simpl in |- *; auto.\nintros a' b' H'2; elim H'1; simpl in |- *; auto.\nintros a' b' H'3; elim H'2; simpl in |- *; auto.\nintros a' b' H'3; elim H'3; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n  exact (M1M M2M1 M2M2 M3 M4).\n\nTheorem T2M_1 : T2M = T2M.\nexact (M2M_1 M1 M2M2 M3M3 M4M4M_1 M4M_2 M4M4M_1 M4M_2 M4_1 M4M4_M4_M4M5_M6 M4_M6_M6_M7_M8_1).\nred in |- *.\nintros x y; case y; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Setoid (M1:=M1) (M2:=M2) (M1:=M2) (M1:=M2) (M1:=M2) (M2:=M2) (M1:=M2) (M2:=M2).\n  simpl in |- *.\n  intros x y z; case x; case y; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Setoid (A:=M1)).\napply (Build_Setoid (A:=M2M2)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M2M3))).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_Setoid (A:=M2M3)).\napply (Build_Setoid (A:=M3M3)).\napply (Build_SetoidDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_power (R:=R)) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R)Defined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Setoid (A:=A) (B:=A) (B:=A) (B:=B) (C:=A) (B:=A) (B:=C) (B:=A) (B:=B) (C:=C) (B:=A) (B:=A) (B:=B) (C:=C) (B:=A) (B:=C) (B:=C) (B:=A) (C:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=A) (B:=A) (B:=C) (C:=A) (B:=C) (C:=C) (B:=C) (B:=C) (B:=C) (B:=C) (C:=C) (B:=C) (B:=C) (B:=C) (C) (B:=C) (B:=C) (B:=C) (B:=C) (C) (B:=C) (B:=C) (B:=C) (C) (B:=C) (B:=C) (B:=C) (B:=C) (Defined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Setoid (R:=R) (A:=R) (B:=A) (B:=B) (B:=C) (B:=A) (B:=B) (B:=C) (B:=A) (B:=C) (B:=B) (B:=C) (B:=A) (B:=C) (B:=C) (B:=C) (B:=A) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C)Defined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 522,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intuition.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y H'; case H'; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intros x y z H'; elim H'; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; apply (rel_trans _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intros x y z; case x; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intros x y H'; exact (H x y H').\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros a b H'; case H'.\nintros a' H'0 H'1; rewrite H'0 in H'0.\napply Trans with (y := a'); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 543,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nunfold Symmetric in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nauto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 564,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 601,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nunfold rel in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nunfold Transitive in |- *; unfold eqT in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nauto using eqTerm_dec.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nunfold eqTerm in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 618,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "****)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; simpl in |- *.\nintros H; elim H; intros H' H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; simpl in |- *.\nintros b1 b2 c3.\ncase (cmp_dec a b1); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'1 H'2; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case a; simpl in |- *.\nintros H'0 H'1 H'2; red in |- *; intros H' H'3; rewrite H'3; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H; case H; simpl in |- *.\nintros H'; elim H'; intros H'0 H'1; clear H'; auto.\nintros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; simpl in |- *; auto.\nintros b2 c2 b3 c4.\ncase (cmp_dec a c2); intros eqAZ; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H H'; rewrite H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *.\nintros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; simpl in |- *; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; simpl in |- *.\nintros H'; elim H'; intros H'0 H'1; clear H'.\napply (H' a0 b0); auto.\nright; red in |- *; intros H'0 H'1; elim H'; intros H'0 H'1; clear H'.\napply (H' a0 b0); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintuition.\napply H0; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros H; elim H; auto.\nintros H; elim H; auto.\nintros H; elim H; auto.\nintros H; elim H; auto.\nintros H; elim H; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros x H'; elim H'; intros H'0 H'1; elim H'1; intros H'2 H'2; clear H'; auto.\nelim H'; intros H'0 H'0 H'1; elim H'1; intros H'1 H'2; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros x H'; elim H'; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'.\nexists x; split; [ idtac | idtac ].\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros x H'; elim H'; intros H'0 H'1; clear H'.\nintuition.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros H; elim H; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros a b H' H'0; elim H'0; auto.\nintros a' b' H'0 H'1 H'2 H'3 H'4; elim H'3; intros H'4 H'5; clear H'3.\nrewrite H'0; auto.\nintros a' b' H' H'0 H'1 H'2 H'3 H'4; elim H'4; intros H'5 H'6; clear H'3.\nrewrite H'0; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := B); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros a b H'; elim H'; intros H'0 H'1; clear H'.\nintros H' H'0; elim H'0; intros H'1 H'2; clear H'.\nintros H' H'0; elim H'0; intros H'1 H'2; clear H'.\nintros H'0 H'1; elim H'0; intros H'1 H'2; clear H'.\nintros H'0 H'1; elim H'0; intros H'0 H'2; clear H'.\nintros H'0; elim H'0; intros H'0 H'1; clear H'.\nintros H'0 H'1; elim H'0; intros H'1 H'2; clear H'.\nintros H'0; elim H'0; intros H'0 H'1; clear H'.\nintros H'0 H'1; elim H'0; intros H'1 H'2; clear H'.\nintros H'0; elim H'0; intros H'1 H'2; clear H'.\nintros H'0 H'1; elim HQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros H' H'0 H'1; elim H'0; intros H'1 H'2; clear H'.\nintros H' H'0 H'1; elim H'1; intros H'1 H'2; clear H'.\nintros H' H'0 H'1 H'2; elim H'1; intros H'3 H'4; clear H'.\nintros H'0 H'1 H'2; elim H'1; intros H'3 H'4; clear H'.\nintros H' H'0 H'1; elim H'0; intros H'3 H'4; clear H'.\nintros H'0 H'1 H'2; elim H'0; intros H'4 H'5; clear H'.\nintros H'0 H'1; elim H'0; intros H'4 H'5; clear H'.\nintros H'0 H'1; elim H'0; intros H'4 H'5; clear H'.\nintros H'0 H'1; elim H'0; intros H'4 H'5; clear H'.\nintros HQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 740,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case a; case b; simpl in |- *; auto.\nintros b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ H' _ _ cs); auto.\napply H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'.\napply H'0; auto.\napply H'.\napply H'.\napply H0; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case a; simpl in |- *.\nintros b H'.\napply H'.\napply H'.\napply H'.\napply H0.\napply H'.\napply H0.\napply H0.\napply H'.\napply H'.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0Qed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case H'; auto.\nintros H' H'0 H'1; elim H'0; intros H'2 H'3; clear H'.\napply Acc_intro with (b := A0); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; simpl in |- *.\nintros H'; apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := B0); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintros b H'.\napply (H a); auto.\napply (H a); auto.\napply (H a); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintros b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; simpl in |- *.\nintros a' b H'.\napply (cmp_eq a' b); auto.\napply (cmp_eq a' b); auto.\napply (cmp_eq a' b); auto.\napply (cmp_eq a' b'); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case (zeroP_dec a b); auto.\nintros a' b' H'0; case (zeroP_dec b' b'); auto.\nintros a' b' H'1; case (zeroP_dec b' b'); auto.\nintros a' b' H'2; case (zeroP_dec b' b'); auto.\nintros a' b' H'3; case (zeroP_dec b' b'); auto.\nintros a' b' H'3; case (zeroP_dec b' b'); auto.\nintros a' b' H'3; case (zeroP_dec b' b'); auto.\nintros a' b' H'4; case (zeroP_dec b' b'); auto.\nintros a' b' H'4; case (zeroP_dec b' b'); auto.\nintros a' b' H'5; case (zeroP_dec b' b'); auto.\nintros a' b' H'5; case (zeroP_dec b' b'); auto.\nintros a' b' H'5; case (zeroP_dec b' bQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'.\napply (H' a b); auto.\napply H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A1); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintros a' b' H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintros a' b' H'0; elim H'0; intros H'1 H'2; clear H'0.\napply H'1; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintros b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 757,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition plusTerm : Term -> Term -> Term.\napply (fun x => plus x x).\nexact (fun x => plus x x).\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H.\napply H.\napply H'.\napply H.\napply H'.\napply H.\napply H.\napply H'.\napply H'.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H'.\napply H.\napply H.\napply H.\napply H.\napply H.Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\napply (fun x => plusTerm x x).\nexact plus_comm.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H'; red in |- *; intros H' H'0.\napply H'.\napply H'.\napply H'.\napply H0.\napply H'.\napply H0.\napply H'.\napply H0.\napply H'.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\napply Build_Setoid_equiv with (R := Term); auto.\napply Build_Setoid_equiv with (R := Term); auto.\napply Build_Setoid_equiv with (R := Term); auto.\napply Build_Setoid_equiv with (R := Term); auto.\napply Build_Setoid_equiv with (R := Term); auto.\napply Build_Setoid_equiv with (R := Term); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nunfold Term; unfold sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, sub, subDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\napply (fun x : Term => plus x x).\nred in |- *; intros x y H'0; red in H'; elim H'; intros H'1;\n elim H'0; intros H'2 H'3; clear H'0.\nelim H'0; intros H'3 H'4; clear H'0.\nelim H'0; intros H'4 H'5; clear H'0.\nelim H'0; intros H'5 H'6; clear H'0.\nelim H'0; intros H'5 H'6; clear H'0.\nelim H'0; intros H'6 H'7; clear H'0.\nelim H'0; intros H'7 H'8; clear H'0.\nelim H'0; intros H'8 H'9; clear H'0.\nelim H'0; intros H'9 H'10; clear H'10.\nelim H'11; intros H'11 H'12; clear H'11.\nelim H'11; intros H'12 H'13; clear H'11.\nelim H'12; intros H'13 HDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\napply Build_Term_eq_dec.\napply Build_Term_eq_dec.\napply Build_order with (A := A) (B := A) (B := A) (B := B) (B := A) (B := A) (B := B).\napply Build_abelian_equality with (B := B) (B := A) (B := B).\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H' H'0; red in |- *; intros H'1.\napply (rel_dec a b); auto.\napply (rel_dec a b); auto.\napply (rel_dec a b); auto.\napply (rel_dec a b); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros; red in |- *; intros H' H'0.\nelim H'0; intros H'1 H'2; clear H'0.\nexists x; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H0.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply H'; auto with relations.\napply H'; auto with relations.\napply H'; auto with relations.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'; red in |- *.\napply zeroP_plus_stable with (a := a); auto.\napply Trans with (a := a); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'; red in |- *; intros H'0; elim H'; auto.\nintros a' b' H'0; rewrite H'0.\nrewrite H'; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply H'.\napply H'.\napply H'; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H0.\napply H'.\napply H0.\napply H'.\napply H0.\napply H'.\napply H'.\napply H'.\napply H0.\napply H'.\napply H'.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply HQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply H'; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H H'0 H'1; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := y); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H; red in |- *; intros H'1.\napply H'.\napply H'1; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply H2; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'0; elim H'0;\n auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := x0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; simpl in |- *; auto.\nintros a' b' H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a2); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; elim H'; auto.\nintros a1 m1 a2 m2 H' H'0; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := (a1, a2)).\napply H'; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; case a; simpl in |- *; auto.\nintros a' H'0 H'1; elim H'0; intros H'0 H'1; clear H'0; auto.\nintros a' H'1 H'2; elim H'0; intros H'3 H'3; clear H'0; auto.\nintros a' H'1 H'2; elim H'1; intros H'3 H'4; clear H'1; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; simpl in |- *; auto.\nintros a' b' H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := a'); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a'); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a'); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; simpl in |- *; auto.\nintros a1 m1 a2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; red in |- *; intros H'1 H2; elim H'1;\n auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (rel_assoc _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := (plusA a1 a2 a1));\n auto.\napply (rel_assoc _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_assoc _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\nintros a1 m2 a3 m3 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H H1 H2; split; auto.\nintros a1 m2 H2 H3 H4; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := (plusA a1 a2)); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := (plusA a1 a2)); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := (plusA a1 a2)); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; red in |- *; intros H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; red in |- *; intros H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; red in |- *; intros H H'1.\napply H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := y); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a2); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := (plusA a1 a2, b c)).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H H0 H1 H2; red in |- *; intros H1 H2.\napply H1.\napply H2.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := (plusA a c)); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := a2); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintros a' b' c' H H0 H1; split; auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := y'); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ csQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := y); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\nintros a1 m2 H2; split; auto.\nintros a1 m2 H3; split; auto.\nintros a1 m2 H3; split; auto.\nintros a1 m1 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a1 m2 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a1 m1 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a2 m2 H3; split; auto.\nintros a3 m3 H3; split; auto.\nintros a3 m3 H3; split; auto.\nintros a3 m3 H3; split; auto.\nintros a3 m3 H3; split; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x2); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintuition.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := x); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := y); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c H; case a; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (rel_comp_l _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := (x,y)) in H1; auto.\napply (rel_comp_r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x) in H2; auto.\napply (rel_comp_r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := x) in H2; auto.\napply (rel_comp_r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_comp_r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_comp_r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_comp_l _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintros a b c H H'0.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := (x,y)).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := (x,y)).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (rel_trans _Qed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintros a b c H H0 H1 H2; apply H2; auto.\nintros a' b' H H2; apply H2; auto.\nintros a' b' H H3; apply H3; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; simpl in |- *; auto.\nintros a' b' H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_transQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 737,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H; case x; simpl in |- *; auto.\nintuition.\nintuition.\napply (rel_dec x y); auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; red in H1.\nrewrite H1 in H1.\nrewrite H2 in H2.\nrewrite H3 in H2.\nrewrite H1 in H2.\ninversion H1.\ninversion H2.\nintros a1 m1 a2 m2 H2; red in H2.\nrewrite H2 in H2.\nrewrite H2 in H2.\nrewrite H3 in H2.\nrewrite H1 in H2.\ninversion H2.\nintros a1 m1 a2 m2 H2; red in H2.\nrewrite H2 in H2.\nrewrite H2 in H2.\ninversion H2.\nintros a1 m1 a2 m2 H1 H2; red in H2.\nrewrite H2 in H2.\nrewrite H2 in H2.\nrewrite H2 in H2.\ninversion H2.\nintros a1 m1 a2 m2 H2; red in H2.\nrewrite H2 in H2.\nrewrite H2 in H2.\nrewrite HQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; auto.\nintros x' y' H H'0 H'1 H'2; split; auto.\nintros x' y' H'0 H'3; red in |- *; intros H'1.\ncut (x = y').\nintros H' H'1; red in H'1.\ncut (x = y').\nintros H' H'1; red in H'1.\ncut (x = y').\nintros H' H'2; red in H'1.\ncut (x = y').\nintros H'3; red in H'1.\ncut (x = y').\nintros H'3; red in H'3.\ncut (x = y').\nintros H'5; red in H'3.\ncut (x = y').\nintros H'6; red in H'3.\ncut (x = y').\nintros H'6; red in H'4.\ncut (x = y').\nintros H'6; red in H'5.\ncut (x = y').\nintros H'6; red in H'6.\ncut (x = y').Qed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; auto.\nintros x' y' H1 H2; split; auto.\napply (relA B x' y'); auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintros a b c H1 H2; split; auto.\nintros a1 b1 c H1 H2; split; auto.\nintros a2 b2 c H1 H2; split; auto.\nintros a1 b1 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a1 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a1 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a1 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a1 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a2 c H1 H2; split; auto.\nintros a3 c H1 H2; split;Qed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; elim H; auto.\nintros a1 m2 H1; elim H1; auto.\nintros a2 m1 H2; elim H1; auto.\nintros a2 m2 H2; elim H2; auto.\nintros a3 m3 H2; elim H2; auto.\nintros a3 m3 H2; elim H2; auto.\nintros a3 m3 H2; elim H2; auto.\nintros a3 m3 H2; elim H2; auto.\nintros a3 m3 H2; elim H2; auto.\nintros a4 m3 H2; elim H2; auto.\nintros a4 m4 H2; elim H2; auto.\nintros a4 m4 H2; elim H2; auto.\nintros a5 m4 H2; elim H2; auto.\nintros a5 m4 H2; elim H2; auto.\nintros a5 m5 H2; elim H2; auto.\nintros a5 m6 H2; elim H1; auto.\nintros a5 m5 H2; elim H2; auto.\nintros aQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H1 H2; split; auto.\napply plusTerm_assoc1; auto.\napply plusTerm_trans1; auto.\napply plusTerm_assoc1; auto.\napply plusTerm_assoc2; auto.\napply plusTerm_comm; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H1 H2; red in |- *; intros H1 H2; elim H2; auto.\nintros a1 m2 H1 H2; red in |- *; intros H1 H2; elim H2; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H1; red in H1.\napply H1.\napply (eqv_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := zeroP m1); auto.\napply (eqv_trans _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := zeroP m2); auto.\napply (eqv_trans _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqv_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; simpl in |- *; auto.\nintros m1 m2 H1 H2; rewrite H1; auto.\nintros m1 m2 H2; rewrite H2; auto.\nintros m1 m2 H2; rewrite H1; auto.\nintros m1 m2 H2; rewrite H2; auto.\nintros m1 m2 H2; rewrite H2; auto.\nintros m1 m2 H1 H2; rewrite H1; auto.\nintros m1 m2 H2; rewrite H1; auto.\nintros m1 m2 H2; rewrite H2; auto.\nintros m1 m2 H2; rewrite H2; auto.\nintros m1 m2 H1 H2; rewrite H1; auto.\nintros m1 m2 H1 H2; rewrite H1; auto.\nintros m1 m2 H2; rewrite H2; auto.\nintros m1 m2 H1; rewrite H1; auto.\nintros m1 m2 H1 H2; rewrite H2; auto.\nintros m1 m2 H2; rewrite H1; auto.\nintros m1Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; simpl in |- *; auto.\nintros H1 H2; red in H1; red in H1; red in H1; red in H2; simpl in H2.\nintros H3 H4; red in H3; red in H3; simpl in H3.\nintros H4 H5; red in H3; simpl in H4.\nintros H5 H5; red in H4; simpl in H3.\nintros H5 H6; red in H3; simpl in H3.\nintros H5 H6; red in H5.\nintros H5 H6; red in H5.\nintros H6; red in H5.\nintros H6; red in H5.\nintros H6; red in H5.\napply H6.\napply H5.\napply H5.\napply H6.\napply H6.\napply H5.\napply H6.\napply H7.\napply H8.\napply H7.\napply H8.\napply H7.\napply H8.\napply H8.\napply H9.\napply H10.Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; simpl in |- *; auto.\nintros H H1 H2; case H1; auto.\nintros H1 H2; case H1; auto.\nintros H1 H2; case H1; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H1 H2; red in |- *; intros H1 H2.\napply H1.\napply H2.\napply H1.\napply H2.\napply H0.\napply H1.\napply H0.\napply H2.\napply H2.\napply H3.\napply H1.\napply H2.\napply H1.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; case m1; simpl in |- *; auto.\nintros H1 H2; rewrite H1; rewrite H2; rewrite H3; auto.\nintros H H1 H2; rewrite H1; rewrite H2; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H1 H2; red in |- *; intros.\napply H1.\napply H2.\napply H0.\napply H1.\napply H2.\napply H2.\napply H1.\napply H2.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H2.\napply H2.\napply H2.\napply H1.\napply H2.\napply H1.\napply H2.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H1 H2; split; auto.\napply H1.\napply H2.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H1.\napply H2.\napply H2.\napply H0.\napply H2.\napply H3.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m1; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nintros m1 m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; red in H; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; simpl in |- *; auto.\nintuition.\nintros a1 m2 H1 H2; elim H1; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; simpl in |- *; auto.\nintros m1 m2 m2 H1 H2; split; auto.\napply plusTerm_trans with (y := m2); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := m1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := m2); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := m2); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; simpl in |- *; auto.\nintuition.\nintuition.\napply plusTerm_trans with (x := x); auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H1 H2; red in H1; red in H1; simpl in H2; simpl in H2.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "P b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 714,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a0; simpl in |- *; auto.\nintros a0 A1 A2 A2 B1 B2 B3 B4; simpl in |- *; auto.\nintros a0 A2 A3 B3 B4; simpl in |- *; auto.\nintros a0 A3 B4; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2; case a0; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ", c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 718,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; split; auto.\napply (H a b c d H H0).\napply (H0 a0 b c d H H1).\napply (H2 a b c d H0 H2).\napply (H2 b c d H H2).\napply (H1 b c d H H2).\napply (H2 b c d H H0).\napply (H0 c d H H2).\napply (H1 b c d H2).\napply (H2 b c d H0 H2).\napply (H3 b c d H1 H2).\napply (H1 b c d H2).\napply (H3 b c d H2 H3).\napply (H3 b c d H3 H3).\napply (H4 b c d H3 H3).\napply (H4 b c d H4 H4).\napply (H4 b c d H4 H4).\napply (H5 c d H4 H4).\napply (H4 c d H4 H1).\napply (H4 c d H4 H1).\napply (H5 cQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; apply comp_eq; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := ls).\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_comm.\napply mult_comm.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napplyQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; red; intros.\nrewrite <- (H0 H1); rewrite <- (H2 H0).\nrewrite <- (H3 H1).\nrewrite <- (H0 H2).\nrewrite <- (H1 H1).\nrewrite (H1 H2).\nrewrite (H2 H0).\nrewrite (H1 H0).\nrewrite (H2 H2).\nrewrite (H3 H0).\nrewrite (H3 H1).\nrewrite (H3 H1).\nrewrite (H2 H2).\nrewrite (H3 H0).\nrewrite (H4 H2).\nrewrite (H1 H3).\nrewrite (H4 H1).\nrewrite (H3 H1).\nrewrite (H1 H3).\nrewrite (H3 H4).\nrewrite (H4 H0).\nrewrite (H4 H0).\nrewrite (H1 H2).\nrewrite (H0 H2).\nrewrite (H1 H2).\nrewrite (H3 H2).\nrewrite (H4 H0).\nrewrite (H1 H1).\nrewrite (H1 H2).\nrewrite (H3 HQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; case b; simpl in |- *; auto.\nintuition.\napply (rel_refl _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (relQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0 H1 H2; split; auto.\napply (comp_trans _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\napply (comp_trans _ _ _ _ _ _ _ _ _ _ _ _ H3 H3).\napply (comp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H3).\napply (comp_trans _ _ _ _ _ _ _ _ _ _ _ H1 H3).\napply (comp_trans _ _ _ _ _ _ _ _ H3 H1 H4).\napply (comp_trans _ _ _ _ _ _ _ _ _ H3 H1 H4).\napply (comp_trans _ _ _ _ _ _ _ H1 H4).\napply (comp_trans _ _ _ _ _ _ H4 H3 H0).\napply (comp_trans _ _ _ _ _ _ H3 H4).\napply (comp_trans _ _ _ _ _ _ H1 H4 H0).\napply (comp_trans _ _ _ _ _ H1 _ H4).\napply (comp_trans _ _ _ _ _ HQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H1 H2; red in H1; unfold eqTerm in H2; unfold eqTerm in H3; unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\nunfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\nunfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3; unfold eqtyp in H3;\n unfold eqtyp in H3; unfold eqtyp in H3Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs).\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs).Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; case a; simpl in |- *; auto.\nintuition.\napply (H0 a0).\napply (H1 a0).\napply (H1 b0).\napply (H2 b0).\napply (H2 b0).\napply (H2 b0).\napply (H3 b0).\napply (H3 b0).\napply (H1 b0).\napply (H2 b0).\napply (H2 b0).\napply (H3 b0).\napply (H3 b0).\napply (H3 b0).\napply (H1 b0).\napply (H3 b0).\napply (H3 b0).\napply (H4 b0).\napply (H3 b0).\napply (H1 b0).\napply (H3 b0).\napply (H1 b0).\napply (H3 b0).\napply (H3 b0).\napply (H1 b0).\napply (H1 b0).\napply (H3 b1).\napply (H3 b0).\napply (H1 b0).\napply (HQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; case a; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs).\napply mult_proper; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs).\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper; auto.\napply mult_proper;Qed."
                ]
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 535,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  unfold lift, lift.\n  apply (lift_TVar x).\n  intros.\n  simpl in *.\n  auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply (lift_TVar _ _ _ _).\n  apply subst_TVar; assumption.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  unfold lift.\n  rewrite subst_tt.\n  reflexivity.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction w; simpl; auto.\n  destruct a; simpl; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply subst_nVar.\n  apply subst_nVar.\n  apply subst_nVar.\n  apply subst_nVar.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction H; [ simpl | idtac ].\n  - reflexivity.\n  - simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl.\n    destruct H.\n    simpl in *.\n    destruct H.\n    simpl in *.Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction H.\n  auto.\n  simpl.\n  rewrite <- IHe.\n  auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply (lift_TVar x).\n  rewrite (lift_TVar y).\n  reflexivity.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfold lift.\n  unfoldQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply (lift_TVar x).\n  apply (lift_TVar y).\n  apply (lift_TVar y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 583,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 659,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  (* The following lemmas are useful for example. *)\n  eauto with simpl_lift_goal.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  unfold lift.\n  apply TApp with (lift w k (1 + k)).\n  apply TApp with (lift w k (1 + k)).\n  apply TApp with (subst w k (1 + k)); auto with datatypes.\n  apply TApp with (subst w k (1 + k)); auto with datatypes.\n  apply TApp with (subst w k (1 + k)); auto with datatypes.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  (* [simpl_lift_goal] can be used as a hint for [eauto]. *)\n  intros. simpl_lift_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 695,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  eauto with simpl_lift_goal.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  eauto with simpl_lift_goal.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 702,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_env. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_env. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_env. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_lift_goal.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_term. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst in H.\n  inversion H; subst; auto with arith.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_env.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_i. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_env. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_i. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_env in H.\n  apply subst_TVar.\n  apply subst_App with (subst v k (subst v k t)).\n  apply subst_subst_var_eq; auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_term. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst_env. reflexivity.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst_env in H.\n  destruct H.\n  subst.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. inversion H.\n  inversion H0; subst; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion HQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. inversion H; eauto with ctx_wff.\n  inversion H; eauto with ctx_wff.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros t1 t2 H; inversion H; subst; clear H.\n  inversion H; subst; clear H.\n  inversion H; subst; clear H.\n  inversion H1; subst; clear H.\n  inversion H2; subst; clear H2.\n  inversion H2; subst; clear H2.\n  inversion H1; subst; clear H2.\n  inversion H1; subst; clear H1.\n  inversion H2; subst; clear H2.\n  inversion H2; subst; clear H2.\n  inversion H2; subst; clear H2.\n  inversion H2; subst; clear H2.\n  inversion H2; subst; clear H2.\n  inversion H1; subst; clear H2.\n  inversion H1; subst; clear H2.\n  inversion H1; subst; clear H2.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros t1 t2.\n  induction t1; intros; simpl.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst. simpl.\n  apply subst_var with x; auto.\n  apply subst_var with x; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros t1 t2. induction H.\n  constructor.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. induction H; simpl; intros; subst; auto.\n  apply H. simpl. apply H. simpl. apply H. simpl. apply H.\n  simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply H. simpl. apply HQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. induction H; intros; subst; simpl in *; omega.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. induction H; simpl; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x. induction H; simpl.\n  auto.\n  intro x. inversion H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n  apply subst_var in H.\n Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. inversion H; subst; simpl_subst; eauto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  inversion 1; subst; eauto with subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction k; intros; simpl_env;\n  econstructor; eauto with lift_open.\n  rewrite subst_var; eauto with subst; simpl_env; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; auto.\n  econstructor; eauto with lc.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  inversion 1; subst; simpl_env; eauto with subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  (* ADMITTED *)\n  intros k x H.\n  induction H; subst; simpl_lift_goal;\n  econstructor; eauto with subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  inversion 1; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H; auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 702,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T. induction H; intros; subst.\n  apply (H x U E).\n  apply (H x U E).\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H. induction H; intros; subst; simpl in *;\n  apply H; auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl in *; try (apply EQ; eauto).\n  Case \"app_case\".\n    apply IHtyping; eauto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion H; auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H; induction H; intros; subst; auto.\n  Case \"typing_abs\".\n  Case \"typing_abs\".\n  Case \"typing_abs\".\n    destruct (typing_abs T2 T3 T4) as [J1 J2].\n    inversion J1; subst; eauto.\n  Case \"typing_abs\".\n    destruct (typing_app T1 T2 T4) as [J1 J2].\n    inversion J1; subst; eauto.\n  Case \"typing_abs\".\n    destruct (typing_app T1 T3 T4) as [J1 J2].\n    inversion J1; subst; eauto.\n  Case \"typing_abs\".\n    destruct (typing_app T1 T2 T4) as [J1 J2].\n    inversion J1; subst; eauto.\n  Case \"typing_abs\".\n    destruct (typing_app T1 T3 T4) as [J1 J2].\n    inversion J1; subst; eauto.\n  Case \"typing_abs\".\n    destruct (typing_app T1 T3 T4) as [J1 J2].\n    inversion J2; subst; eauto.\n  Case \"typing_abs\".Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T. induction T; simpl; intros; subst; auto.\n  Case \"typing_abs\".\n  Case \"typing_abs\".\n    inversion H0.\n  Case \"typing_abs\".\n    inversion H0.\n  Case \"typing_abs\".\n    inversion H0.\n  Case \"typing_abs\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_abs\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n    SCase \"typing_app\".\n      inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n  Case \"typing_app\".\n    inversion H0.\n Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H; induction H; intros; subst; simpl_env; auto.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H; subst.\n  apply (H0 x); auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H.\n  induction H; intros; subst; simpl in *; try (exfalso; eauto).\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T. induction E.\n  apply typing_intro with (x := T) (y := T) (y := T) (T := T); eauto.\n  intros.\n  apply typing_intro with (y := T) (y := T) (y := T) (z := T); eauto.\n  intros.\n  apply typing_intro with (y := T) (y := T) (z := T); eauto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H.\n  apply typing_var with (T:=t) (T:=T) (x:=T) (y:=T) T) (y:=T) (Y:=Y); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert_insert_insert_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; auto.\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; eauto with subst.\n  econstructor; eauto with lookup_insert.\n  econstructor; eauto with lookup_insert.\n  econstructor; eauto with lookup_insert.\n  econstructor; eauto with lookup_insert.\n  econstructor; eauto with lookup_insert.\n  econstructor; eauto with lookup_insert.\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros.\n  auto.\n  Case \"typing_abs\".\n    inversion H; subst.\n    inversion H1.\n    inversion H2.\n    inversion H1.\n    inversion H2.\n    inversion H2.\n    inversion H2.\n    inversion H2.\n    inversion H2.\n    inversion H2.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H4.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H4.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H4.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H3.\n    inversion H4.\n    inversion H3.\n    inversion H4.\n    inversion H4.\n    inversion H4.\n    inversion H3.\n    inversion H4.\n    inversion H4.\n    inversion H3.\n    inversion H4.\n    inversion H3.\n   Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H; subst; simpl_lift_hyp;\n  rewrite subst_env in H; destruct H;Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros E x t1 T2 t2 T2 H1 H2.\n  induction H1; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert_insert_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_hyp;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_node.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 699,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; inversion_closed; eauto with subst.\n  inversion_closed; eauto with ctx_insert.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H.\n  induction H; intros; subst; auto with eval_var_hyp;\n  subst; eauto with eval_var_hyp;\n  apply binds_app; eauto with eval_var_hyp; auto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  inversion H; subst; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  (* Existential *)\n  unfold subst_var; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hyp;\n  intros; eauto with eval_var_hypQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H1 H2.\n  induction H1; subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst; eauto with subst;\n  econstructor; eauto with subst;\n  econstructor; eauto with subst; eauto with subst; eauto with subst;\n  econstructor; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with subst;\n  econstructor; eauto with subst; eauto with substQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_env;\n  econstructor; eauto with lc.\n  (* ADMITTED *)\n  intros.\n  inversion H; subst.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  intros.\n  inversion H; subst.\n  econstructor; eauto with lc.\n  (* ADMITTED *)\n  intros.\n  inversion H; subst.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  intros.\n  inversion H; subst.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  intros.\n  inversion H; subst.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  intros.\n  inversion H; subst.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  eapply subst_lc; eauto with lc.\n  econstructor; eauto with lc.\n  econstructor; eauto with lc.\n  eapply subst_lc; eauto with lc.\n  eapply subst_lc; eauto with lc.\n  eapplyQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H1 H2.\n  induction H1; subst;\n    try solve [apply H1; eauto with map_cons_iff; auto];\n    apply H2; auto.\n  (* New *)\n  intros t1 t2 H2.\n  induction H1; subst;\n    try solve [apply H1; eauto with map_cons_iff; auto];\n    apply H2; auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_subst; auto.\n  destruct (binds_lookup _ _ _ H) as [J1 J2].\n  destruct (binds_lookup _ _ _ H) as [J1 J2].\n  destruct (binds_lookup _ _ _ J1) as [J2 J3].\n  destruct (binds_lookup _ _ _ J1) as [J3 J4].\n  destruct (binds_lookup _ _ _ J1) as [J4 J5].\n  destruct (binds_lookup _ _ _ J1) as [J4 J5].\n  destruct (binds_lookup _ _ _ J3) as [J5 J5].\n  destruct (binds_lookup _ _ _ J5) as [J5 J6].\n  destruct (binds_lookup _ _ _ J5) as [J5 J6].\n  destruct (binds_lookup _ _ _ J5) as [J6 J6].\n  destruct (binds_lookup _ _ _ J5) as [J5 J6].\n  destruct (binds_lookup _ _ _ J5) as [J6 J6].\n  destruct (binds_lookup _ _ _ J5) asQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_subst; auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion_closed. auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H; induction H; subst; auto.\n  (* Base case *)\n  inversion H; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n  (* Base case *)\n  inversion H0; subst; auto.\n Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion_closed. auto.\n  apply H0; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 639,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros x.\nassert (1 + x = 2 + x).\n apply H.\n\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  apply two_plus_one_plus_one_zero_left.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros; subst; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. auto. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros; subst; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction 1; simpl; intros.\n  omega.\n  omega.\n  omega.\n  destruct (IHx a e).\n  destruct (IHx a e).\n  destruct (IHx a e).\n  auto.\n  simpl in IHx.\n  destruct (IHx a e).\n  simpl in IHx.\n  destruct IHx.\n  destruct (IHx a e).\n  auto.\n  simpl in IHx.\n  destruct IHx.\n  destruct (IHx a e).\n  auto.\n  simpl in IHx.\n  destruct IHx.\n  destruct (IHx a e).\n  auto.\n  simpl in IHx.\n  destruct IHx.\n  destruct IHx.\n  destruct (IHx a e).\n  auto.\n  simpl in IHx.\n  destruct IHx.\n  destruct (IHx a e).\n  auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 656,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros; apply raw_insert_zero_left.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  apply raw_insert_zero.\n  destruct o. auto.\n  destruct o. auto.\n  destruct o. auto.\n  destruct o. auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  induction e; simpl; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  apply raw_insert_zero.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  induction e; simpl; intros; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; simpl in *; try discriminate; try discriminate; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. apply raw_insert_zero; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros; unfold raw_insert.\n  destruct (In_dec _ _); tauto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros A o e.\n  induction e; simpl.\n  intuition.\n  simpl.\n  intuition.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold raw_insert; simpl.\n  rewrite <- raw_insert_uniq_rev.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_In.\n  apply raw_insert_InQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros A o e.\n  unfold raw_insert.\n  destruct (S x) as [ | x o ]; simpl; auto.\n  destruct o; simpl; auto.\n  destruct (X.eq_dec x x).\n  subst x. rewrite e. auto.\n  auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros A o e; functional induction (map_inv e); intros.\n  destruct (X.eq_dec e e0); subst; auto.\n  contradiction.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros A o e. functional induction (X.compare e e); intros.\n  rewrite H; auto.\n  rewrite H; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  rewrite <- (raw_insert_involutive e) at 1.\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  rewrite <- (raw_insert_involutive e).\n  apply (raw_Qed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct e.\n  simpl.\n  auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  unfold raw_insert.\n  intros.\n  destruct e.\n  simpl.\n  apply IHm.\n  simpl.\n  auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. simpl. apply raw_insert_In. apply raw_insert_In. apply raw_insert_In. auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct (X.eq_dec x x). subst. auto.\n  destruct (X.eq_dec x x). subst. auto.\n  destruct (X.eq_dec x x). subst. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; simpl.\n  apply X.eq_sym; auto.\n  apply X.eq_sym; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply X.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; simpl in *; subst; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. subst e.\n  destruct e; simpl; auto.\n  apply IHl.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  unfold empty, empty; simpl; intros.\n  destruct (X.compare x e); auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply (empty_inv _ H).\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  apply functional_extensionality; intro.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold empty; intros. contradiction.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite empty_eq_insert.\n  destruct (T x x); simpl in *. congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold lookup; simpl.\n  unfold lookup; simpl.\n  rewrite empty_map_empty.\n  unfold lookup; simpl.\n  rewrite <- H. reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. apply functional_extensionality. intros. auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite empty_eq_insert.\n  auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  unfold empty; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; simpl.\n  rewrite raw_insert_empty_None.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 686,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. rewrite empty_eq_insert. reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  unfold lookup; intros.\n  destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  unfold lookup; intros; destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  unfold lookup; intros.\n  destruct (lookup x a); simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  unfold empty; intros. destruct x; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  unfold lookup; intros; destruct a; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 685,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros; unfold lookup; simpl.\n  destruct (x a); simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  unfold lookup.\n  rewrite update_same. auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; reflexivity.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct e; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 661,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros A x y o e.\n  rewrite functional_insert_bingo.\n  unfold functional_insert; simpl.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_or.\n  rewrite functional_insert_and.\n  rewrite functional_insert_or.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  functional_insert_and.\n  rewrite functional_insert_and.\n  functional_insert_and.\n  rewrite functional_insert_and.\n  repeat rewrite functional_insert_and.\n  repeat rewrite functional_insert_and.\n  rewrite functional_insert_and.\n  functional_insert_and.\n  rewrite functional_insert_and.\n  rewrite functional_insert_Qed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct (find_insert y o e); auto.\n  rewrite H; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct o; simpl; intros.\n  rewrite empty_eq_insert; auto.\n  rewrite empty_eq_insert; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct o.\n  rewrite empty_eq_insert; reflexivity.\n  rewrite empty_eq_insert; reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct e; simpl; congruence.\n  destruct e; simpl; congruence.\n  destruct (ins y o e0); simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros A x y o e H.\n  destruct o; simpl; reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  rewrite (find_empty_None e) in H.\n  destruct (find y o); auto.\n  contradiction.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct o; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  unfold lookup in *.\n  rewrite map_app in *.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e)] *)\nProof.\n  intros.\n  unfold insert.\n  rewrite insert_unfold.\n  destruct y; auto.\n  (* if, is a left *)\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  destruct (lookup x y); destruct (lookup y a); simpl; try solve [\n    elimtype False; omega].\n  (* if, is a right *)\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  destruct (lookup y a); destruct (lookup y a); simpl; try solve [\n    elimtype False; omega].\n  (* if, is a right *)\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  rewrite insert_unfold.\n  destruct y.\n  destruct (insert x a); destruct (insert y a); simplQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* To test the following definition of [lookup x (insert y a e)]. *)\nProof.\n  (* The following lemmas are the following lemmas are used. *)\n  induction x; simpl; intros.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  invQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* To [lookup x (insert y o e)] *)\nProof.\n  intros.\n  destruct x; simpl; try solve [inversion H].\n  (* TODO: This is the next two-zero is not directly, but it should be\n   not be a good way to find it. *)\n  assert (forall x, lookup x (uninsert y o e) = Some x).\n  {\n    intros.\n    unfold insert.\n    destruct x.\n    + inversion H.\n    + inversion H.\n    + inversion H.\n    + inversion H.\n  }\n    destruct x; simpl; try solve [inversion H].\n    inversion H.\n  Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Then [lookup x (update y o e) = Some e]. *)\nProof.\n  intros.\n  unfold lookup.\n  rewrite lookup_lookup.\n  rewrite lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.\n  rewrite <- lookup_lookup.Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Should not happen, [lookup x (insert y a e)] *)\nProof.\n  intros.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega\n  (* The following definition are not useful. *)\n  destruct y; destruct a; simpl; try solve [\n    elimtype False; omega\n    (* Maxx *)\n    apply insert_leaf_None.\n  (* Here we can make a contradiction, [lookup x (insert y a e)] *)\n  destruct y; simpl in *.\n  apply insert_node_None.\n  (* Here we can prove the [lookup x (insert y a e)] *)\n  destruct y; simpl; try solve [\n    elimtype False; omega\n    (* Maxx *)\n    apply insert_node_None.\n  (* Here we can prove the [lookup y (insert y a e)] *)\n  destruct y; simpl; try solve [\n    elimtype False; omega\n    (* Maxx *)\n    apply insert_node_None.\n  (* Here we can show the [lookup y (insert y a e)] *)\n  destruct y; simpl; try solve [\n    elimtype False; omega\n    (* Maxx *)\n    apply insert_node_None.\n  (* Here we can prove the [lookup y (Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* To do this definition, the default\n   and [lookup x (insert y a e)] *)\nProof.\n  intros.\n  destruct x; simpl; auto.\n  destruct y; destruct e; simpl; try solve [inversion H].\n  rewrite (insert_insert_uniq _ _ _ _ H).\n  rewrite insert_insert_uniq. rewrite insert_uniq. rewrite insert_uniq. rewrite insert_uniq.\n  rewrite insert_uniq. rewrite insert_uniq. rewrite insert_uniq. rewrite insert_uniq. auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Same as [lookup x (update y o e)] *)\nProof.\n  intros.\n  unfold insert.\n  simpl insert.\n  rewrite insert_lookup_empty.\n  simpl.\n  rewrite insert_lookup_leaf.\n  simpl.\n  rewrite insert_lookup_node.\n  simpl.\n  rewrite insert_lookup_node.\n  simpl.\n  rewrite insert_lookup_node.\n  simpl.\n  rewrite insert_lookup_node.\n  simpl.\n  rewrite insert_lookup_node.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.\n  simpl.\n  rewrite insert_node_None.Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Then, [lookup x (insert y a e) = lookup y (insert y a e)). *)\nProof.\n  intros.\n  destruct y; simpl; auto.\n  rewrite <- insert_lookup_Empty.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.\n  rewrite H.\n  simpl.Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Then, [lookup x (insert y a e) = Some e]. *)\nProof.\n  intros.\n  unfold insert.\n  simpl.\n  rewrite insert_insert_nil.\n  rewrite insert_insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_node.\n  rewrite insert_nodeQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Same as [insert x (insert y a e) = lookup y (insert x a e)). *)\nProof.\n  intros.\n  unfold insert.\n  destruct y.\n  destruct (eq_dec x y).\n  subst.\n  destruct (eq_dec y x).\n  subst.\n  simpl.\n  auto.\n  simpl.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  unfold map.\n  rewrite empty_map_length.\n  auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  extensionality x.\n  unfold empty.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  rewrite <- map_empty.\n  reflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n induction f; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  induction f; simpl; intros; auto.\n  destruct a; simpl in *; auto.\n  destruct a; simpl in *; auto.\n  destruct a; simpl in *; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nunfold map, map.\nextensionality a.\ndestruct a as [a' b']; simpl; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  induction f; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite <- H.\n  simpl.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup, lookup, lookup_map; simpl.\n  rewrite <- H.\n  rewrite <- H.\n  auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite <- (update_lookup_unfold _ _ _ _ H).\n  reflexivity.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite!List_map_nil.\n  auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct_lookup as [y [e?]].\n  destruct (lookup_lookup x e) as [z [e?]].\n  exists y; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup, lookup; simpl.\n  destruct (f x); auto; try discriminate.\n  rewrite (IHf x).\n  auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup.\n  rewrite H.\n  rewrite H.\n  auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (x,e).\n  destruct H.\n  destruct H.\n  simpl in H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H.\n  destruct H0.\n  destruct H.\n  destruct H.\n  destruct H0.\n  destruct H.\n  simpl in H.\n  destruct H0.\n  destruct H.\n  subst.\n  simpl in *.\n  destruct H.\n  destruct H0.\n  destruct H.\n  simpl in H.\n  destruct H.\n  destruct H.\n  subst.\n  simpl in *.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destruct H.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destruct H.\n  destruct H.\n  simpl in *.\n  destructQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros. destruct H.\n  destruct H0.\n  destruct H0.\n  rewrite H; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct a; simpl; auto.\n  rewrite H; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl in *; subst;\n  solve [apply IHi; auto | congruence ].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  unfold lookup.\n  destruct (f a); reflexivity.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  induction x; intros; destruct e; simpl in *; subst; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  induction x; intros; destruct a; simpl in *; subst; try congruence.\n  destruct H; subst.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  rewrite <- H0.\n  auto.\n  rewrite <- H1.\n  auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H0.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H0.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H0.\n  - inv H0.\n  - inv H.\n  - inv H.\n  - inv H.\n  - inv H0.\n  - inv H0.\n  - inv H.\n  - inv H0.\n  - inv H0.\n  - inv H0.\n  - inv H.\n  - inv H0.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e; simpl in *; subst;\n  solve [inversion H | congruence ].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros A B x a e f; induction e; intros; simpl; auto;\n  try (rewrite (find_map_some _ _ H); auto; congruence).\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  induction x; simpl; intros; destruct e; auto; subst; simpl.\n  destruct a; auto.\n  destruct (IHf _ _ H) as [H|H]; subst; simpl.\n  destruct (IHf _ _ H) as [H'|H']; subst; simpl.\n  rewrite H', H'; auto.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simpl.\n  destruct H' as [H'|H']; subst; simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 663,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction 1; intros; simpl in *; subst; try solve [apply H | apply H].\n  destruct (insert_insert_uniq _ _ _ _ H0) as [a' [??]].\n  exists a'; split; auto.\n  destruct (insert_uniq _ _ _ _ H0) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ _ H0) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ H0) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ _ H0) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ _ H1) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ H1) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ H1) as [b' [??]].\n  exists b'; split; auto.\n  destruct (insert_uniq _ _ _ _ H0) as [b' [?Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; simpl.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label s a); intros; try discriminate.\n  destruct (find_label sQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros A k s a b e.\n  induction e; intros.\n  - simpl. rewrite IHs.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y | ]; auto.\n    destruct (insert_insert_ex a e) as [y |Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction 1; intros; simpl in *; subst; try solve [\n    congruence\n  | rewrite insert_insert_node; auto\n  ].\n  destruct H as [b?].\n  remember (split a b) as b.\n  remember (split a b) as b'.\n  remember (split b' b') as b.\n  remember (split b' b') as b'.\n  remember (split b' b) as b'.\n  remember (split b' b) as b'.\n  remember (split b' b) as b.\n  remember (split b b') as b'.\n  remember (split b' b') as b'.\n  remember (split b' b) as b'.\n  remember (split b' b) as b''.\n  remember (split b' b) as b.\n  destruct b; destruct b'; simpl in *; try solve [\n    congruence].\n  remember (split b' b) as b''.\n  remember (split b' b) as b''.\n  remember (split b b) as b''.\n  remember (split b' b) as b''.\n  remember (split b' b) as b''.\n  remember (split b' b) as b''.\n  remember (split b' b)Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros A k s a b e.\n  induction e; intros; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]?? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; auto].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [destruct e; autoQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; simpl in *; subst; try solve [inversion H].\n  destruct (IHinsert _ _ H0); subst.\n  destruct (IHinsert _ _ H2); subst.\n  destruct (IHinsert _ _ H2); subst.\n  destruct (IHinsert _ _ H3); subst.\n  destruct (IHinsert _ _ H3); subst.\n  destruct (IHinsert _ _ H3); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ H4); subst.\n  destruct (IHinsert _ _ HQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  destruct a; simpl in *.\n  destruct H.\n  simpl.\n  destruct (insert_insert_ex x a0 e) as [b | [b [? [??]]]].\n  exists b.\n  split.\n  exists b.\n  simpl.\n  simpl.\n  auto.\n  destruct (insert_insert_ex x a0 e0) as [b | [b [? [??]]]].\n  exists b.\n  split.\n  simpl.\n  auto.\n  destruct (insert_insert_ex y a0 e0) as [b | [b [? [??]]]].\n  exists b.\n  split; auto.\n  simpl.\n  auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction 1; intros; simpl in *; subst; try solve [inv H | congruence ].\n  inversion H; subst.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H1; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H0; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.\n  inversion H1; subst.Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction 1; intros; destruct e as [ | [ | ]?? ]; simpl in *; subst; try solve [inversion H].\n  destruct (insert_uniq_ex _ _ _ H) as [l1 Hl1].\n  exists l1.\n  split. reflexivity.\n  destruct (insert_uniq_ex _ _ _ _ _ H) as [l2 Hl2].\n  exists l2.\n  split. reflexivity.\n  destruct (insert_uniq_ex _ _ _ _ _ H) as [l2 Hl2].\n  exists l2.\n  split. reflexivity.\n  destruct (insert_uniq_ex _ _ _ _ H) as [l3 Hl3].\n  exists l3.\n  split. reflexivity.\n  destruct (insert_uniq_ex _ _ _ _ H) as [l3 Hl3].\n  exists l3.\n  split. reflexivity.\n  destruct (insert_uniq_ex _ _ _ _ _ H) as [l3 Hl3].\n  exists l3.\n  split. reflexivity.\n  destruct (insert_uniq_ex _ _ _ _ H) as [l4 Hl3].\n  exists l3.\n  split. reflexivity.\n  destruct (insert_uniqQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  destruct H as [a' [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  destruct H as [a' [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 669,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s. generalize k; clear k.\n  induction s; simpl; intros.\n  + simpl in *.\n    inversion H.\n    subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; substQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s. generalize s k; clear s k. induction s; intros.\n  (* Case *)\n  simpl.\n  destruct (gt_dec k s).\n  (* Case *)\n  simpl.\n  destruct (le_gt_dec k s).\n  (* Case *)\n  assert (In (insert k a e) \\/ In (insert k a e) \\/ In (insert k a e) \\/ In (insert k a e) \\/ In (insert k a e) \\/ In (insert k a e)).\n    simpl in H. rewrite H.\n    destruct (lt_gt_dec k s).\n    (* Case *)\n    simpl.\n    destruct (le_gt_dec k s).\n    (* Case *)\n    destruct (le_gt_dec k s).\n    (* Case *)\n    simpl.\n    destruct (le_gt_dec k s).\n    (* Case *)\n    simpl.\n    destruct (le_gt_dec k s).\n    (* Case *)\n    simpl.\n    destruct (le_gt_dec k s).\n    (* Case *)\n    simpl.\n    destruct (le_gt_dec k s).\n    (* Case *)\n    simpl.\n    destruct (le_gt_dec k s).\n    (* Case *)Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction e; intros; simpl.\n  destruct e as [ | [ | ]??? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s. generalize a b.\n  induction s; intros.\n  (* Case [s = 0]. *)\n  simpl.\n  destruct (le_lt_dec k s).\n  (* Sub *)\n  destruct (le_gt_dec k s).\n  (* L *)\n  destruct (lt_gt_dec k s).\n  (* L *)\n  destruct (le_gt_dec k s).\n  (* L *)\n  destruct (le_gt_dec k s).\n  (* L *)\n  destruct (le_gt_dec k s).\n  (* L *)\n  left. exists s.\n  split. apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_trans with s; auto.\n  apply lt_le_transQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 1]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simpl in *.\n  apply IHs; auto.\n  (* Case [s = S s]. *)\n  inv H.\n  destruct s; simplQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  unfold insert.\n  rewrite insert_insert_uniq.\n  rewrite insert_insert_local.\n  apply insert_insert_local.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct k.\n  (* Sub-case [k > 0]. *)\n  apply (insert_insert_local_facts k a (raw_insert k a e) (raw_insert k a e)).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a (raw_insert k a e) (raw_insert k a e)).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a (raw_insert k a e) (raw_insert k a e)).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a e).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a (raw_insert k a e) (raw_insert k a e)).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a e (raw_insert k a e)).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a e (raw_insert k a e)).\n  (* Sub-case *)\n  apply (insert_insert_local_facts k a e (raw_insert k a e) (raw_insertQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct k.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  destruct (IHhi _ H) as [a' [??]].\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s = S s] *)\n  elimtype False; omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omega.\n  (* Case [s = S s] *)\n  omegaQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction s; simpl; intros.\n  (* E_dec *)\n  simpl.\n  destruct s.\n  (* Sub-case *)\n  simpl.\n  destruct s.\n  (* Sub *)\n  simpl.\n  destruct s.\n  (* Sub *)\n  simpl.\n  destruct s.\n  (* Sub *)\n  simpl.\n  destruct s.\n  (* Sub *)\n  simpl.\n  destruct s.\n  (* Sub *)\n  simpl.\n  destruct s.\n  (* Sub *)\n  simpl.\n  destruct s0.\n  (* Sub *)\n  simpl.\n  destruct H.\n  (* Sub *)\n  simpl. destruct H.\n  (* Sub *)\n  simpl.\n  destruct s0.\n  (* Sub *)\n  simpl. destruct s0.\n  (* Sub *)\n  simpl. destruct s.\n  (* Sub *)\n  simpl. destruct s0.\n  (* Sub *)\n  simpl.\n  destruct s0.\n  (* Sub *)\n  simpl. destruct s0.\n  (* Sub *)\n  simpl.\n  destruct s1.\n  (* Sub *)\n  simpl. destruct s0.\n  (* Sub *)\n  simpl. destruct s0.\n  (* Sub *)\n  simpl. destruct H.\n  (* Sub *)\n  simpl. destruct s0.\n  (* Sub *)\n  simpl. destruct sQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s. generalize k; clear k.\n  induction s; intros; simpl in *; subst.\n  rewrite e; auto.\n  rewrite e; auto.\n  rewrite e; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  rewrite insert_insert.\n  rewrite insert_insert.\n  rewrite insert_insert; auto.\n  auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  unfold insert; simpl.\n  destruct (eq_dec x x).\n  subst.\n  rewrite H; auto.\n  destruct H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; subst; apply (insert_nil A).\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (insert_nil A) as [y [e [E]].\n  destruct (insert_nil A) as [e [E]].\n  rewrite E in E.\n  rewrite <- insert_insert.\n  auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction e; simpl; intros; auto.\n  destruct a; auto.\n  rewrite IHt0. rewrite IHt0. auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction e; simpl; intros; try contradiction.\n  inv H.\n  destruct a.\n  destruct (insert_cons_inv _ _ H0).\n  apply insert_insert_local; auto.\n  contradiction H0.\n  destruct H0; subst.\n  destruct H; subst.\n  destruct (insert_cons_inv _ _ H0).\n  destruct (insert_insert_local _ _ H0).\n  destruct H1; subst.\n  destruct (insert_insert_local _ _ H1).\n  destruct (insert_uniq_or _ _ H2).\n  destruct H1; subst.\n  destruct (insert_uniq_or _ _ H2).\n  destruct H1; subst.\n  destruct (insert_uniq_or _ _ H1).\n  destruct H1; subst.\n  destruct (insert_uniq_or _ _ H1).\n  destruct H1; subst.\n  destruct (insert_uniq_or _ _ H0).\n  destruct H1; subst.\n  destruct (insert_uniq_or _ _ H2).\n  destruct H1; subst.\n  destruct (insert_uniq_or _ _ H1).\n  destruct (insert_uniq_or _ _ H2).\n Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; subst; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; simpl; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  rewrite (insert_nil A).\n  rewrite (insert_nil A).\n  rewrite (insert_insert_insert_cons A).\n  rewrite (insert_insert_insert_local A).\n  apply (insert_insert_insert_valid A).\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; apply insert_nil.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 697,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct a1; destruct e2; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct (lt_lt_dec x a1); simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct a1; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  induction 1; intros.\n  rewrite H; auto.\n  rewrite H; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct a1; destruct e2; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e1 e2.\n  induction e1; intros; simpl in *; subst; try congruence.\n  destruct (eq_nat_dec x x0); subst; try congruence.\n  destruct (eq_nat_dec x x1); subst; try congruence.\n  destruct (IHa1 e1); subst; try congruence.\n  destruct (IHa2 e2); subst; try congruence.\n  destruct (IHa2 e1); subst; try congruence.\n  destruct (IHa1 e2); subst; try congruence.\n  destruct (IHa2 e2); subst; try congruence.\n  destruct (IHa2 e1); subst; try congruence.\n  destruct (IHa2 e2); subst; try congruence.\n  destruct (IHa2 e2); subst; try congruence.\n  destruct (IHa2 e1); subst; try congruence.\n  destruct (IHa1 e2); subst; try congruence.\n  destruct (IHa2 e2); subst; try congruence.\n  destruct (IHa1 e2); subst; try congruence.\n  destruct (IHa2 e2); subst; try congruence.\n  destruct (IHa2 e2);Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; destruct e1; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using lookup_insert_bing.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using lookup_insert_eq_insert.\n  destruct (lt_gt_dec x a1).\n  subst.\n  simpl. rewrite insert_insert. rewrite insert_insert. intuition.\n  apply insert_eq_insert_2. auto.\n  apply insert_eq_insert_2. auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using lookup_insert_eq_insert; auto.\n  assert (lookup x a2 = Some b). eauto using lookup_insert_eq_insert; auto.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using lookup_insert_bing.\n  rewrite H. auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x a1 e1 = Some a1). eauto using lookup_insert_bing.\n  subst.\n  rewrite <- insert_insert.\n  apply insert_eq_insert_1; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using lookup_insert_bing.\n  assert (lookup x (insert x a2 e2) = Some a1). eauto using lookup_insert_eq_insert_b.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using lookup_insert_neq_insert_2.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros A x a1 a2 e1 e2.\n  rewrite <- insert_insert.\n  apply insert_eq_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x a1 = Some b). eauto using list_insert_eq_insert.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x a1 e1 = Some a2). eauto using lookup_insert_bing.\n  rewrite (insert_eq_insert_and _ _ _ _ H).\n  congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 658,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x a1 e1) = Some a1). eauto using lookup_insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x a1 e1) = Some a2).\n  destruct (lt_gt_dec x1 y1); simpl in *.\n  intuition.\n  destruct e1; destruct e2; simpl in *.\n  intuition.\n  destruct e1; simpl in *.\n  intuition.\n  destruct e1; simpl in *.\n  intuition.\n  destruct e1; simpl in *.\n  intuition.\n  destruct e2; simpl in *.\n  intuition.\n  destruct e2; simpl in *.\n  intuition.\n  destruct e1; simpl in *.\n  intuition.\n  destruct e1; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuition.\n  destruct e3; simpl in *.\n  intuitionQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x a1 e1) = Some a1).\n  apply insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  inv H.\n  destruct (le_gt_dec x1 y1).\n  subst.\n  assert (x1 = a2). eauto using le_trans with a1. auto.\n  apply le_trans with a2. auto. auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  assert (lookup x1 (insert x a1 e1) = Some a2). auto using lookup_insert_neq_insert_3.\n  destruct (le_gt_dec x1 y1); auto using lookup_insert_neq_insert_3.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct x1; destruct y2; destruct e2; simpl; congruence.\n  destruct e1; destruct e2; try destruct e3; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x a1 e1) = Some a1). eauto using lookup_insert_neq_insert_3.\n  assert (lookup x a2 = Some a2). eauto using lookup_insert_neq_insert_3.\n  destruct (sorted_non_tree_or_app_or_app_or _ _ H0) as [? [??]]; subst; eauto.\n  rewrite <- insert_eq_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using lookup_insert_eq_insert_3.\n  destruct (le_gt_dec x1 y1); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y2 y1); subst; auto.\n  destruct (le_gt_dec y1 y2); subst; auto.\n  destruct (le_gt_dec y1 y1); subst; auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x1 a1 e1) = Some a1). eauto using lookup_insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x a1 e1) = insert x a2 e1). eauto using lookup_insert_eq_insert_3.\n  congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction A; simpl; intros.\ndestruct e.\ndestruct e; simpl.\ndestruct (f a).\ndestruct (f a).\ndestruct (f a).\ndestruct (f a).\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (f a); simpl.\ndestruct (Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  rewrite <- (map_insert_eq_insert_3 _ _ _ H).\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_3.\n  rewrite map_insert_eq_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_2.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_eq_2.\n  rewrite map_insert_eq_insert_3.\n  rewrite map_insert_Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; simpl; intros; auto.\n  f_equal.\n  destruct (f a); simpl; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  rewrite_eq_dec_refl.\n  rewrite <- (map_insert_eq_insert_2 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (map_insert_eq_insert_3 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (map_insert_eq_insert_3 A B f x a e).\n  rewrite <- (map_insert_eq_insert_4 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (map_insert_eq_insert_4 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (map_insert_eq_insert_3 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (map_insert_eq_insert_4 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (map_insert_eq_insert_4 A B f x a e).\n  destruct (f a); simpl; intuition.\n  rewrite <- (mapQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  induction e; simpl; intros; auto.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  induction e; simpl; intros.\n  rewrite IHx.\n  apply map_insert_In.\n  destruct H.\n  destruct H.\n  subst.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  apply insert_eq_insert_2.\n  rewrite <- insert_eq_insert.\n  rewrite <- insert_eq_insert.\n  apply insert_eq_insert_2.\n  rewrite <- insert_eq_insert.\n  apply insert_eq_insert_3.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; simpl; intros; auto.\n  rewrite IHa1. rewrite IHa2. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  rewrite <- (map_insert_eq_insert_2 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_4 f x a e).\n  rewrite <- (map_insert_eq_insert_4 f x a e).\n  rewrite <- (map_insert_eq_insert_4 f x a e).\n  rewrite <- (map_insert_eq_insert_3 f x a e).\n  rewrite <- (map_insert_eq_insert_4 f x aQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  rewrite <- insert_eq_insert_2.\n  destruct (f a x) as [y|v].\n  rewrite <- insert_eq_insert_eq_insert_3.\n  destruct (f a x) as [y|v].\n  auto.\n  rewrite <- insert_eq_insert_eq_insert_3.\n  destruct (f a x) as [y|v].\n  auto.\n  destruct (f a x) as [y|v].\n  auto.\n  rewrite <- insert_eq_insert_eq_insert_2.\n  destruct (f a x) as [y|v].\n  auto.\n  rewrite <- insert_eq_insert_eq_insert_2.\n  destruct (f a x) as [y|v].\n  auto.\n  rewrite <- insert_eq_insert_eq_insert_2.\n  destruct (f a x) as [y|v].\n  auto.\n  rewrite <- insert_eq_insert_eq_insert_2.\n  destruct (f a x) as [y|v].\n  auto.\n  rewrite <- insert_eq_insert_eq_insert_2.\n  destruct (f a x) as [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl in *; auto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; simpl; intros; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; simpl; intros; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl.\n  rewrite IHx; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros. unfold f.\n  rewrite insert_eq_insert.\n  rewrite insert_eq_insert.\n  rewrite insert_eq_insert.\n  destruct e; try destruct_tac; simpl; intuition.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; simpl; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl.\n  rewrite IHx. reflexivity.\n  destruct a; simpl.\n  rewrite IHx. reflexivity.\n  destruct b; simpl.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; subst.\n  destruct (map_raw_insert x (f a) e); auto.\n  rewrite (map_raw_insert x a e0); auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; subst; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; extensionality; simpl.\n  rewrite!map_insert_uniq; reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  induction x; intros.\n  simpl.\n  auto.\n  destruct a; auto.\n  destruct b; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; simpl; auto.\n  rewrite IHl. rewrite IHl. rewrite IHx. auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; rewrite map_raw_insert.\n  rewrite map_raw_insert_eq.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n  apply X.eq_dec.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; simpl in *; f_equal; eauto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros A B C f g h e.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros A B C f g h e.\n  induction h; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; destruct e; simpl in *; eauto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 679,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros A F G B f1 g2 g3.\n  induction e; intros; destruct e; simpl in *; eauto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto.\n  destruct a; auto.\n  destruct (f a); auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl in *; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros A F G B f1 g2 g1 g2.\n  induction e; intros; simpl in *; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl in *.\n  rewrite H; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try rewrite map_map_iff; auto.\n  destruct e; destruct a; simpl; eauto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl in *; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  apply map_ext_in; intros.\n  destruct H0 as [f | [d' [He [H1 H2]]]].\n  subst; apply map_ext; intros.\n  destruct (H2 _ _ H2).\n  subst; apply map_ext; intros.\n  destruct H2 as [f | [d' [He [H1 H2]]]].\n  subst; apply map_ext; intros.\n  destruct H2 as [f | [d' [He [H1 H2]]]].\n  subst; apply map_ext; intros.\n  destruct (H2 _ _ H2).\n  subst; apply map_ext; intros.\n  destruct (H2 _ _ H2).\n  subst; apply map_ext; intros.\n  destruct H2 as [f | [d' [He [H1 H2]]]].\n  subst; apply map_ext; intros.\n  destruct (H2 _ _ H2).\n  subst; apply map_ext; intros.\n  destruct (H2 _ _ H2).\n  subst; apply map_ext; intros.\n  destruct H2 as [f | [d' [He [H1 H2]]]].\n  subst; apply mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl in *.\n  inversion H.\n  inversion H.\n  inversion H2.\n  inversion H0.\n  inversion H0.\n  inversion H2.\n  inversion H3.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H0.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H0.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl in *; auto.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewriteQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl in *; eauto.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewriteQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; simpl; intros; auto.\n  rewrite map_map_map_unfold.\n  rewrite map_map_unfold.\n  rewrite map_map_unfold.\n  rewrite map_map_unfold.\n  rewrite map_map_unfold.\n  rewrite map_map_map_unfold.\n  rewrite map_map_unfold.\n  rewrite map_map_map.\n  rewrite map_map_fold.\n  rewrite map_map_map_unfold.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_map_unfold.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; auto.\n  simpl in *.\n  destruct e.\n  simpl in *.\n  destruct (e a); simpl in *; eauto.\n  simpl in *.\n  destruct (e a); simpl in *.\n  destruct (e a); simpl in *; eauto.\n  simpl in *.\n  destruct (e a); simpl in *; eauto.\n  destruct (e a); simpl in *; eauto.\n  simpl in *.\n  destruct (e a); simpl in *.\n  destruct (e a); simpl in *.\n  destruct (e a); simpl in *; eauto.\n  destruct (e a); simpl in *; eauto.\n  simpl in *.\n  destruct (e a); simpl in *.\n  destruct (e a); simpl in *; eauto.\n  simpl in *.\n  destruct (e a); simpl in *; eauto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_ext.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_ext.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_map_cons.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_map_cons.\n  rewrite map_map_ext.\n  rewrite map_map_ext.\n  rewrite map_map_map_cons.\n  rewrite map_map_ext.\n  rewrite mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  auto.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros T k s Huv Hd.\n  induction e; intros; simpl.\n  rewrite <- IH; auto.\n  rewrite <- IH; auto.\n  rewrite <- IH; auto.\n  rewrite map_map_cons; auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  induction e; intros;\n    try match goal with\n        | id: _ = Some _ |- _ => destruct id end; auto; inversion id\n      end.\n  simpl.\n  repeat f_equal; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  unfold map in *.\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [discriminate|].\n  destruct (f a) eqn:E; [Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; subst; simpl.\n  rewrite <- H0.\n  apply map_insert; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros;\n  simpl; eauto with map_insert.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; subst; eapply map_insert.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl.\n  apply map_insert.\n  destruct (f a); simpl.\n  rewrite (IHmap_eq H0).\n  destruct (f a); simpl.\n  rewrite (IHmap_eq H0).\n  destruct H0; subst.\n  destruct (f a); simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  destruct H0.\n  rewrite H0.\n  simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (IHmap_eq H1).\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (IHmap_eq H0).\n  destruct H1.\n  subst.\n  simpl.\n  rewrite (Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl.\n  rewrite IHl.\n  rewrite map_insert.\n  simpl.\n  rewrite IHl.\n  auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto.\n  destruct a; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite <- map_insert.\n  apply map_insert_map_ext.\n  intros.\n  apply H.\n  destruct H.\n  destruct H0.\n  simpl.\n  split; auto.\n  intro.\n  rewrite H0.\n  split; auto.\n  intro.\n  rewrite H2.\n  split; auto.\n  intro.\n  rewrite H2.\n  split; auto.\n  intro.\n  rewrite H2.\n  split; auto.\n  intro.\n  rewrite H2.\n  split; auto.\n  intro.\n  rewrite H3.\n  split; auto.\n  intro.\n  rewrite H3.\n  split; auto.\n  intro.\n  rewrite H3.\n  split; auto.\n  intro.\n  rewrite H3.\n  split; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  induction e; simpl; eauto with map_insert.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_map_map_map.\n  apply map_insert_map.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g e.\n  induction e; simpl; eauto with map_cons.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  f_equal.\n  apply map_insert_map_ext.\n  intros.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g e.\n  induction e; intros; simpl in *; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g.\n  unfold map.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_cons.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g; induction e; simpl; eauto with map_insert.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g e; induction e; intros;\n  try match goal with |-?x =?y => rewrite y end;\n  simpl; eauto with map_cons.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_insert.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite <- map_insert.\n  rewrite <- map_insert.\n  rewrite <- map_insert.\n  rewriteQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g e.\n  apply functional_extensionality; intro x.\n  rewrite <- map_insert. f_equal.\n  eapply map_cons_map_ext.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_insert.\n  apply map_insert.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. rewrite fold_empty. auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold.\n  rewrite fold_left_empty.\n  rewrite fold_left_empty.\n  rewrite fold_left_empty.\n  rewrite fold_left_empty.\n  rewrite <- fold_left_empty.\n  rewrite fold_right_empty.\n  rewrite <- fold_left_empty.\n  rewrite fold_left_empty.\n  rewrite <- fold_left_empty.\n  rewrite fold_right_empty.\n  rewrite <- fold_right_empty.\n  rewrite fold_left_empty.\n  rewrite <- fold_left_empty.\n  rewrite <- fold_right_empty.\n  rewrite fold_right_empty.\n  reflexivity.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite fold_left_nil_r.\n  rewrite map_map_cons.\n  rewrite map_map_cons.\n  rewrite <- map_map_cons.\n  rewrite <- map_map_cons.\n  rewrite <- map_map_cons.\n  auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n intros.\n rewrite <- (empty_map f) at 2.\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (empty_map_fold_right f).\n rewrite <- (Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. reflexivity.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  rewrite <- H.\n  auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  destruct (f a); simpl; eauto with map.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros; reflexivity.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  rewrite <- (empty_map_f A).\n  rewrite <- (empty_map_f A).\n  rewrite <- (empty_map_f A).\n  rewrite <- (empty_map_f A).\n  rewrite <- (empty_map_f A).\n  auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n unfold fold.\n rewrite fold_left_empty. rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_right_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_right_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_right_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_left_empty.\n rewrite <- fold_right_emptyQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 725,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f e.\n  induction e; intros.\n  simpl.\n  rewrite IHl.\n  auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f.\n  induction e; intros; simpl; auto.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  unfold fold_left.\n  intros.\n  rewrite fold_left_nil.\n  auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f g.\n  destruct (f a) eqn:E; try destruct o; simpl; eauto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; simpl; auto.\n  rewrite IHl. rewrite IHl. rewrite IHl.\n  rewrite IHl. rewrite IHl. rewrite IHl. rewrite IHl. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f g.\n  induction e; simpl; intros.\n  rewrite IHl. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  rewrite fold_left_fold_unfold.\n  rewrite fold_left_unfold.\n  rewrite fold_left_unfold.\n  rewrite map_app.\n  rewrite fold_left_unfold.\n  rewrite IHl.\n  rewrite fold_left_unfold.\n  rewrite fold_right_right_sepcon.\n  apply IHl.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  unfold fold_left.\n  intros.\n  destruct a.\n  destruct e; simpl in *.\n  eauto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  unfold linear_union; intros.\n  destruct (f a) as [ | [ | ] a]; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f.\n  destruct (fold_right f (raw_insert 0 o e)) as [x|] eqn:E;\n  simpl in E; rewrite <- E in E; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 704,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  apply fold_left_ass.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f H.\n  assert (H: forall (e : env A) (e' : env A), P e (fold f e accu)).\n  {\n    intros; simpl; auto.\n  }\n  destruct H.\n  apply H; auto.\n  apply fold_right_sepcon_right; auto.\n  apply fold_right_sepcon_right; auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f H.\n  induction H.\n  - simpl. apply IHfold_left with (f:=fun x => f (x, e) (f x)).\n    rewrite <- (f_equal (fun x => f (x, e) (f x))).\n    rewrite <- (f_equal (fun x => f (x, e) (f x))).\n    apply fold_left with (f:=fun x => f (x, e) (f x)).\n    rewrite <- (f_equal (fun x => f (x, e) (f x))).\n    apply fold_left with (f:=fun x => f (x, e) (f x)).\n    apply fold_left with (f:=fun x => f (x, e) (f x))).\n    apply fold_right with (f:=fun x => f (x, e) (f x)).\n    apply fold_left with (f:=fun x => f (x, e) (f x)).\n    apply fold_right with (f:=fun x => f (x, e) (f x)).\n    apply fold_left with (f:=fun x => f (x, e) (fQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  rewrite fold_left_nil.\n  apply fold_right_rec.\n  intros.\n  destruct H.\n  destruct H0.\n  subst.\n  auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f H.\n  apply fold_rec_invariant with (P:=fun x => f (raw_insert 0 o e) (f (elements_elements_elements_aux a))); auto.\n  intros.\n  rewrite fold_spec. f_equal.\n  apply H.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f H.\n  induction H; intros; subst; auto.\n  constructor.\n  constructor.\n  constructor.\n  apply IHsort; auto.\n  constructor.\n  constructor; auto.\n  constructor; auto.\n  constructor; auto.\n  constructor; auto.\n  constructor; auto.\n  constructor; auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f Hf.\n  apply fold_left_invariant with (f:=f); auto.\n  apply fold_right_invariant with (f:=f); auto.\n  apply fold_right_invariant with (f:=f); auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f Hb H1 H2.\n  remember (f a) as e.\n  apply functional_extensionality; intros.\n  rewrite H1.\n  apply functional_extensionality; intros.\n  rewrite H2.\n  auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f gv H1 H2.\n  revert H2.\n  induction e; intros;\n  try match goal with H:?e =?e |- _ => destruct e end;\n  simpl; eauto with f_equal.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f Hb Hd H.\n  induction H; intros; simpl in *; eauto.\n  rewrite IHl. apply fold_right_app; auto.\n  rewrite IHl. apply fold_right_app; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; intros.\n  inversion H; clear H; subst; auto.\n  inversion H; clear H; subst; auto.\n  inversion H; clear H; subst; auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k k1 k2 H1 H2.\n  destruct (H k1 H2).\n  apply H1.\n  eapply nth_monotonic; eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2.\n  induction k1; simpl.\n  auto.\n  destruct (IHk1 k1 k2).\n  auto.\n  rewrite IHk2.\n  rewrite IHk2.\n  rewrite IHk2.\n  auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros until k1.\n  (* FILL IN HERE *) Admitted.\n(** [] *)\n\n(* ################################################################# *)\n(** * Partial Maps *)\n\n(** * Basic definitions *)\n\n(** The [list] Tactic := [list A]\n    and [fold_left] that do [fold_left] and [fold_right] and [fold_right]\n    and [fold_right].  It is useful for example of [fold_right]. *)\n\n(** The [list] tactic is the [fold_right] tactic. *)\n\nLtac fold_left :=\n  match goal with\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A] |- _ => generalize dependent H\n  | H: context [list A]Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros until k1.\n  induction e; intros k2 H;\n  destruct k1; simpl in *;\n  try (case H; apply H0; omega).\n  apply H0.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2 H1 H2.\n  apply (H1 k1 H2).\n  apply (H1 k2 H2).\n  apply (H1 k2 H2).\n  apply (H2 k1 H1).\n  apply (H k2 H2).\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; intros k1 k2.\n  inversion H; clear H; subst k1.\n  inversion H; clear H; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H; clear H; subst k2.\n  inversion H; clear H; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n  inversion H; clear H; subst k2.\n  inversion H0; clear H0; subst k2.\n  inversion H; clear H0; subst k2.\n Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2. induction e; simpl; intros.\n  inversion H.\n  inversion H0.\n  destruct a as [|k1 l1]; simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k2 + k1); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k2 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destruct (k1 + k2); simpl in *; inversion H.\n  destructQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2 H1 H2.\n  generalize dependent k1. generalize dependent k2.\n  induction H1; intros k1 k2 H2.\n  destruct (IH1 k2 H1).\n  destruct (IH1 k1 H2).\n  destruct (IH1 k2 H2).\n  destruct (IH2 k1 H2).\n  destruct (IH2 k H1).\n  destruct (IH1 k H2).\n  destruct (IH2 k H2).\n  destruct (IH1 k H2).\n  destruct (IH2 k H2).\n  destruct (IH1 k H3).\n  destruct (IH2 k H3).\n  destruct (IH2 k H3).\n  destruct (IH1 k H3).\n  destruct (IH1 k H3).\n  destruct (IH2 k H3).\n  destruct (IH2 k H3).\n  destruct (IH2 k H3).\n  destruct (IH2 k H3).\n  destruct (IH1 k H3).\n  destruct (IH2 k H3).\n  destruct (IH1 k H3).\n  destruct (IH2 k H3).\n  destruct (IH1 k H3).\n  destruct (IH2Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n intros A e k1 k2 H1.\n apply (H (S k1) k2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e x.\n  assert (H := find_empty_alt_1 _ _ _ _ _ H). clear H.\n  induction e; simpl in *; intuition.\n  apply IHk; auto.\n  apply (H1 x); auto.\n  apply (H1 x); auto.\n  apply (H2 x); auto.\n  apply (H2 x); auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e x H.\n  induction H.\n  auto.\n  simpl in H. destruct H.\n  auto.\n  inversion H.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e k x Hx.\n  induction e; simpl; intros; auto.\n  inv Hx.\n  inv Hx.\n  apply IH...\n  rewrite IH...\n  destruct (ins x k1 k2 H0) as [y [Hy Hy]]].\n  exists y; exists y; auto.\n  apply IH...\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e k1 k2 H.\n  induction e; intros; auto.\n  destruct (IHe e1 k2 H) as (e2,He); simpl in *; eauto.\n  destruct (IHe e2 k2 H) as (e,He); simpl in *; eauto.\n  destruct (IHe e1 k2 H) as (e',He'); simpl in *; eauto.\n  destruct (IHe e2 k2 H) as (e',He); simpl in *; eauto.\n  destruct (IHe e2 k2 H) as (e'',He'); simpl in *; eauto.\n  destruct (IHe e' k2 H) as (e'',He'); simpl in *; eauto.\n  destruct (IHe e' k2 H) as (e'',He'); simpl in *; eauto.\n  destruct (IHe e' k2 H) as (e'',He'); simpl in *; eauto.\n  destruct (IHe e' k2 H) as (e'',He'); simpl in *; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e k1 k2 H1.\n  destruct (List.In_dec k1 x) as [e1|e1].\n  left; intros; subst; auto.\n  left; intros; subst; auto.\n  left; intros; subst; auto.\n  right; intros; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros A e k a. induction k; simpl; intros.\n  auto.\n  apply IHn. omega.\n  destruct (IHe a) as [k' [e' [? [??]]]].\n  subst.\n  apply IHn. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros; inv H.\n  eapply H; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  contradiction.\n  destruct H; subst. auto.\n  destruct H; subst. auto.\n  destruct H.\n  subst. auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; intros; simpl in *.\n  auto.\n  destruct a; try discriminate.\n  destruct (IHe a) as [k1 | ].\n  destruct (IHe a) as [k2 | ].\n  eapply H. omega.\n  destruct (IHe a) as [k1 | ].\n  eapply H0. omega.\n  eapply IHe. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; intros.\n  auto.\n  destruct a; simpl in H.\n  inv H.\n  constructor.\n  destruct a.\n  destruct (IHe _ _ H0).\n  destruct H1.\n  destruct H2.\n  destruct H2.\n  destruct H3.\n  subst.\n  destruct H3.\n  destruct H3.\n  subst.\n  constructor.\n  destruct H3.\n  destruct H3.\n  subst.\n  destruct (IHe _ _ H1).\n  destruct H3.\n  subst.\n  constructor.\n  destruct H3.\n  destruct H3.\n  subst.\n  destruct H3.\n  subst.\n  constructor.\n  destruct H4.\n  destruct H3.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  destruct H3.\n  subst.\n  constructor.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  subst.\n  constructor.\n  destruct H4.\n  subst.\n  constructorQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  contradiction.\n  eapply IHwell_founded. apply H.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros A e k a H.\n  induction H; simpl in *.\n  apply IHe.\n  apply IHe.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct (is_empty_dec k).\n  destruct (is_empty_dec k).\n  left.\n  split; auto.\n  right.\n  unfold find in H.\n  apply H.\n  destruct H.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H0.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H0.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H0.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H.\n  destruct H.\n  subst k.\n  apply IHe.\n  destruct H0.\n  subst k.\n  apply IHe.\n  destruct H.\n  subst k.\n  apply IHe.Qed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  eapply H; eauto.\n  destruct a; auto.\n  destruct b; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  inv H.\n  eapply lookup_nil_inv; eauto.\n  eapply IHwell_founded_induction; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 698,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros A.\n  apply Nat2Z.inj_lt. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite <- (Nat.add_1_r (k-k)).\n  auto with arith.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  destruct (eq_nat_dec k k).\n  destruct (eq_nat_dec k k).\n  left; omega.\n  right; split; omega.\n  right; split; omega.\n  right; split; omega.\n  right; split; omega.\n  right; split; omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  apply (H k).\n  apply H.\n  simpl.\n  apply H.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  unfold length.\n  intros.\n  destruct (length e).\n  omega.\n  destruct H.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  induction i; simpl; intros.\n  omega.\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax; simpl.\n  destruct (le_gt_dec i j); [omega | ].\n  simpl.\n  destruct (le_gt_dec i j); [omega | ].\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  induction j.\n  + reflexivity.\n  + simpl. intros.\n    omega.\n  + simpl. intros.\n    omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  destruct (le_gt_dec i j).\n  subst; reflexivity.\n  destruct j; reflexivity.\n  destruct (lt_gt_dec i j).\n  subst; reflexivity.\n  contradiction.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct le_lt_dec.\n  + simpl.\n    replace (S j) with O.\n    reflexivity.\n  + simpl.\n    rewrite <- Nat.add_0_r.\n    simpl.\n    rewrite <- Nat.add_0_r.\n    simpl.\n    reflexivity.\n  + simpl.\n    rewrite <- Nat.add_0_r.\n    simpl.\n    rewrite <- Nat.add_0_r.\n    simpl.\n    reflexivity.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold mymax.\n  destruct le_lt_dec.\n  - destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j); [omega | ].\n    destruct (le_gt_dec i j);Qed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 705,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  rewrite in_app_iff in H.\n  destruct (le_gt_dec k x); [omega | ].\n  simpl.\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [omega | ].\n  destruct (lt_gt_dec k x); [Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros A x k o e.\n  induction e; simpl; intros.\n  auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (lt_ge_dec k x).\n  rewrite H.\n  auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction e; simpl; intros.\n  apply Nat.min_glb_lt.\n  apply Nat.min_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.max_lub_lt.\n  apply Nat.maxQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction e; simpl; intros.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct e; simpl; auto.\n  destruct a; simpl; auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros A x k o e.\n  induction e; simpl; intros.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H0.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.\n  inv H.Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (lt_ge_dec k x); [reflexivity | ].\n  destruct (le_gt_dec k x); [reflexivity | ].\n  destruct (le_gt_dec k x); [reflexivity | ].\n  destruct (le_gt_dec k x); [reflexivity | ].\n  destruct (le_gt_dec k x); [reflexivity | ].\n  destruct (le_gt_dec k x); [reflexivity | ].\n  destruct (le_gt_dec k x); [reflexivity | ].\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec k x).\n  + inversion e.\n  + inversion e.\n  + inversion e.\n  + inversion e.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros A x k o e.\n  unfold mymax.\n  destruct (lt_ge_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].\n  destruct (le_gt_dec k x); [omega | ].Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  rewrite <- (length_insert_with_strong _ _ _ e) by auto.\n  rewrite <- (length_insert_with_strong _ _ _ e) by auto.\n  apply length_insert_general.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction e; simpl; intros.\n  omega.\n  rewrite IHn; omega.\n  rewrite IHn; omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction e; simpl; intros.\n  apply IHn; omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k RV e k RV He1.\n  induction e; simpl; intros; subst; auto.\n  destruct (IHe x k LV e) as [e' [He1 He2]].\n  rewrite (IHe x k' e' e' e'); simpl; auto.\n  rewrite IHe.\n  rewrite IHe.\n  rewrite IHe.\n  rewrite IHe'.\n  rewrite IHe'.\n  rewrite IHe'.\n  auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k Hk.\n  induction k; simpl; intros.\n  inv Hk.\n  destruct (le_gt_dec k x).\n  subst k. auto.\n  apply IHn. omega.\n  destruct (le_lt_eq_dec k x).\n  subst k. auto.\n  destruct (le_gt_dec k x).\n  subst k. auto.\n  apply IHn. omega.\n  destruct (le_lt_eq_dec k x).\n  subst k. auto.\n  apply IHn. omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k Hk1 o1 e1 e2.\n  induction e1; simpl; intros.\n  apply IHk1.\n  destruct (le_gt_dec k x).\n  destruct (le_gt_dec k x).\n  destruct (le_gt_dec k x).\n  subst; simpl.\n  rewrite <- IHn1. rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn2.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn1.\n  simpl.\n  rewrite <- IHn1Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k Hu1 e k Hv1 He2.\n  induction e; simpl; intros; subst; try omega.\n  rewrite IH; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction e; simpl; intros; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clear H; subst.\n  destruct (inf_head e); simpl in *; inversion H; clearQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k pds1 e1.\n  induction e; simpl; intros; subst.\n  apply IHtl.\n  apply le_trans with (length e1 + k).\n  apply le_S_n; auto.\n  apply IHtl.\n  apply le_S_n; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction e; simpl; intros.\n  rewrite <- H1.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H1.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H1.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H1.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H1.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H1.\n  destruct (le_gt_dec k x); try omega.\n  rewrite <- H2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  destruct (le_lt_dec k x).\n  + apply IH.\n  + apply IH.\n  + apply IH.\n  + apply IH.\n  + apply IH.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  unfold from_insert.\n  rewrite list_length_insert.\n  destruct e; simpl; try omega; auto.\n  destruct (insert x a e); simpl; try omega; auto.\n  destruct (insert x a e); simpl; try omega; auto.\n  destruct (insert x a e); simpl; try omega; auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  induction e; simpl; intros.\n  inv H.\n  apply IHn. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  apply (list_nth_error_insert_with A e k a); intros.\n  apply (list_nth_error_insert_with A e k a); intros.\n  apply H0.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_appQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  rewrite <- insert_insert_with_decidable_length.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_lt.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.injQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  generalize dependent e.\n  induction e; intros.\n  apply list_insert_uniq_1 in H.\n  apply in_or_app.\n  destruct H as [k' [??]].\n  apply H0 in H.\n  destruct H.\n  subst k'.\n  apply H in H.\n  destruct H.\n  subst k'.\n  apply H.\n  apply in_or_app.\n  destruct H.\n  subst k'.\n  apply H0 in H.\n  destruct H.\n  subst k'.\n  apply H0 in H.\n  subst k'.\n  apply H0 in H.\n  destruct H.\n  subst k'.\n  apply H0 in H.\n  destruct H.\n  subst k'.\n  apply H0 in H.\n  apply H0 in H.\n  subst k'.\n  apply H0 in H.\n  apply H0 in H.\n  subst k'.\n  apply H0 in H.\n  apply H0 in H.\n  subst k'.\n  apply H0 in H.\n  contradiction H0.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  pose proof (nth_error_insert_end (A:=A) e k x a).\n  omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction e; intros.\n  rewrite app_length in H. omega.\n  assert (x < k).\n  apply (length_insert_end_length _ _ H).\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros A e k x a.\n  induction k; simpl; intros.\n  omega.\n  destruct e.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_with_bits_2 by reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  eapply length_insert_bits_ind; eauto.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_end in * by reflexivity.\n  rewrite app_length, length_insert_end in * by omega.\n  rewrite app_length in * by omega.\n  rewrite app_length in * by omega.\n  rewrite rev_length in * by omega.\n  rewrite rev_length in * by omega.\n  rewrite app_length in * by omega.\n  rewrite <- app_length in * by omega.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewriteQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite <- (list_length _ H) by omega.\n  erewrite nth_error_cons, <- (list_length _ H) by omega.\n  erewrite nth_error_cons, <- (list_length _ H) by omega.\n  rewrite <- (list_length _ H) by omega.\n  rewrite <- (list_length _ H) by omega.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  simpl. rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_error_app.\n  rewrite nth_Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_with in * by reflexivity.\n  apply IHl. omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. eapply length_insert_base_1; eauto.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction e; simpl; intros.\n  destruct a; simpl in *.\n  destruct (IHe _ _ H0) as (e,He).\n  destruct (IHe _ _ H0) as (e,He).\n  destruct (IHe _ _ _ H0) as (e',He').\n  destruct (IHe _ _ _ H0) as (e'',He').\n  destruct (IHe _ _ _ H1) as (e'',He').\n  destruct (IHe _ _ _ H1) as (e'',He').\n  destruct (IHe _ _ H2) as (e'',He').\n  destruct (IHe _ _ H1) as (e'',He').\n  destruct (IHe _ _ H1) as (e'',He').\n  destruct (IHe _ _ H1) as (e'',He').\n  destruct (IHe _ _ H2) as (e'',He').\n  destruct (IHe _ _ H2) as (e'',He').\n  destruct (IHe _ _ H2) as (e'',He').\n  destruct (IHe _ _ H2) as (e'',He').\n  destruct (IHe _ _ H2)Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros A e k x a Hx.\n  induction k; simpl; intros.\n  + simpl in *.\n    assert (length e <= k).\n      { destruct (H k).\n        destruct (H k).\n        destruct (H k).\n        simpl.\n        rewrite IHl.\n        rewrite H.\n        rewrite <- H.\n        simpl.\n        rewrite <- H.\n        simpl.\n        rewrite <- H.\n        simpl.\n        rewrite <- H.\n        simpl.\n        rewrite <- H.\n        simpl.\n        rewrite <- H.\n        simpl.\n        rewrite <- H.\n        simpl.\n        apply H.\n        simpl.\n        omega. }\n      destruct (H k).\n      simpl.\n      rewrite <- H.\n      simpl.\n      rewrite <- H.\n      simpl.\n      rewrite <- H.\n      simpl.\n      rewrite <- H.\n      simpl.\n      apply H.\n      simpl.\n      omega.\n    + simpl.\n      rewrite <- H.\n      simpl.\n      rewrite <- H.\n      simpl.\n      omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 718,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_inner; eauto.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_seq with (e0 := e) by eauto.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_1.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_insert_alt_2.\n  apply length_Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_alt in * by reflexivity.\n  rewrite <- (list_length_insert_alt x).\n  rewrite <- (list_length_insert_end x).\n  rewrite <- (list_length_insert_alt x).\n  rewrite <- (list_length_insert_alt x).\n  apply (list_length_insert_lower_2 (A:=A) (l:=list_length_insert_alt x)).\n  apply (list_length_insert_lower_2 (A:=A) (l:=list_length_insert_alt x)).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_bits x).\n  apply (list_length_insert_Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros A e k x a.\n  induction e; simpl; intros; subst; auto.\n  replace a with a by apply proof_irr.\n  replace a with a by apply proof_irr.\n  rewrite <- map_cons.\n  apply insert_alt_1.\n  apply insert_alt_2.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_bits_alt in * by reflexivity.\n  pose proof (nth_error_insert_in _ _ _ _ H).\n  rewrite insert_alt in * by auto.\n  rewrite insert_alt in * by auto.\n  rewrite insert_alt in * by auto.\n  rewrite insert_alt in * by auto.\n  rewrite insert_alt.\n  apply insert_alt_sorted.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros A e k x a H.\n  induction k; simpl; intros.\n  auto.\n  destruct (IHe _ H).\n  simpl in IHe.\n  destruct H.\n  destruct e.\n  simpl in IHe.\n  destruct H0.\n  destruct H0.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  destruct H0.\n  simpl in IHe.\n  subst k.\n  destruct IHe.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst k.\n  simpl in IHe.\n  destruct IHe.\n  subst k.\n  simpl in IHe.\n  destruct H0.\n  subst kQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_alt in * by reflexivity.\n  rewrite app_length in * by omega.\n  pose proof (list_size_insert_end_1 e (list_size_insert x a e)).\n  assert (length e < k).\n  { rewrite length_insert_alt in * by omega. apply nat_of_P_succ_r. }\n  omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_alt.\n  eapply nth_error_nil; eauto.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  induction e; intros.\n  simpl in *. omega.\n  simpl in *. omega.\n  simpl in *. omega.\n  simpl in *. omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_alt in * by reflexivity. mymax.\n  rewrite length_insert_alt in * by reflexivity.\n  rewrite length_insert_alt in * by reflexivity. rewrite app_nil_r.\n  apply lt_le_trans with (length (insert x a e) <= k).\n  - rewrite app_length. simpl. apply lt_le_trans with (length (insert x a e)).\n    - rewrite app_length. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak.\n  - rewrite app_length. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak. apply lt_le_weak.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite in_map_iff in H.\n  destruct e; simpl in *; try discriminate.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  replace (length e) with (length e).\n  apply Nat2Z.inj_lt.\n  rewrite map_length.\n  apply Nat2Z.inj_le.\n  rewrite <- map_length.\n  apply Nat2Z.inj_le.\n  rewrite map_length.\n  rewrite <- map_length.\n  apply Nat2Z.inj_le.\n  rewrite map_length.\n  apply Nat2Z.inj_le.\n  rewrite <- map_length.\n  apply Nat2Z.inj_le.\n  rewrite map_length.\n  rewrite map_length.\n  apply Nat2Z.inj_le.\n  rewrite <- map_length.\n  apply Nat2Z.inj_le.\n  rewrite <- map_length.\n  apply Nat2Z.inj_le.\n  rewrite map_length.\n  apply Nat2Z.inj_le.\n  rewrite map_length.\n  apply Nat2Z.inj_le.\n  rewriteQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_map_length by reflexivity.\n  apply length_map_conv.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite <- (length_insert_with_norepet _ _ H).\n  rewrite map_rev.\n  rewrite <- (rev_involutive e).\n  rewrite map_rev.\n  apply rev_involutive.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_map_from.\n  reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  unfold map.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  apply IHn.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  erewrite <- map_length.\n  apply Nat2Z.inj_le. apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_lt.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_lt.\n  apply Nat2Z.inj_lt.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Z.inj_le.\n  apply Nat2Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_map_length by reflexivity.\n  rewrite <- (length_map_length _ H).\n  rewrite app_length_cons.\n  rewrite app_length_cons.\n  rewrite map_length_cons.\n  rewrite <- (length_map_length _ H).\n  rewrite <- app_length_cons.\n  rewrite app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_length_cons.\n  rewrite <- app_Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\nintros.\napply list_forall_equiv.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.\n  unfold map.\n  apply map_ext.Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  erewrite length_insert_bits_length; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros A B f e k. revert k. induction e; intros k.\n  simpl.\n  destruct (nth_error e k).\n  rewrite IHl.\n  apply IHn.\n  apply IHn.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e; simpl; intros.\n  destruct (le_lt_dec k k).\n  - apply IHn. omega.\n  - apply IHn. omega.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| k IH]; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros A B f e k. induction k; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. erewrite length_map_from in * by reflexivity.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite <- IHn.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite IHn.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite <- IHn.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e; simpl; intros.\n  omega.\n  simpl in *. omega.\n  rewrite IHl. simpl. omega.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e; simpl; intros.\n  apply in_map_iff in H. destruct H. subst k.\n  apply in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  apply in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_map_iff in H. destruct H. subst k.\n  rewrite in_mapQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  rewrite <- (length_map f e) at 1.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 1.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 1.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 2.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 1.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 2.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 2.\n  apply length_map_ext.\n  rewrite <- (length_map f e).\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 2.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 2.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 2.\n  apply length_map_ext.\n  rewrite <- (length_map f e) at 1.\n  apply length_map_ext.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 690,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  unfold agree.\n  intros.\n  unfold agree.\n  rewrite <- H.\n  apply H.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k Hk H; inversion H; subst; clear H.\n  unfold agree.\n  destruct (K.eq_dec k k); [subst; rewrite Hk; reflexivity | rewrite Hk; reflexivity].\n  unfold agree.\n  destruct (K.eq_dec k k); [subst; rewrite Hk; reflexivity | rewrite Hk; reflexivity].\n  unfold agree.\n  destruct (K.eq_dec k k); [subst; rewrite Hk; reflexivity | rewrite Hk; reflexivity].\n  unfold agree.\n  destruct (K.eq_dec k k); [subst; rewrite Hk; reflexivity | rewrite Hk; reflexivity ].\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k H; induction H; intros.\n  inv H.\n  destruct (IHe1 e2 k H) as [k' EQ].\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k').\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n  { apply IHk. assumption. }\n  assert (k' < k).\n Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k H.\n  apply H.\n  intros x.\n  assert (k = k).\n  rewrite H.\n  apply H.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k H; induction H; intros; subst.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k k H.\n  unfold agree.\n  apply equal_1; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k.\n  assert (k = k).\n  { intros H. inversion H. subst k. reflexivity. }\n  subst k.\n  assert (k = k).\n  { intros H. inversion H. subst k. reflexivity. }\n  subst k.\n  assert (k = k).\n  { intros H. inversion H. subst k. reflexivity. }\n  subst k.\n  rewrite H. apply make_add_stable with k.\n  apply make_add_stable with k.\n  apply make_add_stable with k. apply make_add_stable with k.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k Hk.\n  unfold agree.\n  rewrite (ins_some _ _ _ k).\n  destruct (ins_some _ _ _ _ k) as (k' &? &? &? &?); subst.\n  destruct (ins_some _ _ _ _ k') as (k'' &? &? &?); subst.\n  destruct (ins_some _ _ _ k'') as (k'' &? &?); subst.\n  destruct (ins_some _ _ _ k'') as (k''' &? &?); subst.\n  destruct (ins_some _ _ _ k'') as (k''' &? &?); subst.\n  destruct (ins_some _ _ _ k''' k''') as (k''' &? &?); subst.\n  destruct (ins_some _ _ _ k''' k''' H1) as (k''' &? &? &?); subst.\n  destruct (ins_some _ _ _ k''' H1) as (k''' &? &? &?); subst.\n  destruct (ins_some _ _ _ k''' H1) as (k''' &? &?); subst.\n  destruct (ins_some _ _ _ k''' H1Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (proof_irr H0). rewrite H0. auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k H.\n  induction H; simpl; intros; subst; auto.\n  simpl in H.\n  destruct (IHe1 e2 k H) as [y [ EQ]].\n  destruct (IHe2 e2 k H) as [y [ EQ]].\n  subst.\n  destruct (IHe2 e1 k H) as [y [ EQ]].\n  subst.\n  destruct (IHe2 e2 k H) as [y [ EQ]].\n  subst.\n  exists y.\n  split; auto.\n  right.\n  exists y.\n  split; auto.\n  right.\n  split.\n  destruct (IHe1 e2 k H) as [y [ EQ]].\n  subst.\n  destruct (IHe2 e2 k H) as [y [ EQ]].\n  subst.\n  destruct (IHe2 e2 k H) as [y [ EQ]].\n  subst.\n  exists y.\n  split; auto.\n  right.\n  exists y.\n  split; auto.\n  right.\n  split; auto.\n  left.\n  destruct (IHe2 e2 k H) as [y [ EQ]].\n  subst.\n  exists y.\n  split; auto.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros A e.\n  unfold agree.\n  rewrite env_gempty.\n  rewrite env_gempty. reflexivity.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree.\n  intros. rewrite <- (empty_set A). apply repr_eq.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree.\n  intros A e; unfold agree.\n  rewrite env_empty. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree; intros A e k.\n  rewrite <- elements_merge_empty_left.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_left.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_left.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_left.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_right.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_left.\n  apply functional_extensionality; intro.\n  rewrite <- elements_merge_empty_left.\n  apply functional_extensionalityQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros A e.\n  induction e as [| a l IH]; simpl.\n  auto.\n  destruct a.\n  auto.\n  destruct (IHe _ H).\n  auto.\n  destruct H as [x [v?]].\n  exists x; auto.\n  destruct (IHe _ _ H).\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H1.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree. rewrite <- H. reflexivity.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros; rewrite <- H. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree. rewrite <- empty_map_zero.\n  rewrite <- empty_map_zero.\n  rewrite <- empty_map_zero.\n  rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_map_zero.\n  apply empty_map_ext. rewrite <- empty_mapQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree.\n  intros.\n  rewrite <- (merge_merge_merge_merge e1 e2).\n  rewrite <- (merge_merge_merge e2 e1 e2).\n  rewrite <- (merge_merge_merge e1 e2 e2).\n  rewrite <- (merge_merge_merge e2 e2 e2).\n  rewrite <- (merge_merge_merge e1 e2 e1 e2).\n  rewrite <- (merge_merge_merge e1 e2 e1 e2).\n  rewrite (merge_merge e2 e2 e2).\n  rewrite (merge_merge e2 e2 e1 e2).\n  rewrite <- (merge_merge e1 e2 e2).\n  rewrite (merge_merge e1 e2 e2).\n  rewrite <- (merge_merge e1 e2 e1 e2).\n  rewrite (merge_merge e1 e2 e2).\n  rewrite (merge_merge e2 e2 e1 e2).\n  rewrite (merge_merge e1 e2 e2).\n  rewrite (merge_merge e1 e2 e2 e2).\n  rewrite (merge_merge e1 e2 e2 e2).\n  rewrite (mergeQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  repeat intro. unfold agree.\n  destruct (eval x e).\n  rewrite <- H.\n  apply agree_empty_left.\n  symmetry. apply agree_empty_left.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros A e. unfold agree. apply H.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros A e. apply H. apply repr_is_empty.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros A e; simpl.\n  apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros.\n  rewrite <- H. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros A e. apply agree_empty_left. auto.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply eqm_refl.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 668,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros.\n  rewrite <- (agree_merge_unfold _ _ _ H). auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  rewrite <- (linear_insert_uniq A e1 e2 k H).\n  rewrite <- (linear_insert_uniq A e2 k H).\n  rewrite <- (linear_insert_uniq A e1 e2 k H).\n  rewrite <- (linear_insert_uniq A e2 k H).\n  rewrite <- (linear_insert_uniq A e1 e2 k H).\n  rewrite <- (linear_insert_uniq A e1 e2 k H).\n  rewrite <- (linear_insert_uniq A e2 k H).\n  rewrite <- (linear_insert_uniq A e1 e2 k H).\n  auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e k k.\n  unfold agree. intros.\n  rewrite <- H. apply agree_add with (1 := e2) (2 := e1).\n  rewrite <- H. apply agree_add with (2 := e2) (1 := e2).\n  rewrite H. apply agree_add with (2 := e1) (2 := e2).\n  rewrite H. apply agree_add with (1 := e2) (2 := e1).\n  rewrite H. apply agree_add with (2 := e2) (2 := e2).\n  rewrite H. apply agree_add with (1 := e2) (2 := e1).\n  rewrite H. apply agree_add with (1 := e2).\n  rewrite H. apply agree_add with (2 := e1) (2 := e2).\n  rewrite H. apply agree_add with (1 := e2) (2 := e2).\n  rewrite H. apply agree_add with (1 := e2) (2 := e2).\n  rewrite H. apply agree_add with (1 := e2) (2 := e1).\n  rewrite H. apply agree_add with (1 := eQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. revert e2. induction e2; intros; simpl; congruence.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros.\n  destruct (peq x x).\n  subst. auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e k H.\n  apply agree_merge.\n  rewrite <- H. apply agree_merge.\n  rewrite H. apply agree_merge.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros A e k H.\n  transitivity (eval_expr e1 k); auto.\n  symmetry. rewrite <- H. rewrite <- H.\n  auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e k Hk.\n  unfold agree.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewrite (linear_insert_uniq A e k) by auto.\n  rewriteQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  do 6 intro.\n  revert e2.\n  induction e1 as [| a l1 IH]; simpl; intros.\n  auto.\n  simpl.\n  destruct (get x a); auto.\n  rewrite IHl1. rewrite <- H. auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2 k Hk.\n  rewrite <- (agree_uniq (weak_equiv e1 e2) k).\n  unfold agree. rewrite <- (agree_uniq (weak_equiv e2 e1 e2) k).\n  unfold agree. rewrite <- (agree_uniq (weak_equiv e1 e2 e1 e2) k).\n  unfold agree. rewrite <- (agree_uniq (weak_equiv e2 e1 e2 e2) k).\n  unfold agree. rewrite <- (agree_uniq (weak_equiv e1 e2 e1 e2 e3) k).\n  rewrite (agree_uniq (weak_equiv e1 e2 e3) k).\n  unfold agree. rewrite <- (agree_uniq (weak_equiv e1 e3 e1 e3) k).\n  unfold agree. rewrite (agree_uniq (weak_equiv e1 e3 e3) k).\n  rewrite (agree_uniq (weak_equiv e1 e3 e3 e4)).\n  unfold agree. rewrite <- (agree_uniq (weak_equiv e1 e3 e4) k).\n  rewrite (agree_uniq (weak_equiv e1 e4 e5)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 692,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o.\n    case_eq (o2 o); intros; try discriminate.\n    destruct (o1 o2) as [a2|a2]; try discriminate.\n    destruct o1; auto.\n    destruct o2; auto.\n    destruct o1; auto.\n    destruct o2; auto.\n    destruct o; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o EQ.\n    destruct (eq_nat_dec o o).\n    exists o. auto.\n    exists o. auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o.\n    destruct o; auto with sets.\n    exists o; auto with sets.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o H.\n    generalize H.\n    case_eq (o1); intros.\n    apply H.\n    apply H0.\n    apply H.\n    apply H0.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o; induction o; simpl.\n    (* Einit *)\n    auto.\n    (* Einit *)\n    auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intro o; case (same_eq _ _ _ H); intros;\n    try congruence.\n    destruct o.\n    exists a2; auto.\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t1 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 a2).\n    contradiction (t2 aQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o o.\n    assert (M: forall a, M.In a o -> M.In a o).\n    { intro.\n      destruct (M.In_dec o o); auto.\n      exists o; auto. }\n    { intros a.\n      destruct (M.In_dec o o0); auto.\n      exists o; auto. }\n    { intros a.\n      destruct (M.In_dec o o0); auto.\n      exists o; auto. }\n    { intros a.\n      destruct (M.In_dec o o0); auto.\n      exists o; auto. }\n    { intros a.\n      destruct (M.In_dec o o0); auto.\n      exists o; auto. }\n    { intros a.\n      destruct (M.In_dec o o0); auto.\n      exists o; auto. }\n    { intros a.\n      destruct (M.In_dec o o0); auto.\n      exists o; auto. }\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub.\n    intros.\n    destruct o.\n    exists (Some a2).\n    exists (Some a2).\n    exists (Some a2).\n    split.\n    simpl. auto.\n    destruct o.\n    simpl.\n    exists (Some a2).\n    split.\n    simpl.\n    apply step_if.\n    simpl.\n    auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o.\n    destruct o; auto.\n    exists (fun a2 => None).\n    exists (fun a3 => None).\n    exists (fun a2 => None).\n    exists (fun a3 => None).\n    exists (fun a3 => None).\n    exists (fun a3 => None).\n    exists (fun a4 => None).\n    exists (fun a4 => None).\n    exists (fun a5 => None).\n    split.\n    eauto.\n    auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o r.\n    case_eq (o1 o); intros.\n    exists o; auto.\n    exists o; auto.\n    exists o; auto.\n    exists o; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 707,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub; congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros.\n    destruct (find_def_inv _ _ H) as [a1' [a2' [a3' [? [??]]]].\n    exists a1'.\n    exists a1'.\n    exists (Some a2').\n    exists (Some a2').\n    split.\n    eauto.\n    eauto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros.\n    exists (a1, a2); exists (Some a1); exists (Some a2); exists (Some a2); split; auto.\n    exists (Some a2); exists (Some a2); split; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 738,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros [??].\n    destruct (eq_nat_dec o1 o2);\n      [case (eq_nat_dec o2 o1); intros; auto | auto ].\n    elim (eq_nat_dec o2 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o2 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_dec o1 o2); intros; auto.\n    elim (eq_nat_decQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros?? h.\n    destruct (h _ eq_refl).\n    apply osub_None_Some_inversion; subst.\n    exists a1; auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros [??].\n    destruct (plt a1 a2). subst.\n    exists a1. rewrite e. rewrite e. rewrite e. rewrite e. trivial.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros???? h.\n    destruct (eq_nat_dec o1 o2); [case (eq_nat_dec o2 o1); intro H0; auto | subst; auto].\n    destruct (IHh _ _ _ eq_refl);\n      destruct (IHh _ _ _ _ eq_refl); subst.\n    (* In the case, [IHh] is not the left, but it works in the right *)\n    exists (exist (fun x => x) (h _ _ eq_refl)); split; auto.\n    (* In the case, [IHh] is the right *)\n    exists (exist (fun x => x) (h _ _ eq_refl)); split; auto.\n    (* In the case, [IHh] is the left *)\n    exists (exist (fun x => x) (h _ _ eq_refl)); split; auto.\n    (* In the case, [IHh] is the right *)\n    exists (exist (fun x => x) (h _ _ eq_refl)); split; auto.\n    (* In the case, [IHh] is the right *)\n    exists (exist (fun x => x) (h _ _ eqQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros??. inv H.\n    destruct (X _ _ _ _ _ H1) as [b' [??]].\n    exists b'. rewrite <- H1.\n    rewrite <- H2.\n    auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros??????? h.\n    case (eq_nat_dec o1 o2); [case (eq_nat_dec o2 o2); intro; auto|].\n    contradiction.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros.\n    destruct o.\n      exists a.\n      exists b.\n      auto.\n    destruct o.\n      exists a.\n      exists b.\n      auto.\n    destruct o.\n      exists a.\n      exists b.\n      auto.\n    Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros???. split; intros.\n    apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply X. apply XQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros????.\n    destruct o; simpl; auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o H.\n    destruct H.\n    apply (H _ _ H).\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros.\n    destruct (lookup_dec x o).\n      destruct o; auto.\n      contradiction.\n    destruct o; auto.\n    contradiction.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros.\n    destruct (lookup_lookup x e1) as [[s1 s2] | ];\n    destruct (lookup_lookup_lookup x e2) as [[s1 s2] | ];\n    destruct (lookup_lookup_lookup_lookup x e2) as [[s2 s3] | ];\n    destruct (lookup_lookup_lookup_lookup x e1) as [[s3 s4] | ];\n    destruct (lookup_lookup_lookup_lookup x e3) as [[s4 s5] | ];\n    destruct (lookup_lookup_lookup_lookup_lookup x e3) as [[s6 s6] | ];\n    destruct (lookup_lookup_lookup_lookup_lookup_lookup x e3) as [[s6 s7] | ];\n    destruct (lookup_lookup_lookup_lookup_lookup_lookup x e3) as [[s8 s8] | ];\n    destruct (lookup_lookup_lookup_lookup_lookup_lookup_lookup_eq x e3) as [[s8 s8] | ];\n    destruct (lookup_lookup_lookup_lookup_lookup_lookup_eq x e3) as [[s8 s8]Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 745,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold osub. eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold tp. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume.\n    unfold canonic.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function. unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function. unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function.\n    unfold partial_function. unfold partial_function.\n    unfoldQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold osub. eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold t; eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold \"\\ellub. eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume. auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 729,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_symmetric.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_symmetric.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_star_trans.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_identity_not_eq.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_symmetric.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. auto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_equiv.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. intros [??] [? [? [??]]]].\n    eapply osub_identity_inv in H. apply H. assumption.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_equiv.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 730,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osos. intros??? h.\n    generalize (h _ eq_refl); clear h. intros [[a1' e2] _].\n    subst.\n    rewrite <- (proof_irrelevance a1' e2).\n    reflexivity.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osos. intros Resolve tsub_unit_left.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub. intros??? h.\n    generalize (h _ eq_refl). clear h.\n    destruct (eq_dec e1 e2).\n    auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub. intros [= H].\n    exists a1; auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. intros.\n    apply osub_left_proof in H0.\n    destruct H0 as [a1 [a2 h2]].\n    exists a1; exists a2; auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub. intros. apply osub_identity_no; auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osos. intros.\n    apply (H _ eq_refl).\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub. intros???? h.\n    generalize (h _ eq_refl). clear h. intros [a1 [b2 [h2?]]].\n    exists (exist _ h); auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub. intros. inversion H; subst; eauto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub. intros??????? h.\n    generalize (h _ eq_refl). clear h. intros.\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eq_refl).\n    destruct (h _ _ _ eqQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 722,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. eauto using osub_identity.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold t. auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. eauto using osub_identity_empty.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    destruct e.\n    reflexivity.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. eauto using osub_empty.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold mk, e.\n    intros.\n    unfold t.\n    simpl.\n    apply (H _ (eq_refl _)); auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros. apply H.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 714,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros. unfold mkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkmkQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold osub. intros. apply osub_identity_match.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros. apply osub_empty. apply osub_empty.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold osub. intros. rewrite lookup_empty_None. apply osub_empty_None.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros. apply osub_None_Some_inv.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros. apply osub_empty.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold osub. intros.\n    rewrite lookup_empty_None. apply osub_empty_None.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold osub. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_identity.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ".\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. do 4 intro. intros n.\n    (* Reasoning the goal to avoid useless definitions of definitions. *)\n    repeat find_symbol; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold lower. intros.\n    apply osub_unit_left.\n    apply osub_unit_left.\n    apply osub_unit_right.\n    apply osub_unit_right.\n    apply osub_unit_right.\n    apply osub_unit_right.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    unfold subsume. do 3 intro. intros n.\n    (* The next case, [lookup_insert] is not true, but it is not true, but it is not true, but it is true. *)\n    repeat find_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x < n], [x < n], [y < n], [x < n], [y < n], [x < n], [y < n], [y < n], [x < n], [y < n], [y < n], [y < n], [y < n], [y < n], etc]. *)\n  Lemma subsume_insert:\n    forall t1 t2,\n    subsume_insert t1 t2 ->\n    forall x y o o o',\n    t1 = t2 ->\n    t1 = t2 ->\n    t1 = t2.\n  Proof.\n    intros t1 t2.\n    intros t1 t2.\n    intros.\n    destruct o.\n    (* Reason by cases: [x < n], [y < n], [z < n], [z < n], [x < n], [z < n], [z < n], etc. *)\n    apply t1_trans with (t2:=t1); auto.\n    apply t2_trans with (t2:=t2); auto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold lower. intuition.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold lower. intros.\n    rewrite lookup_empty_None. apply osub_identity_Some_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_invQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. do 6 intro. intros n.\n    (* Reasoning [x = n], [x > n], [x > n], [n < n], [x > n], [x > n], [n < n]. *)\n    case (lt_gt_dec x n); [ case (eq_nat_dec x n) | idtac]; intros;\n    (* In the case, [lookup_insert] to [lookup_insert] does not work *)\n    repeat find_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold osub. intros.\n    case (eq_nat_dec o n); [case (eq_nat_dec o n) | case (eq_nat_dec o n)]; intros;\n    (* In the case, [lookup_insert] is the same as [h]. *)\n    repeat find_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold osub. intros.\n    case (lt_ge_dec x n); [case (eq_nat_dec x n) | ]; intros;\n    (* In the case, [lookup_insert] does not be proved. *)\n    repeat find_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    unfold subsume. do 5 intro. intros n.\n    (* Reasoning this proof works *)\n    repeat find_insert; eauto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 719,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold osos.\n    intros.\n    case (le_gt_dec x n); [case (eq_nat_dec x n) | idtac]; intros;\n    (* In the case, [lookup_insert] does not happen *)\n    repeat find_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    unfold osub.\n    eapply osub_identity.\n    apply osub_identity.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    unfold lower_insert.\n    destruct o1; destruct o2; simpl; auto.\n    rewrite H0.\n    rewrite H.\n    auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold osub. intros. rewrite lookup_empty_None. apply osub_not_eq.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold osub.\n    intros.\n    rewrite <- H.\n    apply osub_Empty_2.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_gso. eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold osub. intros.\n    destruct o1.\n    - destruct o2.\n      * exists e1; split; auto.\n      * destruct o2; auto.\n      * destruct o3; auto.\n      * destruct o3; auto.\n      * destruct o3; auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros h1 h2. intro h1. intro h2. intro n. destruct n.\n    eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros. rewrite restrict_find_left. eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold osub. intros h1 h2. intro n.\n    rewrite <- (h1 h2); auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 708,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct e1, e2; simpl; intros.\n    split; auto.\n    eapply (H a2); auto.\n    intros; apply H; auto.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold partial_map, map.\n    intro a1.\n    destruct a2 as [a2 a3].\n    destruct e1 as [a3 a4].\n    destruct e2 as [a5 a6].\n    destruct e2 as [a7 a8].\n    destruct e as [a8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b8 a9].\n    destruct e as [b11 a12].\n    destruct e as [b11 a12].\n    destruct e as [b11 a12].\n    destruct e as [b11 a12].\n    destruct e as [b12 a13].\n    destruct e as [b11 a12].\n    destruct e as [b12 a12].\n    destruct e as [b21 a12].\n    destruct e as [b21 a22].\n    destruct e as [b21 a22].\n    destruct e as [b31 a22].\n    destruct eQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold id,id, id2, id1, id2.\n    apply functional_extensionality; intro t.\n    destruct t.\n    rewrite H; clear H.\n    unfold map_insert.\n    destruct t.\n    rewrite H0; clear H.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H0.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H0.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H0.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H0.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H0.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H0.\n    f_equal.\n    apply functional_extensionality; intro t.\n    rewrite H; clear H.\n    fQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f.\n    assert (H: forall a1 a2, sub a1 a2 -> sub a2 a1).\n    induction e1; intros; inv H; auto.\n    (* case, [x = a1] *)\n    exists (a1 :: f1). exists (a2 :: f2).\n    split. reflexivity.\n    simpl.\n    split.\n    eapply (H a1).\n    apply (H a2).\n    apply (H a1).\n    apply (H a2).\n    apply (H a2).\n    apply (H a1).\n    apply (H a1).\n    apply (H a2).\n    apply (H a2).\n    apply (H a2).\n    apply (H a1).\n    apply (H a2).\n    apply (H a2).\n    apply (H a1).\n    apply (H a2).\n    apply (H a2).\n    apply (H a2).\n    apply (H a1).\n    apply (H a2).\n    apply (H a2).\n    apply (H a2).\n    apply (H a2).\n    apply (H a2).\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold partial_map.\n    repeat rewrite functional_insert_unfold.\n    apply functional_insert_inversion.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold subsume. do 2 intro.\n    destruct H0.\n    split.\n    eapply (h 1).\n    intro n. eapply (h 1).\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    destruct a2; simpl in *.\n    split; auto.\n    destruct a2; simpl in *.\n    split; auto.\n    destruct a2; simpl in *.\n    split; auto.\n    destruct a2; simpl in *.\n    split; auto.\n    destruct a2; simpl in *.\n    split; auto.\n    destruct a1; simpl in *.\n    split; auto.\n    destruct a2; simpl in *.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    destruct a4; simpl in *.\n    split; auto.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    destruct a3; simpl in *.\n    split; auto.\n    destruct b; simpl in *.\n   Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f H e1 e2.\n    destruct e1; simpl in *;\n    inversion e2; subst.\n    (* S case *)\n    inversion e1; subst.\n    exists f.\n    simpl.\n    split; [reflexivity | split]; intros; apply H0.\n    apply (H0 (f a1) (f a2) (f a1) (f a2) (f a1) (f a2) (f a2) (f a2) (f a1) (f a2) (f a1 a2) (f a2) (f a1) (f a2) (f a2) (f a1 a2) (f a2) (f a2) (f a1 a2) (f a2) (f a1 a2) (f a2) (f a2) (f a1 a2) (f a2) (f a2) (f a2) (f a1 a2) (f a2) (f a2) (f a2) (f a2) (f a2) (f a2 a1) (f a2) (fQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    unfold partial_map; intros f H e1 e2 H1 e2 H2.\n    induction H1; simpl; intros.\n    destruct H2; auto.\n    destruct H2; auto.\n    destruct H2; auto.\n    destruct H2; auto.\n    destruct H2; auto.\n    destruct H2; auto.\n    destruct H2; auto.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct e1.\n    simpl in *.\n    split.\n    apply H.\n    split; auto.\n    apply H0; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n induction n; simpl; intros.\n omega.\n rewrite IHn. rewrite IHn.\n rewrite IHn.\n rewrite IHn.\n rewrite IHn.\n rewrite IHn.\n rewrite IHn.\n rewrite IHn.\n omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  induction n.\n  - simpl. apply IHn.\n    simpl. auto.\n  - simpl. auto.\n  - simpl. auto.\n  - simpl. auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\ninduction n; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintro n; induction n; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n intros.\n omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  rewrite IHn; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros n.\ninduction n; simpl; auto.\ndestruct (n + 1); auto.\ndestruct (n + 1); auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n intros n; rewrite <- (Nat2Z.inj_succ n).\n apply Nat2Z.inj_succ.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof. intros n; apply Nat2Z.inj_lt.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  destruct (IHn _ _ H); auto.\n  destruct n; simpl in H; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 650,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; simpl; intros.\n  omega.\n  simpl.\n  rewrite app_length. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  generalize (n + 1) H; clear n.\n  induction n; intros; simpl in *; omega.\n  auto.\n  auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e2; intros.\n  auto.\n  simpl in H.\n  destruct H.\n  simpl in H.\n  destruct (IHe1 _ H).\n  destruct (IHe2 _ H).\n  simpl in IHe1.\n  destruct (IHe2 _ H).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe1 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe1.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n  destruct (IHe2 _ H0).\n  simpl in IHe2.\n Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  rewrite IHn; omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; intros; simpl in *; try omega.\n  f_equal.\n  destruct (list_nth n e2).\n  rewrite app_nth_0; auto.\n  rewrite app_nth_1; auto.\n  rewrite app_nth_1; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  destruct (in_map_iff _ _ _ H); auto.\n  destruct (in_map_iff _ _ _ H); auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; intros.\n  auto.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite appQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 670,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; intros; simpl.\n  auto.\n  rewrite IHl, map_app, IHl, map_app, map_app, map_app, map_app, map_app, map_app.\n  simpl.\n  rewrite <- map_app. simpl.\n  rewrite <- map_app. simpl.\n  rewrite <- map_app. simpl.\n  auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  destruct (IHe _ _ H) as [e2 [e3 [He [? [??]]]].\n  exists e2.\n  rewrite e3.\n  rewrite <- e4.\n  rewrite <- e3.\n  rewrite <- e4.\n  reflexivity.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e1; simpl; intros; auto.\ndestruct (eq_nat_dec n n).\nsubst n.\nrewrite <- (shift_shift _ _ _ H).\nrewrite <- (shift_shift _ _ _ H).\nrewrite <- (shift_shift _ _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite (shift_shift _ _ H).\nrewrite <- (shift_shift _ _ H).\nrewrite (shift_shift _ _ H).\nrewrite (shift_shift _ _ H).\nrewrite (shift_shift _ _ HQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; intros; simpl; auto.\n  destruct e2; simpl in *.\n  destruct (e1 e2); simpl in *; try discriminate.\n  destruct (e2 e2); simpl in *; try discriminate.\n  destruct (e1 e2); simpl in *; try discriminate.\n  destruct (e2 e2); simpl in *; try discriminate.\n  destruct (e2 e3); simpl in *; try discriminate.\n  destruct (e2 e3); simpl in *; try discriminate.\n  destruct (e2 e3); simpl in *; try discriminate.\n  destruct (e1 e3); simpl in *; try discriminate.\n  destruct (e2 e3); simpl in *; try discriminate.\n  destruct (e3 e3); simpl in *; try discriminate.\n  destruct (e3 e4); simpl in *; try discriminate.\n  destruct (e3 e4); simpl in *; try discriminate.\n  destruct (e4); simpl in *; try discriminate.\n  destruct (e3 e4); simpl in *; try discriminate.\n  destruct (e4); simpl in *; try discriminate.\n  destruct (e4); simpl in *; try discriminate.\n  destruct (e4); simpl in *; try discriminate.\n  destruct (eQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  rewrite H.\n  rewrite IHl1. rewrite H.\n  rewrite <- (app_nil_r (e :: e1)).\n  rewrite <- app_ass.\n  rewrite <- (app_nil_r (e :: e2)).\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite app_ass.\n  rewrite <- app_ass.\n  rewrite app_ass.\n Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  rewrite IHa1. rewrite IHl1. rewrite H. reflexivity.\n  rewrite IHl1. reflexivity.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e2; simpl; intros.\n  auto.\n  destruct (IHe _ _ H0 H1) as [e1 e2].\n  destruct (IHe _ _ _ H1) as [e2 e3].\n  destruct (IHe _ _ _ H2) as [e3 e4].\n  destruct (IHe _ _ _ H2) as [e5 e6].\n  rewrite e3 in H1.\n  inversion H1.\n  rewrite e3 in H1.\n  inversion H1.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e e1 e2 k n H; induction e1; simpl; intros.\n  auto.\n  replace n with (S n) by omega. auto.\n  auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  rewrite H. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 672,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  rewrite IHx; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite H. simpl.\n  replace n with (S (length e1)) by omega.\n  rewrite H. simpl.\n  auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; simpl in H.\n  rewrite app_nil_r in H. discriminate.\n  rewrite app_ass. reflexivity.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  simpl.\n  rewrite app_assQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  - rewrite (IHs1 e1 e2) by auto.\n    rewrite (IHs1 e2 e1 e2) by auto.\n    rewrite (IHs1 e2 e1 e2) by auto.\n    rewrite (IHs2 e1 e2 e2) by auto.\n    rewrite (IHs1 e1 e2 e2) by auto.\n    rewrite (IHs1 e1 e2) by auto.\n    rewrite (IHs2 e2 e2 e2) by auto.\n    rewrite (IHs2 e1 e2 e2) by auto.\n    rewrite (IHs1 e2 e2 e3) by auto.\n    rewrite (IHs1 e2 e3) by auto.\n    rewrite (IHs1 e2 e3) by auto.\n    rewrite (IHs2 e3 e3) by auto.\n    rewrite (IHs1 e3 e3) by auto.\n    rewrite (IHs1 e3 e3) by auto.\n    rewrite (IHs1 e3 e3) by auto.\n    rewrite (IHs1 e3 e3) by auto.\n    rewrite (IHs1 e3 e3) by auto.\n    rewrite (IHs2 e3 eQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  replace (n + 0) with n by omega.\n  rewrite IHl; auto.\n  rewrite IHn; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl app.\n  rewrite app_ass.\n  rewrite app_ass.Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros A n x nx (o,e1) e1 e2.\n  destruct e1; simpl in *.\n  destruct n; simpl in *.\n  subst.\n  destruct n; simpl in *.\n  subst.\n  destruct n0; simpl in *.\n  subst.\n  assert (n = n) by omega.\n  subst n.\n  rewrite <- H1.\n  rewrite H.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewriteQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  - rewrite app_nil_r; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_nil_r; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.\n    rewrite app_ass; simpl.Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_assQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl.\n  rewrite IHn. reflexivity.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; destruct a.\n  rewrite IHl; auto.\n  rewrite IHn; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl; auto.\n  rewrite IHn. rewrite IHl. rewrite IHn. rewrite IHn.\n  auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite IHl; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  rewrite IHn. rewrite IHn. rewrite IHn. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  rewrite IHn; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  omega.\n  rewrite IHn. reflexivity.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  rewrite IHl. rewrite IHl. reflexivity.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite IHn. simpl. omega.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros.\n  auto.\n  destruct a. simpl. rewrite IHn. rewrite IHn. auto.\n  rewrite IHn. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  rewrite app_ass.\n  rewrite H.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite H.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite <- app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_assQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros.\n  destruct e1.\n  simpl.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite app_ass.\n  rewrite IHl1.\n  rewrite app_ass.\n  rewrite IHl1.\n  rewrite <- app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite IHl1.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite IHl1.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite <- app_ass.\n  rewrite (app_ass (length (tail (tail l1) (tail l1))).\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite (app_ass (length (tail l1) (tail l2))).\n  rewrite app_ass.\n  rewrite (app_ass (length (tail l1) (tail l1)).\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite app_ass.\n  rewrite (app_ass (Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  rewrite H.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite map_app.\n  simpl.\n  rewrite IHn.\n  rewrite map_app.\n  rewrite IHn.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite <- map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite <- map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  rewrite H; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  replace (list_nth n a (A:=A) n) with (map (fun i => ne)).\n  rewrite H0.\n  rewrite H0.\n  auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  destruct a.\n  destruct b.\n  simpl.\n  auto.\n  destruct b.\n  destruct b.\n  simpl.\n  destruct H.\n  subst.\n  destruct H.\n  rewrite H0.\n  simpl.\n  rewrite H.\n  simpl.\n  auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  omega.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl in *; auto.\n  rewrite IHn; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat. (replicate. a)] is just an iterated version of [insert. a]. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite (app_ass (A:=A)).\n  apply (IHl e).\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct (eq_nat_dec a a).\n  - subst.\n    rewrite map_app.\n    auto.\n  - simpl.\n    rewrite <- (IH insert_map (fun v => snd v) (rev e)).\n    rewrite map_app.\n    auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite (insert_app a e).\n  rewrite (insert_insert_app a e).\n  rewrite (insert_app a e).\n  rewrite (insert_insert_app a e).\n  rewrite (insert_uniq_insert_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_uniq_uniq_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq a e).\n  rewrite (insert_uniq_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq_uniq a e).\n  rewrite (insert_uniq_insert_uniq_uniq_uniq a e).\n  rewrite (insert_uniq_uniq_uniq aQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (app_nil_l (A:=A)).\n  rewrite (app_nil_r (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (insert_unfold _ _ _ (insert_unfold _ _ _)).\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (insert_unfold _ _ _ H).\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite (Permutation_length _ H).\n  rewrite (Permutation_length _ H).\n  rewrite (Permutation_length _ H).\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct (eq_dec a a).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a0).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a0).\n  subst.\n  destruct (H a0).\n  subst.\n  destruct (H a). subst.\n  destruct (H a).\n  subst.\n  destruct (H a0).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a0).\n  subst.\n  destruct (H a0). subst.\n  destruct (H a).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a). subst.\n  destruct (H a). subst.\n  destruct (H a0).\n  subst.\n  destruct (H a).\n  subst.\n  destruct (H a). subst.\n  destruct (H a0).\n  subst.\n  destruct (H a). subst.\n  destruct (H a).\n  subst.\n  destruct (H a). subst.\n  destruct (H a). subst.\n  destruct (HQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite (app_nil_r (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_ass (A:=A)).\n  rewrite (app_assQed."
                ]
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 571,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros s1 s2 r n pf pf1 pf2.\n  (* a_step /simple induction *)\n  { inversion pf1; subst. inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2; subst. inversion pf2. }\n  { inversion pf2. }\n  { inversion pfQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n; induction s1; intros.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ destruct a.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n destruct a.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl in H1.\n+ simpl inQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros s1 s2 r n pf pf.\n  rewrite /getS /getS /getS /getS; case: (getS s1 l); case: (getS s2 l); case: (getS s1 r); case: (getS s2 r); case: (getS s1 r); case: (getS s2 r); case: (getS s2 r); case: (getS s1 r); case: (getS s2 r); case: (getS s2 r); case: (getS s1 r); case: (getS s2 r); case: (getS s1 r); case: (getS s2 r); case: (getS s2 r); case: (getS s2 r); case: (getS s2 r); case: (getS s1 r); case: (getS s1 r); case.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n pf.\nhave: size r < n by apply: (size_take_In n).\nhave: size r < n by apply: (size_drop_In n).\nhave: size r < n by apply: (size_drop_In n).\nhave: size r < n by apply: (size_drop_In n).\nhave: size r < size r by apply: (size_drop_In n).\nhave: size r < n by apply: size_drop_In; apply: size_drop_In; move/ltnW/ltnW=> ->.\nhave: size r < n by apply: leq_trans (size_drop_In n).\nhave: size r < n by apply: leq_trans (size_drop_In n).\nhave: size r < n by apply: leq_ltn_trans (size_drop_In n).\nhave: size r < n by apply: size_drop_In; move/ltnW=> ->.\nhave: size r < n by apply: leq_trans (size_drop_In n).\nhave: size r < n by apply: leq_ltnQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n.\nmove=> s1 s1 s2 r n.\nmove=> s2 r n.\nhave: s1 = s2 /\\ r = getset n (getS s1 r) = getset n (getS s1 r).\nmove=> s1 s2 r n.\nhave: s1 = s2 /\\ r = getset n (getS s1 r) = getset n (getS s2 r).\nmove=> s2 r n.\nhave: s2 = s1 /\\ r = getset n (getS s1 r) = getset n (getS s2 r).\n- by move=> s1 s2 r n.\nmove=> s1 s2 r n.\nmove=> s1 s2 r n.\nmove=> s1 s2 r n.\ncase: (getS s1 r) => //= s2 r n.\nby rewrite H => r; rewrite H => r; rewrite H => r; rewrite H => r; move/andP; move/andP; move/andP; move/andP; move/andP; move/andP; move/eqP=>Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros s1 s2 r n s1 s2 r n.\n  case: n s1 s2 r n s1 r n => [|n s1 r s2 r n] //= H1.\n  (* 0 = 0 *)\n  - (* 0 = 0 *)\n    apply H; apply/eqP; rewrite -H1 in H0; inversion H0.\n    (* 0 = 0 *)\n    destruct s1; simpl in *; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate;\n      try destruct s2; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;\n      try (destruct s2; try discriminate; try discriminateQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n s1 s2 r n1 s2 r n2 def s1 r n1 def s2 r n1 def s2 r n2 def s1 r n2 def s1 r n1 def s2 r n2 def s2 r n1 def s2 r n1 def s1 r n2 def s2 r n2 def s1 r n1 def s2 r n2 def s2 r n1 def s2 r2 def s3 r n1 def s1 r n2 def s2 r n2 def s3 r n1 def s1 r2 def s3 r1 s3 r2 def s3 r1 def s3 r3 s4 n1 def s4 r1 def s4 r2 r2 def s4 r2 def s4 r4.\nProof.\nmove=> s1 s2 s3 s3 r n s1 s2 n s1 s2 n1 s2 n1 s2 n2 def s1 n1 s2 n2 def s1 s2 n1 s3 n1 def s1 s2 n2 def s3 n2 s3 n1 def s4Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros s1 s2 r n pf.\n  apply: (corestep_trans pf).\n  - apply: (corestep_trans pf).\n  - apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H1.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H2.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H1.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H2.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H2.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H2.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H1.\n    apply: (corestep_mem (fun w => a_step pf (getS s1 l))); first by rewrite H2Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n pf.\nmove: s1 s2 r n pf.\nmove: n pf.\nelim: n pf=> //= s1 s2 r n pf.\nby rewrite /getS s1 /= /getS s2 /= /getS s1 /= /getS s2 /= /getS s2 /= /getS s2 /= eq_refl.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>s1 s2 r n pf.\nelim: n s1 s2 r n m H0 H1 H2 H3 H4;\nmove=>s1 s2 r n pf m H1 H2; rewrite /getS; move: (getS s1 s2 r n m H2 H3) => H1.\nrewrite /getS; move: (getS s1 s2 r n m H1 H3); rewrite /getS; move: (getS s1 s2 r n m H1 H3);\nrewrite /getS; move: (getS s1 s2 r n m H1 H3); rewrite H1;\n by rewrite /getS; move: (getS s1 s2 r n m H1 H3); rewrite H1;\nby rewrite /getS; move: (getS s2 r n m H1 H3); rewrite H2;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "X Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>S; apply/maxgroupP; apply: H; apply/andP; split;\nby rewrite /= /getS /= => /andP[s' S'].\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s1 s2 r n1 s1 s2 r n2 s1 n2 s2 n1 s2 r n2 s1 n2 s2 n1 s2 r n2 s1 n2 s2 n2 s1 n2 s2 r n1 s2 n2 s2 n.\nby case=>H1 H2 H3 H4 H5 H6; apply: H5.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>s H; apply: (safe_sub H); first by rewrite H.\nby rewrite /getS.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> H1; case: (getP s l); first by rewrite H1.\nby rewrite /getP /= /= => ->; apply: H1.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>p [x [s1 [x [s2 [x' [s3 [x' [s3 [x' [s4 s5 x' s6]]]]]]]].\ncase/and3P=> s1 s2 [x [s2 [x' [s3 [x' [s4' [x'' [s6' [s6' [s7' [s7' [s8' [x'x' [s6' [s7' [s8'x' s8'x'x'x' [s8'x'x' [s8'x'x'y' s'x's'y'y's's' [s'x'y' [s'x'' [s'' [x'' [s8'x'x's'' [s'x' [x'' s's'x'y' s'x's's'x's'x'' s'' s'x'' s's'']]]]]]]]]]]]]]]].\nmove=>s1 s1 s2 s2 s1 s2 s2 r n s1 s2 r n s1 s2 r n sQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>p L s; apply: (iffP (H s)).\nrewrite /= in_cat => /andP[s'p Ls]; apply: (iffP (H s')).\nby rewrite /= in_cat => /andP[s'p Ls]; apply: (iffP (H s)).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>p s; apply: step_path; apply: step_path.\nmove=>x s; apply: step_path; rewrite /getS.\nby apply: step_path; rewrite /getS.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H s H; rewrite /getP.\nelim: s H s => //= s s H s' H1; rewrite /getP.\nelim: s H s' H1 s' H2=> //= s' H2; rewrite /getP.\nmove=> s' H2 s'' H3; rewrite /getP.\nelim: s H2 s' H3 s'' H4 H5 H6; rewrite /getP.\nmove=> s'' H4; rewrite /getP.\nelim: s H4 s' H5 H6 H6 H7 H8 H9; rewrite /getP.\nrewrite H3.\nby rewrite /getP.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s; apply/andP; apply/andP; apply/andP; apply/andP; apply/andP.\nmove=> s1 s2 r n; rewrite /getS.\nmove=> s1 s2 r n; rewrite /getS.\nmove=> s1 s2 r n; rewrite /getS.\nmove=> s1 s2 r n; rewrite /getS.\nmove=> s2 r n; rewrite /getS.\nmove=> s1 s2 r n; rewrite /getS.\nmove=> s2 r n; rewrite /getS.\nmove=> s1 r n; rewrite /getS.\nmove=> s1 s2 r n; rewrite /getS.\nmove=> s1 r n; rewrite /getS.\nmove=> s2 r n; rewrite /getS.\nmove=> s1 r n; rewrite /getS.\nmove=> s2 r n; rewrite /getS.\nmove=> s1 r n; rewrite /getS.\nmove=> s2 r n; rewrite /getS.\nmove=> s1 r n; rewrite /getS.\nmove=> s1 r n;Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 s1 s2 r n p; elim: s1 s2 => //= s1 s2 s2 r n p.\nhave H2 : step s1 s2 r -> s2 r -> n step s r.\nby move=>H1 H2; apply: H1; rewrite /getL in H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "let in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>S1 S2; elim: s S1 S2 => [|s' s1 r IHr]; first by exists s1; split.\nby case=>s1 r; right; exists s1; split; [apply: H | apply: H].\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>S H.\nhave [n H1] := (step_step S (n - 1) (S n) H1).\nhave [H2] := (step_step S (n - 1) H2).\nhave: s1 = s2 by apply/step_stepN; exists s2; auto.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\ncase: s S => s' r /= s r /= s r /= s r /= s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r /= S s r.\nProof.\nmove=> S s S s S /= s S /= s S /= s S /= s S /= S s /= S s /= S s /= S s /= S s /= S s /= S s.\nby rewrite eq_sym in S; rewrite eq_sym in S; apply: S; rewrite eq_sym in S; apply: S; rewrite eq_refl.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nelim: s => [|s s IH]; first by case.\n- by move=>H; apply/prefix_cons/IH.\n- by move=>H; apply/prefix_cons/IH/IH.\n- by move=>H; apply/prefix_cons/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>S; apply: step_path_step; last by apply: step_path_step_total.\nby apply: step_path_step_total; apply: step_path_step_total; apply: step_path_step_total; apply: step_path_step_total.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=>S1 S2; case: S2 => s1 s2 r; rewrite /start_step_total.\nmove=> S2; case: S2 => s2 r; rewrite /start_step_total.\nmove=> S1; case: S2 => s1 s2 r; rewrite /start_step_total.\nmove=> S2; case: S2 => s1 s2 r; rewrite /start_step_total.\nmove=> S2; case: S2 => s2 r; rewrite /start_step_total.\nmove=> S1; case: S2 => s1 s2 r; rewrite /start_step_total.\nmove=> S2; case: S2 => s2 r; rewrite /start_step_total.\nmove=> S2; case: S2 => s1 s2 r; rewrite /start_step_total.\nmove=> S2; case: S2 => s1 s2 r; rewrite /start_step_total.\nmove=> S1; case: S2 => s2 s1 r; rewrite /start_step_total.\nmove=> S2; caseQed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by exists s1, (f (safe_sub s1 s2)). Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by do 2!move=>s1 s2 r; apply: step_path_leq_trans; apply: step_path_leq_total. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=>S1 [s1 S1] s2 S2; move: S1 => S2.\nhave S1: s1 \\In S1 by exists s2; split; [apply: step_refl | apply: step_trans].\nexists s1, (f s1, (f s2, (f s1, (f s2, f s2)))) /\\\n               (f s1, (f s2, (f s1, (f s2, f s2)))) /\\\n               (f s1, (f s2, (f s1, (f s2, f s2)))) /\\\n               (f s1, (f s2, (f s1, (f s2, f s2)))) /\\\n               (f s1, (f s2, (f s1, (f s2, f s2)))) /\\\n               (f s1, (f s2, (f s1, (f s2, f s2)))) /\\\n               (f s1, (f s2, (f s1, (f s2, (f s2, f s2)))) /\\\n               (f s1, (Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=>S [s1 [s2 [P [Q R]]]].\nby rewrite eq_sym in Q; apply: (safe_sub S) => s1 s2.\nQed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=>S1 S2.\nhave: s1 \\In 'h'\" by apply: (step_star_step_total S1).\nmove=> S1; case: S2 => // S1 S2; move: S2 => /= S2.\nmove: S1 => S1 S2; case: S2 => //= S1 S2; move: S2 => /= S2.\nby rewrite eq_sym in S1; rewrite eq_sym in S2 *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ";\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; apply: step_step_deterministic; first by move/step_deterministic.\nby move=> s2 S1; apply: step_trans; [apply: H2 | apply: H3].\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S1 S2; case: s1 S1 S2 => [[s1 S1] S2] S1 S2.\ncase: S1 S2 => [[s2 S2] S3] S1.\ncase: S1 S2 => [[s2 S3] S3] S4.\ncase: S1 S2 => [[s3 S4] S5] S6 S6 S7 S7.\nby case: S2 => [[s4 S5] S6] S7 S8.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; case: s1 => [[s1 s2] /= <- H1 H2];\nby rewrite eq_sym in S; rewrite /getNext!inE.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by do 3!case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; case: (step_star S s1 s2)=>H1.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\n- by rewrite /safe_app.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S s2 [S' S' S'] S' S' S' S' S'' S'' S' S' S'' S' S''.\napply: (step_star S' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S''.\n- apply: (step_star S' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S''.\n  - apply: (step_star S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S''.\n  - apply: (step_star S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S''.\n  - apply: (step_star S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S''.\n  - apply: (step_star S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S'' S''.\n Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S1 S2; elim: s1 S2 => [|x s2 r IHr] S1 S2.\n- case: S2 S2 => [|x s1 r IHr] S1 S2.\n  + case S2 => [|x s2 r IHr] S2.\n    by case S2 => [|x s2 r IHr] S2.\n    + case S2 => [|x s2 r IHr] S2.\n      exists x; split; [rewrite IH | right]; split; first by exists x; apply.\n      + case S2 => [|x s2 r IHr] S2.\n        by case S2 => [|x s2 r IHr] S2.\n        rewrite IH; auto.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S1 S2; case: S2=>S2 S2; case: S2=>S2 S3 S4.\n- by case: S3 => S3 S4.\n- by case=>S3 S4.\ncase: S4=>S4 S4.\n- by case=>S4 S4; case=>S5 S5.\nsuff S6: S5 = S4 by case=>S5 S6 S6 S6 S7 S8.\nhave S6: S6 = S6 by case=>S5 S6 S6 S7 S8.\ncase: S5=>S5 S6 S7 S8 S8 S10 S12 S13 S14 S14.\n- by case=>S5 S6 S7 S8 S12.\ncase: S5 => S5 S6 S6 S7 S8 S6 S8 S12.\nsuff S6: S5 = S6 by case=>S6 S6 S6 S7 S8 S8.\ncase: S5 S6 => S7 S6 S6 S7 S8 S8 S10.\nby case=>S6 SQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S1 S2; move: S2=>S2 S1 S2; case: S2 => //= S1 S2.\nby rewrite eq_sym in S2; rewrite eq_sym in S1.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>s; apply/idP/idP; first by apply: h_valid_val; apply: h_valid_val; apply: h_valid_val; apply: h_valid_val.\nby rewrite eq_sym in s; apply: (h_valid_val); apply: h_valid_val; apply: h_valid_val; apply: h_valid_val.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=> f_valid_val; case: s => {f_valid_val}.\nby move: (findP_val); case: s => {f_valid_val}.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\ncase: s => [s' /=|].\nby move=> s' /= /getP[_ H]; apply: H.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\ncase: s=>[x [H1 H2] H3]; exists x; first by apply: try_var_safe_fresh_st; auto.\nmove: (H1 x); rewrite /getP /= => H1.\ncase: H1=>[x [H2 H3]].\nby apply: H1 H2; move: (H3 x); rewrite /getP /= in H2 *.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=> s.\nmove=>H1 H2; apply: H2; apply: H2; apply: H1; auto.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>s; apply: try_recv_act_safe_alloc s. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>s; apply: try_recv_act_safe_form. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>s; apply: try_ind; apply: try_ind; apply: try_ind; apply: try_ind. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: H2; auto.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>s; apply: try_recv_act_safe_at s.\nby apply: try_readv_act_safe_valid_val; apply: try_readv_act_safe_read_path.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> r s r s' r.\ncase: r s=> [|{ r} r r /=.\n- case=>x s' r'].\n  - move=> H; inversion H; subst; auto.\n  - move=> H; inversion H; subst; auto.\n  - move=> H; inversion H; subst; auto.\n  - move=> H; inversion H; subst.\n    - move=> H; inversion H; subst; auto.\n  - move=> H; inversion H; subst; auto.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof. by case: s => //= i s; rewrite -n. Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nelim: s => [|{s} s' r IHr def r IHr def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r def r defQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\ncase: s => [x y] [y y] [z' y'] [z' y'] [z' y'] [z' y'] [z' z'] [z' y'] [z'' z'] [z'' z'' z'' [z'' z'' z'' z'' [z'' z'' [z'' z'' z'' z'' [z'' z'' z'' [z'' z'' z'' z'' [z'' z'' z'' [z'' z'' [z'' z'' z'' z'' [z'' z'' z'' [z'' z'' [z'' z'' [z'' [z'' z'' z'' [z'' z'' [z'' z'' [z'' [z'' z'' z'' z'' [z'' [z'' z'' [z'' z'' [z'' [z'' z'' z'' [z'' z'' [z'' z'' [z'' z'' [z'' z'' [z'' [z'' z'' [z'' [z'' z'' [z'' z'' z'' [z'' [z'' z'' [z'' [z'' z'' [z'' z'' [zQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> r s r s' r.\nelim: s r s r; [intros n s s r] s r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\n- by exists (m :: r); rewrite /r.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nelim: s => [|s' r IH] s' r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\n- by exists [rs r] => r.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> s r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmove=> r.\nmoveQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> r s r.\nelim: s r s r => [|s r] s r /=.\n- by exists [::] => // r [].\n- by exists nil => // r [].\n- by exists nil => //; exists r.\n- by exists nil => //; exists r.\n- by exists nil => //; exists r.\n- by exists nil => //; exists r.\n- by exists nil => //; exists r.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> s;\ncase: s => s' r s' r s' r s' r s' r s' r s' r s' r.\ncase: s => s' r s' r s' r s' r.\n- case: s => s' r s' r s' r s' r s' r.\n  by move=> s r s' r s' r s' r s' r s' r' s' r' s' r' s' r' s' r' s'' r' s''.\n- case=> s r s' r s' r s' r s' r s' r s' r s' r' s''.\n  by move=> s r s' r s' r s' r s' r s' r s' r s' r s' r' s' r' s' s''.\n  by move=> s r s r s' r s' r s' r s'' r s' r' s' r' s'' r s''.\n  by move=> s r s'' r s' r s' r s'' r' s'' r' s''.\n- case=> s' rQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> s' r H; apply/try_recv_act_step_total=> [[s' r] /= H].\nby exists s'; split=>//; exists s'; split=>//; exists s'; split=>//.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /try_casev_act_step.\ncase: (classic (exists l, r = Some (x :: l)))=>[H|H]|H].\n- move=>C; rewrite /try_casev_act_step.\n  by exists l; rewrite /update2; right; exists l; rewrite /update2; right; exists l; rewrite /update2; right.\nby move=>H; rewrite /update2; right.\nmove=>C; rewrite /update2; right; exists l; rewrite /update2; right; exists l; rewrite /update2; right.\nby move=>H; rewrite /update2; right.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, s1 l = s2 r))=>[r|n]; first by rewrite /seqv_act_step.\n- by exists r.\nmove=>D; rewrite /try_case.\nby exists r; [ by left | exists l; rewrite /seqv_act_step].\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, r = Some l /\\ r = Some (x :: l))) => [s]; last first.\n- move=>H; exists s, r; split=>//; last first.\n  by exists l, s; split=>//; right.\n- move=>H; exists s, r.\n  by exists l; split=>//; right.\n- move=>H; exists s; split=>//; right.\n- move=>H; exists s; split=>//; right.\n- move=>H; exists s.\n  by exists r, s; split=>//; right.\nby move=>H; exists l; split=>//; right.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l1, r = Some (x :: l1), r)).\n- move=>B; rewrite /tryrecv_act_step_safe.\n  by exists r; left; split=>//l m; apply: E.\n- move=>A; rewrite /tryrecv_act_step.\n  by exists r; right; exists l, m, m, s1.\nby exists r; right; split=> //; apply: E.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists r, r = Val.has r)) => [m|m]; first by rewrite /unv_act_step.\ncase=>r [m][ok] D; rewrite /unv_act_step.\ncase=>r [D] D; rewrite D in D.\nby exists r, m, r.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, r = Some (x,l))) => [n][n][n][n][n][n][m][n][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][T][TQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, s1 l = s2 r)) => [|{r}s1 D E1 E2 E1 E3 E3.\n- move=>D; rewrite E1 in D.\n  by exists l; rewrite /f_v_act_step.\ncase: (classic (exists l, s1 l = s2 r)) => [[l] D E1 E2 E3].\n- move=>D; rewrite E1 in D.\n  by exists l; rewrite /f_v_act_step.\ncase: (classic (exists l, s1 l = s2 r)) => [[l] D E1 E2 E3 E4].\n- move=>D; rewrite E1 in D.\n  by exists l; rewrite /f_v_act_step.\ncase: (classic (exists l, s1 l = s2 r)) => [[l] D E1 E2 E3].\n- move=>D; rewrite E1 in D.\n  by exists l; rewrite /f_v_act_step.\ncase: (classicQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, is_true (l, is_true (l, is_true (l, is_true (l, is_true (l, is_true)))) then\n                      let: d' :=  d in\n                      r = Some (from, l) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) \\/ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (from, r)) /\\ (r = Some (Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l1 m m1,\n                r = Some (from, s1) /\\\n                def (m1, m1) = (t_rcv_on s1 m1) /\\\n                def (m1, m1) = (t_rcv_on s1 m1) /\\\n                def (m1, m1) = (t_rcv_on s2 m1) /\\\n                def (m1, m1) = (t_rcv_on s1 m1) /\\\n                def (m1, m1) = (t_rcv_on s2 m1) /\\\n                def (m2, m2) = (t_rcv_on s2 m1) /\\\n                def (m2, m1) = (t_rcv_on s2 m2) /\\\n                def (m1, m1) = (t_rcv_on s2 m1) /\\\n                def (m1, m2) = (t_rcv_on s1 m1) /\\\n                def (m1, mQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, p & r = Some (from, p))=>//.\n- by exists s2, r.\nrewrite /trystepv_act_step.\nmove=>D; rewrite /trystepv_act_step.\nmove=>D; rewrite /try_retv.\nby exists r; exists r; split=>//; right.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l, exists m, exists s', step s1 s' r)).\n- move=>S; rewrite /tryrecv_act_step.\n  apply: contraS => S; rewrite (IH S); left; split=> //.\n  by apply: contraS => S; rewrite (IH S); right.\n- move=>S; rewrite /tryrecv_act_step.\n  by apply: contraS => S; rewrite (IH S); right.\n- move=>S; rewrite /tryrecv_act_step.\n  by apply: contraS => S; rewrite (IH S); right.\n- move=>S; rewrite /tryrecv_act_step.\n  by apply: contraS => S; rewrite (IH S); right.\n- move=>S; rewrite /tryrecv_act_step.\n  by apply: contraS => S; rewrite (IH S); right.\n- move=>S; rewrite /tryrecv_act_step.\n  by apply: contraS => S; rewrite (IH S); left.\n- move=>S;Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l, step (fun s2 => step (fun s2 => step (fun s3 => step (fun s4 => step (fun s5 => step (fun s5 => step (fun s6 => step (fun s5 => stepfun s6 => step (fun s6 => stepfun s6 => step (fun s6 => stepfun s6 => stepfun s6 => stepfun s6 => stepfun s6 => stepfun s6 => stepfun s6 s7))))\n                              (fun s4 => step (fun s4 => step (fun s5 => stepfun s6 => stepfun s6 => stepfun s6 => stepfun s6 s7))\n                              (fun s6 => step (fun s6 => stepfun s6 => stepfun s6 => stepfun s6 => stepfun s6 (fun s6 => stepfun s6 => stepfun s6 => stepfun s6)\n                              (fun s6 => stepfun s6 => stepfun s6 (fun s6 => stepfun s6)\n                              (fun s6 => stepfun s6 =>Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l, s1 = s2 /\\ s2 = s2)).\n- move=>H; exists s1, s1, s2; split=>// l m def.\n  by apply: (H (State s1 (fst l))) => //= H.\n- move=>H; exists s1, s2; split=> //.\n  apply/negP=>Z; rewrite Z in E1; clear E1.\n  by rewrite E in E1; clear E1.\nmove=>H; exists s1, s2; split=> //; exists s2, s1, s2.\n- move=>H; exists s2, s1, s2.\n  by apply: (H (State s1 (snd l)) => //= H.\n- by apply: (H (State s1 (snd l))=> // H.\n- move=>H; exists s1, s2; split=> //; exists s1, s2.\n- move=>H; exists s2, s1, s2.\n  by apply: (H (State s1 (snd l)) HQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l, exists s', s' l = s' /\\ t_rc v_wf (getS s1 l))))=>H1 H2.\ncase: (classic (exists l, exists s', s' l = s' /\\ t_rc v_wf (getS s1 l))))=>H2 H3.\n- move=>S.\n  have: s' = s' by apply: H1.\n  by exists l, s'; apply: H2.\ncase: (classic (exists l, exists s', s' l = s' /\\ t_rc v_wf (getS s1 l))))=>H2 H.\ncase: (H1 H2)=>[H2 H3].\n- move: (H2 H)=>H4.\n  by exists l; apply: H2.\n- move: (H3 H)=>H4.\n- move: (H3 H)=>H5.\n- move: (H1 H)=>H6.\n  by exists l; apply: H2.\n- move: (H2 H)=>HQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l, exists t, step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t)))) t))) t))) s1 =>\n                   match step1 with\n                   | Some (s1, s2) => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t => step_to_step (fun t))) t))) t)) t)\n                   end s1 =>\n                   match step2 with\n                   | Some (s1, s2) => step_to_stepQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S s1 s2 r.\ncase: (classic (exists s1, s1 = s2 /\\ netype (snd s1) (snd s2))).\n- move=>S s1 s2 r.\n  case: (classic (S (snd s1))) => [s1 s2] [s2 s3] /= [t] /= H1.\n  by exists s1, s3; left; split=>s1 s2 s3.\n- case: (classic (S (snd s1))) => [s1 s2] /= [t] /= [t] /= H1.\n  by exists s1, s2; right; split=>s1 s2 s3.\n- case: (classic (S (snd s1))) => [s1 s2] /= [t] /= H1.\n  by exists s1, s2; right; split=>s1 s2.\n- move=>S s1 s2 s2 r.\n  case: (classic (S (snd s1))) => [s1 s2] /= [t] /= H2.\n  by exists s1, s2; left; splitQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l, r = Some r)) => s.\n- move=>H; exists s1, s1.\n  apply/negP=>Z; rewrite Z in E1; clear E1 E1.\n  apply/negP=>Z; rewrite Z in E1; clear E1.\n  apply/negP=>Z; rewrite Z in E1; clear E1.\n  apply: E1; move: (L t1 E2); move: (L t1 E2); move: (L t2); move: (L t1); move: (L t1); move: (L t2); move: (L t2); move: (L t2); move: (L t1); move: (L t2); move: (L t2); move: (L t2); move: (L t2); move: (L t1); move: (L t2); move: (L t2); move: (L t1); move: (L t2); move: (L t1); move: (L t2); move: (L tQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\nmove=>S1; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S1; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S1; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S1; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_step.\nmove=>S1; rewrite /tryrecv_act_step.\nmove=>S2; rewrite /tryrecv_act_Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; apply: try_ind2; apply: try_ind2; apply: try_ind2; apply: try_ind2; apply: try_ind2.\ncase: (classic (exists l, exists s', s1 = s' /\\ s2 = s')).\n- move=>S; apply: try_ind2; apply: try_ind2; apply: try_ind2; apply: try_ind2.\n  apply: try_ind2; apply: try_ind2; apply: try_ind2; apply: try_ind2.\n  apply: try_ind2; apply: try_ind2; apply: try_ind2; apply: try_ind2.\n  apply: try_ind2; apply: try_ind2; apply try_ind2; apply: try_ind2; apply.\n  apply: try_ind2; apply try_ind2; apply try_ind2; apply: try_ind2.\n  apply: try_ind2; apply try_ind2; apply: try_ind2.\n  apply: try_ind2; apply try_ind2; apply: try_ind2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 743,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>e H; case: Hg => /= [s H1]; case: Hg => /= [s H2];\ncase: Hg => //= [s H1]; case: Hg => //= [s H2];\ncase: Hg => //= [s H2]; case: Hg => //= [s H2];\ncase: Hg => //= [s H2]; case: Hg => //= [s H2];\ncase: Hg => //= [s H2];\ncase: Hg => //= [s H2]; case: Hg => //= [s H2];\ncase: Hg => //= [s H2]; case: Hg => //= [s H2];\ncase: Hg => //= [s H2];\ncase: Hg => //= [s H2]; case: Hg=> //= [s H2];\ncase: Hg => //= [s H2]; case: Hg;\ncase: Hg=> //=;\ncase: Hg => //=; case: Hg;\ncase: Hg=> //=; case: Hg;\ncase: Hg=> // [s H2]; case: Hg;\ncase: Hg=> //=; case: Hg=> //= [s H2];\ncase: Hg; case:Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> st; apply: (iffP (send_to_se _ st)) => [[f' [s' [J' J]]]] | [f' [s' J]]]] | ].\n- (* Now we have to show that the step *)\n  exists s'; split; [|split]; first by apply: (IH (s, J')); apply: (IH (s, J')); apply: (IH (s, J')); apply: (IH (s, J')); apply: (IH (s, J')); apply: IH.\n  * apply: IH; apply: IH; apply: IH; apply: IH; apply: IH; apply: IH; apply: IH.\n  * apply: IH; apply: IH; apply: IH; apply: IH.\n  * apply: IH; apply: IH; apply: IH; apply: IH; apply: IH.\n  * apply: IH; apply: IH; apply: IH; apply: IH; apply: IH.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>s J; elim: s => //= s IHs /andP[s J].\nelim: s => //= s IHs /andP[s J].\nrewrite IHs /s /s /s /s /s /s /s /s /s /s /s /s /s /s.\nby rewrite IHs /s /s /s /t /t /t /t /t /t /t /t /t /t /t /t /t /t /t /t /t /t.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>e H; case: (getP e)=>e H; case: (getP e)=>e H.\nmove=>D H; move: (getP e)=>e H; case: (getP e)=>e H.\nmove=>D H; move: (getP e)=>e H; move: (getP e)=>e H.\ncase: (getP e)=>e H; move: (getP e)=>e H.\nmove=>D H; move: (getP e)=>e H; move: (getP e)=>e H.\nmove=>D H; move: (getP e)=>e H; move: (getP e)=>e H.\nmove: (getP e)=>e H; move: (getP e)=>e H.\nmove=>D H; move: (getP e)=>e H.\nmove: (getP e)=>e H; move: (getP e)=>e H.\nmove: (getP e)=>e H; move: (getP e)=>e H.\nmove: (getP e)=>e H.\nmove: (getP e)=>e H.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> H1 s1 [H2 H3]; apply/allP; auto.\nmove: H2 H3; apply/allP; auto.\nmove: H3; apply/allP; auto.\nmove: H3; apply/allP; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> st st st' st' st' st' st' st' st' st' st' st'' st''.\ncase=>S s st st' st' st'' st'' st'' st''.\ncase=>S s st' st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' st'' st'' st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st''.\ncase=>S s st'' st'' st'' st'' stQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>s1 s2 H1 [st1' [H1 H2] H3];\n[apply/eqP; apply/andP; apply: H1 | apply: H3].\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=> [[st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st [st' [st' [st' st']]]]]]]]]]]]]]].\n(* Now we need to write the SEP clause *)\napply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st).\napply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st).\napply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st).\nby apply: (test_unst st); first by apply: (test_unst st); first by apply: (test_unst st).\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> st st st st / st / st / st / st / st / st / st.\nelim: st st st / st / st / st / st / st / st / st / st.\n- move=> st st / st / st / st / st / st / st / st / st.\n  move=> st st / st / st / st / st / st / st.\n  by rewrite /st /st /st /st /st /st /st /st /st.\nmove=> st st / st / st / st / st / st / st / st / st / st.\nmove=> st / st / st / st / st / st / st / st / st / st.\nmove=> st / st / st / st / st / st / st / st / st / st.\nmove=> st st / st / st / st / st / st / st / st / st / st.\nrewrite /st /st /st / st / st / st / st / st / st / st / st / st.\nmove=> st / st / st / st / st / st / st / st / st / st / stQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>e H1 H2; apply: (H2 (sread_s_s H2)).\nby apply: (IH (sread_s H2)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>e s1 IHs1 e1 s2 H; elim=>s1 s2; elim=>s1 s2.\n- rewrite /s1 /s2 /s1 /s2 /s2 /s2 /s2 /s2 /s2 /s3/s3/s4/s5.\n  by apply: (IH (s2:=s1) (s2:=s2)); apply: (IH (s2:=s2)); apply: IH (IH (s2:=s1)); apply: IH; apply: IH.\n- rewrite!s2 /s2 /s2 /s3 /s3 /s4/s4/s5/s6/s6/s7/s7/s8/s8/s9/s9/s9/s10/s10/s10/s12/s12/s12/s12/s12/s12/s13/s12/s13/s14/s12/s23/t12/s23/s23/s23.\n- rewrite!s3 /s4 /s4 /s4 /s4/Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>s [st [[]] s].\ncase=>s [st [[]] s].\ncase=>s [st [[]] s].\ncase=>s [[]] s].\ncase=>s [st [[]] s].\ncase=>s [[s] s].\ncase=>s [st [[]] s].\ncase=>s [[s] s].\ncase=>s].\ncase=>s [[s] s].\ncase=>H1 [st [[]] s].\ncase=>H2 [st [[]] s'].\ncase=>s1 [st [[]] s2].\ncase=>s2 [[H2 H3] t]].\ncase=>s [[H4] t]].\ncase=>s H4; first by apply/andP; apply: (IH (st_to H4 H4)).\ncase=>s [[H5] t]].\ncase=>s H5 [st [[]] s].\ncase=>s [[H5 _] t].\ncase=>H6 [st [[]] s'].\ncase=>s [[H7 H8] t].\ncase=>s [[H8 H8] t].\ncase=>H5 [st [[]] s'].\ncaseQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>x y [xs [ys [ys [H [H [H [H' [H' H'']]]]]][_ H' [H' [H'' H'']]]] | H'' [H'' H'']]].\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>C; rewrite /fold_left /=.\napply: (unmap_unmap (fun s => send_act_safe (snd_stars st)) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>s [[H1 H2] [H3 H4] [H5 H6] H7]; subst.\ncase: (send_safe s); case=>s [s H5] [H6] [H7] H8]; subst.\ncase: (send_safe s); case=>s [H7] [H7] [H8] [H9] H10]; subst.\ncase: (sskip_safe s); case=>s [H9] [H10] [H11] [H12] H12; subst.\ncase: (sskip_safe s); case=>s [s H10] [H12] [H13] H13; subst.\ncase: (sskip_safe s); case=>s [H12] [H13] H13; subst.\ncase: (sskip_safe s); case=>s [H12] [H13] [H14] H15; subst.\ncase: (sskip_safe s); case=>s [H13] [H14] [H15] H15]; subst.\ncase: (sskip_safe s);Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=> st st st' s1 H1 H2 H3;\ncase=>st H1 H3 H4;\ncase=>st' H5;\ncase=>st' H6;\ncase=>st' H6;\ncase=>st' H6;\ncase=>st' H6;\ncase=>st' H7;\ncase=>st' H7;\ncase=>st' H7;\ncase=>st' H7;\ncase=>st' H7;\ncase=>st' H8;\ncase=>st' H7;\ncase=>st' H8;\ncase=>st' H8;\ncase=>st' H8;\ncase=>st' H9;\ncase=>st' H8;\ncase H9;\ncase=>st' H9;\ncase=>st' H9;\ncase=>st' H10;\ncase=>st' H9;\ncase=>st' H10;\ncase=>st' H10;\ncase=>st' H12;\ncase=>st' H12;\ncase=>st' H12;\ncase=>st' H12;\ncase=>st'Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=> st st st' st' st' st' st' st' st' st' st' st'.\nelim: st st' st' st' st' st' st' => st' st' st' st' st' st'.\nelim: st st st' st' st' st' st' => st' st' st' st' st' st' st' st'.\n- (* (S,S) *)\n  apply: (all_all_all (fun st' => st' st' st' st' st' st' st' st' st' st' st' st' st' st' st'' st''.\n- (* (S,S) *)\n  apply: (all_all_all (fun st' => st' st' st' st' st' st' st' st' st'' st'' st'' st'' st'' st'' st'' st'' st''.\n- (* (S,S) *)\n  apply: (all_all_all (fun st' => st' st' st' st' st'' st'' st'' st'' st'' st'' st'' st'' st'' st'' st'' st''Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>S H1; case: (send_safe st s); case=>s [H2 H3].\nelim: (send_safe st s); case=>s [H3 H4].\nrewrite /send_safe; case=>s [H4 H5].\nrewrite /send_safe; case=>s [H4 H5].\nrewrite /send_safe; case=>s [H5 H5].\nrewrite /send_safe; case=>s [H6 H6].\nrewrite /send_safe; case=>s [H5 H6].\nrewrite /send_safe; case=>s [H5 H6].\nrewrite /send_safe; case=>s [H5 H6].\nrewrite /send_safe; case=>s [H5 H6].\nrewrite /send_safe; case=>s [H5 H6].\nrewrite /send_safe; case=>s [H5 H6].\nrewrite /send_safe; case=>s [H6 H7].\nrewrite /send_safe; case=>s [H7 H8].\nrewrite /Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>i [n [s [n [s [n [s [n [n [s [n [n [s [n [n [s [n [n [s [n [n [n [s [n [s' [n' [s' [n' [n' [n' [s' [n' [n' [s' [n' [n' [n' [s' [n' [n' [s' [n' [s' [n' [n' [n' [s' [n' [n' [n']]]]]]]]]]]]]]]]]]]]]]].\nexists n; exists s; exists s'; exists s'; split.\ncase=>i [n [s [n [s [n [n [s [n [s' [n [n [s' [n' [s' [n' [n' [s' [n' [n' [s' [n' [n' [s' [n' [n']]]]]]]]]]]]]]]].\nexists n; exists s'; exists s'; split.\ncase=>i [s [n [s [n [s [n [s [n [s [nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase: S => s ss s' r /= /andP[s2' r].\nby exists (2' :: s2'); rewrite /=!sem_add! sem_add!sem_add! sem_add! sem_add! sem_add!sem_add! sem_add! sem_add!sem_add! sem_add! sem_add!sem_add! sem_add! sem_add! sem_add! sem_add!sem_add! sem_add! sem_add! sem_add! sem_add!sem_add! sem_add!sem_add! sem_add! sem_add! sem_add! sem_add! sem_add! sem_add! sem_add!sem_add! sem_add! sem_add! sem_add! sem_add! sem_add_assoc.\n\nLemma send_to_loop_safe s1 s2 r :\n  send_to_loop_safe s1 s2 r -> s2 = s1 ++ s2.\nProof.\ncase: s2 => s1 s2 /= /andP[s2' r].\ncase: sQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nelim: s => //= n s n s n s n s n.\ncase: s => //= n s n s n s n.\ncase: s => //= n s n s n s n s n.\ncase: s => //= n s n s n.\nrewrite /f' /= => i s n s n.\ncase: s => //= n s n s n; rewrite /f' /= => ->.\ncase: s => //= n s n; rewrite /f' /= => ->.\ncase: s => //= n s s n.\ncase: s => //= n s n s n; rewrite /f' /= => ->.\ncase: s => //= n s n; rewrite /f' /= => ->.\ncase: s => //= n s n s n.\ncase: s => //= n s n s n; rewrite /f' /= => ->.\ncase: s => //= n s n s n.\ncase: s n => //= n s n s n.\ncase: s => //= n s n s n.\ncase: s => //= n s n s n.\ncase: s => //= n s n s n.\ncase: s => //= nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\napply: (iffP idP)=> [[H1 H2]] [H1 H2]; exists s'; split=>//.\n- by apply/connectP; exists (s2_star s' r); rewrite/def_s.\n- by apply/def_s/existsP; exists (s2_star s' r); rewrite/def_s.\n- by apply/existsP; exists (s2_star s' r); rewrite/def_s.\n- by apply/existsP; exists (s2_star s' r); rewrite/def_s.\n- by apply/existsP; exists (s2_star s' r); rewrite/def_s.\nby apply/existsP; exists (s2_star s' r); rewrite/def_s.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase: s => [|c s IH]; first by move/(_ _ _)/IH.\nby case: (IH s') => [|{IH s'}; case: s' => // [|{IH s'}; case: s' => //= ->.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>f s; case=>f s; case=>f' s'; case=>f' s'; case=>f' s'; case=>pf' s'; case=>pf' s'; case=>pf' s'; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''.\nby case=>pf' s'; case=>pf' s'; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case/pf' s''; case=>pf' s''; case=>pf' s''; case/pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''; case=>pf' s''.\nby case=>pf' s''; case/pf' s''; case=>pf' s''; case=>pf' s''; case/pf' s''; case=>pf' s''; case=>pf' s''; case/pf' s''; case=>pf' s''; case=>pf' s''; case/pf'Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nsplit; [apply (mk_send_act_step_total S).\nby apply: (mk_send_act_step_total S).\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>S [s1 S1] S1 IH1 S2 IH1 S2 IH2.\ncase=>S [s2 S2] S1 IH1 S2 IH2.\ncase=>S [s2 S2] S2 IH2 S3.\ncase=>S [s3 S4] S1 IH1 S4.\ncase=>S [s3 S4] S4.\ncase=>S [s4 S5] S5.\ncase=>S [s4 S5].\ncase=>S [s4 S5] S6.\ncase=>S1 S2 [s5 S6]; case=>S2 S2 S2.\ncase=>S2 S3 S3.\ncase=>S3 S4; case=>S4 S5 S6.\ncase=>S4 S5 S6 S6 S7 S6 S7 S8.\ncase=>S5 S6 S6 S7 S8 S8 S10 S12.\ncase=>S4 S5 S6 S7 S8 S9 S10 S12.\ncase=>S5 S6 S7 S7 S8 S8 S10 S12Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase.\nintros e s r.\ncase: s=>i [H1 H2] [H3 H4].\ncase: s=>i [H4 H5].\ncase: s=>i [H5].\ncase: s=>i [H5].\nby rewrite -(def_some s (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=x) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (x:=s) (Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase: s => s /=.\ncase: s => [s1 IHs1]; case: s2=>i [s2 IHs2]; case: s2=>i [s3 IHs2]; case: s3=>i [s4 IHs2]; case: s4=>i [s6 IHs2];\ncase: s2=>i [s5 IHs2]; case: s5=>i [s6 IHs2]; case: s6=>i [i s6]; case: s6=>i [i s6]; case: s6=>i [i s6];\ncase: s2; case: s2; case: s2=>i [s6]; case: s6=>i [i s6]; case: s6;\ncase: s2; case: s3=>i [s6]; case: s6=>i [s6]; case: s6=>i [i s6]; case: s6=>i [i s6];\ncase: s6; case: s6; case=>i [i s6]; case: s6=>i [i s6]; case: s6=>i [i s6];\ncase:Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 479,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros; apply (mkJuicyMem (dstate d)); apply H.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d; apply: (coherent_coh (dstate d)).\nby apply: (coherent_coh (dstate d)).\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\ninduction d; simpl; auto.\ndestruct d; simpl; auto.\ndestruct (IHd _ _ H); auto.\ndestruct (IHd _ _ H); auto.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros.\nunfold fe)))) in *.\nrewrite /split /split /split2.\n- by move=> /split_size /andP[/eqP-> /eqP/idPn[].\nhave: (size d <= 1) by move=> /leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_size/leq_Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\ncase: d => d1 d1 d2 /andP [d1 d2] /andP [d2 d2] /andP [d1 d2] /andP [d2 d1 d2] /andP [d2 d2].\nmove=> d1 d2 d2 /andP [d2 d2] /andP [d2 d2 d1] /andP [d3 d4 d5] /andP [d1 d4 d6] /andP [d4 d6].\nmove=> d1 d2 /andP [d1 d2 d3] /andP [d5 d6] /andP [d1 d6] /andP [d5 d6] /andP [d6 d7] /andP [d8 d9] /andP [d10 d11 d12].\nmove=> d1 d2 /andP [d1 d2] /andP [d12 d12 d23 d14] /andP [d12 d23 d14].\nmove=> d12 d12 d23 d14 /andP [d12 d23 d14] /andP [d12 d23 d14].\nmove=> d12 d12 d12 dQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> /perm_of_sh_dec /perm_of_sh_dec /perm_of_sh_dec.\nset (m := (perm_of_sh_dec m)).\nset (m := (perm_of_sh_dec m)) in *.\nset (m := perm_of_sh_dec m).\nset (m' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_sh m).\nset (m'' := perm_of_Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\n  intros H1 H2; split; [intro H1 | intros n H1].\n  - apply H1; split; [intro H2 | intros n H2].\n    destruct H2 as [n' [H2 H3]].\n    destruct H3 as [n' [H3 H4]].\n    eexists.\n    eexists.\n    split.\n    * apply H2; split; [intro H4 | intros n' H5].\n      * apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n' H5].\n        apply H5; split; [intro H5 | intros n'Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nsplit; intros H1 H2.\napply (H2 d).\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>?? H1 H2.\ncase: l1 d => [n|n] d d d /= d d /= d /= d /= d.\nby rewrite /unblock /unblock /unblock /unblock /unblock /unblock /unblock /unblock /unblock/unblock.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nsplit=> [n [n [d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [n d [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 505,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\ncase=> d_neq; case/split.\nby case/split=> //; case/split=> // d_neq; move/eqP: d_neq.\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\ncase=> /andP [d d].\nelim/d.\nelim/d.\nintros H2; exists d; exists d.\nby exists d.\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 535,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d; case=> // n []. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> // n; apply/ltP/ltP/ltP/ltP/lt_n. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nmove=> d; case: d=>[d d|d d|d d|d d|d d|d d|d d|d d|d|d|d d|d|d|d].\ncase=> d d|d d|d d|d d|d|d d|d|d|d d|d|d|d].\ncase=> d d|d d|d d|d|d|d d|d|d|d|d].\ncase=> d|d|d|d d|d|d|d|d|d].\ncase=> d|d|d|d] [|d|d|d] //=; first by rewrite /=?d.\ncase=> d|d|d|d] //=; first by rewrite /=?d.\ncase=> d|d|d|d] //=; first by rewrite /=?d.\ncase=> d|d|d|d] /=; first by rewrite /=?d.\ncase=> d|d|d] //=; first by rewrite /=?d.\ncase=> d|d|d] //=; first by rewrite /=?d.\ncase=> d|d]; firstQed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 686,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n => //= n; rewrite?ltnS?ltn_add // ltnW. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nmove=> x d; rewrite /mkStrMod {1}/mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\ncase: ifP=> //= x d; rewrite /mkStrMod {1}def.\nby rewrite /mkStrMod {1}def.\nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> m; apply: line; Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case=> m n; rewrite /late. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; apply: H. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nmove=> n d; elim: n d => [|n IHn] d /= n d /= n d /= d /= d /= d /= d /= d /= d /= d /= d.\nby rewrite ltnS leqn0 size_poly_eq0 size_poly_eq0 size_poly_eq0 size_poly_eq0.\nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d=> m; elim: n=> //= n []. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n d=>?? []. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H1 H2; case: C => _ _ /(_ n H1). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _ _ _ _ _. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> m d. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H1 H2; case: C H1. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=> H1 H2; rewrite /is_true; case: C => _ /eqP ->.\nby case=> m n d e; rewrite /is_true => /eqP ->.\nQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=> H1; case: C=> _ _ _ H2 /IH [m H2]].\nby rewrite -IH (m H2) // -IH (m H2) // -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H1) -IH (m H2) -IH (m H2) -IH (m H2) -IH (m H1) -IH (m H2) -IH (m H2) -IH (Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H1 H2; case: C => _ H1 _; apply: H2. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H1 H2; case: C => _ _ /(_ n H2). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=> n v d C D d; rewrite /val -dup -(dup (getby n d)) (dup (getby n d)) (dup (getby n d)) in C D d d d.\nby rewrite /val -dup (getby n d) (getby n d) (getby n d) (getby n d) (getby d) d) (getby d) d) (getby d).\nQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ /eqP ->; rewrite H. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H; case: m => [|m]; first by move/eqP.\nby move/eqP=> H1; case: m => [|m]; rewrite findPt => ->; rewrite findPt.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: m n=> [] d ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H1 H2; case: m => [m H1 | m H2]; first by rewrite H1 H2.\nby case: m => [m H1 | m H2]; rewrite /get HH.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H1 H2; case: m => []? [] [] []. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H1 H2; rewrite /get /=!andbA => /and3P[] ->.\nby move=> <-; rewrite findPt /get /get /get /= /get /= /get /= /get /= /get /= /get /= eq_sym.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: m => _ []. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: m n => // n H ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: m => n ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H1 H2; case: m => [|m]; rewrite findPt. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H1 H2; apply: (iffP (injective_id H1)) => /=.\nby apply/eqP; rewrite -H1 -H2 -H3; apply: (injective_id H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": ".\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=> E1; rewrite /set0 /set1 /= => /andP[m d].\nby move=> E2; rewrite /getK; apply: eq_refl => /eqP.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>E; rewrite /getK /getK /getK /getK.\ncase: (h) {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h}Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (lcoh H)=>m; rewrite /get HH. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>H; apply/split.\n- by move=> m; apply/split=> [[H1 H2] H1]; apply: H1.\n- by move=> m; apply/split=> [[H1 H2] H3] H1; apply: H2.\n- by move=> m; apply/split=> [[H1 H2] H3] H3 H4].\n- by move=> m; apply/split=> [[H1 H2] H4] H5 H6.\n- by move=> m; apply/split=> [[H1 H2] H3] H4 H5 H6 H7.\n- by move=> m; apply/split=> [[H1 H2] H3] H5 H6 H7 H8.\n- by move=> m; apply/split=> [[H1 H2] H4] H5 H6 H8 H8.\n- by move=> m; apply/split=> [[H1 H2] H4] H6 H8 H8 H8 H9.\n- by move=> m; apply/split=> [[H1 H2] H4] H5 HQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>D.\nmove=>D.\ncase: (lcoh H)=>m.\ncase: (m d) => /= H1 H2; move: (H2 H2).\ncase: (m d) => /= H1 H2; move: (H2 H2).\nmove: (H3 H2)=>H3; move: (H3 H3).\ncase: (m d) => /= H1 H3; move: (H3 H3).\ncase: (m d) => /= H1 H3; move: (H3 H3).\ncase: (m d) => /= H1 H3.\ncase: (m d) => /= H1 H3; move: (H3 H3).\ncase: (m d) => /= H1 H3; move: (H3 H4).\ncase: (m d) => /= H1 H3; move: (H4 H4).\ncase: (m d) => /= H1 H3; move: (H4 H4).\ncase: (m d) => /= H1 H3; move: (H4 H4).\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; rewrite /getK; apply: pickI. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (hem_preserve H); rewrite E=>H. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; apply: findNK. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; rewrite /getNK. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>E; rewrite /getSize; case: (m \\in [set d | d] _) => /= D.\nby rewrite (eq_refl (eq_refl (eq_refl (eq_sym D))).\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H; apply/val_inj; rewrite /= => H.\nby move: (H n)=>H; rewrite -H.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H; apply/eqP.\nmove=>H; apply/extend_find_ext=> [[x y] h] | ]; last by rewrite h.\nby move: h; apply: (extend_find_ext H).\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=> H1; apply/split; first by move/H1.\nby move=> m d; apply: (IHd m d); apply: (IHd m d); apply: H1.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: m => _ []. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>E; rewrite /load; move: E => /E' /E' /E' /E' /E' /E'.\nmove: E' => /= D' /E' /E' /E' /E' /E' /E'.\nby move=> /E' /E' /E' /E' /E' /E' /E' /E' /E'.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>D; rewrite /m; apply/split.\nby move=> D; move: (D); rewrite /m; apply: (D _ D).\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>E; rewrite /m; case: (m).\n- by move: E; apply: E.\n- by move: (E); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\n- by move=>x y; move: (E y); apply: E.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>E; rewrite /extend; apply: IHm. Qed."
                ]
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros; elim (H x); intros y0 z H1; rewrite (H1 y0); trivial.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H1 H2; elim H1; auto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply (Build_Map (E:=F) (D:=E) (E:=E) (E:=E)).\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H1 H2; elim H1; intros H3 H4; elim H4; intros H5 H6;\n elim (H6 (conj H6 H6)).\nintros H8 H9; elim H9; intros H10 H11; elim H11; intros H11 H12;\n elim (H11 (conj H12 H13)).\nintros H12 H13; elim H14; intros H15 H16; elim H15; intros H15 H16;\n elim (H15 (conj H13 H15)).\nintros H15; elim (H15 H16).\nintros H15; elim H16; intros H15 H16; elim H16; intros H15 H16;\n elim (H15 (conj H15)).\nintros H15; elim H17; intros H15 H17; elim H16; intros H16 H17;\n elim (H16 (conj H15)).\nintros H16; elim H17; intros H17 H17; elim H17; intros H17 H17;\n elim (H17 (conj H15)).\nintros H16; elim H17; intros H17 H18; elimQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H H'0 H'1 H'2.\ncut (exists z : S, in_part x (single z) /\\ in_part y (single z)).\nintro H'3; elim H'3; clear H'3.\nintros H'4 H'5; elim H'4; clear H'4.\nintros H'5 H'6 H'7; elim H'6; clear H'7.\nintros H'7 H'8; elim H'6; clear H'7.\nintros H'8 H'9; elim H'6; clear H'7.\nintros H'8 H'9; elim H'7; clear H'7.\nintros H'10 H'11; elim H'11; clear H'11.\nintros H'11 H'12; elim H'12; clear H'12.\nintros H'11 H'12; elim H'12; clear H'11.\nintros H'13 H'13; elim H'12; clear H'13.\nintros H'14; elim H'13; clear H'14.\nintros H'14 H'14;Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros; elim (is_abelian_group_inverse (G:=inv_nat))).\nintros x y z H1 H2; elim H1; auto with sets.\nintros y H2; elim H2; auto with sets.\nintros y H3; elim H3; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H0 H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6; elim H6;\n intros H6 H7; elim H7; intros H8 H9; elim H9; intros H10 H11; elim H11;\n intros H12 H14; elim H12; intros H14 H15; elim H15;\n intros H15 H16; elim H15; intros H16 H17; elim H17;\n intros H17 H17; elim H17; intros H17 H17; elim H18;\n intros H17 H17; elim H17; intros H17 H17; elim H17;\n intros H17 H17; elim H18; intros H17 H17; elim H17;\n intros H17 H17; elim H18; intros H17 H18; elim H18;\n intros H17 H18; elim H17; intros H18 H18; elim H18;\n intros H18 H18; elim H18; intros H18 H20; elim H20;\n intros H18 H20; elim H20; intros H20 H20; elimQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nunfold is_group in |- *.\nintros.\napply H2.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros; unfold is_group, is_group in |- *; split.\n  exact (proj1_sig (H y)).\n  exact (proj2_sig (H y)).\n  exact (proj1_sig (H y)).\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H' H'0 H'1 H'2; try assumption.\nelim (H'0 x); intros H'4 H'5; try exact H'6; clear H'0 H'1 H'2 H'3 H'4 H'5 H'6.\nelim (H'0 x); intros H'6 H'7; try exact H'7; clear H'0 H'1 H'7; clear H'0 H'1 H'7;\n try assumption.\nelim (H'0 x); intros H'8 H'9; try exact H'10; clear H'0 H'1 H'8 H'9;\n try assumption.\nelim (H'0 x); intros H'10 H'11; try exact H'11; clear H'0 H'11;\n try assumption.\nelim (H'0 x); intros H'11 H'11; try exact H'11; clear H'0 H'1 H'11;\n try assumption.\nelim (H'0 x); intros H'12 H'13; try exact H'11; clear H'0 H'1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* use of opposite *)\nelim (H6 (Add x1 y1) y1); intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9; intros.\nclear H6 H6 H8 H9 H10 H11 H12.\n(* use of opposite *)\nelim (H6 (Add x1 y1) y2); elim H6; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n   intros; elim H5; intros; elim H5; intros; elim H6;\n   intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n   intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H6; intros; elim H6; intros; elim H6; intros;\n   elim H7; intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H7; intros; elim H7; intros; elim H8; intros;\n   elim H9; intros; elim H8; intros; elim H8; intros;\n  Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H12;\n intros; elim H10; intros; elim H10; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H13;\n intros; elim H13; intros; elim H13; intros; elim H13;\n intros; elim H14; intros; elim H15; intros; elim H13;\n intros; elim H15; intros; elim H15; intros; elim H15;\n intros; elim H15; intros; elim H15;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 y1); intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (add_add (Add x1 y1) y1); elim (H0 (Add x2 y2)); elim (H1 (Add x1 y2));\n elim H3; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* use of multiplication *)\nelim (H6 (Add x y1) (Add x y2) z1); elim (H6 (Add x y1) z2);\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n clear H6 H7 H8 H9.\n(* use of multiplication *)\nelim (H9 x1); intros; elim H5; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (add_add (Add x1 y1) y2); intros; elim H5; intros; elim H5;\n   intros; elim H7; intros; elim H7; intros; elim H7; intros; clear H7.\nelim (H6 (Add x1 y2) y3); intros; elim H7; intros; elim H7; intros; elim H8;\n   intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9;\n   intros; elim H9; intros; elim H10; intros; elim H11;\n   intros; elim H12; intros; elim H12; intros; elim H13; intros;\n   intros; elim H13; intros; elim H14; intros; elim H14; intros;\n   intros; elim H14; intros; elim H14; intros; elim H14; intros;\n   clear H15 H16 H17 H17 H17 H17 H18 H19 H18 H19 H20 H20 H20 H20 H20 H21 H21 H22 H22 H23 H23 H22 H23 H23 H24 H25 H26 HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (add_add x1 y1 x2 y2); elim (add_add y2 x1 y2); intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; \n intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H11;\n intros; elim H12; intros; elim H12; intros; elim H12;\n intros; elim H12; intros; elim H13; intros; elim H13;\n intros; elim H13; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H8; intros; elim H10; \n intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H13; intros; elim H12; \n intros; elim H13; intros; elim H13; intros; \n intros; elim H13; intros; elim H13; intros; elim H14; \n intros; elim H14; intros; elim H15; intros; elim H15; \n intros; elim H17; intros; elim H17; intros; elim H15; \n intros; elim H15; intros; elim H15; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H11;\n intros; elim H12; intros; elim H12; intros; elim H12;\n intros; elim H13; intros; elim H12; intros; elim H13;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros.\nrewrite <- (opp_assoc (opp x) y); rewrite <- (opp_assoc (opp y) y); rewrite <- (opp_assoc (opp y) (opp x));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp y) (opp x));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp x) (opp x));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp x) (opp y));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp x) (opp y));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp x) (opp x));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp x) (opp y));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (opp_assoc (opp x) (opp y));\n rewrite (opp_assoc (opp x) (opp y)); rewrite (Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (cmp_ok (Add x y)); intros; elim H0; intros; elim H1;\n rewrite (Add_add x y H0); elim (Add_add x y H1); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H; elim H; intros; elim H0; intros; elim H0; intros.\nclear H; rewrite (H2 x0 y H1); rewrite (H0 y0); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (is_transitive S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add x y) y); elim (is_opp S D); intros.\nrewrite (opp_com (Add xQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros com X y H H0.\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x y); intros; elim H0; intros; elim H0; intros; elim H1;\n clear H0; intros; elim H1; intros; elim H2; intros.\nclear H0; elim (H0 y1 H2); intros; elim H3; intros; elim H5;\n clear H3; intros; elim H5; intros.\nclear H5; elim (H1 y1 H4); intros; elim H5; intros; elim H5;\n clear H5; intros; elim H5; intros; elim H6; \n clear H5; intros; elim H6; intros.\nclear H6; elim (H5 y1 H6); intros; elim H6; intros; elim H6;\n clear H5; intros; elim H6; intros; elim H6;\n clear H6; intros; elim H6; intros; elim H6;\n clear H6; intros.\nclear H5; elim (H6 y2 H6); intros; elim H6; intros; elim H6;\n clear H6; intros; elim H6; intros; elim H6; \nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (opp_is_opp x); rewrite (opp_is_opp x); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y); rewrite (opp_is_opp y);\n rewrite (opp_is_opp y);Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply (is_ring_l x y H H0).\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; \n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H12; \n intros; elim H12; intros; elim H10; intros; elim H13; \n intros; elim H12; intros; elim H13; intros; elim H13; \n intros; elim H13; intros; elim H13; intros; \n elim H14; intros; elim H14; intros; elim H15; \n intros; elim H14; intros; elim H14;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x; unfold opp, is_midpoint, opp, opp, opp, opp, opp;\n intros; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite H.\nrewrite H0; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold is_midpoint in |- *.\napply opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite (opp_involutive x).\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite (opp_involutive x).\nrewrite <- opp_midpoint in H.\nrewrite H.\nrewrite <- opp_midpoint in H.\nrewrite <- opp_midpoint in H.\nrewrite H.\nrewrite <- opp_midpoint in H.\nrewrite H.\nrewrite <- opp_midpoint in H.\nrewrite H.\nrewrite <- opp_midpoint in H.\nrewrite H.\nrewrite <- opp_midpoint in H.\nrewrite H.\nrewrite <- opp_Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewriteQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; \n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n clear H6 H7 H8Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H; rewrite <- (opp_involutive x); apply opp_id; rewrite opp_involutive; auto with *.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutiveQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold is_midpoint in |- *.\nelim H; intros; elim H; intros; elim H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H0; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H0; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclear H; intros.\nclearQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2;\n clear H0 H1 H2 H3.\n(* [x=0] *)\nelim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H8; \n intros; elim H7; intros; elim H8; intros; elim H6; \n intros; elim H8; intros; elim HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) y H0).\nunfold is_transitive in |- *; split.\nelim H; intros; elim H2; intros; elim H3; intros.\nclear H4 H5 H6 H6 H7.\nrewrite (inv_add x y H6); auto.\n(* [(y,y)] *)\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H8; intros; elim HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_unicity H (Opp x y) (Opp x y)).\nunfold is_symmetric in |- *; split.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H10; intros; elim H11; intros; elim H11; \n intros; elim H10; intros; elim H10; intros; elim H12; \n intros; elim H11; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive (inter x y)) in |- *.\nrewrite (opp_involutive (inter x y)); auto.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Opp y x)).\nunfold is_midpoint in |- *; split.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H7Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_symmetric in |- *; split; intros; elim H; intros; elim H0; intros; elim H1;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nclear H4 H5 H6 H7 H8 H9 H10 H11.\nelim (H11 x H1); intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; \n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; apply (opp_unicity H (opp x) y).\nunfold is_midpoint in |- *; split.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H7; intros.\nclear H5 H6 H7 H9 H10 H11.\n(* (x+y)=(x+y) *)\nelim H0; intros; elim H1; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; \n introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Opp y) x).\nunfold is_lub in |- *; split.\nelim H; intros; elim H3; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; elim H6; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H8; intros; elim H10; intros; elim H10Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_uniqueness H (Opp x y) x).\nunfold is_upper_bound in |- *; split.\nelim H0; intros; elim H2; intros; elim H3; intros.\nrewrite H3; rewrite H5; rewrite H6; reflexivity.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_uniqueness H H (Add x y)) in H0.\nrewrite (opp_uniqueness H H0 (Add x y)).\nunfold not in |- *; intro.\nrewrite H0; rewrite H1; rewrite H2; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_morphism H0).\napply (opp_unicity H (Add x y) (Add x y)).\nunfold is_symmetric in |- *; split.\nrewrite (opp_morphism H0).\nrewrite (opp_morphism H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive H0).\nrewrite (opp_involutive HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros.\napply opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_def; assumption.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_is_is_zero; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; auto with *.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; symmetry  in |- *; apply opp_is_opp; auto with arith.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold is_group in |- *; split; [ auto with real | intros; discriminate ].\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros.\nelim (H0 (conj H0 H1)).\nintros; apply opp_zero; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero; apply opp_zero_pos.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros x Hx; elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; clear Hx;\n intros; elim Hx; intros; elim Hx; intros.\napply (H1 (Add x y) H0); assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intro A; apply (H x); auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (R : A -> A -> Prop) (x y : A), R x y -> R (x * y) x.\nintros A R x y H'; try assumption.\napply H'.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P x H x.\n  set (f := fun x => P (f x)).\n  set (f := fun x => P (f x)).\n  apply H.\n  exact (H x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intro A.\n  cut (forall x y : A, R x y -> R y x).\n  intro H0; rewrite H0.\n  apply H0.\n  apply H1.\n  assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P x.\n  rewrite (H x); auto with *.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x H0.\n  apply (H x H0).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x H0; elim H0; intros;\n    absurd (P x); auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P x H.\n  unfold R in |- *.\n  rewrite H.\n  reflexivity.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, {x : A | P x}.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, is_empty A R x.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, is_empty A R x.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, is_empty A R x.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, is_empty A R x.\n\nDefinition is_empty (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, is_empty A R x.\n\nDefinition is_empty (A : Set) (R : ADefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x.\n  elim (H x); intro; assumption.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; intros; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H1.\n\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H3.\n\ninversion H2.\ninversion H3.\n\ninversion H3.\ninversion H4.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold subersible in |- *; intros.\napply inv_inv_inv_inv with (S := fun y : S => plus_reg_l x y).\napply inv_inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : S => plus_reg_l y y).\napply inv_inv with (S := fun y : SQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nsimpl in |- *.\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H0).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H0).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_O _ H).\nelim (le_Sn_OQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold inv_ersible; intros.\napply inv_left; assumption.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nrewrite plus_comm.\napply plus_reg_l with (S n).\nrewrite plus_comm.\napply plus_reg_l with (S n).\napply plus_reg_l with (S n).\napply plus_reg_l with (S n).\napply le_S_n.\nrewrite plus_comm.\napply plus_reg_l with (S n).\napply plus_reg_l with (S n).\napply le_plus_reg_l with (S n).\napply lt_O_Sn.\nrewrite plus_comm.\napply plus_reg_l with (S n).\napply le_S_n.\nrewrite plus_comm.\napply plus_reg_l with (S n).\napply le_plus_reg_l with (S n).\napply lt_O_Sn.\nrewrite plus_comm.\napply plus_reg_l with (S n).\napply lt_O_Sn.\nrewrite plus_comm.\napply plus_reg_l with (S n).\napply le_n_S.\nrewrite plus_comm.\napplyQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold subersible in |- *; intros.\ninversion H0; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold inversible in |- *; intros; elim (le_S_O _ H0).\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros.\nelim plus_n_O; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nchange (Z_of_nat 0) with 1%Z.\nrewrite <- (Z_to_nat_complete_pos (Z_of_nat x)).\nrewrite <- Z_to_nat_complete_pos.\nrewrite <- Z_to_nat_complete_pos.\nrewrite <- (Z_to_nat_complete_pos (Z_of_nat x)).\nreflexivity.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs.\nrewrite <- (Z_to_nat_Z 0).\nrewrite <- (Z_to_nat_Z (Z_of_nat x)).\nrewrite <- Z_to_nat_Z.\nring_simplify (Z_of_nat x).\nrewrite <- (Z_to_nat_Z (Zpos x)).\nring_simplify (Zpos x).\nrewrite <- (Z_to_nat_Z (Zpos x)).\nrewrite <- (Z_to_nat_Z (Zpos x)).\nring_simplify (Zpos x).\napply Z_to_nat_complete.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro.\nunfold Z.sgn at 2 in |- *.\nrewrite <- Zopp_mult_distr_l_reverse.\nrewrite <- Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_reverse.\nrewrite Zopp_mult_distr_l_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.swap; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x; case x; simpl in |- *; auto with zarith.\nintros x y H'; try assumption.\nintros x y H'; try assumption.\napply H'; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x.\napply Z_mult_reg_l with (Z_to_nat 0); auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n constructor.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs.\napply Z_to_group.\napply Z_to_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x; unfold Z.opp, Z.opp in |- *.\nrewrite <- Z_div_opp.\napply Z_div_opp_l.\napply Z_div_opp_l.\napply Z_div_opp_r.\napply Z_div_opp_r.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold ZQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z.opp in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nsimpl in |- *; auto with zarith.\nunfold IdZ in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold Z_ring; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nunfold Z.opp in |- *; simpl in |- *.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; auto with zarith.\nunfold IdZ in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold Z in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nintro H; apply sym_not_equal; apply sym_not_equal; assumption.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 1 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold Z.abs at 2 in |- *.\nunfold ZQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat,\n Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_Qed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nunfold Z.succ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros H1 H2; unfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.\nintros x y.\nunfold inv_commutative_ring.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\napply Z_mult_distr_l.\napply Z_mult_distr_l.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold is_ring in |- *.\nunfold is_ring in |- *.\nunfold is_ring_mult in |- *.\nsplit.\nexact Z_unit.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\nexact Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\nexact Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\nexact Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napplyQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold is_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact Z_unit.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold is_ring_mult in |- *; auto with zarith.\nsplit.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nunfold is_ring_mult in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\napply Z_div_mult; auto with zarith.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact Z_unit.\nunfold opp in |- *. intros. exact I.\nunfold opp in |- *. intros. exact I.\nunfold opp in |- *. intros. exact I.\nunfold opp in |- *. intros. exact I.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\napply Z_unit_equiv.\nunfold opp in |- *. intros. exact I.\nsplit.\napply Z_unit_equiv.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfoldQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integPAD, Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_to_nat in |- *.\nsplit.\nsimpl in |- *.\nintros.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z.abs in |- *; auto with zarith.\nunfold Z.abs in |- *; auto with zarith.\nunfold Z.abs in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\napply Z_is_opp.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nsplit.\ncut (forall x : Z, (x < 0)%Z -> Z_one x < Z_one y)%Z.\nintros H1; case H1; case H2; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros H1; case H1; auto with zarith.\nintros HQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integplicite in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_unit in |- *.\nunfold Z_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z.opp in |- *.\nunfold Z.opp in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_natQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; unfold inversibleZ in |- *.\nintros H; right.\nrewrite <- H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x; simpl in |- *; auto.\nintros; right; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x.\n(* pos n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx.\ncase (Zle_or_lt 0 x).\nintros H1.\ncase (Zle_or_lt 0 x).\nintros H2.\nabsurd (-1)%Z; auto with zarith.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive (- x)).\nrewrite <- (Zopp_involutive x).\nrewrite <- (Zopp_involutive (- x)).\nrewriteQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold integvararg in |- *; intros x; right.\nelim x; simpl in |- *; auto.\nintros; right; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x; simpl in |- *; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim x; simpl in |- *; auto.\nintros; left; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim x.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim x.\n(* pos n *)\nintros; right.\napply sym_equal.\napply Zopp_eq.\napply Zplus_opp_l.\napply Zplus_opp_l.\napply Zplus_opp_l.\napply Zplus_opp_r.\napply Zplus_opp_l.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.\napply Zplus_opp_r.Qed."
                ]
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 334,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E; elim E; auto.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold not in |- *; intros E; elim E; auto.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Empty in |- *.\nintros E.\napply refl_equal.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *.\nintros E H'; elim H'; intros x E0; elim E0; intros x E1; elim E1; intros x E2; elim E2; intros x E3;\n elim E2; intros x E4; elim E4; intros x E5; elim E5; intros x6 E6;\n clear E5.\ngeneralize (lem_vide_propertie E0 x1 x2 x3); intros.\ngeneralize (lem_vide_propertie E0 x1 x2 H); intros.\ngeneralize (lem_vide_propertie E0 x2 x3); intros.\ngeneralize (lem_vide_propertie E0 x3 x4); intros.\ngeneralize (lem_vide_propertie E0 x4); intros.\ngeneralize (H0 x4 H5); intros.\ngeneralize (lem_vide_propertie E0 x4); intros.\ngeneralize (H0 x4 H5); intros.\ngeneralize (H0 x4 H6); intros.\ngeneralize (H1 x4 H5); intros.\ngeneralize (H0 x4 H6); intros.\ngeneralize (H1 x4 H6); intros.\ngeneralize (Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E H'; try assumption.\nelim H'.\nintros H'0 H'1; try assumption.\napply H'1; auto with zfc.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E; elim E; auto.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *.\nintros E; elim E; simpl in |- *; auto.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E H'; elim H'.\nintros H'0; elim H'.\nintros H'1; elim H'.\nintros H'2; elim H'.\nintros H'3; elim H'3; intros H'4 H'5; elim H'5; intros H'6 H'7; clear H'3.\nexists (x x); split; [ auto with zfc | split; [ auto with zfc | idtac ] ].\ngeneralize (H'1 H'0); intro H'4; elim H'4; intros H'6 H'7; clear H'4.\nexists (x x); split; [ auto with zfc | split; [ auto with zfc | idtac ] ].\ngeneralize (H'0 H'1); intro H'5; elim H'5; intros H'6 H'7; clear H'5.\nexists (x x); split; [ auto with zfc | split; [ auto with zfc | reflexivity ] ].\ngeneralize (H'0 H'1); intro H'7; elim H'7; intros H'8 H'9; clear H'8.\nexists (x x); split; [ auto with zfc | split; [Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *.\nintros E; elim E; intros.\nleft; auto.\nright; red in |- *; intros.\nright; red in |- *; intros.\nright; red in |- *; intros.\nelim (H0 x); intros.\nleft; auto.\nright; red in |- *; intros.\nright; red in |- *; intros.\nright; red in |- *; intros.\ngeneralize (H0 x); case (H0 x); intros.\nleft; auto.\nright; red in |- *; intros.\nright; red in |- *; intros.\nelim H; intros.\nright; red in |- *; intros.\nright; red in |- *; intros.\nabsurd (x = y); auto.\nright; red in |- *; intros.\ngeneralize (H0 x); case (H0 x); intros.\nleft; auto.\nright; red in |- *; intros.\nabsurd (x = y); auto.\nright; red in |- *; intros.\nabsurd (x = y); auto.\nright; red in |- *; intros.\nabsurd (x = y); auto.\nright; red in |- *; intros.\nabsurd (x =Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold not in |- *; intros E; elim E; simpl in |- *;\n auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H0; elim H; auto.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H H0; elim H0; auto.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H H0; elim H; intros x H0; elim H0; intros H1 H2; clear H H0.\nelim H0; intros x H1; elim H1; intros H2 H3; clear H1.\ngeneralize (H0 x); clear H0; rewrite <- H1; auto with arith.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H H0; elim H; auto.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H.\nelim (lem_vide_propertie E (fun x : E => exists x : E, In x E' /\\ x = Vide)).\nintros E H'; elim (lem_vide_propertie E (fun x : E => exists x : E, In x E' /\\ x = Vide)).\nintros E H'; elim (lem_vide_propertie E (fun x : E => exists x : E, In x E /\\ x = Vide)).\nintros E H'0; elim (lem_vide_propertie E (fun x : E => exists x : E, In x E /\\ x = Vide)).\nintros E H'0 H'1; elim H'.\nintros H'2 H'3; elim H'3; intros H'4 H'6; clear H'3.\nexists x; exists x; split; [ auto with zfc | idtac ].\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H H0; elim H.\nintros E H1; elim E; intros x E H1; elim E; intros H2 H3; clear E H1.\nintros H1 H2; elim E; intros x E H3; elim E; intros H4 H5; clear E H5.\nintros H4; elim E; intros H5 H6; clear E H5.\nintros H5; elim E; intros H6 H7; clear E H6.\nintros H6; elim E; intros H7 H8; clear E H7.\nintros H7; elim H7; intros H8 H9; clear E H7.\nintros H9; elim H9; intros H11 H12; clear E H10.\nintros H10; elim H11; intros H12 H13; clear H11.\nexists x; exists x; split; [ auto with zfc | split; [ auto with zfc | reflexivity ] ].\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H0; elim H0; auto.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H H0; elim H.\nintros x H0; elim H0; intros H1 H2; clear H H1; auto.\nintros x H0; elim H0; intros H2 H3; clear H0; auto.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H H0; elim H.\nintros x H0; elim H0.\nintros x0 H1; elim H1.\nintros x0 H1; elim H1.\nintros x1 H2; elim H2.\nintros H3; elim H3.\nintros x0 H3; elim H3.\nintros x1 H4; elim H4.\nintros x0 H5; elim H4.\nintros H5 H6; elim H6.\nintros H7; elim H7.\nintros H8; elim H8.\nintros H10; elim H10.\nintros H10; elim H10.\nintros H10; elim H11.\nintros H10; elim H10.\nintros H11; elim H12.\nintros H12; elim H12.\nintros H10; elim H12.\nintros x1 H13; elim H12.\nintros x1 H13; elim H13.\nintros x0 H13; elim H13.\nintros x1 H13; elim H14.\nintros H14; elim H14.\nintros H15; elim HQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; elim H; intros x H0; elim H0;\n intros x H1; elim H1; intros x H2; elim H2;\n intros x0 H3; elim H3; intros x1 H4; elim H4; intros x4 H5;\n apply H4; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Paire : forall E E' : Ens, Ens.\napply (Build_IN E (fun f : F => match f return Prop with\n                                           | Build_finiteT (lt_n _ _ _ _ _)\n                                       | _ => False\n                                       end)).\nred in |- *; intros E E' H0; elim E; auto with zfc.\nintros; elim E; auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E; elim E; intros x E; elim E; intros x E; elim E; intros H0 H1;\n exists x; auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold not in |- *; intros E E' H'0; elim E; intros H'1; clear E H'0.\nunfold not in |- *; intros E E0 H'1; elim E0; intros H'2; clear E H'0.\nunfold not in |- *; intros E0 H'2; elim E0; intros H'3 H'4; clear E H'2.\nunfold not in |- *; intros E1 H'4; elim E0; intros H'4 H'5; clear E H'4.\nunfold not in |- *; intros E0 H'4; elim E0; intros H'5 H'6; clear E H'4.\nunfold not in |- *; intros E0 H'4; elim E0; intros H'6 H'7; clear E0.\nunfold not in |- *; intros E1 H'5; elim E1; intros H'7 H'8; clear E0 H'4.\nunfold not in |- *; intros E0 H'5; elim E0; intros H'7 H'8; clear E0 H'5.\nunfold not in |- *; intros E1 H'5;Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Inhabited in |- *; simpl in |- *; intros E; elim E; intros x H;\n elim H; intros x H0; elim H0; intros x H1; clear H0.\nexists x; auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\napply (Build_EQ (fun x : E => ~ In x E') (fun y : E => ~ In y E'));\n auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Sym, Included in |- *.\nunfold not in |- *; intros E E' H; elim H; clear H.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\napply (Build_SUB (Ap:=fun x : E => exists y : E, x = y /\\ x = y)).\nred in |- *; intros E E' H'0; elim E; simpl in |- *; intros H'1;\n elim (H'0 (e x)); auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\napply (Build_Map (Ap:=fun X : Ens => ~ (exists y : E', x = y)))\n    (reunion (reunion (reunion (reunion (reunion (reunion (first_index E' E'))) (x y)))\n       (reunion (reunion (reunion (reunion (first_index E' E'))) (x y))))\n    (reunion (reunion (reunion (reunion (first_index E' E'))) (x y)))\n    (reunion (reunion (reunion (reunion (first_index E' E'))) (x y)))\n    (reunion (reunion (reunion (first_index E' E'))) (x y))); \n auto with zfc.\n\n(* fun_and_comp est *)\nunfold rel_sig in |- *; simpl in |- *; intros E H0; elim H0; intros.\nunfold inc in |- *; split; [ idtac | auto with zfc ].\n\nunfold inc in |- *; split; [ idtac | auto with zfc ].\n\nunfold singleton in |- *; split; [ idtac | auto with zfc ].\n\nunfold singleton in |- *; split; [ idtac | auto with zfc ].\n\nunfold singleton in |- *; split; [ idtac | auto with zfc ].\n\nunfold singleton in |- *;Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; try assumption.\nelim (classic (exists y : _, In y E /\\ F y)).\nintros E E' H'0 H'1; elim H'1; intros x0 y0.\nexists y0; auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E; elim E; intros; elim E; intros x E; elim E; intros y E; clear E.\nelim (H0 (e x)); auto with zfc.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 537,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paux in |- *; simpl in |- *; intros A' B.\nelim (H (e x)).\nelim (H0 (e x)).\nelim (H0 (e x)).\nauto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire, NEQ in |- *; simpl in |- *; intros A' B; elim (H A').\nintros x y H; elim H; intros y H0; elim H0; intros y H1; elim H1;\n intros y H2; elim H2; intros y H3; elim H3; intros y H4; elim H4;\n intros z H5; elim H4; intros z H5; elim H5;\n intros z H5; elim H5; intros z H6; elim H6; \n intros z H6; elim H6; intros z H7; elim H7; intros z H7; elim H7;\n intros z H8; elim H8; intros z H9; elim H10; \n intros z H10; elim H10; intros z' H11; elim H10; intros z' H11; elim H12;\n intros z' H10; elim H10; intros z' H11; elim H11;\n intros z' H11; elim H11; intros z' H12; elim H13;\n intros z' H12; elim H12; intros z' H12; elim H13;Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A' B; elim (H (blel_not_elim_not_elim_not_elim _ _ _ H)).\nintros A' B' H'0 H'1; exists (a x); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Normal in |- *; intros A A' B B H H0.\nelim H0; intros x; elim H0; intros y H1; elim H1;\n intros y H2; elim H2; intros z H3; elim H3;\n intros z H3; elim H3; intros z H4; elim H4; intros z H5; elim H5;\n intros z H5; elim H6; intros z H6; elim H6; \n intros z H7; elim H7; intros z H7; elim H8; intros z H8; elim H8; \n intros z H8; elim H8; intros z H8; elim H8; intros z H9; elim H9; \n intros z H10; elim H10; intros z10 H11; elim H11; \n intros z11 H12; elim H12; intros z12 H13; elim H13; intros z22 H15; \n elim H14; intros z12 H15; elim H15; intros z22 H15; \n elim H15; intros z22 H16; elim H16; intros z22 H14; elim H15; \n intros z22Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Alant in |- *; simpl in |- *; intros A A' B H H0; elim H0;\n intros x; elim x.\nintros H1 H2; elim H2; intros x1 H3; elim H3; intros x3 H4; clear H3.\nelim H3; intros x4 H4; elim H4; intros x5 H5; elim H5; intros x6 H6;\n elim H6; intros x7 H7; elim H8; intros H8 H9; clear H8.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A' B.\napply (EQ_trans A A' B); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire, decide in |- *; simpl in |- *; auto with *.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold alire, blire, blire, B, C, C, C, C, C, D, C, C, D, C, G, C, D, G, H, G, H, G, H, G, H, H, G, H, H, G, H, G, H, G, H, H, H, G, H, G, H, G, H, H, G, H, H, G, H, H, G, H, H, G, H, G, H, H, G, H, H, G, H, H, G, H, H, G, H, H, G, H, H, G, H, H, G, H, G, H, G, H, H, H, G, H, G, H, G, H, G, H, H, G, H, H, G, H, G, H, H, G, H, H, G, H, G, H, H, H, G, H, G, H, H, G, H, H, G, H, G, H, H, G, H, GQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Inter, Negation in |- *; simpl in |- *; intros A A'; elim H; auto.\nintros; elim (H0 (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A A' B.\napply (H (a A' B)); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 603,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold alire in |- *.\nsimpl in |- *.\nintros; elim (H (a x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Normal in |- *.\nsimpl in |- *.\nintros; split.\nelim H; intros x H0; elim x.\nintros y H0; elim H0; intros y H1; elim H1; intros y H2; clear H1.\nexists y; auto with zfc.\n\nelim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Alant in |- *.\nsimpl in |- *.\nintros; split.\napply H.\nintros; elim H; intros x0 y0 H1; elim H1; intros H2 H3; elim H3; intros H4 H5;\n clear H2 H3.\nexists y1; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nelim (H0 (e x)); auto with zfc.\n\nintros; elim H0; auto with zfc.\n\nintros; elim H0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nintro; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paux in |- *.\nsimpl in |- *.\nintros; split; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; elim (H (a x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nelim H; intros x0 y0; elim y0; intros y1 y2; elim y1; intros y3 y4; elim y4; intros y5 y6;\n clear y3 y4.\nexists (S x0 y1); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold In in |- *; intros E E' H0; elim (H0 E').\nintro; elim H; intros x0 E0.\nexists x1; auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold IN in |- *.\nintros E E' H; elim H; clear H; intros E E' H0; elim E'.\nintros H H0; elim E'.\nintros H1 H2; elim E'.\nintros H2 H3; elim E'.\nintros H4 H5; elim E'.\nintros H5 H5; elim E'.\nintros H6 H7; elim E'.\nintros H7 H8; elim E'.\nintros H7 H8; elim E'.\nintros H8 H9; elim E'.\nintros H9 H10; elim E'.\nintros H10 H11; elim E'.\nintros H11 H11; elim E'.\nintros H10 H11; elim E'.\nintros H12 H13; elim E'.\nintros H10 H11; elim E'.\nintros H12 H12; elim E'.\nintros H13 H13; elim E'.\nintros H13 H13; elim E.\nintros H13 H14; elim E'.\nintros H13 H15; elim E'.\nintros H14 H15; elim E'.\nintros H15 H16; elim E'.\nintros H15 H16; elimQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; intros E E F.\nelim (classic (exists y : _, IN E E /\\ F y)).\nintros; exists (Var x); auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; simpl in |- *; intros E E F; elim F; intros F E F; elim E; intros F E; elim E; intros F E; clear E F.\nexists (F ++ F).\nsplit; [ auto with zfc | exists F; auto with zfc ].\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold P in |- *; simpl in |- *.\nintros; elim (H (A:=A)); intros.\nleft; exists false; auto with zfc.\n\nintros; elim (H0 (A:=A)); intros.\nleft; exists true; auto with zfc.\n\nright; exists a; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; intros E E F; elim F; clear F; intros E F; elim F; clear F; intros E F; elim F;\n clear F; intros E F; elim F; clear F; intros F; elim E;\n clear E F; intros F; elim F; clear E F; intros F; elim F;\n clear E F; intros F; elim F; clear E F; intros F; elim F; \n clear E F; intros F; elim F; clear E F; intros F; elim F; \n clear E F; intros F; elim F; clear E; intros F; elim F; \n clear E F; intros F; elim F; clear F; intros F; elim F; \n clear E F; intros F; elim F; clear F; intros F; elim F; \n clear E F; intros F; elim F; clear E; intros F; elim F; \n clear E F; intros F; elim E; clear E; intros F; elim F; \n clear E F; intros F; elim F; clear E; intros F; elim E; \n clear E F; intros F; elim F; clear E; intros F; elim EQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; intros E E; elim E; intros a E; elim E; intros a E; elim E; intros a E; elim E; intros H0 H1;\n clear E.\nexists a; exists E; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; intros E E' H0 H1; elim H1; clear H1.\nintros x H; elim (H x).\nexists (a x); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; intros E E E' H0; elim H0; clear H0.\nintros x H0; elim H0; clear H0.\nintros x0 H1; elim H1; clear H1.\nintros x0 H1; elim H1; clear H1.\nintros x1 H2; elim H2; clear H2.\nintros x1 H2; elim H2; clear H2.\nintros x2 H2; elim H2; clear H2.\nintros x3 H4; elim H4; clear H4.\nintros x4 H4; elim H4; clear H4.\nintros x4 H4; elim H4; clear H4.\nintros x5 H6; elim H5; clear H5.\nintros x5 H6; elim H5; clear H5.\nintros x6 H7; elim H6; clear H5.\nintros x6 H7; elim H7; clear H7.\nintros x8 H9; elim H9; clear H9.\nintros x10 H10; elim H10; clear H10.\nintros x11 H12; elim H12Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold In in |- *; intros E F H'; elim H'.\nintros; elim H'.\nintros; elim H'.\nintros; elim H'.\nintros x0 y0 H'1; elim H'1; intros H'2 H'3; clear H'1.\nelim (H' x0 H'1); intros H'3 H'4; clear H'1.\nelim (H' x0 H'1); intros H'5 H'6; clear H'1.\nexists (cons x0 (cons y0 y1)); split; auto with zfc.\n\nelim H'5; intros H'6 H'7; clear H'5.\nexists (cons x0 y); split; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Same in |- *; simpl in |- *; intros E E' H0; elim H0; clear H0; intros E E'.\nexists (cons x E); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold lsaire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\n\n(* End of proof of lem_Pr5_rev_right: algebra. *)\n\nTheorem In_aire_so_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_not_aire_Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Inhabited in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\n\nTheorem IN_ deme_not_in_def :\n forall (A : Ens) (P : Ens -> Prop) (a : Prop) (b : Prop),\n (forall a : Prop, ~ P a -> P a) ->\n (forall a : Prop, ~ P a -> P a) ->\n (forall a : Prop, ~ P a -> P a) ->\n (forall a : Prop, ~ P a) ->\n (forall a : Prop, ~ P a) ->\n (forall a : Prop, ~ P a -> P a).\n(* End of the intersection *)\n\nTheorem P1 : forall A : Ens, ~ P A.\nintros A P H.\napply H.\nred in |- *.\nintros; apply H; intros x H; elim H.\nintros x H0; elim H0.\nintros x0 H1; elim H1; intros x1 H2; elim H2.\nintros x1 H2; elim H2; intros x2 H3; elim H3.\nintros x3 H4; elim H4;Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros E E' H0; elim H0; intros H1 H2; elim H2;\n intros x1 H2; elim H2; intros H3 H4; elim H4;\n intros y1 H4; elim H4; intros H5 H6; elim H6;\n intros y2 H6; elim H6; intros H7 H8; elim H8;\n intros y3 H8; elim H8; intros H9 H10; elim H11;\n intros y4 H9; elim H10; intros y11 H12; elim H12;\n intros y11 H12; elim H12; intros H12 H13; elim H13; \n intros y12 H13; elim H13; intros H14 H15; elim H15;\n intros y15 H16; elim H16; intros H16 H16; elim H16;\n intros y15 H16; elim H16; intros H16 H17; elim H16;\n intros y15 H16; elim H16; intros H17 H17; elim H17; \n intros H17 H17; elim H18; intros H17Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold OF, In in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Same in |- *; simpl in |- *; intros E E' H'0; elim H; clear H; intros E E'.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Inhabited in |- *; simpl in |- *; unfold P in |- *; unfold P in |- *;\n unfold P in |- *; unfold P in |- *; unfold P in |- *;\n unfold P in |- *; unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; unfold P in |- *;\n unfold P in |- *; unfold P in |- *; unfold P in |- *;\n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *;\n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *;\n unfold P in |- *; unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; \n unfold P in |- *; unfold P in |- *; unfold P in |- *; \n unfold P in |- *; unfold P in |- *; \n unfold P in |- *; \nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold P, Sym, P in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold alt in |- *; simpl in |- *; intros E E' H; elim H.\nintros x H; elim H.\nintros x0 H1; elim H1; intros x1 H2; elim H2; intros x2 H3; elim H3; intros H4 H5;\n exists x2; split; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paise in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold lsaelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paelel in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paelire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paelire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Same in |- *; simpl in |- *; intros; elim (H E'); auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold lsael in |- *; simpl in |- *; unfold PC in |- *; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; intros; split.\napply NNPP; red in |- *; intro H; elim H.\nexists a; auto with zfc.\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold alire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Disj in |- *; simpl in |- *; intros E; elim E; intros H0 H1; elim H1;\n intros H2 H3; elim H3; intros H4 H5; elim H4;\n intros H5 H6; elim H5; intros H6 H7; elim H6;\n intros H6 H7; elim H7; intros H8 H9; elim H9; intros H10 H11;\n elim H11; intros H12 H13; elim H13; intros H14 H15;\n exists (cons r (cons r r) (cons r0 r2)); split;\n [ apply H15 | assumption ]; assumption.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Canc in |- *; simpl in |- *.\nintros x y H0; elim H0; clear H0.\nintros x0 y H0; elim H0; clear H0.\nintros x0 y0 H1; elim H1; clear H1.\nintros y0 y0 H1; elim H1; clear H1.\nintros y0 y1 H2; elim H2; clear H1.\nintros y0 y1 H3; elim H3; clear H3.\nintros y0 y1 H3; elim H3; clear H3.\nintros y0 y1 H3; elim H3; clear H3.\nintros y1 y2 H3; elim H3; clear H3.\nintros y0 y1 H3; elim H3; clear H3.\nintros y0 y1 H4; elim H3; clear H3.\nintros y1 y2 H4; elim H3; clear H3.\nintros y2 y3 H4; elim H4; clear H3.\nintros y1 y2 H4; elim H4; clear H4.\nintros y2 y3 H4; elim HQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Non in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; intros E H'; elim H'.\nintros a H'; elim H'.\nintros a H'0; elim H'.\nintros a H'0; elim H'0; intros a H'1 H'2; elim H'0; intros H'3 H'4; clear H'0 H'0 H'1.\nelim H'.\nintros a H'0; elim H'0; intros a H'0 H'1; elim H'0; intros H'3 H'4; clear H'0 H'0 H'1.\nexists a; exists b; split; [ auto with zfc | split; [ auto with zfc | idtac ] ].\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Disj in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; intros E; elim E; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros E; elim E; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros E; elim E; intros H'0; elim H'0; intros H'1 H'2; clear H'0.\nexists x; exists (single x); auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Setminus in |- *; simpl in |- *.\nintros; elim H; intros x H0; elim H0; intros x0 H1; clear H1.\nexists x0; exists x0; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Canc in |- *; intros E1 E2; elim (Apart (Pdec E1) E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; intros E1 E2 E3; elim (Pdec E1 E2); intros H1 H2;\n [ idtac\n | exists x; auto with zfc ].\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; intros E1 E2 E3; elim (benv_not_eq E1 E2); intros H1 H2;\n elim (vb_not_eq E3 E0); intros H3 H4; elim (H1 H4); clear H1 H3 H4;\n intros H5 H6; elim (H1 H6); clear H1 H6; intros H7;\n elim (H1 H7); clear H1 H7; intros H7 H8; elim (H1 H8); clear H1 H8;\n intros H8 H9; elim (H0 H9); clear H9; intros H10 H11; elim (H10 H11);\n clear H11; intros H10 H11; elim (H12 H10); clear H11 H12; \n intros H12 H13; elim (H13 H13); clear H12 H13; intros H13 H14; \n elim (H12 H14); clear H14; intros H15 H15; elim (H13 H15); clear H15; \n intros H15 H16; elim (H16 H15); clear H15; intros H16;\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; intros E1 E2 E3; elim (Pdec E1 E2); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; red in |- *; intro.\napply H.\napply H0.\napply H1.\napply H.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H2.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H2.\napply H0.\napply H1.\napply H2.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H2.\napply H0.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P H H0; elim H0; auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\napply (Build_Predicate (Pred_of_compatible_prf:forall x : A, P x) -> Pred_compatible_prf:Prop.\nintros x H; elim H; intros H1 H2.\nexists x; split; [ intros H1; elim H2; clear H2 | intros H1; elim H2; clear H2 ].\nexists (fun x : A => exists y : A, P y).\nsplit; [ intros H1; elim H1; intros H2 H3; elim H3; clear H3\n | intros H3; elim H3; clear H3\n | intros H3; elim H3; clear H3\n | intros H3; elim H3; clear H3\n | intros; elim H3; clear H3\n | intros; elim H3; clear H3\n | intros; elim H3; clear H3\n | intros; elim H3; clear H3\n | intros; elim H3; clear H3; intros; elim H3; clear H3\n | intros; elim H3; clear H3\n | intros; elim H3; clear H3\n | intros; elim H3; clear H3;Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; split.\nintros; apply H1.\nintros; apply H1; auto with zfc.\nintros; apply H1; auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; exists (fun x : A => P x).\nelim H; auto with zfc.\n\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P H1 H2; elim H1; auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; elim (IN_hd A P) with (1 := H); auto with zfc.\n\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; apply (Build_Setoid (A:=A) (P:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=Q) (Q:=P) (Q:=P) (Q:=Q) (Q:=P) (Q:=Q) (Q:=P) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q) (Q:=Q) (Q) (Q:=Q) (Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q) (Q:=Q) (Q).\n\n(* We have a subset of theDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P H H0; elim H0; auto with zfc.\n\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nexact (Build_Map (A:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=B) (B:=B)).\n\nDefinition Comp' : Ens -> Ens -> Prop :=\n  forall x y : A, P y -> exists y : A, y = y.\n\nDefinition Set_of_sigT : Prop :=\n  forall x y : A, P x y -> exists y : A, y = y.\n\nHint Unfold Set_of_sigT: algebra.\n\nLemma Set_of_sigT :\n forall (A : Set) (P : A -> Prop),\n (forall x : A, P x -> exists y : A, y = y) ->\n (forall x : A, P x -> exists y : A, y = y).\nProof.\nintros A P.\nexists (fun x : A => P x).\nsplit; [ idtac | assumption ].\nelim H.\nelim H1; intros y H1; elim H1; intros y H2; elim H2; intros y H3; clear H3.\nexists y; split; [ assumption | assumption ].\nelim H3;Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold inclus in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Inhabited, Inc, Inv, Complement, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus,Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Im in |- *; simpl in |- *; unfold Chux in |- *; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nred in |- *; intros E P; elim (classic (P x)).\nintros x0 p; exact (Ex x0).\nintros y0 p; exact (Ex y0).\nintros y0 p; exact (Ex x0).\nintros y0 p; exact (Ex y0).\nintros y0 p; exact (Ex y0).\nintros z1 q; exact (Ex y0).\nintros y1 q1; exact (Ex y1).\nintros y2 q2; exact (Ex y2).\nintros y3 q3; exact (Ex y1).\nintros y4 q4; exact (Ex y1).\nintros z4; exact (Ex y3).\nintros z4; exact (Ex y4).\nintros z4; exact (Ex y4).\nintros z5 q6; exact (Ex y4).\nintros z5; exact (Ex z4).\nintros z5 q6; exact (Ex z5).\nintros z6; exact (Ex z5).\nintros z6; exact (Ex z6).\nintros z6; exact (Ex z6).\nintros z6; exact (Ex z6).\nintrosQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold inclus, Equiv, respectful, respectful, respectful, respectful, respectful, respectful, respectful,\n         and, respectful, respectful, respectful, respectful,\n         and, respectful, respectful, respectful, respectful, respectful,\n         and, respectful, respectful, respectful, respectful, respectful, respectful, respectful,\n           and, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful,\n         and, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful,\n           and, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful,\n           and, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectfulQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nintros E P H'; elim H'; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Qdiv,Comp in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold equivalence in |- *.\nintros E P x; red in |- *; simpl in |- *.\napply H; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nred in |- *.\nunfold ExComp, Negation in |- *; simpl in |- *; intros; split.\napply H0; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited, Inhabited,\n(* the set of the set of elements of elements of elements of the\n of the elements of the elements of the set of the\n elements of the set of elements of the set of\n the set of the set of elements of the set of the set of\n elements of the set of the set of elements of the set. *)\n\nDefinition inter : (forall x : A, P x) -> Prop :=\n  forall x y : A, P x -> P y -> P y.\n\nLemma inter_sym : forall (E : Ens) (P : Ens -> Prop),\n equivalence (inter E P) (inter E P).\nunfold inter, inter, Subtract, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, SetminusQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 319,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0 H'1; try assumption.\napply H'.\napply H'.\napply H'.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nintros A' B B' H'0 H'1; elim H'1; intros H'2; clear H'1.\nunfold cart in |- *; simpl in |- *.\nintros a0 b0 H'1; elim H'1; intros H'3; clear H'1.\nunfold cart in |- *; simpl in |- *.\nintros a0 b0 H'1; elim H'1; intros H'3; clear H'1.\nunfold cart in |- *; simpl in |- *.\nintros a1 b0 H'2; elim H'2; intros H'4; clear H'2.\nunfold cart in |- *; simpl in |- *.\nintros a0 b0 H'2; elim H'2; intros H'4; clear H'2.\nunfold cart in |- *; simpl in |- *.\nintros a0 b0 H'2; elim H'2; intros H'4; clear H'2.\nunfold cart in |- *; simpl in |- *.\nintros a0 b0 H'2; elim H'2; intros H'4; clear H'2.\nunfold cart in |- *; simplQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B' H' H'0 H'1; try assumption.\nred in |- *; intros H'2; (apply H'0); auto with sets.\nred in |- *; intros H'3; (apply H'3); auto with sets.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold EQ in |- *.\nintros A B A' B' H'0 H'1.\napply H'; auto with *.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0 H'1 H'2; try assumption.\napply H'; auto with *.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0 H'1 H'2; try assumption.\nelim H'1; intros H'3 H'4; try assumption.\nelim H'2; intros H'6 H'7; try exact H'7.\nelim H'2; intros H'7 H'8; try exact H'7.\nelim H'3; intros H'8 H'9; try exact H'9.\nelim H'3; intros H'9 H'9; try exact H'9.\nelim H'3; intros H'9 H'10; try exact H'10.\nelim H'10; intros H'11 H'12; try exact H'10.\nelim H'11; intros H'12 H'13; try exact H'14.\nelim H'10; intros H'13 H'14; try exact H'13.\nelim H'14; intros H'15 H'16; try exact H'15.\nelim H'16; intros H'15 H'16; try exact H'16.\nelim H'15; intros H'16 H'15; try exact H'Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0 H'1; try assumption.\nelim H'0; clear H'0.\nintros H'1; try assumption.\napply Trans with (y x); auto with algebra.\napply Trans with (y y); auto with algebra.\napply Trans with (y x); auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A' B B B' H'0 H'1; try assumption.\napply H'; auto with sets.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold union, Complement, Negation in |- *; intros A A' B B' H'0 H'1; try assumption.\napply Trans with (subtype_elt (B:=A') (subtype_elt (B:=B') (B:=B') (B:=B') (B:=B'));\n auto with algebra.\napply Trans with (subtype_elt (B:=A') (subtype_elt (B:=B') (B:=B') (B:=B'));\n auto with algebra.\napply Trans with (subtype_elt (B:=A') (subtype_elt (B:=B') (B:=B'));\n auto with algebra.\napply Trans with (subtype_elt (B:=B') (subtype_elt (B:=B') (B:=B'));\n auto with algebra.\napply Trans with (subtype_elt (B:=B') (subtype_elt (B:=B') (B':=B)));\n auto with algebra.\napply Trans with (subtype_elt (B:=B') (subtype_elt (B:=B') (B:=B)));\n auto with algebra.\napply Trans with (subtype_elt (B:=A') (subtype_elt (B:=B')Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros.\napply H.\napply H0.\napply H1.\napply H.\napply H0.\napply H1.\napply H.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 647,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros x H; elim H; simpl in |- *; auto with zfc.\nelim (H x); simpl in |- *; auto with zfc.\n\nintros x H; elim H; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros x0 y.\nelim (H2 y).\nintros x1 y.\nelim (H2 y).\nintros x2 y.\nelim (H3 y).\nintros x3 y4.\nelim (H3 y4).\nintros x5 y5.\nelim (H6 y5).\nintros x6 y7.\nelim (H6 y7).\nintros x7 y8.\nelim (H3 y8).\nintros x8 y9.\nelim (H3 y8).\nintros x9 y10.\nelim (H2 y10).\nintros x10 y11.\nelim (H3 y10).\nintros x11 y12.\nelim (H3 y12).\nintros x12 y13.\nelim (H2 y12).\nintros x13 y14.\nelim (H3 y12).\nintros x15 y13.\nelim (H2 y13).\nintros x15 y15.\nelim (H3 y12).\nintros x15 y15.\nelim (H2 y12).\nintros x15 y15.Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros.\napply H0; auto with zfc.\n\nintros.\napply H0; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A' B B' H' H'0 H'1 H'2; elim H'1; elim H'2; elim H'2; elim H'2;\n simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros a b c; elim b; simpl in |- *; auto with zfc.\nintros a b c; elim b; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros a0 b0 H H1 H2.\ncut (EQ (couple A' b0) (couple B' b0)).\nsimpl in |- *.\nsimple induction a0.\nauto with zfc.\nintros a1 b0 H1 H2.\ncut (In a0 b0).\nsimpl in |- *.\nintro.\nelim (H1 (couple a0 b0)); simpl in |- *.\nintro.\ncut (In a0 b0).\nsimpl in |- *.\nintro.\nelim H1.\nclear H1.\napply H1; auto with zfc.\n\nintros a1 b1 H1 H2.\ncut (In a0 b1).\nsimpl in |- *.\nintro.\nelim H2.\nclear H2.\napply H2; auto with zfc.\n\nintros a1 b1 H2.\ncut (In a0 b1).\nsimpl in |- *.\nintro.\ncut (In a0 b0).\nsimpl in |- *.\nintro.\nelim H2.\nclear H2.\napply H1; auto with zfc.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros x y H H0 H1; elim H1; simpl in |- *; auto with zfc.\nintros x y H H0; elim H1; simpl in |- *; auto with zfc.\n\nintros x y H H0; elim H; simpl in |- *; auto with zfc.\n\nintros x y H H0; elim H; simpl in |- *; auto with zfc.\n\nintros x y H H0; elim H; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Setminus in |- *; simpl in |- *.\nsimple induction 1.\nintros x y H H0 H1 H2.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Setminus in |- *.\nintros A A' B B' H H0.\nelim H0; clear H0.\nintros x; elim x; simpl in |- *; auto with zfc.\n\nintros x; elim x; simpl in |- *; auto with zfc.\n\nintros x0 H0; elim x; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros x y H0; elim H0; intros H1 H2; elim H2; intros H3 H4;\n elim H4; intros H5 H6; elim H6; intros H6 H7;\n elim H6; intros H7 H8; elim H7; intros H8 H8; elim H8; intros H9 H9;\n elim H9; intros H10 H11; elim H12; intros H12 H13; elim H12; \n intros H13 H14; elim H14; intros H15 H16; elim H16; \n intros H16 H17; elim H17; intros H17 H17; elim H17; intros H16 H17; elim H17; \n intros H17 H17; elim H17; intros H17 H17; elim H17; \n intros H17 H17; elim H17; intros H17 H18; elim H17; intros H18 H20; elim H18; \n intros H17 H17; elim H18; intros H20 H18; elim H18; intros H20 H20; elim H20; \n introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod, Diff, Sum, Sum, Ar2 in |- *.\nunfold Ar2 in |- *.\nintros A' B B' f g H H0 H1; try assumption.\nelim H1; auto.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *.\nintros A' B A' B; elim (H A').\nintros x y z H'0 H'1; clear H'.\nunfold App_t in |- *.\nintros a b c f x y z H'0 H'1 H'2 H'3 H'4 H'5; clear H'.\nunfold App_t in |- *.\nintros a b c f x y z H' H'0 H'1 H'2 H'3 H'4; clear H'.\nunfold App_t in |- *.\nintros a b c f x y z H'0 H'1 H'4 H'1 H'4 H'5; clear H'.\nunfold App_t in |- *.\nintros a b c f x y z H'0 H'1 H'4 H'5; clear H'.\nunfold App_t in |- *.\nintros a b c f x y z H' H'1 H'4 H'5; clear H'.\nunfold App_t in |- *.\nintros a b c f x y z H' H'1 H'4 H'5; clear H'.\nunfold App_t in |- *.Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *; simpl in |- *.\nsimple induction 1.\nintros.\nelim H.\nintros.\nelim H1.\nintros.\nrewrite <- H2.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H0.\nrewrite H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H2.\nrewrite <- H2.\nrewrite H3.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite H3.\nrewrite <- HQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *; simpl in |- *.\nsimple induction 1; auto with zfc.\n\nintros x y z; elim z; intros z0 H0; elim H0; intros z1 H1; elim H1; intros z2 H2;\n elim H2; intros z3 H3; elim H3; intros z4 H4; elim H3; intros z5 H5;\n elim H5; intros z5 H6; elim H6; intros z7 H8; elim H8; intros z8 H8;\n elim H8; intros z9 H10; elim H10; intros z10 H11; elim H12; intros z10 H11;\n elim H12; intros z12 H12; elim H12; intros z12 H13; elim H13; intros z13 H14;\n elim H12; intros z13 H14; elim H15; intros z15 H15; elim H15;\n intros z15 H16; elim H15; intros z22 H17; elim H17; intros z23 H16;\n elim H17; intros z15 H16; elim H17; intros z22 H17; elim H18;Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *.\nintros A A' B B' H H0; split; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *.\nintros A A' B.\nelim (H A' B); auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *; simpl in |- *.\nsimple induction 1; intros.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H4.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H4.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H4.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H5Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod, transp in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim H1; intros H3 H4.\nelim H1; intros H5 H6.\nexists (fun a : prod_t A' A' =>\n     match a with\n       | pair_t a' a' => Append (f a') (f' a') (f' b')\n       end).\nintros H H1; elim H1; intros H3 H4.\nexists (fun a : prod_t A' A' =>\n     match a with\n       | pair_t a' b' => cons (f a') (f' b')\n       end).\nsplit; [ elim H3; intros H4 H5; elim H5; intros H6 H7.\nexists (fun a : prod_t A' A' =>\n     match a with\n       | pair_t a' b' => cons (f a') (f' b')\n       end).\nsplit; [ elim H3; intros H5 H6; elim H5; intros H6 H7.\nexists (fun a : prod_t A' A' =>\n       match a with\n      Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod, Prod, Sum, Sum, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    O, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    O, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    O, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    O, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    O, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,\n    O, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *.\nintros A A' B; elim A'; intros H1 H2.\nelim (H1 (H2 A' B) (H3 B) (H1 B) (H2 B) (H3 B) (H4 H4)).\nintro H4; elim H4; intros H5 H6.\nexists (f' a'); exists (f' a'); exists (f' a'); exists (f' a'); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "simple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": ".\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; simpl in |- *.\nunfold Setminus in |- *; simpl in |- *.\nintros x y z H'0 H'1 H'2.\napply (not_EQ_\t\t\t\t\t\t\t\t\t   \napply (not_EQ (H' x y) z); auto with zfc.\napply (not_EQ (H' x y) z); auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; simpl in |- *.\nintros; auto with zfc.\n\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; simpl in |- *.\nintros E1 E2 E3; elim E1; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Included in |- *; simpl in |- *.\nintros E1 E2 E3; elim E1; intros H1 H2; elim H2; clear H1.\napply (not_EQ_commut E1 E2' E2' H1 H2); auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; simpl in |- *.\nintros E1 E2 E3; elim E1; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1 E2' H'0 H'1 H'2 H'3.\napply H'2.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nred in |- *.\nintros E1 E2' E1' H'0 H'1 H'2; elim H'1; clear H'.\nintros H'0 H'1 H'2 H'3; elim H'2; clear H'.\nintros H'0 H'2; elim H'2; clear H'.\nintros H'3 H'4; elim H'4; clear H'.\nintros H'4 H'5; elim H'4; clear H'4; intros H'4 H'5; clear H'.\nintros H'4 H'5; elim H'5; clear H'4; intros H'5 H'6; clear H'.\ngeneralize (H'4 x x0 H'4); clear H'4 H'5 H'5 H'6; intros H'6 H'7;\n elim H'5; clear H'5; intros H'7 H'8; clear H'5; \n elim H'7; clear H'7; intros H'8 H'9; clear H'7; \n elim H'7; clear H'8; intros H'9 H'10; elim H'10Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nred in |- *; intros.\nelim (H E1' E2).\nintros x e; simpl in |- *.\nelim (IN_EXSet (sup A1 f1) E2').\nintros x e; simpl in |- *.\nelim (IN_EXSet (sup A1 f1) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A1 f2) E1').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A1 f2) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A1 f2) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A2 f2) E3).\nintros x0 e; simpl in |- *.\nelim (IN_EXSet_is_finite_finite_case x0 x0); intros y0 e; simpl in |- *.\nelim (IN_EXSet_is_finite_case x0 y0); intros.\nabsurd (In (Couple (sup A1 f2) x0) (sup A2Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Setminus in |- *; intros; apply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split.\nintros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split.\nintros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split; intros.\napply Extensionality_Ensembles; split.\nintros.\napply Extensionality_Ensembles;Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n\nunfold Couple in |- *; intros; split; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Setminus in |- *; intros.\nsplit.\nelim (axs_comprehension (fun x : E => In x E1' x) (union E1' E2')).\nintros x y H H0; elim H0; intros y E1; elim E1; intros y E2; clear E1.\nexists y; split; [ auto with zfc | idtac ].\nelim (axs_comprehension (fun x : E => In x E1' x) (union E1' E2')).\nintros x0 H0; elim H0; intros y E1; elim E1; intros y E2; clear E1.\nexists y; split; [ auto with zfc | idtac ].\nelim (axs_comprehension (fun x : E => In x E1' x) (union E1' E2')).\nintros x0 H1; elim H1; intros y E1; elim E2; intros y E3; clear E1.\nexists y; split; [ auto with zfc | idtac ].\nelim (axs_comprehension (fun x : E => In x E1' x) (union E1' E2')).\nintros x0 H1; elim H1Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nred in |- *; intros E1 E2' H'0.\nelim (IN_EXSet (sup A1 f) E1').\nintros x e; simpl in |- *.\nelim (IN_EXSet (sup A1 f) E2).\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A2 f) E1').\nintros x0 e0; simpl in |- *.\nelim (IN_EXSet (sup A1 f) E1').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A1 f) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A2 f) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A1 f) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A2 f) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSet (sup A2 f) E2').\nintros x0 e; simpl in |- *.\nelim (IN_EXSetQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1 E2' H' H'0; split; intros H'1 H'2; elim H'2; clear H'.\nunfold In in |- *; simpl in |- *; intros; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E' H'0 H'1; red in |- *; intros E F E'' i.\nelim (IN_EXType F E'' i).\nintros x y H'1 H'2; red in |- *; intros F E F E'' i.\nelim (IN_EXType F E'' i).\nintros x y H'3; elim H'3; intros H'4 H'5; clear H'3.\nexists x; split.\nauto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E'' H'0; try assumption.\nred in |- *.\nintros E E F' H'1; try assumption.\nelim (IN_EXType (sup A) (sup A)) (Singleton E')); intros H'2 H'3; clear H'3.\nelim (IN_EXType (sup A) (sup A)) (Singleton E)); intros H'4 H'5; clear H'5.\nelim (IN_EXType (sup A) (sup A)) (Singleton E)); intros H'6 H'7; clear H'5.\nelim (IN_EXType (sup A) (sup A)); intros H'7 H'8; clear H'7.\nelim (IN_EXType (sup A) (sup A))); intros H'8 H'9; clear H'8.\nexists (Empty A); split.\nexact H'10; auto with zfc.\n\nelim (IN_EXType (sup A) (sup A))); intros H'10; clear H'10.\nexists (Empty A); split.\nexact H'10; auto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E' H'; elim H'; clear H'; intros E E'0.\nelim (IN_EXType (sup A) E').\nintros x0 E1.\nelim (IN_EXSet (sup A) E').\nintros x0 E2; elim E2.\nintros x1 E3; elim E2.\nintros x2 E4; elim E4.\nintros x4 E5; elim E5.\nintros x6 E5; elim E5.\nintros x7 E5; elim E5.\nintros x7 E8; elim E8.\nintros x8 E8; elim E8.\nintros x9 E9; elim E9.\nintros x10 E11; elim E12.\nintros x12 E12; elim E12.\nintros H12 E12; elim E12.\nintros x12 E12; elim E12.\nintros x13 E12; elim E12.\nintros x12 E12; elim E12.\nintros x13 E12; elim E12.\nintros x13 E12; elim E12.\nintros x13 E12; elim E12.\nintros x13 E12Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E' H'0 H'1; red in |- *; simpl in |- *.\nintros E0 E0' x x H'2; elim H'2; intros a1 b1 a2 b2 b2 H'3;\n clear H'3.\nintros E1' x H'2 x H'3; elim H'3; intros a1 b1 b2 H'4;\n clear H'4.\nexists (fun x : E => In (couple x x) (App a1 b1))); split;\n [ idtac | split; [ auto with zfc | idtac ] ].\napply\n (axs_comprehension (fun x : E => In (couple x x) (App a1 b1))); auto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E'' H H0 H1; clear H1 H2.\nelim (IN_EXType (fun (A : Ens) (B : Ens) (x : IN E' A) => IN (Couple A B) E'' H0));\n intros x H0; elim H0; clear H0; intros x0 H1;\n clear H1; intros x0 H2; elim H2; clear H2; intros H3 H4;\n clear H2; intros H4; clear H4; intros H4;\n clear H4; intros H4; clear H4; intros H5; clear H4; \n elim H4; clear H4; intros H5; clear H5; intros H6;\n clear H4; intros H5; clear H5; elim H6; clear H5; intros H6;\n clear H5; intros H6; clear H6; intros H6; clear H6; \n elim H6; clear H6; intros H6; clear H6; \n elim H6; clear H6; intros H7; clear H6; \n intros H8; clear H6; intros H7; elim H7Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E' H'0.\nelim (IN_pr_EXSet E' E').\nintros x H'1 x; red in |- *.\nexists (Prod (fun B : Ens => In (couple x y) E) (fun B : Ens => In (couple x y) E) (fun B : Ens => EQ (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => EQ (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => EQ (couple x y) E) (fun B : Ens => EQ (couple x y) E) (fun B : Ens => EQ (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => EQ (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => IN (couple x y) E) (fun B : Ens => EQ (Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E' H; elim H; clear H; intros E E.\nexists (fun (A : Ens) (f : Ens) (x : A) => star (Couple A B) x) (fun A : Ens => EQ (Singleton A) x)).\nsplit; [ idtac | idtac ].\nelim (H (fun (A : Ens) (f : Ens) (x : A) => star (Couple A x) x) (fun A : Ens => star (Singleton A) x) (fun A : Ens => star (Singleton A) x) x)).\nintros x y H'; elim H'; clear H'; intros A1 x1 x2; elim H'1; clear H';\n intros A2 x3 y1 y2; elim H'1; clear H'1; intros A3 x4 y4; elim H'5;\n clear H'1; intros A4 x5 y6; elim H'6; clear H'6;\n intros A6 A7 y7; elim H'7; clear H'7; intros A8 y8; elim H'7;\n clear H'7; intros A8 y9; elim H'7Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E'' H H'0; elim H'0; clear H'0.\nintros E'0 H'1; elim H'1; clear E'.\nintros E'1 H'2 H'3 H'4; elim H'2; clear H'2.\nintros x0 E1' H'4 H'5 H'6; elim H'3; clear H'3.\nintros x1 E2' H'6; elim H'3; clear H'3.\nintros x1 E1' H'6; elim H'3; clear H'3.\nintros x2 E2' H'6; elim H'4; clear H'3.\nintros H'7 H'8; elim H'8; clear H'4.\nintros x3 E3'7; elim E4; clear H'3.\nintros x4 E5; elim E5; clear H'4.\nintros H'7 H'9; elim H'9; clear H'9.\nintros H'9 H'10; elim H'10; clear H'10.\nintros H'11 H'12; elim H'12Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E'' H x; try assumption.\nelim H; intros x0 y0 H'0; clear H'.\nexists (fun A : Ens => Exists (Couple E' x) (fun B : Ens => EQ (Couple A B) E') x0).\ncut (In (Carrier_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_def_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_lemma_of_lemma_of_lemma_of_lemma_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_of_lemma_Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E'' H E0.\nelim (IN_EXType (sup A) (sup (Singleton E0) (fun B : Ens => IN (Intersection E F) A) H)).\nintros A0 B E0 H'1; elim H'1; intros A1 A2 f1 r.\nexists (Add (fun B : Ens => IN (Intersection E F) A) (Union E0 B) A2 f1 r).\nunfold Empty in |- *; unfold Empty in |- *; unfold Empty in |- *.\nintros E0; elim E0; clear E0.\nintros x0 y0; simpl in |- *; elim E0; clear E0.\nintros H'1 H'2; elim H'2; intros H'3 H'4; clear H'2.\ngeneralize H'2; clear H'2; clear H'2.\nrewrite H'1; clear H'2.\nrewrite H'2; clear H'2.\nrewrite H'2; clear H'2.\nintros x0 y0; elim (H'2 x0); clear H'2; intros H'4 H'5; clear H'2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 399,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition EQC : Ens -> Ens -> Type.\nexact EQC.\n\nDefinition EQC : Ens -> Prop := forall x y, EQC x y -> EQC x y.\n\nDefinition EQC : Ens -> Prop := forall x y, EQC x y -> EQC x y.\n\nDefinition EQC : Ens -> Prop := forall x y, EQC x y -> EQC x y.\n\nDefinition EQC : Ens -> Prop := forall x y, EQC x y -> EQC x y.\n\nDefinition EQC : Ens -> Prop := forall x y, EQC x y -> EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC x y.\n\nDefinition EQC : Ens -> Prop := fun x y => EQC xDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof fun (x y : C) (x y : C) =>\n  match x, y with\n  | (y,y) => y\n  | (y,y) => y\n  end.\n\nDefinition EQC : Ens -> Prop :=\n  forall (x y : C), EQC x y -> EQC y x.\n\n(*\nDefinition P : Ens -> Prop :=\n  forall (x y : C), P x y -> P y x.\n\n(* This used to show that the following proof of the domain *)\n\nDefinition P : Prop :=\n  forall (x y : C), P x y -> P y x.\n\n(* We now prove that the following proof of the form of the domain *)\n\nDefinition P2 : Prop -> Prop :=\n  forall (x y : C), P x y -> P y x.\n\n(* It is useful to show that the following proof of the domain *)\n\nDefinition P3 : Prop :=\n  forall (x y : C), P x y -> P3 x y.\n\n(*\nDefinition fun_choice :\n  forall (x y : C), P y x -> P y x -> P y x.\n*)\n\nDefinition P :Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nexact (fun X => X) (fun X => X) (fun X => X).\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintros x y H'; elim H'; auto.\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof fun A B f g h => EQ_prop _ _ (f g h).\n\nDefinition EQC : Ens -> Prop := forall A B f g h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQC : Ens -> Prop := forall A B f h, EQC A B f h -> EQC A B h.\n\nDefinition EQDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintros.\napply (A:=fun x : Prop => ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintros x y H'; red in |- *; intros H'0.\ninversion H'; inversion H'0; inversion H'0; inversion H'0; inversion H'0; inversion H'0; inversion H'1; inversion H'0; inversion H'1; inversion H'1; inversion H'0; inversion H'1; clear H'0;\n inversion H'0; inversion H'0; inversion H'0; inversion H'0; inversion H'0; inversion H'1; inversion H'0; clear H'0;\n inversion H'0; inversion H'0; inversion H'0; inversion H'0; inversion H'0; inversion H0; inversion H'0; inversion H0;\n inversion H'0; inversion H'0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0;\n inversion H0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0;\n inversion H0; inversion H0; inversion H0; inversion H0; inversion H0; inversion H0;Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nrefine\n  (fun (A : Ens) (B : Ens) (C : Ens) (h : EQ C A) =>\n   (forall (A : Ens) (h : EQ C A), EQ C A h -> EQ C A h)\n    (fun (A : Ens) (h : EQ C A) =>\n   EQ C A h (sym_equal C A h))\n    (fun (A : Ens) (h : EQ C A) =>\n   EQ C A h (sym_equal C A h))\n    (fun (A : Ens) (h : EQ C A) =>\n   EQ C A h (sym_equal C A h))\n    (fun (A : Ens) (h : EQ C A) =>\n   EQ C A h (sym_equal C A h))\n    (eq_refl_equal C A h))\n    (eq_refl_equal C A h)).\n\nDefinition EQC : Ens -> Prop := EQC.\n\n\nDefinition EQC (A : Ens) : Prop :=\n  forall (A : Ens) (h : EQ C A), EQC A h -> EQC A h.\n\nLemma EQC : forall (A : Ens) (k :Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof fun (A B : Ens) (b : B) => (b A) (b B).\n\n(* Definition of the following property, we define the following property  *)\n(*  - natural numbers, the number of A or A or B are a pair of A or B *)\n(*   - natural numbers, the number of B and B are equal *)\n(*   - natural numbers, the number of B *)\n(* - natural numbers, the number of B and B are equal *)\n(*     - natural numbers, the number of B and B are equal, and B *)\n(*   - natural numbers, the number of B is equal to B *)\n(*     - natural numbers, the number of B and B *)\n(*   - natural numbers, the number of B and B *)\n(* - natural numbers, the number of B and B are equal, or B *)\n(*   - natural numbers, the number of B and B *)\n(*   - natural numbers, the number of B and B are equal. *)\n\n(* - natural numbers, the number of B and B are equal *)\n(*   - natural numbers, the number of B and B *)\n(*   - natural numbers, the numberDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintros H.\napply H.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 502,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CIN : Ens -> Ens -> Type.\nintros x y.\ncase (CIN _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintro.\ninversion H.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H2.\ninversion H2.\ninversion H4.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros.\napply (A2_1_1 A_1_1_1_2).\nexact (forall y : B, CIN A y) (fun y : B => CIN A y).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros C; elim C; intros A f eq1.\nexact (fun x : A => C (f x))).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros A B f eq1.\ngeneralize (f (fun x : A => A) (fun x : A => B) (fun x : A => B) (fun x : A => B) (fun x : A => B)).\nelim A.\nintros x0 H1 H2.\ncut (f (fun x : A => B) (fun x : A => B) (fun x : A => B)).\nintros x H1 H2.\ncut (f (fun x : A => B) (fun x : A => B) (fun x : A => B)).\nintros x0 H3.\ncut (f (fun x : A => B) (fun x : A => B) (fun x : A => B)).\nintros x0 H3.\ncut (f (fun x : A => B) (fun x : A => B) (fun x : A => B)).\nintro H4.\ncut (f (fun x : A => B) (fun x : A => B) (fun x : A => B)).\nintros x0 H3.\ncut (f (fun x : A => B) (fun x : ADefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros A B f; try assumption.\nred in |- *; intros H1; inversion H1.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nunfold CIN in |- *; unfold CIN in |- *; unfold CIN in |- *;\n unfold CIN in |- *; unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *;\n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *;\n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *;Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros C; elim C.\nexact C.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros x y H; red in |- *.\ngeneralize (H x y H); intro H'.\ninversion H'.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros A B f.\napply (Build_EQ (A:=B) (B:=A) (B:=C) (B:=A) (B:=C) (B:=C) (B:=C) (B:=A) (B:=A) (B:=C) (C:=B) (C:=A) (B:=C) (B:=C) (C:=C) (f:=A) (B:=C) (B:=C) (B:=C) (C:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (A:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (C:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=C) (B:=CDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 551,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CINC : Ens -> Ens -> Type.\nintro.\ngeneralize (EQC H).\nintro.\nelim (EQC H).\nintro.\napply H0.\napply H1.\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros x y H; elim H; intros y H0; exact H0; clear H0.\nintros x y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clear H0.\nintros y H; elim H; intros y H0; exact H0; clearDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\napply (Build_Setoid (fun y : B => EQC X y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros.\nexact (fun x : A => C) (A:=A) (B:=A) (B:=B) (B:=A) (B:=A) (B:=B)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nexact (f A f0).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintro.\nred in |- *.\nintros.\napply (fun y : A => EQC X y)).\nexact (fun y : A => EQC X y).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintro; red in |- *; intros x y H'; red in |- *.\napply (fun x y : A => plus_reg_l x y).\nexact (H' x y).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nexact (f (fun y : B => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros.\nelim H.\nintros H'0.\nelim H'.\nintros x H'1 H'2.\nexists (S x).\napply Trans with (y := S y).\nexact (fun y : A => EQC X (e y))).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 589,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintro E.\nexact (EQC_refl E).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintro E; elim E; auto.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nred in |- *.\nintros E E1 E2.\nexact (EQC_refl).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E E H'.\napply EQC_refl.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintro E; elim E; elim E; reflexivity.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E E.\nexact (EQC_refl E).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintro E; apply EQC_refl.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nunfold EQC in |- *.\nintros E E1 E2.\napply EQC_refl.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintro E; elim E; clear E.\nintros x E1 E2; elim E1; clear E2.\nintros x E1 E2; elim E2; clear E1.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E1; clear E2.\nintros x E1 E2; elim E2; clear E1.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E1; clear E1.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E1; clear E2.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 E2; elim E2; clear E2.\nintros x E1 EQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E; elim E; elim E; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 602,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simpl in |- *; auto with zfc.\nintros E1 E2.\napply EQC_sym.\nexact (EQC_refl E1 E3).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nunfold CIN in |- *; intuition eauto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\napply EQC_sym; apply EQC_refl.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\napply EQC_trans with (f:=fun y : B => EQC Y (f y))).\nexact (fun y : B => EQC Y (f y)).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\napply EQC_refl.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\napply EQC_symm.\nred in |- *; intro H.\nsplit; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\napply EQC_trans with E3; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\ngeneralize (EQC_sym E1 E2 E3).\ngeneralize (EQC_sym E1 E2 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E2 E4).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E3).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\ngeneralize (EQC_sym E1 E4).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\napply EQC_trans with (injectC E1 E2); auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\ninversion (EQC_refl E3).\nintros x y E1 E2.\ninversion (EQC_refl E1 E2).\nintros x0 E3.\ninversion (EQC_refl E1 E2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; [ apply EQC_refl | auto with zfc ].\nelim (H0 E2); intros.\nexists x1.\napply H1; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3;\n intros.\nsplit; [ idtac | idtac ].\nelim (a0 x); intros.\nexists x0.\napply EQC_refl.\n\nelim (a0 x); intros.\nexists x1.\napply EQC_refl.\n\nelim (a0 x); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x0); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x0); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x0); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x1); intros.\nexists x1.\napply EQC_refl.\n\nelim (b0 x1); intros.\nexists x1.\napply EQC_refl.\n\nelim (bQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; [ apply EQC; apply EQC; apply EQC; apply EQC; apply EQC; apply EQC;\n apply EQC; apply EQC; apply EQC; apply EQC; apply EQC;\n assumption.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; [ try assumption | idtac ].\nelim (H0 E2).\nintros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nelim (a x); intros.\napply (a0 x0); auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; [ try assumption | idtac ].\nelim (H0 x); intros.\nelim (b x); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nelim (H X1); intros.\ngeneralize (EQC H0); rewrite (EQC H0).\nauto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\napply EQC_refl.\nelim (a0 x); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; [ auto with zfc | idtac ].\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3;\n intros.\nsplit; [ auto with zfc | idtac ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'; simple induction E'.\nintros.\nelim (H (CIN E E' H0)).\nelim (H (CIN E E' H0)).\nelim (H (CIN E E' H1)).\nintros.\nelim (H0 (CIN E E' H1)).\nelim (H (CIN E E' H2)).\nelim (H1 (CIN E E' H1)).\nintros.\nelim (H0 (CIN E E' H1)).\nelim (H1 (CIN E E' H0)).\nintros.\nelim (H1 (CIN E E' H1)).\nintros.\nelim (H0 (CIN E E' H0)).\nintros.\nelim (H1 (CIN E E' H0)).\nintros.\nelim (H1 (CIN E E' H2)).\nintros.\nelim (H3 (CIN E E' H1)).\nintros.\nelim (H3 (CIN E E' H3)).\nintros.\nelim (H1 (CIN E E' H3)).\nintros.\nelim (H1 (CINQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros.\napply EQC_refl; apply EQC_trans with E'.\nelim (b x0); intros.\nelim (b x0); intros.\nexists x1.\napply Y with (e0 x0); auto with zfc.\n\nelim (b x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros.\nelim (H H0); intros.\nelim H1; intros.\nexists x0; auto with zfc.\n\nelim (H0 H); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros x H; elim H; intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros.\napply (Par_trans _ _ _ _ H0 H1).\napply EQC_trans with (C D); auto with zfc.\n\nelim (b y); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros.\napply EQC_refl.\nelim (a y); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros.\nexists x; auto with zfc.\n\nelim (b x); intros.\nexists x0.\napply X with (e0 x0); auto with zfc.\n\nelim (b x0); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'.\nintros.\napply EQC_trans with (D:=fun y : B => EQC X (e y))).\nauto with zfc.\n\nelim (H0 y); intros.\nelim (b y); intros.\nexists x0; auto with zfc.\n\nelim (b y); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E; simpl in |- *; intros.\nelim H; intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'.\nintros.\nunfold E in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'.\nintros.\nelim (H0 E'); intros.\nelim (H0 E'); intros.\nelim (H0 E'); intros.\nelim (H1 E'); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'.\nintros.\nred in |- *.\napply (EQC_sym E' H0).\napply EQC_trans with (e y); auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros; \n unfold D_dist in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold D_dist in |- *; intros; unfold CINC in |- *;\n unfold D_dist in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |-Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim (H0 E); intros.\nelim (H1 E); intros.\ngeneralize (H0 E'); intros.\nelim (H0 E'); intros.\ngeneralize (H1 E' H0); intros.\napply H1; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E'.\nintros H H0 H1 H2.\nelim H2; intros.\nelim (a0 x); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E; simpl in |- *; intros;\n auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; elim H;\n intros.\nsplit; [ elim (H0 (sym_eq H1)) | idtac ].\nelim (H0 (sym_eq H1)); intros.\nelim (H0 (sym_eq H1)); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'.\nintros.\nelim H1; intros.\nrewrite H2; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'.\nintros.\ninversion H1; inversion H2.\nintros.\napply (Par_trans E0 E' H4).\napply (Par_trans E0 E' H4).\napply (Par_trans E0 E0 E' H4).\napply (Par_trans E0 E' H4).\napply (Par_trans E0 E' H4).\napply (Par_trans E0 E0 H4).\napply (Par_trans E0 E' H4).\napply (Par_trans E0 E0 H4).\napply (Par_trans E0 E0 H4).\nassumption.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'.\nintros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E' E'' H'0 H'1; try assumption.\nelim (H' E'' E'' H'1); intros.\nelim (H' E'' E'' H'2); intros.\nelim (H' E'' E'' H'3); intros.\nelim (H' E'' H'3); intros.\nelim (H' E'' H'3); intros.\nelim (H' E'' H'3); intros.\nelim (H' E'' H3); intros.\nelim (H' E'' E'' H3); intros.\nelim (H' E'' H3); intros.\ngeneralize (H' H3 E'' H3); intros.\nelim (H' E'' H3); intros.\nelim (H' E'' H3); intros.\ngeneralize (H' E'' H3); intros.\nelim H3; intros.\nelim (H' E'' H4); intros.\nelim H3; intros.\nelim (H' E'' H4); intros.\ngeneralize (H' E'' H4); intros.\ngeneralize (H' E'' H4); intros.\ngeneralize (H'Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E' E'' H'0 E'' H'1 E'' H'2 E'' H'3 E''.\nunfold CIN in |- *.\nelim (classic (Equal (fun x : A => EQC (e0 y) (e0 y))) (e0 y)); intros.\nelim (H' x); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; simple induction E''.\nintros; apply H1.\nintros; apply H2.\nintros; apply H1; clear H1.\napply H2; clear H2.\napply H1; clear H1.\napply H1; clear H1.\napply H1; clear H1.\napply H1; clear H1.\napply H1; clear H1.\napply H1; clear H1.\napply H1; clear H1.\napply H1; clear H1.\napply H2; clear H2.\napply H0; clear H1.\napply (H3 x); auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nred in |- *; unfold CIN in |- *; unfold CIN in |- *;\n intros; split; intros.\napply H1; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E' E'' H'0 H'1 H'2; apply EQC_symm.\nred in |- *; red in |- *; intro; apply H'; clear H'; clear H'.\nelim H'; clear H'; intros.\nsplit; [ try assumption | idtac ].\nelim (b x); intros.\nexists x; split; [ auto with zfc | idtac ].\n\nelim (b x); intros.\nexists x0; split; [ auto with zfc | idtac ].\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nunfold CIN in |- *; simpl in |- *; intros; split; intros.\nelim H0; intros.\nelim (H0 H0); intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H3 H0); intros.\nelim H4; intros.\nelim (H3 H0); intros.\nelim H4; intros.\nelim (H4 H0); intros.\nelim (H6 H0); intros.\nelim H4; intros.\nelim (H6 H0); intros.\nelim H6; intros.\nelim (H6 H0); intros.\nelim (H1 H0); intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim (H6 H7); intros.\nelim H7; intros.\nelim (H7 H7); intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; introsQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; simple induction E'.\nintros.\nunfold CIN in |- *; simpl in |- *.\nelim (H0 E'' H2); intros.\nelim (H0 E'' H3); intros.\nelim (H1 E'' H3); intros.\nelim (H2 E'' H3); intros.\nelim (H3 E'' H3); intros.\nelim (H4 E'' H3); intros.\nelim (H4 E'' H3); intros.\nelim (H5 E'' H3); intros.\nelim (H6 E'' H3); intros.\nelim (H6 E'' H4); intros.\nelim (H6 E'' H4); intros.\nelim (H6 E'' H4); intros.\nelim (H6 E'' H4); intros.\nelim (H6 E'' H5); intros.\nelim (H6 E'' H4); intros.\nelim (H6 E'' H4); intros.\nelim (H7 E'' H5); intros.\nelim (H7 E'' H4); intros.\nelim (H7 E'' H6); intros.\nelim (H7Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nred in |- *; intros E E E' H'0 H'1; apply H'1; clear H'1.\nelim H'1; intros.\nelim H'1; intros.\nelim H'1; intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nunfold CIN in |- *; simpl in |- *; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim (H0 H); intros.\nelim (H0 H); intros.\nelim (H1 H); intros.\nelim (H0 H); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nred in |- *; unfold CIN in |- *; unfold CIN in |- *;\n unfold CIN in |- *; unfold CIN in |- *; \n unfold CIN in |- *; unfold CIN in |- *; \n unfold CIN in |- *; unfold CIN in |- *; \n unfold CIN in |- *; unfold CIN in |- *; \n unfold CIN in |- *; \n unfold CIN in |- *; unfold CIN in |- *; \n unfold CIN in |- *; \n intros; split; intros.\napply (H (x0 y) (e0 x0)); intros.\nelim (b x0); intros.\nexists x0; auto with zfc.\n\nelim (b x0); intros.\nexists x1; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nunfold CIN in |- *; simpl in |- *; intros;\n unfold CIN in |- *; simpl in |- *.\nelim (classic (CIN E E'' /\\ CIN E E')).\nintros y H'0.\napply CIN_th_th_th with E; auto with zfc.\napply CIN_th_th_th with E; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E; simple induction E''; simpl in |- *;\n intros; split; intros.\nelim H0; intros.\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | idtac ].\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | idtac ].\n\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | idtac ].\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | reflexivity ].\n\nelim (H0 y); intros.\nexists x0; split; [ auto with zfc | reflexivity ].\n\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | reflexivity ].\n\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | reflexivity ].\n\nelim (H0 y); intros.\nexists x0; split; [ auto with zfc | reflexivity ].\n\nelim (H0 y); intros.\nexists y; split; [ auto with zfc | reflexivity ].\n\nelim (H0 y); intros.\nexists x1; split; [ auto with zfc | reflexivityQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simpl in |- *; intros;\n split; intros.\nelim (H x); intros.\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nintros E E' E'' H'0 H'1 H'2; try assumption.\nelim H'1; intros.\nelim H'1; intros.\nelim (a x); intros.\ngeneralize (H'0 y); intros.\ngeneralize (H' y); intros.\nrewrite H0; auto with zfc.\n\napply (H' y); intros.\ngeneralize (H' x); intros.\ngeneralize (H' y); intros.\nrewrite H0; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simpl in |- *; intros.\nelim H0; intros.\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim H0; intros.\nelim (H x); intros.\nelim (H0 x); intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''.\nintros E0 E'' H1 H2 H3 H4.\nelim (H0 E'' H1); intros.\nelim (H2 E'' H2); intros.\nelim (H3 E'' H3); intros.\nelim (H1 E'' H3); intros.\nelim (H3 E'' H3); intros.\nelim (H3 E'' H4); intros.\nelim (H4 E'' H4); intros.\nelim (H4 E'' H4); intros.\nelim (H6 E'' H4); intros.\nelim (H7 E'' H5); intros.\nelim (H8 E'' H5); intros.\nelim (H7 E'' H6); intros.\nelim (H8 E'' H5); intros.\nelim (H9 E'' H6); intros.\nelim (H8 E'' H5); intros.\nelim (H8 E'' H6); intros.\nelim (H8 E'' H6); intros.\nelim H8; intros.\nelim (H8 E'' H6); intros.\nelim H8; intros.\nelim H9; introsQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simple induction E'; simpl in |- *; intros.\nelim H1; intros.\nelim (b x); intros.\nelim (b y); intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim H0; intros.\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H0 y); intros.\nexists x0; auto with zfc.\n\nelim (H x); intros.\nelim (H0 y); intros.\nrewrite (H0 y0); intros.\nrewrite (H1 y0); intros.\nrewrite (H2 y0); intros.\nrewrite H2; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim (H E); intros.\nelim (H0 H); intros.\nelim (H0 H1); intros.\nelim (H0 H0); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim (classic C); intros.\nelim (classic C); intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros;\n split; intros.\nelim H1; intros.\nelim (H x); intros.\nelim H2; intros.\nelim (H0 x); intros.\nelim H2; intros.\nelim (H2 y0); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; unfold C eqn in |- *; unfold C eqn in |- *; simpl in |- *; \n intros; split; intros.\nelim (H0 y); intros.\nelim (a x); intros.\nexists y; auto with zfc.\n\nelim (H0 y); intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim H; intros.\nelim H0; intros.\nelim (H x0); intros.\nelim (H0 x0); intros.\nexists x1; auto with zfc.\n\nintros.\nelim (H x0); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim H; intros; elim H1; intros.\nelim (H1 y); intros.\nelim (H2 y); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E; simpl in |- *; intros;\n split; intros.\nelim (H0 x); intros.\nelim (H0 x); intros.\nexists x; auto with zfc.\n\napply (H1 x); intros.\ngeneralize (H1 y); rewrite (H0 y); auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; unfold CIN in |- *; simpl in |- *; intros;\n split; intros.\nelim H; intros.\nelim (H x); intros.\nexists x0; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E; simple induction E''.\nintros.\nelim H1; intros.\nelim H1; intros.\nrewrite H2; auto with zfc.\n\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim (CINC_sound_right A f XR); intros.\nelim (CINC_sound_right B f XR); intros.\nelim (CINC_sound_right B f XR); intros.\nelim (CINC_sound_right B f XR); intros.\nelim (CINC_sound_right C f XR); intros.\napply (DINC_sound_right C f XR); intros.\nelim (CINC_sound_right C f XR); intros.\nelim (CINC_sound_right C f XR); intros.\nelim (CINC_sound_right C f XR); intros.\nrewrite H1; auto with zfc.\n\nelim (CINC_sound_right C f XR); intros.\nelim (CINC_sound_right C f XR); intros.\nrewrite H1; auto with zfc.\n\nelim (CINC_sound_right C f XR); intros.\nrewrite H1; auto with zfc.\n\nelim (CINC_sound_right C f XR); intros.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; simpl in |- *; intros E E E' E'' H0.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E H; elim H; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold tout_vide_est_vide_est_vide_propertie.\nelim (classic (fun E' : Ens => CIN E' E' /\\ F)).\nintros E0 E0; elim E0; intros.\nelim E0; intros.\ngeneralize E0; clear E0.\nelim (X2 E0); intros.\nelim H1; intros.\nrewrite H1; auto with zfc.\n\nintros.\ngeneralize E0; clear E0.\nelim (X2 E0); intros.\nrewrite H1; auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold tout in |- *; simpl in |- *; intros.\nelim (X2 E0); intros.\nexists x0; apply EQC_ 1996 with (y := x0); auto with zfc.\n\nunfold E in |- *; auto with zfc.\n\nunfold E in |- *; auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; simpl in |- *; intros.\nelim H0; intros.\nelim (X2 E0); intros.\nexists x; auto with zfc.\n\nelim (X2 E0); intros.\nexists x0; auto with zfc.\n\nelim (X2 E0); intros.\nexists x1; auto with zfc.\n\nelim (X2 E0); intros.\nexists x1; auto with zfc.\n\nelim (X2 E0); intros.\nexists x2; auto with zfc.\n\nelim (X2 E0); intros.\nexists x1; auto with zfc.\n\nelim (X2 E0); intros.\nexists x2; auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold not in |- *; intros E E0 H1; elim E0; intros.\nelim (X2 E0); intros.\nelim (X2 E0); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E H; try assumption.\nelim (X2 E); try assumption.\nelim (X2 E); intros.\nelim (X2 E); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold tout in |- *; simpl in |- *; auto with zfc.\n\nelim (X2 E0); auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E; try assumption.\nelim (X2 E); try assumption.\nelim (X2 E0); try assumption.\nintros x0 x1; elim x1; intros.\nexists x1; apply EQC_extensional with (x := x1); auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold tout in |- *; intros E E0; elim E0; simpl in |- *;\n intros; elim E0; intros.\nelim (X2 E0); intros; apply EQC_inc with (e x); auto with zfc.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold tout in |- *; unfold Cir in |- *; simpl in |- *;\n intros E E0; elim E0; intros; apply E1; intros.\nelim (X2 E0); try assumption; intros.\nexists x; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold decide in |- *; simpl in |- *; intros A A' B H; elim H;\n intros x1 H1; elim H1; intros.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Same_vide in |- *; simple induction E; simpl in |- *;\n intros A f X; elim X; intros.\napply\n (H0 (a x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A A' B; try assumption.\nelim (classic (A' = A /\\ A' = B)).\nintros H0 H1; elim H1; intros H2 H3; elim H3; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold alont in |- *; simple induction E; simpl in |- *;\n intros.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold alire, alel_vide, Negation in |- *; simpl in |- *;\n intros A A' B H H0; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold ales in |- *; unfold A' in |- *; simpl in |- *; unfold A' in |- *;\n intros A A' B; elim (H (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfoldlfes in |- *; simpl in |- *; intros A A' B' H' H'0; elim H'0; clear H'.\nintros A' B' H'0 H'1; elim H'0; clear H'.\nintros x H'0; elim H'0; clear H'0.\nintros x0 H'1; elim H'0; clear H'0.\nintros x0 H'2; elim H'0; clear H'0.\nintros x1 H'3; elim H'3; clear H'3.\nintros x1 H'4; elim H'4; clear H'4.\nintros x1 H'4; elim H'4; clear H'4.\nintros x2 H'5; elim H'4; clear H'4.\nintros x3 H'5; elim H'4; clear H'4.\nintros x4 H'6; elim H'4; clear H'4.\nintros x5 H'6; elim H'5; clear H'4.\nintros x5 H'6; elim H'5; clear H'5.\nintros x6 H'7Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold decide in |- *; simple induction E; simpl in |- *; intros A.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold ales in |- *; simpl in |- *; intros A A' B; elim (H (e x));\n auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A' B; elim (H (a x)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold ales in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim (H (e x)); auto with zfc.\n\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold alrome in |- *.\nsimpl in |- *.\nintros; split.\nelim (classic (exists y : Point, C y)).\nintro; exists y; auto with zfc.\nexists (x := fun y : Point => B' y).\nexists (x := fun y : Point => B' y).\nunfold fun_ in |- *; simpl in |- *; auto with zfc.\n\nunfold fun_ in |- *; simpl in |- *.\nintros; split; [ exists y; auto with zfc | reflexivity ].\n\nelim (axs_comprehension (fun x : Point => exists y : Point, C y)).\nintro; apply H.\n\ngeneralize\n (H0 H); clear H H0 H1; intros.\nelim H; clear H; intros.\ngeneralize (H0 H0); clear H0 H1; intros.\ngeneralize (H1 H0); clear H0 H1; intros.\nelim (H0 x); intros.\ngeneralize (H1 x); clear H1; intros.\ngeneralize (H0 H0); clear H0 H1; intros.\ngeneralize (H1 x); clear H1; intros.\ngeneralize (H1 H0);Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold alome in |- *.\nsimpl in |- *.\nintros; split.\nunfold alome in |- *.\nelim (H (e x)); auto with zfc.\n\nunfold alome in |- *.\nelim (H (e x)); auto with zfc.\n\nintros; unfold alome in |- *.\nelim (H (e x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold alire in |- *.\nsimpl in |- *; intros.\nelim (classic (exists x : A, C x /\\ C x)).\nintros a b; elim (H (a, b)).\nintros a b H; elim H; intros.\nexists a; auto with zfc.\n\nintros; exists a; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paise in |- *.\nsimpl in |- *.\nintros; split; [ assumption | apply in_map_inv_leftC; apply in_map_inv_rightC; apply in_map_inv_leftC; apply in_map_inv_leftC; apply in_map_inv_rightC.\n\nunfold alur in H; simpl in H; apply in_map_inv_leftC; apply in_map_inv_leftC.\n\nunfold alur in H; simpl in H; apply in_map_inv_rightC; apply in_map_inv_d; apply in_map_inv_d; apply in_map_inv_d.\n\nunfold alur in H; simpl in H; apply in_map_inv_d.\n\nunfold alur in H; simpl in H; apply in_map_inv_d; apply in_map_inv_d; apply in_map_inv_d; apply in_map_inv_d.\n\nunfold alur in H; simpl in H; apply in_map_inv_d; apply in_map_inv_d.\n\nunfold alur inQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *.\nintros; split.\nsimple induction x.\nexists (a x); auto with zfc.\n\nexists (a x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold blire in |- *.\nsimpl in |- *.\nintros; split.\nelim (H (a x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paux in |- *.\nsimpl in |- *.\nintros; split; [ idtac | idtac ].\nexists true; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold alel, B' in |- *; simpl in |- *; intros A B A' B' H0 H1; \n split.\nintros; elim (H (e x)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nelim (H (e x)); auto with zfc.\nexists false; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nunfold CIN in |- *; intros; split.\nunfold CIN in |- *; intros.\nelim (H (a x)); auto with zfc.\nexists x; auto with zfc.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nintro; exists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nauto with zfc.\n\nelim (classic (In C D)).\nintros H' H'0; elim H'0; intros.\nexists x; exists x; exists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nintros; elim H; clear H; intros.\nelim H0; clear H0; intros.\nelim (H0 (Ax A' B' H1)); auto with zfc.\n\nintros; elim H1; clear H1; intros.\nelim (H0 (Ax A' B' H1)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nunfold CIN in |- *; simpl in |- *; intros.\nelim (H (e x)); auto with zfc.\n\nintros; exists (e y); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nunfold CIN in |- *; simpl in |- *; intros; split.\nunfold CIN in |- *; simpl in |- *; intros.\nelim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros.\nelim (H E'); auto with zfc.\nexists x; exists y; auto with zfc.\nexists x; exists y; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nunfold CIN in |- *; simpl in |- *; intros.\nelim (H (e x)); auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold ales in |- *; simpl in |- *; intros; split.\nunfold CIN in |- *; exists true; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; unfold CIN in |- *;\n intros E E' H0 x; elim x; clear x.\nexists (a x); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split; [ assumption | idtac ].\nexists true; auto with zfc.\n\nunfold CIN in |- *; simpl in |- *.\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nintros; apply CIN_Paire_elim_rightC with E'; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_assifC : forall E E' : Ens, CIN E E' -> C<>E'.\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nintros; elim (H (axet_vide_propertie a x)); auto with zfc.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Alelont in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\n\nTheorem CIN_alire_rightC :\n forall (A : Ens) (P : Ens -> Prop), CLet_EQ A P A.\nunfold CLet_EQ in |- *; simpl in |- *; intros; split; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Inter in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold ales in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Gront in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold alt_t in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold alie in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold alire in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold incl in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Sum in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold alie, BCER in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold alt_t in |- *; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold In in |- *; intros E; elim (H (Var E)); intros.\nelim (H (Var E)); intros.\nexists a; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Same in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Clos in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold ACIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Equ in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold ACIN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold alt_t in |- *; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 351,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Nat : nat -> Ens.\nexact (O_Sn (O_Sn O_Sn O_Sn)).\n\nDefinition nat_of_P (n : nat) :=\n  match n return (forall m : nat, m = S n -> nat_of_P m) with\n  | 0 => False\n  | S m => True\n  end.\n\n(*\nInductive fin (n : nat) : Prop :=\n  | n_O : forall m : nat, fin m -> fin m.\nHint Resolve fin_S: algebra.\n\nLemma nat_of_P_lt_O : forall n : nat, nat_of_P n -> fin n.\nsimple induction n.\nintros; absurd (exists n : nat, n = S n).\nred in |- *; intro.\nexists 0; auto with arith.\nintros n0 H'; elim H'; auto with arith.\nintros n0 H'0 H'1 H'2; exists n0; auto with arith.\nintros n1 H' H'0 H'1; exists n0; auto with arith.\nintros n1 H' H'1; exists n0; auto with arith.\nintros n1 H'1 H'2;Defined.",
                    "Definition Nat : nat -> Ens.\nintros.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nred in |- *.\nintros a b c.\napply (Build_Setoid (E:=O)).\nredDefined.",
                    "Definition Nat : nat -> Ens.\nintros n H'; red in |- *; red in |- *; red in |- *; intros.\napply (H n).\napply (H0 n).\napply (H n).\napply (H n).\napply (H n).\napply (H n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (H0 n).\napply (HDefined.",
                    "Definition Nat : nat -> Ens.\nintros.\napply (O_Sn_1 (A:=O)).\nred in |- *.\nintros.\napply (O_Sn_1 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_1 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_2 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_1 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_1 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_1 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_1 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_2 (A:=O_Sn_1 A)).\nred in |- *.\nintros.\napply (O_Sn_2 (A:=O_Sn_1 A)).\nred in |- *.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Setoid (A:=A)).\nred in |- *.\nintros x y H; elim H; auto with algebra.\nintros H0 H1; elim H1; auto with algebra.\nintros H1 H2; elim H1; auto with algebra.\nintros H1 H2; elim H2; auto with algebra.\nintros H1 H2; elim H2; auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\nintros.\napply (O_Sn_O_Sn_O).\napply (O_Sn_O_Sn_O_Sn_O_Sn_Sn_O_Sn_O_Sn_O_Sn_Sn_O_Sn_Sn_O_Sn)).\napply (O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_O_Sn_O_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_Sn_O_O_S_Sn_O_Sn_O_O_Sn_O_O_S_O_Sn_n_m)\n auto with *.\napply (O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_Sn_O_O_Sn_O_O_Sn_O_O_Sn_m)\n auto with *.\napply\n (O_Sn_O_Sn_O_SnDefined.",
                    "Definition Nat : nat -> Ens.\nintros.\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\napply (O_Sn_O).\nDefined.",
                    "Definition Nat : nat -> Ens.\nintros; auto with *.\nDefined.",
                    "Definition Nat : nat -> Ens.\nexact (fun n : nat => n = 0).\nDefined.",
                    "Definition Nat : nat -> Ens.\nintros n m H.\nelim H; elim H; auto with sets.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nunfold Omega in |- *; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof fun E : Ens => fun E : Ens => fun E : Ens => E.\n\n(*\nLemma fin_pred :\n forall (E : Ens) (n : nat), IN E (Set_Of E).\nintro E; red in |- *; simpl in |- *.\nintros E; elim E; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred in |- *; red in |- *; red in |- *; intros.\nexact (Set_inf_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_o_prop_Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred in |- *; simpl in |- *.\nunfold eq in |- *; unfold eq in |- *; unfold eq in |- *; simpl in |- *.\nintros; apply Refl.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred in |- *; red in |- *; red in |- *; intros.\napply H; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nconstructor; [ red in |- *; intros E; inversion E; clear E | idtac ].\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof\n  fun E : Ens => EQ E.\n\n(*\nInductive Empty : Ens -> Prop :=\n  | Empty : Empty Empty\n  | Empty : Empty\n  | Empty : Empty.\n\n(*\nInductive Empty : Ens -> Prop :=\n  | Empty : Empty empty\n  | Empty : Empty.\n\n(*\nInductive Empty : Ens -> Prop :=\n  | Empty : Empty\n  | Empty : Empty.\n\n(*\nInductive Empty : Ens -> Prop :=\n  | Empty : Empty Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty Empty\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty : Empty.\n\n(*\nInductive Empty : Prop :=\n  | Empty :Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof fun E F : Ens => fun x : E => Ap2 (A:=E) F.\n\nTheorem Omega :\n forall (E F : Ens) (n : nat),\n IN E (Class_succ E).\nProof fun E F : Ens => fun x : E => Ap2 (A:=E) F.\n\nDefinition Omega_in_finite_parts :\n forall (E F : Ens) (n : nat),\n IN E (Record_Setoid E F) := \n  {inverse_prf : (F:=E) (inverse_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf : (F:=E) (comp_prf F);\n   inverse_prf :Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred in |- *; simpl in |- *.\nintros E; elim E; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof fun E : Ens => fun x : Ens => x.\n\nTheorem Singleton_empty :\n forall (X : Ens) (x : Ens), IN X (Singleton X) -> IN X (Singleton X).\nProof fun E : Ens => fun x : Ens => x.\n\n(*\nInductive Empty : Ens -> Prop :=\n  | Empty_cons : forall x y : Ens, Empty x -> Empty y\n  | Empty_cons : forall x y : Ens, Empty x -> Empty y -> Empty y.\n\n(*\nInductive Empty : Ens -> Prop :=\n  | Empty_cons : forall x y : Ens, Empty x -> Empty y -> Empty y.\n\nTheorem Empty_not_empty :\n forall (X : Ens) (x : Ens), IN X (Singleton X).\nProof fun X x y : Ens => IN X x.\n\nTheorem Singleton_not_empty :\n forall (X : Ens) (x : Ens), IN X (Singleton X).\nProof fun X x y : Ens => IN X x.\n\nTheorem Singleton_not_empty :\n forall (X : Ens) (x : Ens), IN X (Singleton X).\nProof\n  fun X x : EnsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 484,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Disj in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Disj in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;\n unfold Sing in |- *;Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold not in |- *; unfold Canc in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; intros H'0; elim H'0; clear H'0; intros H'1 H'2;\n elim (H'0 x0); clear H'0; intros H'3 H'4;\n elim (H'0 x1); clear H'0; intros H'5 H'6;\n elim (H'2 x2); clear H'0; intros H'7 H'8;\n elim (H'3 x2); clear H'3; intros H'8 H'9;\n elim (H'7 x2); clear H'0; intros H'8 H'9;\n elim (H'8 x2); clear H'8; intros H'10 H'11;\n elim (H'10 x1); clear H'11; intros H'12 H'13;\n elim (H'13 x2); clear H'12; intros H'13 H'15;\n elim (H'13 x2Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Exs_succ in |- *; unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *; \n unfold Ims in |- *; unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |- *;\n unfold Ims in |- *; unfold Ims in |-Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold group in |- *; unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;\n unfold Top_rel in |- *; unfold Top_rel in |- *;Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold not in |- *; unfold Non_empty in |- *;\n apply X.\nred in |- *; simpl in |- *; unfold Non_empty in |- *;\n apply X.\nred in |- *; simpl in |- *; unfold Non_empty in |- *;\n apply X.\nred in |- *; simpl in |- *; unfold not in |- *; unfold not in |- *;\n intros E; unfold not in |- *; intros E; unfold not in |- *;\n intros E; unfold not in |- *; intros E; unfold not in |- *;\n intros E; unfold not in |- *; intros E; unfold not in |- *; intros E;\n unfold not in |- *; intros E; unfold not in |- *; intros E;\n unfold not in |- *; intros E; unfold not in |- *; intros E;\n unfold not in |- *; intros E; unfold not in |- *; intros E;\n unfold not in |- *; intros E; unfold not in |- *; intros E;\n unfold not in |- *; intros E; unfold not in |- *; intros E; unfold not in |- *;\n intros E; unfold not in |- *; intros E; unfold not in |- *; intros E;\n unfold not in |- *; intros E; unfold not in |-Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nsimpl in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold not in |- *; unfold Disj in |- *;\n unfold not in |- *; unfold Disj in |- *;\n unfold not in |- *; simpl in |- *; intros; discriminate.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold not in |- *; unfold Disj in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; intros.\ngeneralize H0; case x; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold not in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; simpl in |- *.\nunfold not in |- *; unfold Disj in |- *; simpl in |- *.\nunfold not in |- *; unfold Disj in |- *; simpl in |- *.\nintros E H H0; elim E; intros H1 H2; elim E; intros H3 H4; clear E.\nexists x0; split; [ auto with zfc | idtac ].\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold not in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold not in |- *;\n unfold Disj in |- *; unfold not in |- *; intros; discriminate.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Reflexive in |- *; unfold originally in |- *;\n unfold originally in |- *;\n unfold originally in |- *; unfold originally in |- *;\n unfold originally in |- *; unfold originally in |- *;\n unfold originally in |- *;\n unfold originally in |- *; simpl in |- *.\nintros H; generalize (H1 x H); clear H H1; intros H1 H2;\n clear H2; intros H1; generalize (H1 x H); clear H1; \n intros H1; generalize (H2 x H); clear H1; \n intros H1; generalize (H1 x H1); clear H1; \n intros H1; generalize (H2 x H); clear H1; \n intros H2; generalize (H1 x H); clear H2; \n intros H3; generalize (H3 x H); clear H3; \n intros H3; generalize (H3 x H3); clear H3; \n intros; elim (H4 x H3); clear H3; \n intros; elim H3; clear H3; intros H4; elim H4; clear H4; \n intros; elim H4; clear H4; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 554,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'; unfold iff in |- *; unfold inc in |- *; unfold inc in |- *;\n unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; intros; (left; auto with zfc).\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof\n  fun E E' H H'0 H'1 H'2; intros E' H'3; intros E'4; elim E'4; clear E'4.\n\nTheorem EQ_Class_succ_or :\n forall (E : Ens) (x : E), ~ EQ E (Class_succ E).\nProof\n  fun E x : E => ~ EQ E (Add E x) (Add E x).\n\n(*\nTheorem elim_Rel_of_imp :\n forall (E : Ens) (x y : E), ~ EQ E (Add E x) (Add E y).\nintros E x y H'; unfold Relation_succ in |- *; unfold Sep in |- *;\n apply EQ_Rel_of_imp; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nred in |- *; unfold Disj in |- *; unfold Disj in |- *;\n apply EQ_Class_succ_or; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold not in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n intros.\napply H; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold not in |- *; unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold not in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold not in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *; unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfold Non_empty in |- *;\n unfoldQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nred in |- *; unfold Disj in |- *; unfold Disj in |- *;\n apply EQ_or_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty_not_Empty.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold not in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold not in |- *; unfold not in |- *; simpl in |- *; unfold not in |- *;\n unfold not in |- *; simpl in |- *; unfold not in |- *;\n unfold not in |- *; simpl in |- *; intros.\napply (axs_comprehension (fun x y : E => ~ x) y); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'; unfold not in |- *; unfold Disj in |- *; unfold Disj in |- *;\n apply EQ_symm.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'; unfold iff in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; intros.\napply H0.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'0; unfold Reflexive in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; intros; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E in |- *; unfold Same_set in |- *.\nintros E E; red in |- *.\nintros E0; red in |- *.\nintros E1; red in |- *.\nintros E1; red in |- *.\nintros E1; red in |- *.\nintros E2; red in |- *.\nintros E3; red in |- *.\nintros E4; red in |- *.\nintros E5; red in |- *.\nintros E5; red in |- *.\nintros E5; red in |- *.\nintros E5; red in |- *.\nintros E6; red in |- *.\nintros E5; red in |- *.\nintros E5; red in |- *.\nintros E5; red in |- *.\nintros E6; red in |- *.\nintros E6; red in |- *.\nintros E6; red in |- *.\nintros E5; red in |- *.\nintros E6; red in |- *.\nintros E5; red in E6; red in |- *.\nintros E5; red in E5; red in E6; red in E6; red in E6; red in E6; red in E6;\n intros E6;Qed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; unfold not in |- *; intros E E F; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; \n unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E in |- *;\n unfold E inQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; unfold not in |- *; unfold not in |- *; intros E H0; elim H0; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E, F in |- *; unfold E, F in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; apply E_1.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; unfold not in |- *; unfold not in |- *; intros E F.\nelim (Union_IN E F); auto with zfc.\n\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; intros E E0 H'; elim E0; intros i1 i2.\nelim (H (I E0)); intros i1 i2.\nelim (H (I E0)); intros i2 i3.\nelim (H (I E1 i2)); intros i3 i4.\nelim (H (I E0 i3)); intros i4.\nelim (H (I E0 i3)); intros i5.\nexists (I E1 i4).\nsplit; [ auto with zfc | idtac ].\nelim (H (I E0 i3)); intros i5.\nexists (I E1 i4).\nsplit; [ auto with zfc | idtac ].\nelim (H (I E0 i3)); intros.\nexists (I E1 i4).\nsplit; [ auto with zfc | idtac ].\nelim (H (I E0 i3)); intros.\nexists (I E1 i4).\nsplit; [ auto with zfc | idtac ].\nelim (H (I E1 i2)); intros.\nexists (I E1 i4).\nsplit; [ auto with zfc | idtac ].\nelim (H (I E0Qed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E in |- *.\nintros E H'; red in |- *; intro H'.\nelim (IN_Predicate E E); auto with zfc.\nintros; right; apply IN_Add with E x; auto with zfc.\n\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E; unfold not in |- *; unfold not in |- *; intros E F I; elim I; intros i1 i2.\nelim (H_or_not_IN E (IN E E) I).\nintros x y; elim (H_or_not_IN E (IN E E) I).\nintros x y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_or_not_IN E (IN E E) I).\nintros x y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_or_not_IN E (IN E E) I).\nintros y H'; elim (H_orQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E in |- *.\nintros E F; unfold E in |- *; unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; unfold E in |- *;\n unfold E in |- *; ring_simplify.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; unfold not in |- *; intros E F; elim (IN_Set_opp F); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; elim n; intros n0 H'; elim H'.\nintros n1 H'0; elim H'0.\nintros n2 H'1; elim H'0.\nintros n2 H'2; elim H'2.\nintros n3 H'3; elim H'3.\nintros n3 H'4; elim H'4.\nintros n4 H'5; elim H'5.\nintros n4 H'5; elim H'5.\nintros n4 H'6; elim H'6.\nintros n4 H'5; elim H'6.\nintros n5 H'6; elim H'6.\nintros n4 H'6; elim H'6.\nintros n5 H'7; elim H'7.\nintros n5 H'6; elim H'6.\nintros n5 H'7; elim H'7.\nintros n5 H'7; elim H'7.\nintros n5 H'8; elim H'8.\nintros n5 H'8; elim H'8.\nintros n5 H'8; elim H'8.\nintros n6 H'8Qed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; elim n; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nred in |- *; unfold not in |- *; unfold not in |- *; intros n; elim n; auto with arith.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; elim n; clear n.\nelim (O_Sn_n n); auto with *.\nintro n; elim (O_Sn_n n).\nintros; right; apply (H0 n).\nintros n0 H; elim (H0 n0).\nintros n1 H; elim (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 n1).\nintros; right; apply (H0 nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; elim n; clear n.\nelim (Lt_irrefl n).\nintros n0 H; elim (Lt_irrefl n0).\nintros n1 H; elim (Lt_irrefl n1).\nintros n2 H0; elim (Lt_irrefl n2).\nintros n2 H0; elim (Lt_irrefl n2).\nintros n3 H0; elim (Lt_irrefl n1).\nintros n3 H0; elim (Lt_irrefl n2).\nintros H1; elim (Lt_irrefl n2).\nintros n3 H0; elim (Lt_irrefl n3).\nintros n4 H1; elim (Lt_irrefl n4).\nintros n4 H0; elim (Lt_irrefl n4).\nintros n5 H1; elim (Lt_irrefl n3).\nintros n4 H1; elim (Lt_irrefl n4).\nintros n5 H0; elim (Lt_irrefl n5).\nintros n5 H1; elim (Lt_irrefl n4).\nintros n5 H1; elim (Lt_irrefl n5).\nintros n5 H1; elim (Lt_irreflQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintro n; elim n; clear n; intros n H; elim H; auto with zfc.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; elim n; clear n; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; unfold not in |- *; intros n; unfold not in |- *;\n apply (H (S n)); auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nred in |- *.\nintro n; elim n; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nred in |- *; unfold Empty in |- *; unfold Empty in |- *;\n auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nred in |- *.\nintros x H'; red in |- *; intro; elim H'.\nintros H'0; elim H'.\nintros H'1; elim H'.\nintros H'2; elim H'.\nintros H'3; elim H'2; intros H'4 H'5; elim H'5; intros H'6 H'7; clear H'2.\nexists (S n0); auto with zfc.\n\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold SUB in |- *; unfold Singleton in |- *;\n unfold Singleton in |- *; split; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; red in |- *.\nintros n; elim (H (IN_Omega E) (Singleton E)); intros a h.\nexists (empty F); auto with zfc.\n\ngeneralize (EQ_equal E (Singleton E) (Singleton E)); intros a h.\nexists (empty F); auto with zfc.\n\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; red in |- *; intros x H; elim H; clear H.\nintros; elim (H x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold not in |- *; unfold Setminus in |- *;\n simpl in |- *.\nintros x y H'0; elim H'0.\nintros H'1 H'2; elim H'2.\nintros x0 H'3; elim H'3; intros H'5 H'6; clear H'3.\nexists x0; split; [ idtac | idtac ].\napply Trans with (x := x0); auto with zfc.\n\nintros x0 H'3; elim H'4; intros H'6 H'7; clear H'4.\nexists x0; split; [ auto with zfc | idtac ].\napply Trans with (x := x0); auto with zfc.\n\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; elim E; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nunfold not in |- *; intros E; elim E; intros.\nexists x; split.\napply Trans with (x := x0); auto with zfc.\n\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nred in |- *; intros E; elim E; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; exists (fun n : nat => EQ (Nat n) E).\napply le_S_n.\nexact (H (A:=A) (B:=B) (B:=B) (A:=B) (B:=B) (B:=B)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros E; unfold Setoid_sub in |- *; unfold Empty in |- *;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; apply (IN_Omega_EX A (fun n : nat => EQ E (Nat n) E)).\nred in |- *; red in |- *; red in |- *; simpl in |- *.\nintros n H; elim (H (S n)); auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nunfold not in |- *; simple induction 1.\nintros n E.\nexists E; auto with zfc.\nexists n; auto with zfc.\nexists n; auto with zfc.\nexists n; auto with zfc.\nexists n; auto with zfc.\n\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; elim E; intros i1 i2.\nexists (Add_bounded E (fun p : nat => EQ (Nat p) E) i1);\n [ intros i2 i3; elim i1; intros i3 i4.\nexists (Add_bounded E (fun p : nat => EQ (Nat p) E) i3);\n [ intros i3 i4; elim i3; intros i5.\nexists (Add_bounded E (fun p : nat => EQ (Nat p) E) i3);\n [ intros i3 i4; elim i4; intros i5.\nexists (Add_bounded E (fun p : nat => EQ E (Nat p) E) i1);\n [ intros i6; elim i5; intros i6.\nexists (Add_bounded E (fun p : nat => EQ E (Nat p) E) i1);\n [ intros i6; elim i6; intros i6.\nexists (Add_bounded E (fun p : nat => EQ E (Nat p) E) i2);\n [ intros i6; elim i6; intros i6.\nexists (Add_bounded E (funQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintro E; elim E.\nintros n E; elim E.\nintros x H'; elim E.\nintros x0 H'0; elim E.\nintros x1 H'0; elim E.\nintros x2 H'1; elim E.\nintros x2 H'2; elim E.\nintros H'3 H'4; elim E.\nintros x3 H'4; elim E.\nintros x4 H'5; elim E.\nintros x5 H'6; elim E.\nintros H'6 H'7; elim E.\nintros H'7; elim E.\nintros H'8; elim E.\nintros x4 H'9; elim E.\nintros H'9; elim E.\nintros x4 H'9; elim E.\nintros H'10; elim E.\nintros H'10; elim E.\nintros H'11; elim E.\nintros H'11; elim E.\nintros H'11; elim E.\nintros H'12; elim E.\nintros x4 H'12; elim E.\nintros H'12; elim E.\nintros H'12; elim E.Qed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nred in |- *; simple induction 1.\nintros; simpl in |- *; apply EQ_symm.\nintros; apply EQ_symm.\napply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nintros; apply EQ_symm.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros E; case E; intros p E; elim E; intros p E; elim E; intros q E; elim E; intros q E;\n intros q E; elim E; intros q E; elim E; intros q E; \n clear E; intros q E; elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; elim E; intros q E; \n intros q E; elim E; intros q E; elim E; intros q E; \n clear E; intros q E; elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; \n elim E; intros q E; elim E; intros q E; elim E; intros q E; \n clearQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1; intros.\napply False_ind; auto with zfc.\nintros n0 H; elim (H n0); auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; elim E; simpl in |- *; auto with zfc.\nintros n E; elim E; simpl in |- *; auto with zfc.\nintros n E; elim E; simpl in |- *; auto with zfc.\nintros n E; elim E; simpl in |- *; auto with zfc.\n\nintros n E0; elim E; simpl in |- *; auto with zfc.\n\nintros n E0; elim E0; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros E; elim E.\nintros n0 H'0; exists n0; auto with zfc.\nintros n1 H'1; exists n1; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintros x y.\nunfold Y in H.\nelim (IN_Included_Included_inv x y).\nintros a; apply H; auto with zfc.\nintros; apply H; auto with zfc.\n\nintros x0 y.\ncut (y = y0).\nauto with zfc.\nintros a; apply H; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold EQ, NEQ, NEQ, NEQ, NEQ, NEQ, NEQ, NEQ in |- *.\nintros.\nelim (H E); auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; red in |- *; red in |- *; red in |- *; intro; apply H; clear H.\nintros; red in |- *; red in |- *; intro; apply H; clear H.\nintros; red in |- *; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in H; red in H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintros; red in |- *; intro; apply H; clear H.\nintrosQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintros x y H'; red in |- *.\nelim (IN_PO (Union (Singleton x) y) H'); intro H'.\nelim (H' y); auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintro x; elim x.\nintros; elim x0.\nintros; elim H0; intros.\napply H0; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H0; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H0; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H0; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H0; intros.\napply H1; intros.\napply H1Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Singleton in |- *.\nintros x H'; elim H'; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Included in |- *.\nintros x H'; elim H'.\nintros.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EX.\napply Definition_of_PO_EXQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Same_relation in |- *; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold EQ at 1 in |- *.\nunfold EQ at 1 in |- *.\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (Union_Union _ _ _ H0)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (Union_Union _ _ _ H)).\nintros.\nelim (H (UnionQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nintros.\napply Extensionality_Ensembles.\napply Empty_set_is_empty.\napply Empty_set_is_empty.\napply Empty_set_is_empty.\napply Empty_set_is_empty.\nQed."
                ]
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 255,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. rewrite <- (Oeq_eq x y H); auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. unfold eq; intros. discriminate. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H. apply eq_sym. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. apply O.eq_sym. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. apply O.eq_sym. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. rewrite H. reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq, eq. intros x y.\n    unfold eq, eq, eq. intuition.\n    apply O.lt_trans with x; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq; intros.\n    rewrite <- H; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. rewrite H, H0; auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 285,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite <- 2 eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros x y z H. apply H. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros x y z H. apply (eq_trans H). Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros x y z H1 H2.\n    destruct (eq_sym H1) as [H | [H | H]].\n    left. exists (S y); auto.\n    right. exists (S y); auto.\n  Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now transitivity x y. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now transitivity y z. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 321,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros x y z H H'. rewrite H, H'; auto. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with x y. apply lt_trans with z. assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply compare. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. rewrite <- (lt_irrefl y). apply lt_not_eq. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply compare_trans with x y; assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with (O.lt x y). apply LT. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with x y; assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with (S.lt y z); trivial. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros x y z H H0.\n  rewrite H, H0; auto.\n  Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply le_trans with x. apply le_trans with y. apply le_trans with y. apply le_trans with z. apply le_trans with z. apply le_trans with z. apply le_trans with z. assumption. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 357,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply LT. assumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply (O.lt_not_eq H). Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq; assumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply O.lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros x y H. apply (lt_not_eq (S x) H). Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros?? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 404,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros; constructor.\n    intros;Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now rewrite <- compare.\n  Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply (StrictOrder_Irreflexive y). Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y. unfold eq. apply compare. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply LT. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. inversion H. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now rewrite <- 2 compare. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y; destruct (compare x y).\n  - right. apply O.lt_irrefl.\n  Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply (StrictOrder_Irreflexive y). Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply (compare x y). Qed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n induction n; simpl in |- *; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nsimple induction n; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n unfold mult at 1; unfold mult at 1; unfold mult at 1; unfold mult at 1;\n   rewrite mult_1_r; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nsimple induction n; simpl; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n unfold multZ, multZ in |- *.\n rewrite mult_n_O; rewrite mult_n_O; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n simple induction n; simpl in |- *; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n unfold multZ in |- *.\n reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  unfold multZ in |- *.  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n destruct n; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; apply multZ_eq1; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 728,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm yQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq2.\n\nLemma multZ_eq5 : forall x y : Z, multZ (neg x) y = Zminus (multZ x y).\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n auto.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n auto.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ", multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x; auto.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintrosQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* posQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; rewrite (tech_mult_negZ n0 y).\nelim (Qdiv_neg_l (multZ (neg n0) y) 0 (oppZ y)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ y)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).\nelim (Qdiv_neg_r (multZ (neg n0) y) 0 (negZ z)).Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nintros x y; do 2 rewrite (tech_exp (neg y) (neg (pos y) - neg x)).\nrewrite (tech_exp (neg y) (neg (neg x) - neg x)).\nreflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nintros x y; do 2 rewrite (tech_exp (neg y) (neg (neg x) - neg y)).\nrewrite (tech_exp (neg y) (neg x) (neg y)).\nreflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nintros x y; do 2 rewrite (tech_exp (neg y) (neg x) (neg y)).\nreflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nintros x y; do 2 rewrite (tech_exp (neg y) (neg x)).\nreflexivity.\n(* pos O *)\nintros x y; do 2 rewrite (tech_exp (neg y) (neg x) (neg y)).\nreflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; discriminate.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple inductionQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos O *)\nintros; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nintros; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos O *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimple induction n.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivityQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimplQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* pos pos O *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* pos pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x; rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm (mult x x)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x x)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_comm (mult x (mult y x))); rewrite (mult_comm x (mult y));\n rewrite (mult_comm (mult x y)); rewrite (mult_comm (mult x y));\n rewrite (mult_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintro; auto.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nsimple induction x.\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm x 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 0).\n(* 0 *)\nsimpl in |- *;Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; simpl in |- *; auto.\nintros n0 H; do 2 rewrite (tech_oppZ x).\nrewrite (tech_oppZ x).\nrewrite (tech_oppZ (neg x)).\nrewrite (tech_oppZ (neg x) (neg (S x)) (neg (S x))).\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintro x; case x.\n(* pos 0 *)\nsimpl in |- *; rewrite (add_0_r 0); rewrite (add_0_r 0); rewrite (add_0_r 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n rewrite (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n (add_comm 0); rewrite (add_comm 0); rewrite (add_comm 0);\n (add_comm 0); rewrite (add_commQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg O *)\nreflexivity.\n(* neg O *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x y H; rewrite (tech_mult_negZ x y H).\napply pos_pos_pos.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x y H; rewrite (tech_mult_negZ x y H).\napply pos_pos_neg.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x y H; rewrite (tech_mult_negZ x y H).\napply pos_pos_neg.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(*Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos S n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_comm (mult_comm 0)).\nrewrite (mult_commQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x; simpl in |- *; auto with arith.\n(* pos n *)\nintro; rewrite (tech_mult_negZ x IZ); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply (add_S n); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply (add_S n); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply (add_S n); reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply (add_S n); reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply (add_S n); reflexivity.\n(* neg n *)\nsimpl in |- *; symmetry  inQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm x).\n(* neg n *)\nsimple induction n.\n(* pos (S n) *)\nreflexivity.\n(* pos O *)\nsimpl in |- *; reflexivity.\n(* pos (S n) *)\nintros z H; rewrite (tech_mult_posZ z Dz); rewrite H; reflexivity.\n(* pos (S n) *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z Dz); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* neg O *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* pos O *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* neg O *)\nintros x H; rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_oppZ x H); rewrite (tech_oppZ x H); rewrite H; reflexivity.\n(* pos 0 *)\nintros x H;Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nreflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* posQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x IZ); rewrite H; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x IZ); rewrite H; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* posQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x; simpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 744,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* neg 0 *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintro H; rewrite (tech_mult_negZ (neg n) 0); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (neg n) 0); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintro H; rewrite (tech_plus_negZ (neg n) 0); rewrite H; reflexivity.\n(* neg n *)\nintros x H; rewrite (tech_negZ (neg n) 0); rewrite H; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros x H; rewrite (tech_negZ (neg n) 0); rewrite H; reflexivity.\n(* pos n *)\nintros x H; rewrite (tech_negZ (neg n) 0);Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_plus_posZ (neg x) (neg x) (neg x)) in H.\nrewrite (tech_oppZ (neg x) (neg x)) in H.\nrewrite (add_neg (neg x) (neg x)) in H.\nrewrite (add_pos (neg x) (neg x)) in H.\nrewrite (add_pos (neg x) (neg x)) in H.\napply (add_pos (neg x) (neg x)).\napply (add_neg (neg x) (neg x)).\napply (add_pos (neg x) (neg x));\napply (add_neg (neg x) (neg x)).\napply (add_pos (neg x) (neg x)).\napply (add_neg (neg x) (neg x)).\napply (add_neg (neg x) (neg x)).\napply (add_neg (neg x) (neg x));\napply (add_neg (neg x) (neg x)).\napply (add_neg (neg x) (neg x)).\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nelim mult_clear mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ y IZ); rewrite H; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *.\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *.\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *.\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *.\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *.\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *.\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos n *)\nelim mult_reverse; simpl in |- *; reflexivity.\n(* pos nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nintros x H.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y zero (neg 0)); rewrite H; reflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y zero (neg 0)); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z 0); rewrite H; reflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nintros n0 H; rewrite (tech_mult_negZ (neg n0) (neg n)) in H.\nelim (mult_comm (neg n0) (neg n0)); reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros n0 H; rewrite (tech_mult_negZ (neg n0) (neg n)) in H.\nelim (mult_comm (neg n0) (neg n)); reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros n0 H; rewrite (tech_mult_negZ (neg n0) (neg n)) in H.\nelim (mult_comm (neg n0) (neg n0)); reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros n0 H; rewrite (tech_mult_negZ (neg n0)) in H.\nelim (mult_comm (neg n0) (neg n0)); reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros n0 H; rewrite (tech_mult_Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_0_reverse (neg n0) (neg n)).\nrewrite H; rewrite (add_0_reverse (neg n0)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_0_reverse (neg n0) (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_0_reverse (neg n0) (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_0_reverse (neg n0) (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* pos O *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_negZ n0 H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_negZ n0 H); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_negZ n0 H); rewrite H; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_posZ x (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in H;\n rewrite (tech_negZ x (neg 0)) in H; rewrite (tech_negZ x (neg 0)) in HQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nreflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros x.\n  elim (negZ_eq_dec x 0).\n  intro.\n  apply neg_pos_pos.\n  apply neg_pos_neg.\n  apply neg_neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg_neg.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros; unfold ANd, negZ, negZ, oppZ in |- *; simpl in |- *.\n  auto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros x.\n apply (pos_absZ_pos x).\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  simple induction x.\n  auto with arith.\n  intros x y H; elim H; auto with arith.\n  intros x0 H0; elim H0; auto with arith.\n  intros x1 H0; elim H0; auto with arith.\n  intros x1 H0; elim H0; auto with arith.\n  intros x1 H1; elim H1; auto with arith.\n  intros x2 H1; elim H1; auto with arith.\n  intros x3 H3; elim H3; auto with arith.\n  intros x4 H4; elim H4; auto with arith.\n  intros x4 H5; elim H5; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros.\n unfold Corollary opp_Z_opp : forall x : Z, Corollary opp_Z_opp : forall x : Z, Corollary opp_Z_opp : forall x : Z, x < x.\nProof.\n intros x H; apply (opp_Z_opp x).\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold Lin in |- *.\nintros x y.\nelim x.\nintros y.\nelim y.\nintros y0.\nelim y0.\nintros y1.\nelim y1.\nintros y2.\nelim y2.\nintros y4 y5.\nelim y4.\nintros y6.\nelim y4.\nintros y7.\nelim y5.\nintros z8.\nelim y5.\nintros z8.\nelim y6.\nintros z9.\nelim z9.\nintros z11.\nelim z12.\nintros z11.\nelim z12.\nintros z12.\nelim y5.\nintros z15.\nelim z14.\nintros z15.\nelim z12.\nintros z15.\nelim z14.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nintros z15.\nelim z15.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold])).\n unfold absZ in |- *.\n intros x H; elim H; intros y H; elim H; intros z H; elim H; intros z H; elim H;\n intros z H; elim H; intros z H; elim H; intros z H; elim H;\n intros z H; elim H; intros z H; elim H; intros z H; elim H;\n intros z H; elim H; intros z H; elim H;\n intros z H; elim H; intros z H; elim H; intros z H; elim H; \n intros z H; elim H; intros z H; elim H; intros z H; elim H;\n intros z H; elim H; intros z H; elim H; \n intros z H; elim H; intros z H; elim H; \n intros z H; elim H; intros z H; elim H; \n intros z H; elim H; intros z H; elim H; intros z H0; elim H; \n intros z H; elim H; intros z H; elim H; \n intros z H; elim H; intros z H; elim H; intros z H; elim H; \n intros z H; elimQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold upaco.\n intros; apply Z.abs_pos.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfoldusing, regZ in |- *.\n intros x0.\n apply neg_pos_pos.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n simple induction x.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H1.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H2.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.\n elim H1; intros.\n apply H3.\n simpl in |- *.\n intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nsimple induction x; simpl in |- *.\nintros; elim H0; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nintros; elim (le_lt_or_eq _ _ H).\nintros; rewrite H; auto with arith.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *; intros; auto.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simplQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nsimple induction x.\nauto with arith.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nsimple induction x; simpl in |- *; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rlt, Ropp, Ropp in |- *; intros; elim H.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rgt in |- *; auto with arith.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nred in |- *.\nelim z.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply mod_le_pos_abs; assumption.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rlt, tech_le_pos; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nred in |- *; intros x y H'; apply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply tech_le_pos_abs; assumption.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rlt in |- *; intros x y H'; elim H'.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nunfold Rlt, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech, tech.\n\t*)\n\nTheorem tech_R0_le_pos : forall x y : Z, x < y -> x < y -> y < x.\nProof.\nsimple induction 1; intros; elim H0; intros; auto with arith.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nexact tech_le_pos_abs.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim x.\n(* (neg n) *)\nintros; elim y.\n(* (neg n) *)\nintros; elim y.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintrosQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *. exact I.\nintros; elim H.\n(* pos n0 *)\nelim x.\n(* pos n0 *)\nintros; elim y; simpl in |- *. exact I.\n(* pos n0 *)\nelim y.\n(* pos n0 *)\nelim y.\n(* pos n0 *)\nintros; elim y; simpl in |- *. exact I.\n(* pos n0 *)\nelim y.\n(* pos n0 *)\nelim z.\n(* pos n0 *)\nintros; elim y; simpl in |- *. exact I.\n(* pos n0 *)\nelim z.\n(* pos n0 *)\nelim z.\n(* pos n0 *)\nelim z.\n(* pos n0 *)\nelim z.\n(* pos n0 *)\nintros; elim y0.\n(* pos n0 *)\nelim z0.\n(* pos n0 *)\nintros; elim y0.\n(* pos n0 *)\nelim z.\n(* pos n0 *)\nelim z0.\n(* pos n0 *)\nintros; elim z0.\n(* pos n0 *)\nelim z0.\n(* pos nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nunfold lt_absZ in |- *; intros; elim H; trivial.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nunfold lt_absZ in |- *; intros x y H'; elim H'.\n(* (neg n) *)\nintros; elim H'.\n(* (pos n) *)\nelim (le_lt_eq_dec x y).\n(* (neg n) *)\nintros; elim H'.\n(* (neg n) *)\nintros; elim H'.\n(* (neg n) *)\nintros; elim H'.\n(* (neg n) *)\nintros; elim H'.\n(* (neg n) *)\nintros H'0; elim H'.\n(* (neg n) *)\nintros; elim H'.\n(* (neg n) *)\nintros H'0; elim H'.\n(* (neg n) *)\nintros; elim H'.\n(* (neg n) *)\nintros H'0; elim H'.\n(* (neg n) *)\nintros H'0; elim H'.\n(* (neg n) *)\nintros H'1; elim H'.\n(* (neg n) *)\nintros H'0; elim H'.\n(* (neg n) *)\nintros H'1; elim H'.\n(* (neg n) *)\nintros H'0; elim H'.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nintros; elim H; auto with arith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\n (* n = 0 *)\nintro; rewrite H; rewrite H0; rewrite H0; reflexivity.\n (* n = 0 *)\nintros; elim H0.\n(* (pos n) *)\nrewrite (neg_pos n); intro; rewrite H; rewrite H; reflexivity.\n(* (neg n) *)\nrewrite (neg_neg n); intro; rewrite H; reflexivity.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nrewrite (neg_neg n); intro; rewrite H; reflexivity.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nrewrite (neg_neg n); intro; rewrite H; reflexivity.\n(* (neg n) *)\nrewrite (neg_neg n); intro; rewrite H; reflexivity.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nrewrite (neg_neg n); intro; rewrite H; reflexivity.\n(* (neg n) *)\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 742,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.\n(* a n *)\nreflexivity.Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |- *; unfold dist in |- *;\n unfold dist in |- *;\n unfold dist in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* m *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold decide equality;\n unfold lt_absZ in |- *; simpl in |- *; intros;\n unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold gt_absZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold gt in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivityQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nunfold lt_absZ in |- *; unfold modulus in |- *; unfold ltZ in |- *;\n unfold tge in |- *; unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_plus in |- *;\n unfold Qpositive_Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n (* n *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nreflexivity.\n(* m = 0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus at 2 in |- *.\n unfold Zminus in |- *.\n unfold Zminus at 2 in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n unfold Zminus at 1 in |- *.\n unfold Zminus in |- *.\n unfold Zminus at 2 in |-Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  simple induction y.\n  auto.\n  simpl in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus at 2 in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus at 1 in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfoldQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  simple induction y; auto.\n  simple induction y.\n  reflexivity.\n  intros.\n  apply E_S.\n  apply E_S.\n  apply E_S.\n  apply E_S.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold Zminus in |- *.\nintros.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *.\n  unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *.\n  unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *.\n  unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *.\n  unfold Zminus in |- *. simpl in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. simpl in |- *.\n  unfold Zminus in |- *. unfold Zminus in |- *. unfold Zminus in |- *. simpl in |- *.\n  unfold Zminus in |- *. rewrite (Zplus_assoc (Z.mul (Z.add (Z.add (Z.add (Z.add (Z.add (Z.add (Z.add (Z.mul a0 (Z.mul a0 (Z.mul a0 (Z.mul a0)))));\n    rewrite Zplus_assoc.\n    rewrite Zplus_assoc.\n    rewrite Zplus_assoc. rewrite Zplus_assoc.\n    rewrite Zplus_assoc.\n    rewrite Zplus_comm.\n    rewrite Zplus_assocQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  simple induction y.\n  simple induction y.\n  simpl in |- *.  intros.  discriminate H.\n  simpl in |- *.  intros.  discriminate H.\n  simpl in |- *.  intros.  discriminate H.\n  simpl in |- *.  intros.  discriminate H.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros y; elim y; simpl in |- *; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  simple induction y; simpl in |- *; intros.\n  discriminate H0.\n  reflexivity.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros; discriminate H0.\n  elim (pos_eq _ _ H).\n  intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_reverse x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_\ufffd_r x).\n(* pos n *)\nsimple destruct n; simpl in |- *; symmetry  in |- *; exact (succ_reverse x).\n(* pos n *)\nsimple destruct n; simpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_reverse x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers_add x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers_add x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers_add x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers_add x).\n(* pos n *)\nsimpl in |-Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ (?&?&?).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l (pos n0) y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_)](pred_))(pred_predZ y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_))(pred_succZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l (pos n0) y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_pull (pos n0) y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_pull (pos n0) y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_pull (pos n0) y).\n(* pos n *)\nsimpl in |- *; symmetry  inQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* var n *)\nintro n; case n.\n(* x *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ IZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exactQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r x y).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_))(pred_succZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_)](pred_ tick y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_))(pred_succZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_pull (pos n) y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_powers y).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 740,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_opp_neg_predZ.\n\n(***************)\n\nLemma tech_add_neg_neg_neg :\n forall x y : Z, succ_predZ x = neg_neg y -> neg_neg x = neg_neg y.\nProof ptc_add_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg :\n forall x y : Z, neg_neg x = neg_neg y -> neg_neg x = neg_neg y.\nProof ptc_add_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall x y : Z, neg_neg x = neg_neg y -> neg_neg x = neg_neg y.\nProof ptc_add_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg :\n forall x y : Z, neg_neg x = neg_neg y -> neg_neg x = neg_neg y.\nProof ptc_opp_neg_neg.\n\nLemma tech_opp_neg_neg :\n forall x y : Z, neg_neg x = neg_neg y -> neg_neg x = neg_negQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof..|].\nintros; elim x; simpl in |- *; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_opp_neg_discr.\n\nLemma tech_opp_neg_neg_neg :\n forall x y : Z, symmetry  in |- *; exact (opp_involutive x).\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_opp_neg_succZ.\n\n(************)\n\nLemma tech_add_neg_pos_neg :\n forall (x y : Z) (y : Z), symmetry (neg (S x)) y = negZ (addZ x y).\nProof ptc_opp_neg_neg_neg.\n\n(*************)\n\nLemma tech_add_neg_pos_neg :\n forall (x y : Z) (y : Z), symmetry (neg (S x)) y = negZ (addZ x y).\nProof ptc_opp_neg_neg_neg.\n\nLemma tech_add_neg_neg :\n forall (x y : Z) (y : Z), symmetry (neg (S x)) y = negZ (predZ x).\nProof strongly_add_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg :\n forall (x y : Z) (y : Z), symmetry (neg (S x)) y = negZ (stepr (neg x) y).\nProofstrong_add_neg_neg.\n\nLemma tech_add_neg_neg_neg :\n forall (x y : Z) (y :Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofstrong_opp_neg_succZ.\n\n(*simple induction 1 *)\nsimple destruct 1.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_liftenv_r x y).\n(* pos n *)\nsimple destruct 1.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (pred_succZ x)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (pred_liftenv_r x y)).\n(* pos n *)\nsimple destruct 1.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Snm_nSm (pos n)).\n(* pos n *)\nsimple destruct 1.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Snm_nSm (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Snm_nSm (pos n)).\n(* pos n *)\nsimple destruct 1.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Snm_nSm (pos n)).\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Abelian_add_neg_predZ.\n\nLemma tech_succ_pos_neg_neg_neg :\n forall x y : Z,)))); [ rewrite <- opp_neg_neg | rewrite <- opp_neg_neg | rewrite <- opp_neg_neg_neg | rewrite <- opp_neg_neg | rewrite <- opp_neg_neg | rewrite <- opp_neg_neg ];\n reflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_add_neg_predZ.\n\n(* monoid *)\nsimple destruct 0.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_commutativity (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ PARTICULAR PURPOSE.add_neg_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_commutativity (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof distr_r.\n\nLemma tech_add_neg_neg_pos :\n forall (x y : Z) (y : Z),)))); trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Zminus_diag_l; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Abelian_add_neg_ Scope forall x y : Z, ptrofs x = ptrofs y.\nsimple destruct x; simpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\nRequire Import Rbase.\nRequire Import Rfunctions.\nRequire Import SeqSeries.\nRequire Import SeqSeries.\nRequire Import Ranalysis1.\nRequire Import Ranalysis1.\nRequire Import Ranalysis1.\nRequire Import Ranalysis2.\nRequire Import Ranalysis3.\nRequire Import Ranalysis5.\nRequire Import Ranalysis5.\nRequire Import Ranalysis5.\nRequire Import Rtrigo_reg.\nRequire Import Ranalysis7.\nRequire Import Ranalysis1.\nRequire Import Ranalysis4.\nRequire Import Ranalysis5.\nRequire Import Ranalysis5.\nRequire Import Ranalysis6.\nRequire Import Ranalysis7.\nRequire Import Ranalysis7.\nRequire Import Ranalysis7.\nRequire Import Ranalysis7.\nRequire Import Ranalysis7.\nRequire Import RanalysisQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Floats_r.\nunfold Zminus in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_INRIA*****)\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_nseq.\n(* pos n *)\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_nseq.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\nrewrite (techQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Canonical Structure add_law_r.\n\nLemma pred_diag_l : forall x y : Z, Zminus x y = succZ (discr x y).\nProof Abelian_succ_r.\nLemma tech_succ_r : forall x y : Z, - x = succZ (discr y).\nProof Abelian_succ_r.\nLemma tech_succ_r : forall x y : Z, - y = succZ (discr x y).\nProof Abelian_succ_r.\n\nLemma tech_succ_r : forall x y : Z, - x = succZ (discr x y).\nProof Abelian_succ_r.\n\nLemma tech_succ_r : forall x y : Z, - y = succZ (discr x y).\nProof Abelian_succ_r.\n\nLemma tech_succ_r : forall x y : Z, - x = succZ (discr x y).\nProof Abelian_succ_r.\n\nLemma tech_succ_r : forall x y : Z, - y = succZ (discr x y).\nProof Abelian_succ_r.\n\nLemma tech_succ_r : forall x y : Z, - xQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof ::= auto with arith.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_ Scope assumption.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_succZ n0).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_pos_predZ n0).\n(* pos n *)\nintros; rewrite (tech_add_neg_predZ n0).\nrewrite H0.\napply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_predZ n0).\n(* pos n *)\nintros; rewrite (tech_add_neg_predZ n0).\nrewrite H0.\napply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_predZ n0).\n(* pos n *)\nsimpl in |- *; symmetry  inQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof strongly_add_neg_ Scope forall x y : Z, Floats (neg x) y = negZ (addZ x y).\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof ptc_add_neg_predZ.\n\nLemma tech_add_neg_neg_neg_neg :\n forall (x : nat) (y : Z),2018 x (only parsing) = zero -> pred_addZ x y = succZ (addZ x y).\nProof ptc_add_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall (x : nat) (y : Z),\n unfold2018 x (only parsing) = zero -> pred_ redefinition x y = negZ ( account x y).\nProof Floats_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg :\n forall (x : nat) (y : Z),\n unfold Team x, y in |- *.\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite pred_addZ_r.\n(* neg n *)\nsimpl in |- *; rewrite pred_addZ_l.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_ SCaseQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Basic.\nsimple induction 1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_pos_predZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H1.\n(* neg n *)\nintro.\nrewrite (tech_add_neg_succZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_succZ n).\nelim H1.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_ Scope  forall x y : Z, symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nintro.\nrewriteQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof ptc_opp_neg_predZ.\n\nLemma tech_add_neg_neg_neg_neg :\n forall x y : Z, License x (only parsing) = zero_ind (addZ x y).\nProof strongly_add_neg_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall x y : Z,\n License x (only parsing) = zero_ind (BEq (neg x) y).\nProof sor.(SORopp_opp_opp_neg).\n\nLemma tech_opp_neg_neg_neg :\n forall x y : Z,\n License x (only parsing) = zero_ind (disc (neg x) y).\nProof Abelian_opp_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg :\n forall x y : Z,\n License x (neg y) = neg_ind (disc (neg x) y).\nProof Abelian_opp_neg_neg.\n\nLemma tech_opp_neg_neg :\n forall x y : Z,\nZ.sgn (neg x) = neg_ind (BEq (neg x) y).\nProof AbelianQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Software Foundation; apply/pred_Ealignof.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintro.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintro.\n(* pos n *)\nsimpl in |- *; rewrite pred_succZ; trivial.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite pred_succZ; trivial.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite pred_succZ; trivial.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_succZ; trivial.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivityQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Abelian_add_neg_predZ.\n\nLemma tech_add_neg_succZ :\n forall x y : Z,2018 x ->2018 y = succZ (shiftin x y).\nProof Abelian_add_neg_powers.\n\nLemma tech_add_neg_pos_neg_neg :\n forall x y : Z, y = succZ (shiftin x y).\nProof Abelian_add_neg_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall x y : Z, y <> succZ (neg x) -> y = succZ (shiftin x y).\nProof Abelian_add_neg_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall x y : Z, y <> 0 -> y <> 0 -> x = y.\nProof Abelian_add_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall x y : Z, y <> 0 -> x = y.\nProof Abelian_add_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg :\n forall x y :Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 751,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos x *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply add_neg_neg_pos_pos.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros.\ndo 2 rewrite (tech_add_neg_succZ n0).\nrewrite H; apply add_neg_pos_pos.\n(* neg n *)\nrewrite H; apply add_neg_neg_pos.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* (neg x) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nintro.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* neg n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintro.\n(* pos n *)\nintros.\n(* pos n *)\nintro.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; simpl in |- *; auto with arith.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos_predZ.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_succZ n0).\nrewrite H0; apply succ_pred_pos_neg.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos_neg.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos_pos.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos_pos.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_pull n0).\nrewrite H0; apply succ_pred_pos_neg.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos_pos.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nunfold mone; intros.\nelim x; reflexivity.\n(* neg n *)\nunfold zero in |- *; apply succ_pred_opp_neg.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pred_pos.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pred_pos.\n(* (neg n) *)\nintro.\ndo 2 rewrite (tech_add_neg_succZ n).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(*Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n; simpl in |- *; auto with arith.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H;Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_double.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_double.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_double.\n(* pos n *)\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof!.\nsimple induction x; simpl in |- *; exact (succ_predZ x).\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos 0 *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nintro.\ncase n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nintros.\npattern n at 1 in |- *.\nelim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nintros.\npattern n at 1 in |- *.\nelim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(* pos n *)\nassumption.\n(*Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; simpl in |- *; auto with arith.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_succZ.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pos_neg.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n).\nelim H; reflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintro; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_neg_predZ.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pos_pos.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pos.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 747,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* pos n *)\nsimpl in |- *; reflexivity.\nintros; rewrite tech_add_neg_bijective; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)simple induction n.\nreflexivityQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\npattern (pos n) at 1 in |- *.\napply succ_pred_pred_succZ.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* zero *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_ Scope nat_scope.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivityQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* (neg n) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* pos n *)\nintro.\ncut (neg n = pos n).\nintro.\ncut (neg n = neg n).\nintro.\napply H; symmetry  in |- *; apply succ_pred_pos_pred_pos.\n(* pos n *)\nintro.\ncut (neg n = pos n).\nintro.\napply H; symmetry  in |- *; apply succ_pred_pos_pred.\n(* pos n *)\nintro.\ncut (neg n = pos n).\nintro.\napply H; symmetry  in |- *; apply succ_pred_pos.\n(* pos n *)\nintro.\ncut (neg n = neg n).\nintro.\napply H.\napply H; symmetry  in |- *; apply succ_pred_pos.\n(* pos n *)\nintro.\ncut (neg n = pos n).\nintro.\napply H; symmetry  in |- *; apply succ_pred_Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivityQed."
                ]
            }
        ],
        "UnifySL": [
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "port Logic.MinimunLogic.ProofTheory.Minimun.\nRequire Import Logic.MinimunLogic.ProofTheory.RewriteClass.\nRequire Import Logic.PropositionalLogic.ProofTheory.Intuitionistic.\nRequire Import Logic.PropositionalLogic.ProofTheory.DeMorgan.\nRequire Import Logic.PropositionalLogic.ProofTheory.GodelDummett.\nRequire Import Logic.PropositionalLogic.ProofTheory.Classical.\nRequire Import Logic.PropositionalLogic.ProofTheory.RewriteClass.\nRequire Import Logic.SeparationLogic.ProofTheory.SeparationLogic.\nRequire Import Logic.SeparationLogic.ProofTheory.DerivedRules.\nRequire Import Logic.SeparationLogic.ProofTheory.RewriteClass.\nRequire Import Logic.Extensions.ProofTheory.Stable.\n\nLocal Open Scope logic_base.\nLocal Open Scope syntax.\nImport PropositionalLanguageNotation.\nImport SeparationLogicNotation.\n\nClass Corable (L: Language) {minL: MinimunLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\n",
                "context_tokens": 639,
                "proof_start_offset": 2647,
                "proof_end_offset": 2756,
                "proof": "Lemma corable_truep: corable TT.\nProof.\napply (@truep_stable L _ _ Gamma corable corable_pstable); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_truep: corable TT.\nProof. apply (@implp_stable L _ _ Gamma corable_imp) with corable. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@prop_ext _ _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@same_p_stable L _ _ Gamma corable_p). Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@propp_stable L _ _ Gamma corable_imp); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@and_p_stable L _ _ Gamma); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@and_p_stable L _ _ Gamma corable_propp); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_stable L _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@same_p _ _ _ _ Gamma corable_andp); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@extp_stable L _ _ Gamma corable_impp_stable); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@unpp_stable L _ _ Gamma corable_p); auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "unLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 3431,
                "proof_end_offset": 3600,
                "proof": "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\nintros.\nrewrite andp_comm.\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ Gamma corable_sub_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ Gamma); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ _ _ _ _ _ _ _ _ H H0 H1). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ Gamma corable_s abs_wd); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ _ Gamma corable_pi); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4 H5 H6 H7).\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ _ Gamma corable_sub_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@wand_sepcon_comm L _ _ _ _ _ Gamma corable_pstable); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ Gamma corable_sub_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans L _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "ogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\nLemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 3602,
                "proof_end_offset": 3802,
                "proof": "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\nintros.\nrewrite sepcon_comm.\nrewrite (sepcon_comm x z).\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon2; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply (@imp_andp_sepcon_1 L _ _ _ _ _ _ Gamma corable_sepcon_andp1); auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon2; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 737,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd_for_euclid with (b - a).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - a).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_for_euclid with (b - b).\n apply Zis_gcd_Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H; apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H1; split; intros H2.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - b); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - b); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n apply Zis_gcd_for_euclid with (b - a); trivial.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply (H (b - a)).\n apply (H (b - a)).\n apply (H (b - a)).\n apply (H (b - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H (c - a)).\n apply (H c).\n apply (H (c - a)).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (H c).\n apply (Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\ndestruct (gcd_eq_bool a b); intuition.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - b); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - b); trivial.\n intros.\n apply Zis_gcd_for_euclid with (b - a); trivial.\n intros.\n apply Zis_gcd_Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H; apply Zis_gcd_refl; apply H.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H; unfold Zis_gcd in |- *.\n apply Zis_gcd_for_euclid with (a - b); auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\ndestruct d.\ndestruct a.\napply H.\napply H.\napply H0.\napply H1.\napply H2.\napply H2.\napply H1.\napply H2.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n case (Zis_gcd_bool a b d); auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\n intros (H1,H2).\n exists (fun a => b - a).\n apply Zis_gcd_sym; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 742,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case (Z_eq_dec x y); intros; auto with zarith.\n  apply Zneq_bool_true; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case (Z_eq_dec x y); auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z.eq_dec x y); intros H1 H2.\n  subst; intuition.\n  apply Z.eq_refl.\n  apply Z.eq_dec.\n  apply Z.lt_neq_bool_false; auto with zarith.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  applyQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros; rewrite Zneq_bool_true; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case (Z.eq_dec x y); intro H; subst; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  apply Z.eq_dec.\n  applyQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H.\n destruct (Zeq_dec x y); auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Zeq_dec x y); intros H1 H2; subst; auto with zarith.\n  case (Zeq_dec y x); intros H3 H4; subst; auto with zarith.\n  case (Zeq_dec y x); intros H4; subst; auto with zarith.\n  case (Zeq_dec x y); intros H5; subst; auto with zarith.\n  case (Zeq_dec x y); intros H6; subst; auto with zarith.\n  case (Zeq_dec y x); intros H6; subst; auto with zarith.\n  case (Zeq_dec y x); intros H6; subst; auto with zarith.\n  case (Zeq_dec y x); intros H6; subst; auto with zarith.\n  case (Zeq_dec y x); intros H6; subst; auto with zarith.\n  case (Zeq_dec y x); intros H6; subst; auto with zarith.\n  case (Zeq_dec x y); intros H6; subst; auto with zarith.\n  case (Zeq_dec y x); intros H7; subst; auto with zarith.\n  case (ZQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case H; intros.\n apply Zneq_bool_false; auto.\n apply Zneq_bool_false; auto.\n apply Zneq_bool_false; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; case (x?= y); auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros post e H; elim H; intro;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros e' H;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros e' H;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros e' H;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros e' H;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros e' H;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  intros;\n    unfold st; intros;\n    inversion H; clear H; subst; auto.\n  Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros H H.\n  destruct H as [x [H1 H2]].\n  assert (forall x, p x -> p x).\n  intros. eapply H.\n  eauto.\n  eauto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p; split; intros.\n  apply H0.\n  apply H0.\n  apply H1.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hereditary; intros.\n  split.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; split; intros H;\n  destruct H as [e' H'].\n  destruct (H0 _ H') as [e'' [H2 H4]].\n  subst e'' H1.\n  auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  split; simpl; intros.\n  destruct H; subst; auto.\n  destruct H; subst; auto.\n  destruct H; subst; auto.\n  destruct H; subst; auto.\n  destruct H; subst; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p.\n  destruct H.\n  eapply H; eauto.\n  destruct H0.\n  eapply H; eauto.\n  eapply H; eauto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros p post e H;\n  unfold hereditary; intros; unfold hereditary; intros;\n    inversion H; subst; simpl; auto.\n  destruct p as [p0 e0].\n  destruct p0 as [p1 e1].\n  destruct p0 as [p2 e2].\n  destruct p0 as [p3 e3].\n  destruct H as [p4 e5].\n  destruct H as [p5 e6].\n  destruct H as [p6 e7].\n  destruct H as [p7 e8].\n  destruct H as [p6 e9].\n  destruct H as [p8 e9].\n  destruct H as [p6 e9].\n  destruct H as [p8 e9].\n  destruct H as [p8 e9].\n  destruct H as [p11 e11].\n  destruct H as [p11 e12].\n  destruct H as [p11 e12].\n  destruct H as [p11 e12].\n  destruct H as [p12 e13].\n  destruct H as [p11 e12].\n  destruct H as [p13 e23].\n  destruct H as [p11 e13].\n  destruct H as [p11 e12].\n  destructQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros pre p post e H;\n  spec H; repeat intro; subst;\n  destruct H as [v [H1 H2]].\n  destruct H as [v' [H1 H2]].\n  destruct H as [v' [H1 H2]].\n  destruct H as [v' [H3 H4]].\n  destruct H4 as [v' [H4 H5]].\n  destruct H5 as [v' [H5 H6]].\n  destruct H6 as [v' [H5 H6]].\n  destruct H6 as [v' [H5 H6]].\n  destruct H7 as [v' [H8 H8]].\n  destruct H8 as [v' [H9 H11]].\n  destruct H11 as [v' [H11 H12]].\n  destruct H12 as [v' [H12 H13]].\n  destruct H12 as [v' [H12 H13]].\n  destruct H13 as [v'' [H13 H14]].\n  destruct H13 as [v''' [H13 H14]].\n  destruct H14 as [v'' [H14 H15]].\n  destruct H15 as [v'' [H15 H15]].\n  destruct HQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hereditary; intros.\n  destruct H as [p H | p' H];\n    destruct H as [p' H'].\n  destruct H' as [p'' H'].\n  destruct H' as [p'' H'].\n  destruct H' as [p'' H'].\n  destruct H' as [p'' H'].\n  destruct H' as [p'' H'].\n  destruct H' as [p'' H']].\n  destruct H' as [p'' H''].\n  destruct H' as [p'' H''].\n  destruct H'' as [p'' H''].\n  destruct H'' as [p'' H''].\n  destruct H'' as [p'' H''].\n  destruct H'' as [p'' H''].\n  destruct H'' as [p'' H''].\n  destruct H'' as [p'' H''].\n  destruct H''.\n  destruct H'' as [p'' H''].\n  destruct H''.\n  destruct H''.\n  destruct H'' as [p'' H''].\n  destruct H''.\n  destruct H'' as [p'' H''].\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; split; intros H1 H2.\napply H1.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold post; intros.\n destruct H as (p & q & s & H & H1 & H2 & H3).\nassert (forall x, p x -> p x).\n intros.\n destruct H as (p & q & H1 & H3 & H4 & H5 & H6 & H7 & H8 & H9 & H10 & H11 & H10 & H11 & H12 & H12 & H13 & H14 & H15 & H15 & H15 & H15 & H15 & H16 & H16 & H17 & H17 & H17 & H17 & H17 & H17 & H17 & H17 & H17 & H18 & H18 & H18 & H19 & H18 & H18 & H19 & H19 & H19 & H19 & H20 & H20 & H21 & H21 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 & H22 &Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct H as [st p].\ninversion H0.\n(* - case [Icall] *)\nintros.\nassert (forall v, pre v).\nintros v H.\napply (H0 v).\napply (H0 v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H v).\napply (H vQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply hoare_wp; auto with hoare;\n intros; split; intros.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply H; unfold hereditary; auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply H; split; intros.\n  apply H; auto.\nQed."
                ]
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 322,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\ncase n; simpl; auto with arith.\nintros; elim (mult_comm n m); auto with arith.\nintros n0 H; elim (mult_comm m n0); auto with arith.\nintros n0 H; elim H; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; elim H; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n m H; elim H; intros m H0; elim H0; intros m H1; elim H1;\n intros m H2; elim H2; intros m H3; elim H3;\n auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; elim H; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m; case m; simpl in |- *; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\ngeneralize (le_gt_cases m n); intro H'.\nrewrite <- H'; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\ncase (le_or_lt 0 m).\nintros H1 H2.\napply lt_le_trans with (n - m); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - n); auto with arith.\nintros H1 H2.\napply le_trans with (m - nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m; elim m; simpl in |- *.\nintros n m; elim m; simpl in |- *.\nintros n0 H1; elim H1; simpl in |- *.\nintros n1 H2; elim H1; simpl in |- *.\nintros n1 H2; elim H2; simpl in |- *.\nintros n2 H3; elim H3; simpl in |- *.\nintros n2 H3; elim H3; simpl in |- *.\nintros n3 H4; elim H4; simpl in |- *.\nintros n3 H4; elim H4; simpl in |- *.\nintros n4 H5; elim H4; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4 H5; elim H5; simpl in |- *.\nintros n4Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m; apply lt_le_trans with m; auto with arith.\nintros n0 m1; apply le_trans with m1; auto with arith.\nintros m1; apply le_n_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 414,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply le_plus_r.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply le_S_n; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n1 Hrec; elim H1; auto with arith.\nintros n1 Hrec; elim H1; auto with arith.\nintros n1 Hrec; elim H1; auto with arith.\nintros n1 Hrec; elim H1; auto with arith.\nintros n1 Hrec; elim H1; auto with arith.\nintros n2 Hrec; elim H1; auto with arith.\nintros n2 Hrec; elim H1; auto with arith.\nintros n3 Hrec; elim H2; auto with arith.\nintros n3 Hrec; elim H2; auto with arith.\nintros n3 Hrec; elim H3; auto with arith.\nintros n3 Hrec; elim H3; auto with arith.\nintros n3 Hrec; elim H3; auto with arith.\nintros n3 Hrec; elim H3; auto with arith.\nintros n4 Hrec; elim H3; auto with arith.\nintros n4 Hrec; elim H3; auto with arith.\nintros n4 Hrec; elim H3; auto with arith.\nintros n4 Hrec; elim H3; auto with arith.Qed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply le_0_n; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto.\nintros m H1; apply Rec; apply le_plus_r; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply le_n_Sn; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply le_O_n; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply le_S_n; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 439,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0; elim H0; auto with arith.\nintros n H1; apply Rec; apply le_S_n; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; apply le_minus; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H1 H2; elim H1; simpl in |- *; auto.\nintros n H2; elim H2; simpl in |- *; auto.\nintros n H1 H2; elim H2; simpl in |- *; auto.\nintros n H2; elim H2; simpl in |- *; auto.\nintros n H1 H2; elim H2; simpl in |- *; auto.\nintros n H1 H2; elim H2; simpl in |- *; auto.\nintros n H1 H2; elim H2; simpl in |- *; auto.\nintros n H1 H2; elim H2; simpl in |- *; auto.\nintros n H1 H2; elim H1; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c; elim b; simpl in |- *; auto.\nintros n H1 b; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H2; case b; simpl in |- *; auto.\nintros n2 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |- *; auto.\nintros n3 H2; case b; simpl in |-Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H1 H2; case a; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0; case b; simpl in |- *; auto.\nintros n H1; case b; simpl in |- *; auto.\nintros n H1; case b; simpl in |- *; auto.\nintros n H1; case b; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H1 H2; case a; simpl in |- *; auto.\nintros n H1 H2; case n; simpl in |- *; auto.\nintros n H1 H2; case n; simpl in |- *; auto.\nintros n H1 H2; case n; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H H0 H1 H2; case a; simpl in |- *; auto.\nintros n H H H1 H2; case a; simpl in |- *; auto.\nintros n H H H1 H2; case a; simpl in |- *; auto.\nintros n H H H1 H2; case a; simpl in |- *; auto.\nintros m H H H H0 H2; case a; simpl in |- *; auto.\nintros m1 H H H1 H2 H2; case a; simpl in |- *; auto.\nintros m1 H H H H0 H2; case a; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H1 H2.\napply le_minus_n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 524,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_r; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite plus_comm; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\napply plus_minus; auto with arith.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 593,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b.\n  destruct b as [b|b].\n  - left; auto with arith.\n  - right; auto with arith.\n  - right; auto with arith.\n  - right; auto with arith.\n  - right; auto with arith.\n  - right; auto with arith.\n  - right; auto with arith.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intro a; elim a; auto.\n  Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b.\ncase a; case b; simpl; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b.\n  case b; case a; case a; case b; simpl in |- *; auto.\n  case b; case b; case b; simpl in |- *; auto.\n  case b; case b; simpl in |- *; auto.\n  Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  decide equality.\n  decide equality.\n  decide equality.\n  decide equality.\n  decide equality.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intro a.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_bool_dec a a); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_bool_dec a a0); intros; auto.\n  case (eq_Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof using eq_bool_dec.\nLtac case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b);\nmatch goal with\n| |- context[if?a then _ else _ ] => case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b);\nend.\n\nTheorem eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof using eq_bool_dec.\nintros; case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b); case_eq (a = b);\nmatch goal with\n| |- context[if?a then _ else _ ] => case_eq (a = b);Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b.\ncase_eq (bool_dec a b); intros H1; auto.\nright; right; right; reflexivity.\nright; right; right; reflexivity.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = a); intro H; auto.\n  case_eq (b = b); intro H; auto.\n  case_eq (b = b); intro H; autoDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b H.\n  case (eq_bool_dec a b); intros H; auto.\n  case (eq_bool_dec a b); intros H; auto.\n  left; apply H; auto.\n  left; apply H; auto.\n  right; apply H; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b H.\ncase a; case b; simpl in |- *; auto.\nintros H; case H; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  induction a; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case b; simpl in |- *; auto.\n  case bQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b H.\ncase a; case b; simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool b b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.\nintros H; case (le_bool a b); simpl in |- *; auto.Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros H1 H2; case (le_bool a b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool b b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool b b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool b b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool b b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool a b); auto.\nintros H1; case (le_bool b b); auto.\nintros H1; case (le_Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  induction a; simpl in |- *; auto.\n  intros a' b' H1 H2.\n  case a'; case b'; simpl in |- *; auto.\n  intros a' b' H1 H2.\n  case a'; case a'; case b'; simpl in |- *; auto.\n  intros a' b' H1.\n  case a'; case b'; simpl in |- *; auto.\n  intros a' b' H1 H2.\n  case a'; simpl in |- *; auto.\n  intros a' b' H1 H2.\n  case a'; case b'; simpl in |- *; auto.\n  intros H1 H2.\n  case a'; simpl in |- *; auto.\n  intros a' b' H1 H2.\n  case a'; simpl in |- *; auto.\n  intros a' b' H1.\n  case b'; simpl in |- *; auto.\n  intros H1 H2.\n  case a'; simpl in |- *; auto.\n  intros H1 H2.\n  case a'; simpl in |- *; auto.\n  intros H1 H2.\n  case a'; simpl in |- *; auto.\n  intros H1 H2.\n  case a'; simpl in |- *; auto.Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case a; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n H b H b; case b; simpl in |- *.\nintros n0 H b0 H0 H1; apply le_bool_correct1; auto.\nintros n H b0 H1 H2; case b; simpl in |- *.\nintros n0 H1 b1 H2; apply le_bool_correct1; auto.\nintros n0 H1 b1 H2; case b1; simpl in |- *.\nintros n0 H1 b1 H2; case b1; simpl in |- *.\nintros n1 H1 b1 H2; case b1; simpl in |- *.\nintros n1 H1 b2 H2; case b1; simpl in |- *.\nintros n1 H2 b2 H3; case b1; simpl in |- *.\nintros n1 H2 b2 H3; case b1; simpl in |- *.\nintros n2 H3 b3; case b1; simpl in |- *.\nintros n2 H3; case b2; simpl in |- *.\nintros n3 H4; case b3; simpl in |- *.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; elim b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *.\nintros n1 H1; case b; simpl in |- *.\nintros n1 H1; case b; simpl in |- *.\nintros n1 H1; case b; simpl in |- *.\nintros n1 H1; case b; simpl in |- *.\nintros n1 H1; case b; simpl in |- *.\nintros n1 H1; case b1; simpl in |- *.\nintros n1 H1; case b1; simpl in |- *.\nintros n2 H2; case b1; simpl in |- *.\nintros n2 H2; case b1; simpl in |- *.\nintros n2 H2; case b1; simpl in |- *.\nintros n2 H3; case b1; simpl in |- *.\nintros n3 H3; case b1; simpl in |- *.\nintros n3 H3; case b1; simpl in |- *.\nintros n3 H4; case b3; simpl in |- *.\nintrosQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b0 H0 b1 H1; case b1; simpl in |- *; auto.\nintros n1 H b1 H1 b1 H2 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H1 b2 H2; case b1; simpl in |- *; auto.\nintros n1 H1 b1 H2 b2 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H1 b2 H2 H3; case b1; simpl in |- *; auto.\nintros n1 H1 b2 H2 H3; case b1; simpl in |- *; auto.\nintros n1 H1 b2 H2 H3; case b1; simpl in |- *; auto.\nintros n1 H1 b2 H2 H3; case b1; simpl in |- *; auto.\nintros n1 H1 b2 H2; caseQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H b0; case b0; simpl in |- *; auto.\nintros n0 H0 b1; case b0; simpl in |- *.\nintros n1 H0 b1; case b1; simpl in |- *.\nintros n2 H1 b2; case b2; simpl in |- *.\nintros n3 H1 b3; case b3; simpl in |- *.\nintros n3 H1 b4; case b4; simpl in |- *.\nintros n4 H1 b4; case b5; simpl in |- *.\nintros n4 H1 b5; case b5; simpl in |- *.\nintros n5 H2 b5; case b5; simpl in |- *.\nintros n5 H2 b6; case b5; simpl in |- *.\nintros n6 H3 b4; case b5; simpl in |- *.\nintros n5 H3 b5; case b5; simpl in |- *.\nintros n6 H3 b6 H4; case b5; simpl in |- *.\nintros n6 H3 b5; case b6; simplQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n0 H1; apply le_bool_correct1; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H1 H2; case b; simpl in |- *; auto.\nintros n1 H1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H1 H2; case b; simpl in |- *; auto.\nintros n1 H1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; elim H; auto.\nintros n H0 b H0.\napply le_bool_correct1; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b0 H0; case b0; simpl in |- *; auto.\nintros n0 H b0 H1; case b0; simpl in |- *; auto.\nintros n0 H b0 H1; case b0; simpl in |- *; auto.\nintros n1 H b1 H1; case b0; simpl in |- *; auto.\nintros n1 H b1 H1; case b0; simpl in |- *; auto.\nintros n1 H b1 H1 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H1 H1; case b1; simpl in |- *; auto.\nintros n1 H b1 H1; case b1; simpl in |- *; auto.\nintros n1 H b1 H1 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H1; case b1; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H H0.\ncase b; simpl in |- *; auto.\nintros n0 H b0 H1.\ncase b0; simpl in |- *.\nintros H1; inversion H1.\nintros n1 H b0 H2; case b0; simpl in |- *.\nintros n1 H2; case b0; simpl in |- *.\nintros H1; inversion H2.\nintros n1 H2; case b0; simpl in |- *.\nintros n2 H2; case b0; simpl in |- *.\nintros n2 H3; case b0; simpl in |- *.\nintros H3; inversion H3.\nintros n3 H4; case b0; simpl in |- *.\nintros n3 H4; case b0; simpl in |- *.\nintros n3 H4; case b0; simpl in |- *.\nintros n4 H4; case b0; simpl in |- *.\nintros H5; inversion H5.\nintros n4 H5; case b0; simpl in |- *.\nintros n4 H5; case b0; simpl in |- *.\nintros n4 H5; case b0;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; case a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H b; elim b; simpl in |- *; auto.\nintros n0 H b0 H b1 H0.\ncase b; simpl in |- *; auto.\nintros n1 H b1 b2 H0; case b1; simpl in |- *; auto.\nintros n1 H b2 H0 b2 H0.\ncase b1; simpl in |- *; auto.\nintros n1 H b2 H b2 H0 H1 H2.\ncase b1; simpl in |- *; auto.\nintros n1 H b2 H0 b3 H0.\ncase b1; simpl in |- *; auto.\nintros n1 H b2 H0 b3 H0.\ncase b1; simpl in |- *; auto.\nintros n1 H b2 H0 b3 H0.\ncase b1; simpl in |- *; auto.\nintros n2 H b3 H0.\ncase b1; simpl in |- *; auto.\nintros n2 H b3 H0 b4 H0.\ncase b1; simpl in |- *; auto.\nintros n3 H b4 H0.\ncase b1; simpl inQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; elim b; simpl in |- *; auto.\nintros n0 H b0 H1; case b; simpl in |- *; auto.\nintros n0 H b0 H1; case b; simpl in |- *; auto.\nintros n1 H b0 H1; case b; simpl in |- *; auto.\nintros n0 H b0 H1; case b0; simpl in |- *; auto.\nintros n1 H b0 H1; case b0; simpl in |- *; auto.\nintros n1 H b1 H1; case b0; simpl in |- *; auto.\nintros n1 H b1 H1; case b0; simpl in |- *; auto.\nintros n1 H b1 H1 H1; case b1; simpl in |- *; auto.\nintros n1 H b1 H1; case b1; simpl in |- *; auto.\nintros n1 H1 b1 H1; case b1; simpl in |- *; auto.\nintros n1 H1 b1 H1; case b1; simpl in |- *; auto.\nintros n1 H1 b1 H1; case b1; simplQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H b0; case b; simpl in |- *; auto.\nintros n0 H b0 H b1 H2; case b; simpl in |- *; auto.\nintros n0 H b1 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H1 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H2; case b1; simpl in |- *; auto.\nintros n1 H2 b2 H2; case b1; simpl in |- *; auto.\nintros n1 H2 b2 H3; case b1; simpl in |- *; auto.\nintros n1 H2 b2; case b1; simpl in |- *; auto.\nintros n1 H2 bQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; elim b; simpl in |- *; auto.\nintros n H b H0 b0 H1 H2; apply le_bool_correct1; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H b; case a; simpl in |- *; auto.\nintros n H b H0; case b; simpl in |- *; auto.\nintros n0 H b0 H b0; case b; simpl in |- *; auto.\nintros n0 H b0 H b0 H1 b1 H2; case b; simpl in |- *; auto.\nintros n0 H b0 H b1 H2; case b0; simpl in |- *; auto.\nintros n0 H b0 H2; case b0; simpl in |- *; auto.\nintros n0 H1 b1 H2; case b0; simpl in |- *; auto.\nintros n0 H b1 H2; case b0; simpl in |- *; auto.\nintros n0 H2 b1 H2; case b0; simpl in |- *; auto.\nintros n0 H2 b1 H2; case b0; simpl in |- *; auto.\nintros n0 H2 b1 H2; case b0; simpl in |- *; auto.\nintros n0 H2 b1 H2; case b0; simpl in |- *; auto.\nintros n0 HQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b0; case b0; simpl in |- *; auto.\nintros n1 H b1 H b1; case b1; simpl in |- *; auto.\nintros n1 H b1; case b1; simpl in |- *; auto.\nintros n1 H b1; case b1; simpl in |- *; auto.\nintros n1 H b1; case b1; simpl in |- *; auto.\nintros n1 H b1 H b1; case b1; simpl in |- *; auto.\nintros n1 H b1 H b2; case b1; simpl in |- *; auto.\nintros n1 H b1; case b1; simpl in |- *; auto.\nintros n1 H b1 H b2; case b1; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; elim a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; elim a; simpl in |- *; auto.\nintros n0 H b0 H b0 H0; case b0; simpl in |- *; auto.\nintros n0 H b0 H1 b0 H2; case b0; simpl in |- *; auto.\nintros n0 H b0 H1 b1 H2; case b0; simpl in |- *; auto.\nintros n1 H b0 H2; case b0; simpl in |- *; auto.\nintros n1 H b1 H2; case b0; simpl in |- *; auto.\nintros n1 H b1 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H2; case b1; simpl in |- *; auto.\nintros n1 H b1 H2; case b1; simpl in |- *; auto.\nintros n1 H2 H1 b2 H2; case b1; simpl in |- *; auto.\nintros n1 H1 b2 H2; case b1; simpl in |- *; auto.\nintros n1 H2 H2; case b1; simpl in |- *; auto.\nintros nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "Proof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 736,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros; case H; auto; intros l2 (l3, Hl); exists l3;\n simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros l2 H1 H2.\nrewrite <- H1; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2Qed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.\nintros; case H.Qed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros H; case H; auto.\nintros H; case H.\nintros H; case H.\nintros H; case H; auto.\nintros H; case H.\nintros H; case H.\nintros; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros; case H.\nintros H; case H.\nintros; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros H; case H.\nintros; case H.\nintros; case H.\nintros H; case H.\nintros H; caseQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2 H1 H2; rewrite H1; auto.\nintros l2 H1 H2; case H1; auto; intros l2 H2; apply H1; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros H; case H; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros l2 l2 H a0 l2 H1 a1 H2.\nrewrite <- H1; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros a1 l2 H1 H2.\nrewrite <- (H1 a1 l2); simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros; case H; auto; intros l2 (l3, Hl); exists l3;\n simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 731,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3; elim l1; simpl in |- *; auto.\nintros l1 l2 H [H1| H1]; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H1 H2; rewrite app_ass; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 488,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros n ln t l.\n  induction t as [| t l IH]; simpl.\n  tauto.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.\n  inversion_clear IH; subst.Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  induction n; destruct l; simpl; intros.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct a0; simpl in *.\n  destruct a1; simpl in *.\n  destruct a0; simpl in *.\n  destruct H; simpl in *.\n  destruct H.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H; simpl in *.\n  destruct H;Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n.\nunfold height_pred in *.\ndestruct t as [| n l].\nsimpl in *.\ndestruct t as [| t].\nsimpl in *.\nassert (H : S (S n) = (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S n) + (S nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\ninduction n; intros.\ninversion H.\ninversion H.\ndestruct l.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl in *.\ninversion H.\ndestruct l.\nsimpl inQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l.\ninduction n.\nintros.\nsimpl.\napply IHn.\nauto.\nintros.\nsimpl.\napply IHn.\nauto.\nintros.\nsimpl.\napply IHn.\nauto.\nintros.\nsimpl.\napply IHn.\nauto.\nintros.\nsimpl.\napply IHn.\nauto.\nintros.\nsimpl.\napply IHn.\nauto.\nintros.\nsimpl.\napply IHn.\nauto.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l.\nunfold height_pred in *.\ndestruct (le_dec (S n) (S (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t' t))));\n    [ | assert (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t (max t)))));\n    [ rewrite max_l | rewrite max_l];\n      repeat rewrite max_l; repeat rewrite max_r; repeat rewrite max_r; repeat rewrite max_l;\n          repeat rewrite max_r; repeat rewrite max_r; repeat rewrite max_r; \n          repeat rewrite max_r; repeat rewrite max_r;Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l.\nassert (H := length_pred_inf n ln).\nassert (H := length_pred_inf n ln).\nassert (H := length_pred_inf n ln).\nassert (H' := length_pred_inf n ln).\nassert (H' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_inf n ln).\nassert (H'' := length_pred_infQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros nln t; induction t.\nintros.\nrewrite list_length_zero in H.\nrewrite app_length in H.\nsimpl in H.\nrewrite app_length_tail in H.\nrewrite app_length in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimpl in H.\nrewrite <- app_length_tail in H.\nsimplQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n; induction n; intros.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros.\nassert (forall n : nat, n <> 0 -> n <> 0 -> 0 < n) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> 0 < n) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> n <> 0) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> n <> 0) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> 0 < n) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> 0 < n) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> n <> 0) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0 -> 0 < n) by (intro; omega).\nassert (forall n : nat, n <> 0 -> n <> 0) by (intro;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 533,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros a b H; elim H; simpl in |- *; auto.\nintros a b H; elim H; simpl in |- *; auto.\nintros a b H; elim H; simpl in |- *; auto.\nintros a b H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using lt_wf_ind_dec.\nintros n ln H; elim H; simpl in |- *; auto.\nintros n H; elim H; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 594,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nintros nln t l; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln H; elim H; simpl in |- *; auto.\nintros n1 ln H; elim H; simpl in |- *; auto.\nintros n2 ln H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n1 ln H; elim H; simpl in |- *; auto.\nintros n2 ln H; elim H; simpl in |- *; auto.\nintros n3 ln H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 244,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H' H'0.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'.\napply H'.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H' H'0; elim H'0; intros H'1 H'2; clear H'0.\nelim H'1; intros H'3 H'4; clear H'1.\nelim H'2; intros H'5 H'6; clear H'2.\nelim H'3; intros H'6 H'7; clear H'3.\nexists (a * b); split; [ auto with zfc | split; auto with zfc ].\n\napply\n (H'5 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) _ _ (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))))) _ _ _ H'1)).\napply\n (H'5 (S (S (S (S (S (S (S (S (Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'; elim H'.\nauto with arith.\nintros H'0; elim H'0.\nauto with arith.\nintros H'1; elim H'1; auto with arith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; red in |- *; intros H; discriminate H.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'.\ncut (a -> ~ b).\nauto.\ncut (a -> ~ b).\nauto.\ncut (a -> ~ b).\nauto.\ncut (a -> ~ b).\nauto.\ncut (a -> ~ b).\nauto.\ncut (a -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).\nauto.\ncut (b -> ~ b).Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H' H'0; try assumption.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\napply H'.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 277,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H'; red in |- *.\nintros H'0; elim H'0; intros H'1 H'2; clear H'0.\nintros H'1; elim H'1; intros H'2 H'3; clear H'1.\nintros H'1; elim H'1; intros H'3 H'4; clear H'1.\nintros H'1; elim H'1; intros H'4 H'5; clear H'1.\nintros H'1; elim H'1; intros H'5 H'6; clear H'1.\nintros H'1; elim H'1; intros H'5 H'6; clear H'1.\nintros H'1; elim H'1; intros H'5 H'6; clear H'1.\nintros H'1; elim H'1; intros H'6 H'7; clear H'1.\nintros H'1; elim H'1; intros H'7 H'8; clear H'1.\nintros H'1; elim H'1; intros H'7 H'8; clear H'1.\nintros HQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H'.\nelim H' as (b, (H', H')); auto.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H; elim H; auto.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H H0.\napply H; auto with *.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H H0.\nrewrite H0.\nrewrite H0.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H; apply H.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H H'0.\napply H'0.\napply H'.\napply H'.\napply H'.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H'; elim H'.\nauto with arith.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H.\napply H.\napply H.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 305,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintros a H'; elim H'; auto.\nQed."
                ]
            }
        ],
        "PolTac": [
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\nTheorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n\n",
                "context_tokens": 668,
                "proof_start_offset": 1675,
                "proof_end_offset": 2086,
                "proof": "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 < nat_of_P p1)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate).\nintros m1 n1 m2 H; case (le_or_lt m1 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt m1 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt n1 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt n2 m1); intros; auto.\nintros m1 m2 H; case (le_or_lt m1 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt m2 m1); intros; auto.\nintros m1 m2 H; case (le_or_lt n1 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt n2 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt m1 m2); intros; auto.\nintros m1 m2 H; case (le_or_lt n2Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros; Contradict H.\nintros n H; Contradict H.\nintros n H; Contradict H.\nintros n H; Contradict H.\nintros n1 n2 H; Contradict H.\nintros n1 n2 H1.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H0; case (N.ge_ge n m); auto with arith.\nintros H1 H2; rewrite <- (Nat2N.id (S m)); auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H0 H1 H2.\ncase (le_or_lt (N.to_nat m) (N.to_nat m)) (N.to_nat m)); auto.\nintros H1 H2; inversion H2.\nintros n1 m1 H1 H2; case (le_or_lt (N.to_nat m1) (N.to_nat m1)); auto.\nintros H1 H2; inversion H1.\nintros m1 m2 H H2; case (le_or_lt (N.to_nat m1) (N.to_nat m2)); auto.\nintros H3 H4; inversion H4.\nintros m1 m2 H H4; case (le_or_lt (N.to_nat m1) (N.to_nat m1)); auto.\nintros H4; inversion H4.\nintros m1 m2 H H4; case (le_or_lt (N.to_nat m2) (N.to_nat m2)); auto.\nintros H5; inversion H5.\nintros m1 m2 H H5; caseQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H1 H2; case (le_or_lt m n); auto with arith.\nintros m1 m2 H2; case (le_or_lt m n); auto with arith.\nintros m1 m2 H1 H2.\ncase (le_or_lt m n); auto with arith.\nintros H1 H2; rewrite <- (Nat2N.id m1); rewrite <- (Nat2N.id m2); apply nat_of_P_lt_rev.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H0.\napply N.ge_le_rev; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate).\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_lt m1 m2); auto with arith.\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_lt n m2); auto with arith.\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_lt n m2); auto with arith.\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_lt n m1); auto with arith.\nintros m1 m2; case (le_or_ltQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros.\ncase (N.le_gt_dec n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n1 m1 H2; case (le_or_lt n m1); auto with arith.\nintros n1 m1 H1 H2; case (le_or_lt n1 m1); auto with arith.\nintros m1 H1 H2; case (le_or_lt n1 m1); auto with arith.\nintros n2 m2 H H1 H2; case (le_or_lt n2 m2); auto with arith.\nintros m1 H1 H2; case (le_or_lt n1 m2); auto with arith.\nintros m1 H1 H2; case (le_or_lt n2 m1); auto with arith.\nintros m2 H1 H2; case (le_or_lt n1 m2); auto with arith.\nintros m1 H1 H2; case (le_or_lt n2 m1); auto with arith.\nintros m2 H2 H1 H2Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H0 H1.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (m := N.to_nat m); auto with arith.\napply le_trans with (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).\nintros x y z H; rewrite H; auto.\nQed.\n\nTheorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).\nintros x y z H1 H2; red; apply Rge_trans with z; auto.\nQed.\n\n(* For RGroundTac *)\n\n\n",
                "context_tokens": 746,
                "proof_start_offset": 32895,
                "proof_end_offset": 33883,
                "proof": "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; auto.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1);ring.\nintros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; apply Z2R_le; rewrite Z2R_IZR; auto with real.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; unfold Z2R; simpl; auto with real.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; simpl; auto with zarith.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintro p; unfold Z.succ, Z.succ, Z.succ, Z.succ; simpl; ring.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros; unfold Z2R; rewrite <- Z2R_IZR; auto with real.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le;\n apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le;\n apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le;\n apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le;\n apply Z2R_le; apply Z2R_le; apply Z2R_lt; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le;\n apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_le; apply Z2R_leQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; unfold Z2R; simpl; rewrite <- (Z2R_IZR p); auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros; apply Z2R_correct; rewrite Z2R_correct; auto with real.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; red in |- *; intros.\napply (Z2R_le_succ_r (Zpos p) (Zpos p)); auto with zarith.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; unfold Z2R; apply Z2R_le_cancel.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\n",
                "context_tokens": 6,
                "proof_start_offset": 24,
                "proof_end_offset": 107,
                "proof": "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y; induct x; intros.\nrewrite (ars_test1 x y); auto with relations.\nrewrite (ars_test1 y y); auto with relations.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y; unfold pols, pols, pred, pols; simpl.\nrewrite pred_plus, pred_plus, pred_plus, pred_plus, pred_plus, pred_plus.\napply pred_monotone; tauto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y; rewrite <- (succ_pred_succ x y); apply pred_lt_compat; auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y.\nunfold pols; rewrite pred_eq_compat.\ndestruct x; destruct y; simpl; intros; trivial.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y.\nunfold pols.\napply pred_ext.\nintros x y.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_Ropp_plus_distr.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napplyQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y; pattern y at 2; apply sub_add_lt_compat; auto with arith.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y.\ndestruct x.\napply (proj_sig_valid_bound x y).\nnow apply poly_sub_monotone_l.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y; apply (ars_test x y); auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\napply (ars_test1 x y Hx Hy).\nrewrite Hy.\napply Rle_trans with (y + y).\nnow apply Rle_trans with y.\nnow apply Rle_trans with y.\nnow apply Rle_trans with y.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y; case_eq (x + y); intros H1 H2.\nrewrite H1 in H1; apply H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 109,
                "proof_end_offset": 188,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (pss_test1 x y H).\napply (pss_test2 x y H).\napply (ps_test2 x y H).\napply (ps_test2 x y H).\napply (ps_test1 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test1 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test1 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y z H).\napply (ps_test2 y zQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (ars_test2 x y).\nnow apply pred_eq_compat.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (ars_test2 x y).\napply (ars_test2 y y).\napply (ars_test2 y y).\napply (ars_test2 y y).\napply (ars_test2 y y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ngeneralize (ars_test x y H).\nrewrite <- (ars_test2 x y H).\nrewrite <- (ars_test2 x y H).\nrewrite <- (ars_test2 x y H).\nrewrite <- (ars_test2 x y H).\nnow apply pred_eq_ext.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x yQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ngeneralize (ars_test2 x y).\nintro.\nrewrite H0 in H.\napply H.\napply H0.\napply H.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply poly_bound_bound_bound_pos.\nrewrite <- (map_map_map_compat _ _ x y).\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply map_ext.\nrewrite <- (map_map_compat _ _ y).\napply mapQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1.\nrewrite <- (mult_comm x y).\napply mult_compat_r.\napply mult_compat_l.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_r.\napply mult_compat_l.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_r.\napply mult_compat_l.\napply mult_compat_l.\napply mult_compat_r.\napply mult_compat_r.\napply mult_compatQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrevert y H.\nrewrite <- (ars_test1 x y).\nnow apply (le_antisymm y).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npred_pos.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 84,
                "proof_start_offset": 191,
                "proof_end_offset": 311,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (proj2_sig x y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj1_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj1_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewrite <- (proj2_sig y).\nrewriteQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test2 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test2 y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (ars_test4 x y).\napply (ars_test3 y).\napply (ars_test3 x y).\napply (ars_test3 x y).\napply (Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ngeneralize (ars_test2 x y).\nintros.\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 y y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 y).\nrewrite <- (ars_test2Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nassert (H: 0 <= x).\napply Rle_lt_trans with (2 * x).\napply Rle_lt_trans with (2 * y).\napply Rle_trans with (2 * x).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 * y).\napply Rle_trans with (2 *Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 y x).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (succ_pred_pred_pred x y).\napply pred_ext; auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrevert x y H.\ninduction H.\nintros.\nrewrite H0.\napply H.\napply H.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 145,
                "proof_start_offset": 314,
                "proof_end_offset": 436,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 yQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ngeneralize (ars_test2 x y z).\nunfold pols.\nintros x y z.\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x yQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (succ_succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite (succ_pred z).\nrewrite <- (succ_pred z).\nrewrite <- (succ_pred z).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrevert x y z.\ninduction z ; intros; simpl in *; omega.\nrewrite H in H0.\napply H0 in H0.\napply H0 in H0.\napply H1 in H0.\napply H0 in H0.\ntauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npred_compat.\nrewrite pred_compat.\nrewrite <- pred_compat.\nrewrite <- (P_correct x y z).\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\napply P_correct.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (ars_test5 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test5 x z y z).\nrewrite <- (ars_test5 x y z).\nrewrite <- (ars_test5 y z y).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test5 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test5 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test5 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_test5 y z).\nrewrite <- (ars_test6 y z).\nrewrite <- (ars_Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (succ_pred (x + y)) at 2.\nrewrite <- (succ_pred (x + y)) at 2.\nrewrite <- (succ_pred (x + y)) at 2.\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (succ_pred (x + y)).\nrewrite <- (Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\napply mult_le_compat.\napply mult_le_compat_r.\napply mult_le_compat_r.\nnow apply mult_le_compat_l.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\napply (ars_test5 x y z).\nnow rewrite <- (ars_test6 x y z).\nnow rewrite <- (ars_test5 x y z).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 208,
                "proof_start_offset": 439,
                "proof_end_offset": 515,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (ars_test2 x y).\napply pols_test1.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pred_ext;auto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (pred_opp_pred x).\nrewrite <- (pred_opp_pred x).\nrewrite <- (pred_opp_pred x).\nrewrite <- (pred_opp_pred y).\nrewrite <- (pred_opp_pred x).\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\napply pred_inj.\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_inj.\nrewrite <- (pred_opp_pred y).\napply pred_injQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply (ars_test2 x y).\napplyars_test1.\napplyars_test2.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npred_pred_zero.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pred_bound_le with (2 * x + y).\napply pred_bound_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_pos_le with (2 * y).\napply pred_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_le with (2 * y).\napply pred_pos with (2 * y).\napply pred_le with (2 * y).\napply pred_pos with (2 * y).\napply pred_le with (2 * y).\napply pred_bound_le with (2 * y).\napply pred_le with (2 * y).\napply pred_pos with (2 * y).\napply pred_le with (2 *Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (ars_test1 x y z).\napplyars_test1...\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pred_ext.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 244,
                "proof_start_offset": 517,
                "proof_end_offset": 613,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply polf_test2.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npred_compat.\napply H.\napply H.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (ars_test1 x y H0).\napply H1.\napply H2.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ndestruct (le_gt_dec x y).\nleft.\napply le_trans with y.\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with y.\napply le_trans with y.\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans withQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npred_compat.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napplyQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npred_compat ; trivial.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ngeneralize (ar2_test2 x y).\nintro.\nrewrite <- (ar2_test2 x y).\nrewrite <- (ar2_test2 x y).\napplyar2_test2_correct...\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrevert x y H0; induction H0; intros.\nrewrite H1 in H0.\ninversion H0.\nrewrite H1 in H0.\ndestruct H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrevert x y H0.\nunfold pred, pred in H0.\nclear H0 H1.\nrevert y H1.\ninduction H0.\nnow apply pred_pos.\nnow apply pred_pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 290,
                "proof_start_offset": 617,
                "proof_end_offset": 735,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (arc x y z H H1).\nintros.\ngeneralize (arc x y z H0 H2).\nclear H1.\nrevert x z.\ninduction n; intros; simpl in *.\nrewrite H1 in H1.\ndestruct H1.\napply H2.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\ncontradict H.\napply Rle_trans with y.\nnow apply (le_trans x y).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradictQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H0 := proj2_sig x y).\napply H0.\napply H1.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert z.\napply (arr_test1 x y z H0 H1).\nintros.\ngeneralize H1.\napply H1.\napply H0.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H0.\nsubst.\nrewrite <- H0.\napply H.\napply H.\napply H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (arz_test2 x y z H0 H1).\napply div_unique with (y + x); auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (succ_pred_pred_pred_pred_pred x y z H0).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y + z).\napply pred_le_trans with (y +Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pred_pos_lt.\napply Rle_trans with (2 * x + y * y).\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_compat.\napply poly_le_Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert x y z H1 H2.\ninduction H1.\nintros.\ndestruct H1.\nrewrite H2.\napply H2.\napply H2.\napply H3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\n",
                "context_tokens": 33,
                "proof_start_offset": 123,
                "proof_end_offset": 285,
                "proof": "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2.\nrewrite (mult_comm n p); auto with arith.\nrewrite mult_comm; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H.\ndestruct (le_gt_cases n m); try order.\napply le_lt_trans with (p * n).\nrewrite <- (mult_comm n p).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite mult_assoc.\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p.\napply le_lt_trans with (n + p); auto with *.\napply (mult_lt_compat_l m n); auto with *.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H1 H2; apply (mult_lt_compat_l n m p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H; elim H; simpl in |- *; auto with arith.\nintros m p H; elim H; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2.\nrewrite (mult_comm n m).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (mult_comm m n).\nrewrite (Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p.\ndestruct p.\nnow apply lt_le_trans with (m * p).\nnow apply (mult_le_compat_l n m p).\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p.\napply plus_le_compat_r; auto with *.\napply lt_le_trans with n; auto with *.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H_gt_0_1 H_gt_0; apply le_trans with (m * p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H; apply lt_le_trans with (p * n); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\n",
                "context_tokens": 98,
                "proof_start_offset": 287,
                "proof_end_offset": 396,
                "proof": "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n m p H; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm m p); apply mult_ge_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1 H2; repeat rewrite (mult_comm p); apply mult_ge_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm m); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1 H2; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm m); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_ge_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\n",
                "context_tokens": 142,
                "proof_start_offset": 398,
                "proof_end_offset": 535,
                "proof": "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; case (le_gt_dec n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1 H2; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; apply (mult_gt_compat_l p m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; case H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; case (le_gt_cases n m); intros H2.\napply plus_le_compat_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 201,
                "proof_start_offset": 537,
                "proof_end_offset": 655,
                "proof": "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; apply le_lt_trans with (p * n); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; apply (mult_gt_compat_l n m p H1).\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; apply le_trans with (m * p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red in |- *; apply mult_gt_compat_r; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red in H1; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; red; apply mult_lt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 250,
                "proof_start_offset": 657,
                "proof_end_offset": 889,
                "proof": "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case n; simpl; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case n; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case n; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case n; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case (mult_gt_compat_l n m); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1 H2; apply (mult_lt_compat_l n m); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\n",
                "context_tokens": 345,
                "proof_start_offset": 892,
                "proof_end_offset": 1010,
                "proof": "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nintros H1; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H1; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\nintros; absurd (p * n > p * m); auto with arith.\napply le_lt_trans with (p * m); auto with arith.\napply le_lt_trans with (p * m); auto with arith.\napply le_lt_trans with (m * p); auto with arith.\napply le_trans with (p * m); auto with arith.\napply le_plus_minus.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nintros m p H; case (le_or_lt m n); auto with arith.\nintros m p H; case (le_or_lt m p); auto with arith.\nintros m p H; case (le_or_lt n m); auto with arith.\nintros H0; case (le_or_lt n m); auto with arith.\nintros H1; case (le_or_lt n m); auto with arith.\nintros H0; case (le_or_lt n m); auto with arith.\nintros m p H H0; case (le_or_lt n m); auto with arith.\nintros m p H H0; case (le_or_lt n m); auto with arith.\nintros m p H0; case (le_or_lt n m); auto with arith.\nintros m p H0; case (le_or_lt m n); auto with arith.\nintros m p H0; case (le_or_lt p m); auto with arith.\nintros m p H0; case (le_Qed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H1; case (le_or_lt p n); auto with arith.\nintros m H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H1 H2; case H1; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 394,
                "proof_start_offset": 1012,
                "proof_end_offset": 1197,
                "proof": "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case m; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H1; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\n",
                "context_tokens": 470,
                "proof_start_offset": 1199,
                "proof_end_offset": 1445,
                "proof": "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (n * m > p * n); auto with arith.\napply plus_le_compat_l; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (n * m > p * m); auto with arith.\napply lt_not_le; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n > p * m); auto with arith.\napply mult_le_compat_l; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply le_not_lt; apply mult_lt_compat_l; auto with arith.\napply mult_le_compat_r; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n > p * m); auto with arith.\napply le_mult_l; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; apply mult_le_compat_l; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\nintros m p H1; case (le_or_lt m n); auto with arith.\nintros m0 H2; case (le_or_lt n m); auto with arith.\nintros m0 H3; case (le_or_lt n m); auto with arith.\nintros H3; absurd (p * m0 < p * m); auto with arith.\napply mult_gt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 569,
                "proof_start_offset": 1447,
                "proof_end_offset": 1704,
                "proof": "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith; intros H3; absurd (p * n > p); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith; intros H3.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n > p * m); auto with arith.\napply le_not_le; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1 H2; case (le_or_lt n m); auto with arith.\nintros H1 H2; absurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 1706,
                "proof_end_offset": 1872,
                "proof": "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1; absurd (0 < a * b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt 0 a); auto with arith; intros H1; absurd (0 < b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt 0 a); auto with arith; intros H1.\nabsurd (0 < a * b); auto with arith.\napply lt_not_le; apply mult_gt_compat_r; auto.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1; absurd (0 < b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (lt_or_lt a b); auto with arith; intros H1; absurd (0 < b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H H0; case (le_or_lt b a); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (lt_or_lt a b); auto with arith; intros H1.\nabsurd (0 < a * b * b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1; case (lt_or_lt 0 a); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H1; case (lt_or_lt a b); auto with arith; intros H2; absurd (0 < a * b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 1874,
                "proof_end_offset": 1996,
                "proof": "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt b 0); auto with arith.\nintros H1 H2; absurd (0 < b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case (le_or_lt b 0); auto with arith.\nintros n H1 H2; absurd (0 < a * b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1; case (le_or_lt a b); auto with arith.\nintros H2; absurd (0 < a * b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (lt_or_lt a b); auto with arith; intros H1; absurd (0 < a * b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt a b); auto with arith; intros H1 H2; absurd (0 < b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt a b); auto with arith.\nintros H1 H2; absurd (0 < a * b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt 0 b); auto with arith; intros H1; absurd (0 < a * b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt a b); auto with arith.\nintros H1 H2; absurd (0 < a); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1.\nabsurd (0 < a); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 1999,
                "proof_end_offset": 2106,
                "proof": "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; red; apply lt_mult_0; auto.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; elim H1; intros H2; absurd (a * b < a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; case (lt_mult_0_l a b); auto with arith; intros H3; absurd (0 < a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case b; simpl; auto with arith.\nintros H H H1; apply lt_mult_0_l; auto.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; apply lt_mult_0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; red; apply lt_mult_0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; elim H1; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; case (le_or_lt a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2108,
                "proof_end_offset": 2250,
                "proof": "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case (lt_mult_rev_0 a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H; elim H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case a; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; red; apply lt_mult_0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; red; apply lt_mult_rev0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case (lt_mult_rev a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; case (lt_mult_rev a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; red; apply lt_mult_rev0_l; auto.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H1; case (lt_or_eq a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2252,
                "proof_end_offset": 2358,
                "proof": "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H0; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H H0; red; apply lt_mult_rev_0; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case a; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < a * b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2360,
                "proof_end_offset": 2503,
                "proof": "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case (lt_mult_rev a b); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case a; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; red; apply lt_mult_rev_0; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; red; apply lt_mult_rev_0_l; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case a; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "Qed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 2505,
                "proof_end_offset": 2590,
                "proof": "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n; case n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; elim H; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case (le_or_lt n 0); auto with arith.\nintros H0; absurd (0 <= 0); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1 H2; case (le_gt_dec n 0); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; elim H; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_compat_l || apply mult_lt_compat_l ||\n              apply mult_ge_compat_l || apply mult_gt_compat_l ||\n              apply lt_mult_0 || apply gt_mult_0); auto with arith.\n\nLtac hyp_nsign_tac H :=\n  match type of H with\n   0 <= _ => clear H\n|?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ <=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_le_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4783,
                "proof_end_offset": 5148,
                "proof": "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros.\ngeneralize (f_equal (fun y => 1 + 1) b c d e); intros.\nexact (f_equal (fun x => 1 + 1) b c d e).\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\npattern a, b, c, e, e, e, f, g, g, h0, h1, h2, h2, h3, h4, h6, h6, h7, h8, h8, h9, h10, h11, h12, h12, h13, h14, h12, h14, h15, h16, h16, h15, h16, h18, h15, h16, h15, h16, h17, h18, h18, h19, h19, h19, h21, h21, h22, h22, h21, h21, h22, h21, h23, h21, h22, h22, h21, h22, h22, h21, h22, h21, h22, h22, h22, h23, h22, h21, h22, h22, h21, h23, h22, h23, h22, h24, h23, h24, h, h22, h22, h23, h22, h23, h22,Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\ncase H; auto.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\nintros.\nintros.\nrewrite (H a b c d e).\nauto.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e He H1 H2.\napply (lem_p_eq_0 _ _ _ _ He H2).\nrewrite He in He.\nassert (e < 0) by (rewrite He in He; apply He; auto).\nclear He; intros; apply He; auto with arith.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\nassert (a * b <= a * b * c * b * b + c * b + c * b + c * b * b + c * b * c).\n intros.\nassert (a * b <= c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * bQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e.\n functional induction (test_test_test a b c d e).\n\n(* Test *)\n\nLemma test_test_test_eq_0 : forall a b c d e, 0 < a -> 0 < b -> 0 < a -> 0 < c -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e -> 0 < e.\nProof.\nintros a b c d e e He He.\nintros.\n(* Test *)\n\nLtac hyp_test_eq :=\n  match goal with\n  | H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ H: context [ HQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e.\ndestruct e.\nreflexivity.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros.\npattern (a * b + c * a * b + c * a) at 1.\nrewrite (plus_0_r a b c d e).\nrewrite (plus_0_r a b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_l b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_l c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_l b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c d e).\nrewrite (plus_0_r b c dQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\napply H; auto.\nrewrite H0; auto.\nrewrite H; auto.\nrewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\nLet hyp_test : forall a b c d e, \n  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H should disappear *)\nhyp_nsign_tac H.\n(* a in H2 should disappear *)\nhyp_nsign_tac H2.\n(* H3 unchanged *)\ntry hyp_nsign_tac H3.\n(* d should disappear *)\nhyp_nsign_tac H4.\n(* Prove it *)\nhyp_nsign_tac H5.\nQed.\n\n\n",
                "context_tokens": 718,
                "proof_start_offset": 5151,
                "proof_end_offset": 5516,
                "proof": "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3.\n(* a = b *)\nassert (H4: a * b > a * b + c * b > a * b + c * b + c * b).\ndestruct H4; try solve [inversion H4].\n(* a = b *)\nassert (H6: a * b > b + c * b > b * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + cQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3.\n(* H3 unchanged *)\ngeneralize (H2 (refl_equal H3)).\n(* a in H3 unchanged *)\ngeneralize (H2 (refl_equal H3)).\n(* a in H3 unchanged *)\nclear H3 unchanged *)\nintros a b c d e H H0 H1 H2 H3 H4.\n(* H3 unchanged *)\ngeneralize (H3 (refl_equal H3)).\n(* a in H3 unchanged *)\nclear H3 unchanged *)\nintros a b c d e H H0 H1 H2 H3.\n(* H3 unchanged *)\ngeneralize (H3 (refl_equal H3)).\n(* a in H3 unchanged *)\ngeneralize (H1 (refl_equal H3)).\n(* a in H3 unchanged *)\nclear H3 unchanged *)\nintros a b c d e H0 H1 H2 H3 H4.\n(* H3 unchanged *)\nassert (H6 := H3 H0 H4).\n(* a in H3 unchanged *)\ngeneralize (H3 H3).\n(* a in H3 unchanged *)\nassert (H6 := H1Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\n(* h is still a b in H2 should be used *)\nelim H2; clear H2.\n(* a in H2 should be used *)\nelim H2; clear H2.\n(* a in H2 should be used *)\nelim H2; clear H2.\n(* a in H2 should be used *)\n(* a in H3 should be used in H3 *)\nelim H3; clear H2.\n(* a in H2 should be used in H3 *)\n(* a in H3 after H3 *)\nelim H3; clear H3.\n(* a in H2 should be used in H3 *)\nelim H3; clear H3.\n(* a in H2 should be used in H3 *)\nrewrite (H2 H3) in H3; clear H3 H3.\n(* a in H3 after H3 after H3 after H3 *)\nelim H3; clear H3.\n(* a in H2 should be used in H3 after H3 after H3 after H3 after H3 after H3 after H3 after H4 *)\n(*Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3 H4.\n(* a in H2 to H3 to H4 to H4 *)\ndestruct (a+b)%Z as [e|e].\n(* a = b => a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H4.\n(* a = b => a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H3 H4.\n(* a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H4.\n(* a = b => a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H3.\n(* a = b => a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H3.\n(* a = b => a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H3.\n(* a = b => a = b *)\nintro H3.\nrewrite H3 in H3;clear H3 H3.\n(* a = b => a = bQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2.\n(* a in H2 should be discover *)\nassert (H3 : 0 <= a * b <= a * b + c * a + b * b < a * b + c * b + c * b < a * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b +Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\n(* a in H2 to H3 but not happen *)\nassert (H1 : a > 0 -> b > a * b) by omega.\n(* a in H2 to H3 but not in H3 but not in H3 but not in H3 but not in H3 but not in H4 but not in H4 but not in H4 but not in H4 but not in H4 but not in H4 but not in H4 but not in H4 but not in H4 but not in H5, H5 but not in H4 but not in H5 but not in H5. *)\n(* H1 to H1 and H2 but not in H4 but not in H5 but not in H5 but not in H5 but not in H5 but not in H5 but not in H5, not in H5 but not in H5 but not in H5 but not in H5 but not in H5.  *)\n(* H1 and H2 are not in H5, or not in H5 but not in H5 but not in H5, not in H5 but notQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2.\n(* a = 0 *)\nassert (H3 : a = 0 /\\ b = 0 /\\ c = 0 /\\ d = 0) by (apply eq_refl; rewrite H1; reflexivity).\n(* a = 0 *)\nassert (H4 : a = 0 /\\ b = 0) by (apply eq_refl; rewrite H1; reflexivity).\n(* a = 0 *)\nassert (H4 : b = 0 /\\ b = 0) by (apply eq_refl; rewrite H2; reflexivity).\n(* a = 0 *)\nassert (H5 : b = 0 \\/ b = 0) by (apply eq_refl; rewrite H3; reflexivity).\n(* a = 0 *)\nassert (H5 : b = 0 /\\ b = 0) by (apply eq_refl; rewrite H3; reflexivity).\n(* a = 0 *)\nassert (H5 : a = 0 /\\ b = 0 /\\ c = 0) by (apply eq_refl; rewrite H3; reflexivity).\n(* a = 0 *)\nassert (H5 : a = 0 /\\ b = 0) by (apply eq_refl; rewrite H3; reflexivity).Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3.\nrewrite H in H1.\nrewrite H in H1.\nrewrite H in H2.\nrewrite H in H2.\nauto.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4.\n(* a =0 *)\nassert (H1 : a = 0 \\/ b = c /\\ b = c /\\ b = c).\ndestruct H1 as [H1|H1]; try solve [contradiction H1];\ntry solve [right; auto].\n(* a =0 *)\nassert (H2 : a = 0 \\/ b = c /\\ b = c).\ndestruct H2 as [H2|H2]; try solve [contradiction H2];\ntry solve [right; auto].\n(* a =0 *)\nassert (H3 : a = 0 \\/ b = c /\\ b = c /\\ b = c /\\ b = c /\\ c = c /\\ c = c).\ndestruct H3 as [H3|H3]; try solve [right; auto].\n(* a =0 *)\nassert (H4 : a = 0 \\/ b = c /\\ c = c /\\ b = c /\\ c = c /\\ c = c).\ndestruct H3 as [H3|H3]; try solve [right; auto].\n(* a =0 *)\nassert (H5 : b = c /\\ cQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3.\n(* a > 0 *)\nassert (H3 := eq_refl_equal _ _ _ H2).\n(* a > 0 *)\nassert (H4 := eq_refl_equal _ _ _ H2).\n(* a > 0 *)\nassert (H5 := eq_refl_equal _ _ _ H0).\n(* a > 0 *)\nassert (H6 := eq_refl_equal _ _ _ H2).\n(* a = 0 *)\nassert (H7 := eq_refl_equal _ _ _ H3).\n(* a > 0 *)\nassert (H6 := eq_refl_equal _ _ H1).\n(* a = 0 *)\nassert (H7 := eq_refl_equal _ _ _ H0).\n(* a > 0 *)\nassert (H7 := eq_refl_equal _ _ _ H2).\n(* a = 0 *)\nassert (H7 := eq_refl_equal _ _ _ H1).\n(* a > 0 *)\nassert (H8 := eq_refl_equal _ _ _ H1).\n(* a > 0 *)\nassert (H8 :=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\n",
                "context_tokens": 329,
                "proof_start_offset": 839,
                "proof_end_offset": 971,
                "proof": "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simplQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros n1 n2; case p; simpl; auto with arith.\nintros n1 n2; case p; simpl; auto with arith.\nintros p1 n2; case p; simpl; auto with arith.\nintros n1 n2; case p; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintros n1 n2; case p1; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintros n1 n2; case p1; simpl; auto with arith.\nintros p1 n2; case p1; simpl; auto with arith.\nintrosQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; try (intros; discriminate).\nintros p; case (le_or_lt m n); auto with arith.\nintros n1 m1; case (le_or_lt n1 m1); auto with arith.\nintros n2 m2; case (le_or_lt n2 m2); auto with arith.\nintros n3 m1; case (le_or_lt n2 m2); auto with arith.\nintros m3; case (le_or_lt n2 m3); auto with arith.\nintros m4; case (le_or_lt n2 m3); auto with arith.\nintros m4; case (le_or_lt n2 m3); auto with arith.\nintros n4 m5; case (le_or_lt n2 m1); auto with arith.\nintros m5; case (le_or_lt n2 m3); auto with arith.\nintros m5; case (le_or_lt n2 m3); auto with arith.\nintros m5; case (le_or_lt n2 m3); auto with arithQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p1; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p1; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.\nintros p1 p2; case p2; unfold N.le; simpl; auto with arith.Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m1 m2 H1; case (le_or_lt n1 m2); auto with arith.\nintros H2; case H1; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_succ_nat_eq_succ; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m2 m2; case (le_or_lt n2 m2); auto with arith.\nintros H1; case (le_or_lt n1 m2); auto with arith.\nintros H1; case (le_or_lt n1 m2); auto with arith.\nintros m3; case (le_or_lt n1 m3); auto with arith.\nintros H1; case (le_or_lt n2 m3); auto with arith.\nintros H1; case (le_or_lt n2 m3); auto with arith.\nintros H1; case H1; auto with arith.\nintros m3; case (le_or_lt n2 m3); auto with arith.\nintros H1; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_nat_eq_succ;Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nintros m1 n1 H2; case (le_or_lt n1 m1); auto with arith.\nintros H2; case (le_or_lt n1 m1); auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintros HQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; try (intros; discriminate).\nintros p; case p; unfold N.le; simpl; tryQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; try (intros; discriminate).\nintros n1 m1; case m1; unfold N.le; simpl; try (intros; discriminate).\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m2; case m2; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.le; simpl; auto with arith.\nintros m1 m2; case m1; unfold NQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros m1 m2 H2; case (le_or_lt n1 m2); auto with arith.\nintros H1; case H1.\napply nat_of_P_lt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_of_succ_nat_eq_succ; auto with arith.\nintros H1; case H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 386,
                "proof_start_offset": 973,
                "proof_end_offset": 1244,
                "proof": "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.lt; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.lt; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.lt; simpl; auto with arith.\nintros H1; case H1; intros H2; case H2; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite <- nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros p; case p; simpl in |- *; auto with arith.\nintros p; case p; simpl in |- *; auto with arith.\nintros p; case p; simpl in |- *; auto with arith.\nintros p1 p1; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2; case p1; simpl in |- *; auto with arith.\nintros p1 p2;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros n1 m1; case m1; unfold N.le; simpl; auto with arith.\nintros H1 H2; case H1; intros H2; case H2.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite <- H2.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply leQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m H; case n; unfold N.le; simpl; auto with arith.\nintros n H1; case (le_or_lt n m); auto with arith.\nintros H2; case (le_or_lt n m); auto with arith.\nintros H3; case (le_or_lt n m); auto with arith.\nintros H3; case H3.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite <- nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nintros H3; case (le_or_lt n m); auto with arith.\nintros H3; case H3.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite <- nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nintros H3; case H3.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite <- nat_of_P_o_P_of_succ_nat_eq_Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros H1; case (le_or_lt n m); auto with arith.\nintros H2; case (le_or_lt n m); auto with arith.\nintros H3; case (le_or_lt n m); auto with arith.\nintros H3; case (le_or_lt n m); auto with arith.\nintros H3; case (le_or_lt n m); auto with arith.\nintros H3; case (le_or_lt m n); auto with arith.\nintros H3; case (le_or_lt n m); auto with arith.\nintros H3; case H3; auto with arith.\nintros H4; case H3; auto with arith.\nintros n1 n2 H1; case (le_or_lt n1 m); auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintros H3; case H3; auto with arith.\nintrosQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m H; apply le_antisym; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros m1 n1 H1; case m1; unfold N.le; simpl; auto with arith.\nintros H2; case (le_or_lt m1 m1); auto with arith.\nintros H3; case H3; auto.\nintros m1 n2 H3; case (le_or_lt m2 m1); auto with arith.\nintros H3; case H3; auto.\nintros m1 n2 H3; case (le_or_lt m1 m2); auto with arith.\nintros H3; case H3; auto.\nintros m1 m2 H3; case (le_or_lt m2 m1); auto with arith.\nintros H3; case H3; auto.\nintros H3; case H3; auto.\nintros H3; case H3; auto.\nintros H3; case H3; auto.\nintros m1 m2 H3; case (le_or_lt m1 m2); auto with arith.\nintros H3; case H3; auto.\nintros m1Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros pQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m H; case (le_or_lt m n); auto with arith.\nintros H1; case H1; auto.\nintros n1 n2 H1; case (le_or_lt n1 m); auto with arith.\nintros H2; case (le_or_lt m n1); auto with arith.\nintros H3; case (le_or_lt n2 m); auto with arith.\nintros H3; case (le_or_lt n1 m); auto with arith.\nintros H3; case H3; auto with arith.\nintros n1 n2 H1 H2; case (le_or_lt n2 m); auto with arith.\nintros H3; case (le_or_lt n2 m); auto with arith.\nintros H3; case H3; auto with arith.\nintros n1 n2 H H1 H2; case (le_or_lt n1 m); auto with arith.\nintros H3; case H3; auto with arith.\nintros n1 n2 H1 H2; case (le_or_lt n2 m); auto with arith.\nintros HQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 m); auto with arith.\nintros H2; case (le_or_lt n1 m); auto with arith.\nintros H3; case (le_or_lt n2 m); auto with arith.\nintros H3; case (le_or_lt n1 m); auto with arith.\nintros H4; case (le_or_lt n2 m); auto with arith.\nintros H4; case (le_or_lt n1 m); auto with arith.\nintros H5; case (le_or_lt n2 m); auto with arith.\nintros H5; case (le_or_lt n1 m); auto with arith.\nintros H5; case (le_or_lt n2 m); auto with arith.\nintros H6; case (le_or_lt n1 m); auto with arith.\nintros H5; case (le_or_lt n2 m); auto with arith.\nintros H6; case (le_or_lt n1 mQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 1246,
                "proof_end_offset": 1540,
                "proof": "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H; inversion H.\nintros n0 H1; case (le_or_lt n0 m); auto with arith.\nintros H2; inversion H2.\nintros H; inversion H1.\nintros H; inversion H.\nintros n1 H1; case (le_or_lt n1 m); auto with arith.\nintros H2; inversion H2.\nintros H2; inversion H1.\nintros n1 H1; case (le_or_lt n1 m); auto with arith.\nintros H2; inversion H2.\nintros H3; inversion H3.\nintros H3; inversion H3.\nintros H3; inversion H4.\nintros H4; inversion H4.\nintros H4; inversion H4.\nintros H5; inversion H4.\nintros H5; inversion H5.\nintros H5; inversion H5.\nintros H5; inversion H5.\nintros H5; inversion H5.\nintros H5; inversion H5.\nintros H5; inversion H5.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros n1; case n1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros n1 m1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m1 m2 H2; absurd (nat_of_P p < nat_of_P p)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros H1; inversion H1.\nintros n1 m1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; inversion H1.\nintros n1 m1 H2; case (le_or_lt n1 m1); auto with arith.\nintros H3; inversion H3.\nintros m1 m2 H1; case (le_or_lt n1 m2); auto with arith.\nintros H3; inversion H3.\nintros n1Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); autoQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate).\nintros n1 n2; case (le_or_lt n1 m); auto with arith.\nintros n1 n2; case (le_or_lt n2 m); auto with arith.\nintros n1 m1 n2; case (le_or_lt n1 m1); auto with arith.\nintros m1 m1 n2; case (le_or_lt n2 m1); auto with arith.\nintros m1 n2; case (le_or_lt n1 m2); auto with arith.\nintros m1 m2 n2; case (le_or_lt n2 m1); auto with arith.\nintros n1 m1 n2; case (le_or_lt n1 m1); auto with arith.\nintros m1 n2; case (le_or_lt n2 m1); auto with arith.\nintros n1 m1 n2; case (le_or_lt n2 m2); auto with arith.\nintros m1 m1 n2; case (le_or_lt n1 m1Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 H1; inversion H1.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate).\nintros; apply lt_O_Sn.\nintros; apply lt_O_Sn.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate).\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\n",
                "context_tokens": 610,
                "proof_start_offset": 1542,
                "proof_end_offset": 1672,
                "proof": "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S m1)).\nsimpl; apply lt_le_rev.\napply le_trans with (m1 + m1)%nat; auto with arith.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napply lt_trans with (m1 + m2)%nat; auto with arith.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napply lt_trans with (m1 + m2)%nat; auto with arith.\napply lt_le_rev.\napply lt_le_rev.\napply lt_trans with (m1 + m1)%nat; auto with arith.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napply lt_le_rev.\napplyQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 n1; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.lt; simpl; auto with arith.\nintros m1 m2; case m1; unfold N.lt; simpl; auto with arith.Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m; case (le_or_lt m n); auto with arith.\nintros H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros H1; inversion H1.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1))).\nsimpl; apply nat_of_P_lt_Gt_compare_complement_morphism; auto.\nintros H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1))).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros H1; inversion H1.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1))).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism;Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H H0; inversion H.\nintros n1 m1; case (le_or_lt n1 m1); auto with arith.\nintros H1; inversion H1.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m2 m3; case (le_or_lt n2 m3); auto with arith.\nintros m3; case (le_or_lt n1 m3); auto with arith.\nintros m4; case (le_or_lt n1 m3); auto with arith.\nintros m4; case (le_or_lt n1 m3); auto with arith.\nintros m5; case (le_or_lt n2 m3); auto with arith.\nintros m5; case (le_or_lt n1 m3); auto with arith.\nintros m5; case (le_or_lt n1 m3); auto with arith.\nintros m5; case (le_or_lt n1 m1); autoQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m2 m2; case (le_or_lt n2 m2); auto with arith.\nintros m3 m4; case (le_or_lt m3 m4); auto with arith.\nintros m4 m4; case (le_or_lt m4 m4); auto with arith.\nintros m4 m5; case (le_or_lt m4 m5); auto with arith.\nintros m5; case (le_or_lt n4 m5); auto with arith.\nintros m5; case (le_or_lt m4 m5); auto with arith.\nintros m5; case (le_or_lt m5 m6); auto with arith.\nintros m5; case (le_or_lt m4 m5); auto with arith.\nintros m5; case (le_or_lt n4 m5); auto with arith.\nintros m6; case (le_Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m; case m; unfold N.lt; simpl; try (intros; discriminate).\nintros m1 n1 m2 H H0; case (le_or_lt m1 n2); auto with arith.\nintros H1 H2; inversion H1.\nintros m1 m2 H H0; case (le_or_lt m2 n1); auto with arith.\nintros m1 m2 H H1; case (le_or_lt m2 n1); auto with arith.\nintros m1 m2 H1; case (le_or_lt n2 m1); auto with arith.\nintros m1 m2 H H2; case (le_or_lt m2 n2); auto with arith.\nintros m1 m2 H1 H2; case (le_or_lt m1 n2); auto with arith.\nintros m1 m2 H1 H2; case (le_or_lt m1 n2); auto with arith.\nintros m1 m2 H1 H2; case (le_or_lt m2 n2); auto with arithQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.lt; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfold N.le; simpl; auto with arith.\nintros p; case p; unfoldQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros H1; inversion H1.\nintros m1 n1 H1; case (le_or_lt n m1); auto with arith.\nintros H2; inversion H2.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply nat_of_P_lt_Gt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n H1; case m; unfold N.lt; simpl; auto with arith.\nintros H1; case H1; auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\n",
                "context_tokens": 20,
                "proof_start_offset": 66,
                "proof_end_offset": 153,
                "proof": "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y; induction y; simpl; intros; auto.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y.\nassert (H := P_wd _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y; induction x; simpl; trivial.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y; rewrite <- (pred_succ x y); trivial.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  apply (le_lt_trans x y H).\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y; apply (pow_pos_lt_mono x y); trivial.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y.\ndestruct (le_gt_cases y x) as [Hx|Hx].\nrewrite Hx, Hy.\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_trans with (1:=Hx).\napply Rle_transQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y; induct y; simpl; auto.\nrewrite pred_succ.\nrewrite pred_succ.\nrewrite pred_succ.\nrewrite pred_succ.\nrewrite pred_succ.\nnow rewrite pred_succ.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y.\n  unfold pols.\n  case_eq (leb x y); intros.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y.\n  destruct (lt_ge_dec y x).\n  apply Rle_trans with y.\n    apply Rle_trans with (y + x).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y + x).\n      apply Rle_trans with (y + y).\n      apply Rle_trans with (y +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 63,
                "proof_start_offset": 155,
                "proof_end_offset": 234,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ngeneralize (ars_test x y).\nintros.\nassert (forall n, x + x < y ->  (x + y) <= x).\napply pred_le_trans with (2 * x + y).\napply le_trans with (2 * x + y).\napply le_trans with x.\napply le_trans with x.\napply le_trans with y.\napply le_trans with (2 * y).\napply le_trans with x.\napply le_trans with (2 * y).\napply le_trans with y.\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with (2 * y).\napply le_trans with x.\napply le_trans with x.\napply le_trans with (2 * y).\napply le_trans with x.\napply le_trans with (2 * y).\napply le_trans with y.\napply le_trans with x.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with x.\napplyQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (ars_test1 x y H0).\napply (ars_test2 x y H0).\napply (ars_test2 x y H0).\napply (ars_test1 y H0).\napply (ars_test2 x y H0).\napply (ars_test2 y H0).\napply (ars_test1 y H0).\napply (ars_test2 x y H0).\napply (ars_test2 y H0).\napply (ars_test1 y H1).\napply (ars_test2 x y H0).\napply (ars_test1 y H0).\napply (ars_test1 y H0).\napply (ars_test2 x y H0).\napply (ars_test2 y H0).\napply (ars_test2 x y H0).\napply (ars_test2 y H0).\napply (ars_test1 y H0).\napply (ars_test2 y H0).\napply (ars_test2 y H0).\napply (arsQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply pred_lt_compat.\napply pred_le_compat.\napply pred_pos_lt.\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (2:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (2:=x + y).\napply Rle_trans with (1:=y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (2:=x + y).\napply Rle_trans with (2:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (1:=x + y).\napply Rle_trans with (2:=x + y).\napply Rle_trans with (1:=xQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npols.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply Rle_trans with y.\napply Rle_trans with y.\napply Rle_trans with y.\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with y.\napply Rle_trans with x.\napply Rle_trans with x.\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with y.\napply Rle_trans with x.\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with (1 := Hxy).\napply Rle_trans with y.\napply Rle_trans with (1 :=Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npred_zero.\nintros.\napply pred_ext.\nintros.\nrewrite <- (Ropp_involutive y).\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply RoppQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1; rewrite <- (le_succ_r x).\nrewrite (le_succ_r x y).\napply (le_succ_l x y).\napply (le_succ_r x y).\napply (le_succ_r x y).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply H.\napply H.\napply H0.\napply H1.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napplyQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nassert (H := proj2_sig (pos_div2 x y)).\nrewrite <- H in H.\napply le_trans with y; trivial.\napply le_trans with y; trivial.\napply le_trans with x; trivial.\napply le_trans with y; trivial.\napply le_trans with y; trivial.\napply le_trans with y; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 101,
                "proof_start_offset": 237,
                "proof_end_offset": 357,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rle_trans with (2 * x + y * x * y * y * x * y * y * y * y + x * y * y * y * y * y * y)).\napply Rle_trans with (2 * x + y * x * y * y * y * y * y + x * y * y * y * y)).\napply Rle_trans with (2 * x + y * y * x * y * y * y * y * y * y + y * y * y * y * y * y * y)).\napply Rle_trans with (2 * x + y * y * y * y * y * y + x * y * y * y * y * y * y * y + y * y * y * y * y * y)).\napply Rle_trans with (2 * x + y * y * y * x * y * y * y + y * y * y * y * y * y).\napply Rle_trans with (2 * x + y * y * x * y * y * y * y * y + y * x * y * y * y * y * y)).\napply RleQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npred_compat.\napply pred_ext;auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 ; rewrite <- mult_n_Sm.\napply mult_le_compat.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (ars_test2 x y).\napplyars_test1.\napplyars_test2.\napplyars_test2.\napply IH_eq with (y:=x)...\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrevert x y H.\ninduction H.\nrewrite IHx.\nrewrite IHx.\nnow rewrite <- (mult_comm x y).\nrewrite mult_assoc.\nrewrite mult_distr_l.\nrewrite mult_assoc.\nrewrite mult_distr_l.\nrewrite mult_assoc.\nrewrite plus_assoc.\nrewrite mult_distr_r.\nrewrite (mult_comm x y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_distr_l.\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite mult_distr_l.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm yQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nintros.\napply succ_le_0.\napply pred_ext.\napply succ_le_mono.\napply pred_ext.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply pred_le_mono.\napply succ_le_mono.\napply pred_pos.\napply succ_le_mono.\napply succ_le_mono.\napply pred_pos.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_mono.\napply succ_le_Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 ; rewrite <- (Rplus_comm y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\nnow apply Rle_0_minus.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pred_ext.\napply pred_ext.\napply H0.\napply H1.\napply H0.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 in |- *.\nrewrite H.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npred_compat.\napply pred_pos.\napply Rle_lt_trans with (2 * x + y * x + y * y * x).\napply pred_pos.\napply Rlt_trans with (2 * x + y * x + y * y * y * x).\napply pred_pos.\napply Rle_trans with (2 * x + y * y * x + y * y * y + y * y * y).\napply pred_pos.\napply Rlt_trans with (2 * x + y * y * y + y * y * y + y * y * y).\napply pred_pos.\napply Rle_trans with (2 * x + y * y * y + y * y * y + y * y * y).\napply pred_pos.\napply Rle_trans with (2 * x + y * y * y + y * y * y + y * y * y).\napply pred_pos.\napply Rle_trans with (2 * x + y * y * y + y * y * y + y * y * y).\napply pred_pos.\napply Rle_trans with (2 *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 162,
                "proof_start_offset": 360,
                "proof_end_offset": 482,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrevert x y z H0; induction H0.\napply le_trans with (2 * x + y * x).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * x).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * y).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * x).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * y).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * x).\napply plus_le_compat_r.\napply le_trans with (2 * y + y * y).\napply plus_le_compat_l.\napply le_trans with (2 * x + y * x).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * y).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * x).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npred_pos.\nrewrite <- (plus_succ_r 2).\nrewrite <- (plus_succ_r 2).\napply plus_le_compat_r.\napply le_trans with (2 * x + y * 2 * y + 2 * y + 2 * y + 2 * y + 2 * y + 2 * y + 2 * y + 4 * y + 2 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * y + 4 * yQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 ; rewrite <- plus_assoc.\napply mult_le_compat_r.\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).\napply div_unique with (y + z).Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 y z).\nrewrite <- (ars_test3 x y z).\nrewrite <- (Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrevert x y z H.\ninduction z; simpl in H; intros; try discriminate.\nrewrite H2.\nsimpl in *.\nrewrite mult_assoc.\nrewrite mult_comm.\napply mult_le_compat_l; auto with arith.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\napply pols_test5 with (x + y) ; trivial.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrevert x y z H; induction x ; intros; simpl in *.\nrewrite H1, H2 in H.\napply le_trans with (y + x).\napply le_trans with (y + x).\napply le_trans with (y + y).\napply le_trans with (y + x).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + x).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (y + y).\napply le_trans with (yQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (Ropp_mult_distr_r 2 0).\nrewrite <- (Ropp_mult_distr_r 2 0).\nrewrite <- (Ropp_mult_distr_l 2 0).\nrewrite <- (Ropp_mult_distr_l 2 0).\nrewrite <- (Ropp_mult_distr_r 2 0).\nrewrite <- (Ropp_mult_distr_l 2 0).\nrewrite Ropp_plus_distr_l.\napply Ropp_lt_contravar.\napply Ropp_lt_contravar.\napply Ropp_lt_contravar.\napply Ropp_gt_lt_contravar.\napply Ropp_gt_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_gt_gt_0_lt_contravar.\napply Ropp_lt_gt_contravar.\napply Ropp_gt_gtQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\napply div_unique with (2 * x + y * y + y * y + y * y + 2 * y + 2 * x).\napply div_unique with (2 * x + y * y + y * y + 2 * y + 2 * y + 2 * y + 2 * y + 2 * y + 2 * y + 2 * x * y + 2 * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 4Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 in |- *.\nrewrite <- (succ_pred_pos x) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_pred_pos y) at 2 in H0.\nrewrite <- (succ_predQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 225,
                "proof_start_offset": 485,
                "proof_end_offset": 561,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply (ars_test1 x y).\napply (ars_test2 x y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npred_pos.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply (ars_test1 x y z).\nrewrite <- (ars_test2 x y z).\nrewrite <- (ars_test2 x y z).\napplyars_test2.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 2; rewrite <- (ars_test3 x y z).\napplyars_test1.\napplyars_test2.\napplyars_test2.\napplyars_test2.\napplyars_test3.\napplyars_test2.\napplyars_test4.\napplyars_test2.\napplyars_test3.\napplyars_test2.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyars_test4.\napplyarQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napplyQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napplyQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrevert x y H.\ninduction H;intros.\nleft.\napply H0.\napply H.\napply H0.\napply H.\napply H.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napplyars_test1.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 261,
                "proof_start_offset": 563,
                "proof_end_offset": 659,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npred_compat.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x, y in H0.\napply H0 with (x + y).\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (ars_test1 x y H H0).\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrevert x y H.\nrevert y H.\ninduction H; intros.\nrewrite H.\napply Rle_refl.\napply Rle_refl.\napply Rle_refl.\napply Rle_refl.\napply Rle_refl.\napply Rle_refl.\napply Rle_refl.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (ars_test1 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\nrewrite <- (ars_test2 x y).\napply (ars_test2 x y).\nrewrite <- (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (arQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (ars_test1 x y H0 H1).\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply pred_ext.\nintros.\napply H.\napply H.\napply H0.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply pred_ext; intros.\nrewrite H1 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\nrewrite H0 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\ndestruct H0 as [H1 H2].\nrewrite H2 in H0.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napply pred_pos.\napply pred_compat.\napplyQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (pred_le_trans _ _ _ H0).\napply (pred_le_trans _ _ _ H1).\napply pred_le_trans with (2 * x + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).\napply pred_le_trans with (2 * y + y).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 307,
                "proof_start_offset": 663,
                "proof_end_offset": 781,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct (le_lt_lt_dec x y) as [H|H].\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H1.\napply H.\napply H0.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x + y <= x + y + y + z * y + x * y * y + x * y * y + x * y * y + x * y * y + x * y * y).\nintros.\napply pred_ext.\napply H0.\napply H1.\napply H1.\napply H2.\napply H3.\napply H3.\napply H1.\napply H2.\napply H3.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct x; destruct y; simpl in *;try discriminate.\napply IHx; trivial.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pred_pos.\napply le_trans with (1:=y + z).\napply H.\napply H.\napply H0.\napply H.\napply H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct x, y; simpl; intros.\ndestruct y; simpl in *.\ndestruct z; simpl in *.\napply H; auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (arr_test1 x y z).\ngeneralize (arr_test2 x y z).\nunfold polr_test1.\nintros.\nrewrite H0 in H.\nclear H0.\nrewrite <- (arr_test1 x y z).\nrewrite H0.\napply H0.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (arc_test x y z H0); intro.\nrewrite H0 in H0.\nrewrite H1 in H0.\napply H0.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x + y * z <= 2 * x).\nintros.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H2.\napply H1.\napply H0.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert x y z H0.\ninduction H0.\nrewrite H1.\napply H1.\napply H2.\napply H1.\napply H3.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H2 := H3 H1).\nassert (H3 := H2 H3).\nassert (H5 := H3 H2).\nassert (H5 := H5 H0).\nassert (H6 := H4 H1).\nassert (H6 := H4 H3).\nassert (H6 := H6 H4).\nassert (H7 := H7 H7).\nassert (H10 := H8 H9).\nassert (H10 := H8 H9).\nassert (H10 := H10 H10).\nassert (H11 := H9 H10).\nassert (H12 := H5 H10).\nassert (H13 := H9 H10 H12).\nassert (H13 := H5 H14).\nassert (H15 := H14 H2).\nassert (H15 := H14 H0).\nassert (H15 := H0 H1).\nassert (H15 := H0 H2).\nassert (H15 := H0 H7).\nassert (H15 := H15 H0).\nassert (H15 := H0 H1).\nassert (H15 := H0 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 223,
                "proof_start_offset": 611,
                "proof_end_offset": 812,
                "proof": "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply N.le_ngt; apply lt_N_le; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_ngt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply N.lt_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p; apply N2Nat.inj_mul.\napply plus_le_compat_r; apply lt_N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_r; apply le_lteq; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply Plus.mult_le_compat_r; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\napply Plus.mult_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply H1; apply H2; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply N2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 814,
                "proof_end_offset": 1025,
                "proof": "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_antisym; repeat rewrite N2Nat.inj_mul.\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply le_0_l | apply H1].\napply le_trans with (p * n + p); [apply leQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_ltA; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_ZERO; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_ZERO; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_ZERO; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans with p ];\n apply le_lt_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans with p ];\n apply le_lt_trans with p.\n apply le_lt_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans with p ];\n apply le_lt_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans with p ];\n apply le_lt_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans with p ];\n apply le_lt_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans with p ];\n apply le_lt_trans with (p * m); [ apply le_lt_trans with p | apply le_lt_trans withQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_lossless; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_bezout; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_fixpoint.\napply plus_le_compat_l; apply lt_N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply gt_N_le; repeat rewrite N2Nat.inj_mul.\napply Pos.le_trans with (p * m); [assumption | apply (lt_O_n m p) ].\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply N2Nat.inj_ge; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_Nlt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply gt_N_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1027,
                "proof_end_offset": 1270,
                "proof": "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply ge_ Scope nat_scope.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_gt_compat_l; apply lt_O_n; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply ge_ coefXn; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply H1; apply H2; apply H3; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply Pos.lt_gt. apply Pos.lt_le_incl; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_gt_compat_l; apply gt_INR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply N2Nat.inj_lt; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply ge_ initialize.le_weak; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_gt_compat_l; apply lt_O_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1272,
                "proof_end_offset": 1502,
                "proof": "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; apply N2Nat.inj_lt; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_le; apply ltO_le; apply lt_O_le; apply lt_O_le; apply lt_le; apply lt_O_le; apply lt_O_le; apply lt_O_le; apply lt_le; apply lt_O_le.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; apply H1.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; apply lt_O_1; apply lt_O_1.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; apply le_lteq; apply H1.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply plus_gt_compat_l; apply lt_O_1; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; apply H1; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply lt_le_trans with (m * n) by (apply Nat.lt_le; apply lt_N_lt; repeat rewrite N2Nat.id; auto).\napply Nat.lt_le_trans with (m * n) by (apply Nat.lt_le; apply lt_0_1).\napply plus_le_compat_l; apply lt_S; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt; apply Pos.lt_le_incl; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply lt_O_le; repeat rewrite N2Nat.inj_mul.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " p * n > p * m -> n > m.\nintros n m p H1; apply Ngt_gt; apply mult_gt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3553,
                "proof_end_offset": 3760,
                "proof": "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N a). \nrewrite <- H1; rewrite <- (nat_of_N_nat a).\nrewrite <- (nat_of_N_nat a).\nrepeat rewrite <- (nat_of_N_nat a).\nrepeat rewrite <- (nat_of_N_nat a).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; apply Ngt_mult_rev_0_l with (nat_of_N b).\nrewrite <- (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul H1 H2))) a)\n .\nrewrite <- (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul H2 H))) a)\n .\nrewrite <- (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul H2))) a)\n .\nrewrite <- (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul (N2Nat.inj_mul H2N2Nat.inj_mul H2N)))).\nrewrite <- (NQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_l.\nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2Nat.inj_mul; apply lt_mult_rev_0; apply lt_mult_rev_0;\n rewrite <- N2NatQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Ngt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_r.\nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nlt_trans with (nat_of_N b).\nrewrite <- (nat_of_N_nat b); apply lt_mult_rev_0; apply lt_mult_rev_0; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Ngt_mult_rev_0_r with (nat_of_N b).\nrewrite <- (N2Nat.inj_mul); apply gt_mult_rev_0_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- H1; rewrite <- H2; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Ngt_mult_rev_0_r with (nat_of_N b).\nrewrite <- (N2Nat.inj_mul N2Nat.inj_mul); apply gt_mult_rev_0_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3762,
                "proof_end_offset": 3929,
                "proof": "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply N.le_0_lt_0; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_neq; apply lt_0_eq; apply lt_neq;\n apply lt_0_eq; apply lt_0_eq; apply lt_neq; apply lt_0_neq; apply lt_neq; apply lt_0_neq; apply lt_neq;\n apply lt_0_eq; apply lt_neq; apply lt_O_eq; apply lt_neq; apply lt_0_neq; apply lt_neq;\n apply lt_O_eq; apply lt_neq; apply lt_0_neq; apply lt_0_neq; apply lt_neq; apply lt_0_neq;\n apply lt_O_eq; apply lt_neq; apply lt_0_neq; apply lt_neq; apply lt_0_neq;\n apply lt_O_eq; apply lt_neq; apply lt_0_neq; apply lt_neq; apply lt_0_neq; apply lt_neq;\n apply lt_OQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nlt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_1_eq; apply lt_0_eq; apply lt_0_eq.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; elim H; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H0; apply N.ge_0; apply lt_le; apply lt_0_eq; apply lt_0_eq; apply lt_O_eq; apply lt_O_eq; apply lt_0_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1 H2; apply N.le_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_le_weak.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nlt_0_eq; rewrite <- H1.\napply lt_0_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply lt_O_eq; rewrite <- H1.\napply ltQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply N.le_0_lt; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n apply lt_O_neq; apply lt_O_Qed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nlt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq;\n rewrite <- H1; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply N.lt_le; apply lt_0_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n rewrite <- N2Nat.inj_mul; apply gt_0_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n rewrite <- N2Nat.inj_mul; apply gt_0_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n rewrite <- N2Nat.inj_mul; apply gt_0_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_O_neq;\n rewrite <- N2Nat.inj_mul; apply gt_0_neq; apply gt_O_neq; apply lt_O_neq; apply lt_O_neq; apply lt_Qed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply N.lt_0_eq_0. apply N.lt_le_0_iff. apply N.lt_0_iff. apply N.lt_0_iff.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3931,
                "proof_end_offset": 4128,
                "proof": "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nchange (0 >= nat_of_N n)%nat.\napply ge_Nge; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\napply N.ge_ge; apply lt_O_eq; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H; rewrite <- (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite <- (N2Nat.id n).\nrewrite (Nat.id n).\napply le_antisymm; auto.\napply Nat.le_antisymm; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewriteQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply N.le_ngt; apply lt_0_eq_0; apply lt_0_eq; apply lt_neq; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply N.ge_gt; apply lt_0_eq; apply lt_le_weak; apply lt_0_eq; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H H1; apply N.ge_0; apply lt_0_eq_0.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (Nat.id n).\nrewrite (NatQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- (N2Nat.id n).\napply le_lteq; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply N.gt_lt; apply lt_0_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq; apply lt_O_eq.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " simplify x * y? x * z where? is < > <= >= *)\n\nTheorem Rmult_le_compat_l:\n  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.\nauto with real.\nQed.\n\nTheorem Rmult_le_neg_compat_l:\n  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30052,
                "proof_end_offset": 30304,
                "proof": "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n + p)%R with ((p * n) + m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto withQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n + p)%R with (p * n)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * n + p * m)%R); auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rlt_le; auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with (p * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * n) * m)%R; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * m + p * m))%R; auto with real.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l.\napply Rinv_0_lt_compat; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rinv_0_lt_compat; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rinv_0_lt_compat; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rinv_0_lt_compat; auto with real.\napply Rinv_0_lt_compat; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rinv_0_lt_compat; auto with real.\napply Rmult_le_compatQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * n)%R); auto with real; try ring.\nreplace (p * n)%R with ((p * n)%R); auto with real; try ring.\napply Rmult_le_compat_l; auto with real; apply (Rmult_le_compat_l m); auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * n + m))%R; auto with real.\nrewrite H1; rewrite H2; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((m * n) + (p * n))%R; auto with real.\nreplace (p * m)%R with (n * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real; rewrite Rmult_comm;\n rewrite (Rmult_comm m n); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30306,
                "proof_end_offset": 30566,
                "proof": "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rle_ge; apply Rmult_le_pos_l; auto.\napply Rlt_le_trans with (m := p); auto with real.\napply Rmult_le_pos_l; auto.\napply Rlt_le; apply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; replace (p * m)%R with (p * m)%R; auto with real.\nrewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; replace (p * n)%R with (p * m)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < p * n)%R; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto.\napply Rlt_le; apply Rmult_le_pos_l; auto.\napply Rlt_le; apply Rmult_le_pos_l; auto.\napply Rlt_le; apply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < p * n)%R; auto with real.\napply Rle_lt_trans with (m * n)%R; auto with real.\napply Rmult_le_compat_l; auto.\napply Rle_trans with (m * n)%R; auto with real.\napply Rmult_le_compat_l; auto.\napply Rlt_le; apply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; apply Rmult_le_pos_l; auto with real.\nreplace (p * m + p * m)%R with (p * m)%R; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": ", (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30568,
                "proof_end_offset": 30827,
                "proof": "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_r; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\nrewrite H1; rewrite H2; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\napply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\napply Rmult_lt_compat_l; auto.\napply Rinv_0_lt_compat; auto with real.\napply Rlt_dichotomy_converse; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n < m * p)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\napply Rmult_lt_reg_l with (r := p); auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto.\napply Rmult_le_pos; auto.\napply Rmult_le_pos; auto.\napply Rmult_le_pos; auto.\napply Rmult_le_pos; auto.\napply Rmult_le_pos; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto.\napply Rlt_le; apply Rmult_lt_compat_l; auto.\napply Rmult_le_compat_l; auto.\napply Rlt_le; apply Rmult_le_compat_l; auto.\napply Rmult_le_compat_l; auto.\napply Rmult_le_compat_l; auto.\napply Rmult_le_compat_l; auto.\napply Rmult_le_compat_l; auto.\napply Rlt_le; apply Rmult_le_compat_l; auto.\napply Rmult_le_compat_l; auto.\napply Rlt_le; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (n * m < p * m)%R; auto with real.\napply Rle_ge; apply Rmult_le_pos_l; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30829,
                "proof_end_offset": 31096,
                "proof": "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (m < 0)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_pos_compat; auto.\napply Rmult_lt_pos_compat; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_ge; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_reg_l with (r := r).\napply Rlt_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto; intros H3.\nabsurd (p * m < p * m)%R; auto with real.\napply Rle_lt_trans with (m * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * m < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\napply (Rle_trans _ _ _ H1).\napply Rlt_le; apply Rlt_trans with (1 := H1).\napply Rlt_trans with (1 := H2).\napply Rlt_trans with (2 := H1).\napply Rlt_trans with (1 := H1).\napply Rlt_trans with (1 := H2).\napply Rlt_le; apply Rlt_trans with (1 := H1).\napply Rlt_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; replace (p * n)%R with (- p * m)%R; auto with real.\nreplace (m * n)%R with (m * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_reg_l with (r := p); auto with real.\napply Rlt_le; auto with real.\napply Rinv_0_lt_compat; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto.\napply Rmult_lt_compat_l; auto with real.\napply Rle_ge; auto with real.\napply Rmult_le_pos_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\napply Rmult_le_pos_compat_l; auto.\napply Rmult_le_pos_compat; auto.\napply Rmult_lt_pos_compat; auto.\napply Rmult_le_pos_compat; auto.\napply Rmult_le_pos; auto.\napply Rmult_le_pos; auto.\napply Rmult_lt_pos; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31098,
                "proof_end_offset": 31286,
                "proof": "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_r; auto with real.\napply (Rmult_lt_reg_l (r := n + m)%R); auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto with real.\napply Rlt_le; apply Rmult_le_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_l; auto with real.\napply Rlt_le; apply Rmult_lt_compat_Qed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (n * m = m * n)%R; auto with real.\napply Rle_ge; apply Rmult_lt_compat_l; auto with real.\nrewrite (Rmult_comm (m * n) (m * n)%R); auto with real.\nreplace (m * n)%R with (m * n)%R; auto with real; try ring.\nreplace (m * n)%R with (m * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (n * m < p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_compat_r; auto with real.\napply Rlt_dichotomy_converse; right; apply Rlt_dichotomy_converse; left; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_lt_reg_l with (r := n); auto with real.\nrewrite H1; rewrite H2; rewrite Rmult_1_r; auto with real.\nreplace (m * n)%R with (m * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nrewrite H1; rewrite Rmult_1_r; auto with real.\napply Rmult_lt_reg_l with (r := n); auto with real.\napply Rmult_lt_reg_l with (r := n); auto with real.\nrewrite <- Rmult_assoc; rewrite <- Rinv_r_sym; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_reg_l with (p := n); auto with real.\napply Rlt_le; apply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_l; auto with real.\nrewrite Rmult_assoc; rewrite Rinv_r; auto with real; apply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < 0)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_pos_l; auto with real.\napply Rmult_le_pos_l; auto with real.\napply Rmult_lt_reg_l with (r := p); auto with real; try assumption.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\napply Rmult_le_pos_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31288,
                "proof_end_offset": 31484,
                "proof": "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * m < p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m = 0%R); auto with real.\napply Rlt_not_le; apply Rmult_le_pos_l; auto with real.\napply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_ge; apply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rmult_le_pos_l; auto with real.\napply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; apply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1 H2; rewrite <- (Rmult_1_l (n + p)); apply Rmult_le_compat_l;\n auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; apply Rmult_le_pos_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; apply Rmult_ge_neg_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31486,
                "proof_end_offset": 31663,
                "proof": "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m * p > 0)%R; auto with real.\napply Rmult_lt_reg_l with (r := n); auto with real.\napply Rlt_le; auto with real.\napply Rmult_lt_reg_l with (r := n); auto with real.\nrewrite <- (Rmult_comm n); rewrite Rmult_assoc; rewrite Rinv_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * m > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); intros H2.\nabsurd (n * m > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_gt_0_compat_l; auto with real.\nreplace (p * n + m)%R with (n * m)%R; [ idtac | ring ].\napply Rmult_lt_compat_l; auto with real.\nreplace (m + n * m)%R with (n * m)%R; [ idtac | ring ].\napply Rmult_le_compat_l; auto with real.\nreplace (m + n * m)%R with (m * n)%R; [ idtac | ring ].\napply Rmult_le_compat_l; auto with real.\nreplace (m + n * m)%R with (n * m)%R; [ idtac | ring ].\napply Rmult_le_compat_l; auto with real.\nreplace (m + n * m)%R with (n * m)%R; [ idtac | ring ].\nreplace (m + n * m)%R with (n * m)%R; [ idtac | ring ].Qed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; replace (p * n)%R with (p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); intros H3.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto with real.\napply Rlt_le; apply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * m <= p * n)%R; auto with real.\napply Rle_ge; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1;\n apply Rle_ge; apply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; apply Rle_ge; apply Rmult_ge_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (n * m < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto with real.\nrewrite <- (Rmult_comm (n * m)).\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; apply Rle_ge; apply Rmult_lt_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31665,
                "proof_end_offset": 31850,
                "proof": "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2; case (Zle_or_lt n m); auto; intros H3.\nabsurd (p * n > p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rmult_lt_reg_l with (r := n); auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m > 0)%R; auto with real.\napply Rmult_le_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; rewrite <- (Rmult_0_r n m p) in H1.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2; apply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1;\n red in |- *; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; apply Rmult_gt_neg_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; red; apply Rmult_gt_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1 H2; elim H1; intros.\napply Rle_trans with (p * n)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_pos_l; auto.\napply Rmult_le_pos_l; auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m * n > p * m)%R; auto with real.\napply Rle_ge; apply Rmult_lt_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 31871,
                "proof_end_offset": 31978,
                "proof": "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1;\n apply eq_Rlt; apply H1; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; apply Rle_antisym; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; apply (Rlt_le_trans _ _ _ H1); auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case H1; intros; auto with real.\napply H; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1;\n red; apply Rmult_lt_reg_l with (y := x); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1;\n red; apply H; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; rewrite H1; rewrite H; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; rewrite H1; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; case (Rle_or_lt y z); auto; intros H2.\nabsurd (y < y); auto with real.\napply Rle_trans with (y - z); auto with real.\napply H1; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; rewrite H1; apply lt_le_trans with (y := x); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 31979,
                "proof_end_offset": 32086,
                "proof": "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1 H2; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1 H2; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32087,
                "proof_end_offset": 32194,
                "proof": "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H0; rewrite H0; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H1; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H1 H2; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H0; rewrite H0; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H0; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32195,
                "proof_end_offset": 32302,
                "proof": "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H1 H2; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H H0; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32303,
                "proof_end_offset": 32412,
                "proof": "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H1 H2; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H0; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H H1; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " a Z *)\nLtac RCst t :=\n  match t with\n   | R0 => constr:(Z0)\n   | R1 => constr:(Zpos xH)\n   | Rplus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4809,
                "proof_end_offset": 4938,
                "proof": "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4940,
                "proof_end_offset": 5073,
                "proof": "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H1; case H1.\napply plus_le_compat_r; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l with m; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply f_equal2 with (n := m); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_r; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H1; case H1.\napply plus_gt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H1; case H1; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply f_equal2 with (m := p); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5075,
                "proof_end_offset": 5184,
                "proof": "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b c H H1; case H; subst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H1; case H1; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H H0; case H; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H1.\napply plus_gt; auto.\napply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H1.\napply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H1; intros H2; rewrite H2; ring.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H.\napply plus_gt; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H1.\napply plus_gt_compat_l with b; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H1.\napply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_gt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5186,
                "proof_end_offset": 5320,
                "proof": "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H1; case H1; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1 H2.\ncase (le_or_eq n m); intro H3.\nrewrite H3 in H3; discriminate H3.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1.\napply plus_lt_reg_l with m; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1.\napply plus_le_reg_l with a; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H1; case H; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1.\napply plus_le_reg_l with m; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H1; intros H2 H3; elim H3; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\nTheorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.\n\n(* For replace *)\n",
                "context_tokens": 736,
                "proof_start_offset": 5340,
                "proof_end_offset": 5446,
                "proof": "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case H1; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1 H2; case H; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case H1; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case (le_lt_eq_dec x z); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; case H; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; case H; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1 H2; case H; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case H; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case H1; intros H2 H3; rewrite H2;\n [ idtac | assumption ]; auto with arith.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; case H; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 485,
                "proof_start_offset": 1028,
                "proof_end_offset": 1154,
                "proof": "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d + d).\npolr (a + c < d + d).\npolr (a + c < d + d).\nlam r (a + c < d + d).\nlam r (a + c < d + d).\nlam r (a + c < d + d).\nlam r (a + c > d + d).\nlam r (a + c < d + d + d).\nlam r (a + c < d + d + d).\nlam r (a + c < d + d + d).\nlam r (a + c < d + d).\nlam r (a + c > d + d).\nlam r (a + c < d + d + d).\nlam r (a + c + d) (b + c + d).\nlam r (a + c + d) (b + c + d).\nlam r (a + c) (a + c + d) (b + c + d).\nlam r (a + c) (a + c + d) (b + c + d).\nlam r (a + c + d) (Qed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npolr (a + c < d)).\nauto.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d).\nlam (a + c < d).\nlam (a + c) (b + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nlam (a + c) (c + d)).\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d).\nlam_polr (a + c < d).\nlam_polr.\nauto.\nlam_pols.\nauto.\nlam_pols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c) b c d H1 H2.\npolr (a + b + c) d H2.\npolr (a + b + c) d H1 H2.\npolr (a + b) d H1 H2.\npolr (a + c) d H2 H3.\npolr (a + b + c + d) d H1 H3.\npolr (a + b) d H2 H3.\npolr (a + c) d H1 H3.\npolr (a + c) d H3 H4.\npolr (a + c + d) d H1 H4.\npolr (a + b + c + d) d H1 H5.\npolr (a + c + d) d H2 H3.\nlam (a + c + d) d H3 H4.\nlam (a + c + d) d H5 H5.\nlam (a + c + d) d H5 H6.\nlam (a + c + d) d H5 H6.\nlam (a + b + c +Qed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npolr (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (a + b + c * d) P.\nlam r (aQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + b) c d H1 H2.\npolr (a + b) c d H1 H2.\npolr (a + b) c d H1 H2.\nlam (a + b) c d H1 H2.\nlam (a + c) d H2.\nlam (a + c) d H2 H3.\nlam (a + c) d H1 H3.\nlam (a + c) d H3.\nlam (a + c) d H3.\nlam (a + c) d H3 H4.\nlam (a + c) d H4.\nlam (a + c) d H4.\nlam (a + c) d H4.\nlam (a + c) d H4.\nlam (a + c) d H4.\nlam (a + c) d H4.\nlam (a + c) d H4.\nlam (a + c) d H5.\nlam (a + c) d H5.\nlam (a + c) d H5.\nlam (a + c) d H5.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 552,
                "proof_start_offset": 1156,
                "proof_end_offset": 1273,
                "proof": "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nlam_div_auxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxauxQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolcf (0 < d) P.\napply P.R 1%Z.\nTime Qed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolwordr (a + c) d H1 H2.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c) d H1 H2.\npolr (a + c) d H1 H2.\npolr (a + c) d H1 H3.\npolr (a + c) d H3 H3.\npolr (a + c) d H1 H3.\npolr (a + c) d H3 H4.\npolr (a + c) d H4.\nlam (a + c) d H1 H4.\nlam (a + c) d H1 H4.\nlam (a + c) d H5 H2 H5.\nlam (a + c) d H5 H6.\nlam (a + c) d H5 H6.\nlam (a + c) d H5 H6.\nlam (a + c) d H6.\nlam (a + c) d H6 H7.\nlam (a + c) d H6.\nlam (a + c) d H6.\nlam (a + c) d H6.\nlam (a + c) d H6.\nlam (a + c) d HQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npold (a + c) c d H1 H2.\npold.\nauto.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + b + c + d) c d H0 H1 H2.\npolr (a + b + c + d) c d H0 H2.\nlamr (a + b + c + d) c d H H2.\nlamr (a + b + c + d) c d H0 H2.\nlamr (a + b + c + d) c d H H2 H3.\nlamr (a + b + c + d) c d d H H3.\nlamr (a + b + c + d) c d H d H0 H1 H2.\nlamr (a + b + c + d) c d d H H3.\nlamr (a + b + c + d) c d H3 H3.\nlamr (a + b + c + d) c d d H3 H4.\nlamr (a + b + c + d) c d d H H3.\nlamr (a + b + c + d) c d d H3 H5.\nlamr (a + b + c + d) c d H d HQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + b + c + d) P.R 1%Z.\npols.\nauto.\nlam r (a + b + c + d) P.\nlam r (a + b + c + d) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + b + c) P.\nlam r (a + bQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nlamr (a + c) b c d H0 H1.\nlamr (a + c) b c d H H1.\nlamr (a + c) b c d H H2.\nlamr (a + c) b c d H H1.\nlamr (a + c) b c d H H1.\nlamr (a + c) b c d H1 H2.\nlamr (a + c) b c d H H2.\nlamr (a + c) b c d H H3.\nlamr (a + c) b c d H d H0 H1.\nlamr (a + c) b c d H H0 H2.\nlamr (a + c) b c d H H3.\nlamr (a + c) b c d H H3.\nlamr (a + c) b c d H d H0 H1.\nlamr (a + c) b c d H d H1.\nlamr (a + c) b c d H H2.\nlamr (a + c) b c d H d H0 H1Qed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c) c d H0.\npolr (a + c) d H1.\nlam (a + c) d d H2.\nlam (a + c) d d H2.\nlam (a + c) d d H1.\nlam (a + c) d d H2.\nlam (a + c) d d H1.\nlam (a + c) d d H2.\nlam (a + c) d d H2.\nlam (a + c) d d H2.\nlam (a + c) d d H3.\nlam (a + c) d d H3.\nlam (a + c) d d H3.\nlam (a + c) d d d H3.\nlam (a + c) d d H3.\nlam (a + c) d d d H3.\nlam (a + c) d d H3.\nlam (a + c) d d H3.\nlam (a + c + d) d H3.\nlam (a + c) d d H3.\nlam (a + c) d dQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c + d) P.\npols.\nauto.\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 611,
                "proof_start_offset": 1275,
                "proof_end_offset": 1401,
                "proof": "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + b) c d H H0.\npolr (a + b) c d H H1.\npolr (a + b) c d H H0.\npolr (a + b) c d H H0.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H0.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H0.\npredicater (a + b) c d H1.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H0.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H0.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H1.\npredicater (a + b) c d H H2.\npredicater (a + b) c d H H H0.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < d + b).\npolr (a + c < d + b).\npolr.\nauto.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c) b c d H1 H2.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + b + c) H1 H2.\npolr (a + b + c) H1 H2.\npolr (a + b + c) H2 H3.\npolr (a + b + c) H1 H3.\npolr (a + b + c) H3 H1 H3.\npolr (a + b + c) H3 H1 H3.\npolr (a + b + c + d) H3 H4.\npolr (a + b + c + d) H1 H3.\npolr (a + b + c + d) H3 H4.\npolr (a + b + c + d) H1 H3.\npolr (a + b + c + d) H3 H1 H3.\npolr (a + b + c + d) H3 H4.\npolr (a + b + c + d) H1 H3.\npolr (a + b + c + d) H3 H4.\npolr (a + b + c + d) H3 H4.\npolr (Qed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\nrep_aux.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + b + c + d) P.\nlam_div_eucl_aux_aux a b c d H0 H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_div_eucl_aux a b c d H H1 H2.\nlam_Qed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + b) c d H H0.\npolr (a + c) d H0.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c + d) c d H1 H2.\npolr (a + c + d) c d H1 H2.\npolr (a + c + d) c d H2 H3.\npolr (a + b + c + d) c d H H3.\npolr (a + b + c + d) c d H H1 H2.\npolr (a + c + d) c d H H2 H3.\nconstraintr (a + c + d) c d H H1 H3.\npolr (a + c + d) c d H H3.\npolr (a + c + d) c d H H3.\npolr (a + c + d) c d H H3.\npolr (a + c + d) c d H H1 H3.\nconstraintr (a + c + d) c d H3 H3.\npolr (a + c + d) c d H3 H3.\npolr (a + c + d) c d H3 H4.\npolr (a + c + d) cQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + b) c d H1 H2.\nlam_nonneg a b c d H1 H2.\nlam_nonneg b c d H1 H2.\nlam_nonneg a b c d H1 H2.\nlam_nonneg b c d H1 H2.\nlam_nonneg b c d H2 H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b c d H1 H3.\nlam_nonneg b cQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 1463,
                "proof_end_offset": 1579,
                "proof": "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1 in |- *.\npattern c at 1Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\n *:_div_eucl_aux a b c d H1 H2.\n *:_div_eucl_aux a b c d H1 H2.\n])%C.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + b + c * d) c d H.\npolr (a + b + c * d) d.\napply H.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c) b c d H1 H2.\npolr (a + c) b c d H1 H2.\npolr (a + c) b c d H H1 H2.\npolr (a + c) b c d H H2.\npolr (a + c) b c d H H1 H2.\npolr (a + c) b c d H H2.\npolr (a + c) b c d H H1 H2.\npolr (a + c) b c d H H H3.\npolr (a + c) b c d H H1 H3.\npolr (a + c) b c d H H H1 H2.\npolr (a + c) b c d H H2 H3.\npolr (a + c) b c d H H H1 H3.\npolr (a + c) b c d H H1 H3.\npolr (a + c) b c d H H1 H3.\npolr (a + c) b c d H H1 H3.\npolrQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolr (a + c) d.\npolrQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + b + c * d + b * d + c * d + d * b + d * c + d * d).\nintros.\npolr (a + b + c * d + b * d + c * d + d * b + d * d + d * b + d * c + d * d).\nintros.\nlamr (a + b + c * d + d * b + d * b + c * d + d * b + d * b + d * d + d * b + d * c + d * d + d * c + d).\nintros.\nlamr (a + b + c * d + b * d + c * d + d * b + d * b + d * b + d * b + d * b + d * c + d * b + d * b + d * b + d * c + d * d + d * b + d * b + d * c + d * d + d * d + d * b + d * b + d * d + d * c * d + d * b + d * b + d * b + d * b +Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolg_equiv_1.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nalg_ring_simplify.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + b + c + d) c d.\npolr (a + b + c + d) c d.\npolr (a + b + c + d) c d.\nrep_aux_aux_aux_aux_aux a b c d.\nfield.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nalg_for_euclid a b c d H1 H2.\nalg_for_euclid a b c d H1 H2.\nfield.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Open Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\nGoal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 1581,
                "proof_end_offset": 1693,
                "proof": "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\npolr (d = 0).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + c + c + d) H0 H1.\nconstraintr H1.\nauto.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nlam_pos_correct a b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct b c d.\nlam_pos_correct c d.\nlam_neg_correct c d.\nlam_pos_correct c d.\nlam_pos_correct b c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c d.\nlam_pos_correct c dQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + b) c d H.\npolr (a + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d H.\npredicater (b + c) d HQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + b + c + d) H0.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.\npolr (a + b + c + d) H1.Qed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolc (a + c + d) b c d H0.\npolr (a + c + d) b c d H0.\npolr (a + c + d) b c d H H1 H2.\npolr (a + c + d) b c d H H0.\npolr (a + c + d) b c d H H1.\npolr (a + c + d) b c d H H1.\npolr (a + c + d) b c d H H2.\npolr (a + c + d) b c d H H0.\npolr (a + c + d) b c d H H1 H2.\npolr (a + c + d) b c d H H0.\npolr (a + c + d) b c d H H1 H2.\npolr (a + c + d) b c d H H0.\npolr (a + c + d) b c d H H1 H2.\npolr (a + c + d) b c d H H0.\npolr (a + c + dQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nalgs.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + b + c + d) c d.\npols.\nauto.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + c + d) c d H1.\npolr (a + b + c) d H2.\npolr (a + b + c + d) d H1 H2.\npolr (a + b + c + d) d H1 H2.\npolr (a + b + c + d) d H1 H2.\npolr (a + b + c + d) d H1 H2.\npolr (a + b + c + d) d H1 H2.\npolr (a + b + c + d) d H2 H3.\npolr (a + b + c + d) d H3.\npolr (a + b + c + d) d H3.\npolr (a + b + c + d) d H3.\npolr (a + b + c + d) d H3.\npolr (a + b + c + d) d H3.\npolr (a + c + d) d H3.\npolr (a + b + c + d) d H3.\npolr (a +Qed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + c) b c d H H0.\npolr (a + b + c + d) c d H H1 H2.\npolr (a + b + c + d) c d H H1 H2.\npolr (a + b + c + d) c d H H H3.\npolr (a + c + d) c d H H3.\npolr (a + c + d) c d H H H1 H2.\npolr (a + b + c + d) c d H H H3.\npolr (a + c + d) c d H H3.\nlam (a + b + c + d) c d H H3.\nlam (a + b + c + d) c d H H3.\nlam (a + b + c + d) c d d H H3.\nlam (a + c + d) c d H H3.\nlam (a + c + d) c d d H H3.\nlam (a + c + d) c d H H3.\nlam (a + c + d) c dQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 293,
                "proof_start_offset": 635,
                "proof_end_offset": 724,
                "proof": "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pred_lt_trans with (y * x + y + y * x + y * y)%R.\nnow apply pred_le_compat.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pols_test1; auto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply (pows_test2 x y).\napply (pows_test3 x y).\napply (pows_test1 x y).\napply (pows_test2 x y).\napply (pows_test1 y).\napply (pows_test1 y).\napply (pows_test2 y).\napply (pows_test2 y).\napply (pows_test1 y).\napply (pows_test1 y).\napply (pows_test2 y).\napply (pows_test2 y).\napply (pows_test2 y).\napply (pows_test2 y).\napply (pows_test1 y).\napply (pows_test2 y).\napply (pows_test1 y).\napply (pows_test2 y).\napply (pows_test1 y).\napply (pows_test2 y).\napply (pows_test2 y).\napply (pows_test1 y).\napply (pows_test2 y).\napply (pows_test2 y).\napply (pows_test2 yQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply (ars_test1 x y z).\napply (ars_test2 x y z).\napply (ars_test1 x y z).\napply (ars_test2 y z).\napply (ars_test2 x z y).\napply (ars_test2 y z).\napply (ars_test2 y z).\napply (ars_test1 y z).\napply (ars_test1 y z).\napply (ars_test2 y z).\napply (ars_test1 y z).\napply (ars_test2 x y z).\napply (ars_test1 y z).\napply (ars_test2 y z).\napply (ars_test2 x z).\napply (ars_test2 x z).\napply (ars_test2 y z).\napply (ars_test1 y z).\napply (ars_test2 y z).\napply (ars_test1 y z).\napply (ars_test1 y z).\napply (ars_test2 y z).\napply (ars_Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply (ars_test1 x y).\napply (ars_test1 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 x y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test2 y).\napply (ars_test1 y).\napply (ars_test2 y).\napply (ars_test2 x y).\napply (ars_test2 y).\napply (arQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply (ars_test5 x y 0 0 0 0); auto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply (ars_test1 x y (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 x y (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test1 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test1 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test1 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\napply (ars_test1 y 0 (S O)).\napply (ars_test2 y 0 (S O)).\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pred_ext.\nintros; now apply pred_ext.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 336,
                "proof_start_offset": 726,
                "proof_end_offset": 820,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply (ars_test_5 x y H).\napply H0.\napply H.\napply H0.\napply H1.\napply H.\napply H1.\napply H.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H1.\napply H2.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nassert (H := proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H))) H)).\nrewrite <- H.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplit.\napply proj2_sig.\nsplitQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply (ars_test1 x y).\napply (ars_test1 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).\napply (ars_test2 x y).Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npred_compat.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napply pred_compat.\napplyQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply (ars_test3 x y).\napply (ars_test4 x y).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test5 y).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test5 y x).\napply (ars_test4 y).\napply (ars_test4 y x).\napply (ars_test4 y).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test4 y x).\napply (ars_test5 y).\napply (arQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply (ars_test2 x 0 1); auto with real.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\neapply (exp_eq_dec x 0); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, (0 < x -> x  <= x  * y -> 1 <= y)%R.\nintros.\nhyp_polf H0.\nQed.\n\n",
                "context_tokens": 382,
                "proof_start_offset": 822,
                "proof_end_offset": 950,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H1.\napply H.\napply H.\napply H0.\napply H.\napply H1.\napply H0.\napply H.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut ((x * y + x * y) + y * (x + y) * (x + y) * (x + y) * (x + y) * (x + y) * (x + y) * (y + y)).\nintros.\ncut ((x * y + x * y + x * y + y * (x + y) * (y + y) * (x + y) * (y + y) * (x + y) * (y + y) * (y + y)).\nintros.\ncut ((x * y + x * y + x * y + y * (x + y * y) * (x + y) * (x + y) * (y + y) * (x + y) * (y + y) * (x + y) * (y + y)).\nintros.\ncut ((x * y + x * y + y * y + x * y * (x + y * y) * (x + y) * (y + y) * (x + y) * (y + y) * (x + y) * (y + y) * (yQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H.\napply H1.\napply H2.\napply H0.\napply H1.\napply H1.\napply H2.\napply H0.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert z.\ninduction x.\nsimpl.\nrewrite IHx.\napply IHx.\nrewrite IHx.\napply IHx.\nrewrite IHx.\napply IHx.\napply IHx.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H1 as [H2|H2].\nleft.\napply H.\napply H2.\napply H1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert x y z H0.\ndestruct (le_lt_dec x 0).\nsubst z.\napply le_trans with y.\napply le_trans with x.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with x.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with x.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with x.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with y.\napply le_trans with x.\napply le_trans with x.\napply le_trans with y.\napply le_trans with x.\napply le_trans with x.\napply le_trans withQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x + y + z = x + y * x + y * y + y * y + y * y * x).\nintros.\napply (le_trans (S x + y + y * x + y * x + y * y + y * y + y * x)).\napply (le_trans (S x + y + y * x + y * y + y * x + y * y + y * x));\n auto with real.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x * y <= z * x + y * x + y * x + y * y + 2 * x + y * y + 2 * x + y * y + 2 * y + 2 * x * y + 2 * y + 2 * y * x + 2 * y * y + 2 * y + 2 * y * y + 2 * y * y + 2 * y + 2 * x * y + 2 * y + 2 * y * y + 2 * x * y + 2 * y * y + 2 * x * y + 2 * y * y + 2 * y * y + 2 * x * y + 2 * y * y + 2 * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 2 * y * y + 4 * y * y + 2 * y * y +Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct x ; destruct y ; simpl ; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": " (-0)%R; auto with real.\nQed.\n\nTheorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.\nintros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring.\napply Rmult_lt_0_compat; auto with real.\nQed.\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3923,
                "proof_end_offset": 4160,
                "proof": "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H0 H1 H2; rewrite H1; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0; apply Rle_ge; apply Rle_antisym; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0 H1 H2; apply Rle_antisym; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0 H1; rewrite H0; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H0 H1 H2; apply Rle_trans with (y0); auto with real.\napply Rle_trans with (y0); auto with real.\napply Rle_trans with (y0); auto with real.\napply Rle_trans with (y0); auto with real.\napply Rle_trans with (y0); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0 H1 H2; apply Rle_antisym; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H0; rewrite <- (Ropp_involutive y); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H0 H1 H2; rewrite H1; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0 H1 H2 H3; apply Rle_antisym; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rlt_le; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": ".\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4162,
                "proof_end_offset": 4401,
                "proof": "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\napply Rle_trans with (x * y)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y * x)%R; auto with real.\nintros H3; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H5; absurd (y * x <= 0)%R; auto with real.\nintros H5; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H5; absurd (y * x <= 0)%R; auto with real.\nintros H5; absurd (y * x < 0)%R; auto with real.\nintros H5;Qed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\nintros H3; absurd (y * x < 0)%R; auto with real.\nintros H3; absurd (y * x <= 0)%R; auto with real.\nintros H3; absurd (y * x < 0)%R; auto with real.\nintros H3; absurd (y * x <= 0)%R; auto with real.\nintros H3; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x <= 0)%R; auto with real.\nintros H4; absurd (y * x < 0)%R; auto with real.\nintros H5; absurd (y * x < 0)%R; auto with real.\nintros H5; absurd (y * x <= 0)%R; auto with real.\nintros H5; absurd (y * x <= 0)%R; auto with real.\nintros H5; absurd (y * x <= 0)%R; auto with real.\nintros H5;Qed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y * x)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; auto.\napply Rle_ge; apply Rle_ge; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= y)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rle_ge; apply Rlt_trans with (x * y)%R; auto with real.\napply Rlt_le_trans with (y * y)%R; auto with real.\napply Rle_ge; apply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply RltQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y * x)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (x * y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_Rminus; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y * x < 0)%R; auto with real.\napply Rle_ge; apply Rlt_not_le; apply Rlt_Rminus; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4403,
                "proof_end_offset": 4640,
                "proof": "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt x y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; apply Rlt_le; auto with real.\napply Rle_ge; apply Rlt_le; auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; apply Rle_ge; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= y * x)%R; auto with real.\napply Rle_trans with (1 := H1).\napply Rle_trans with (1 := H1).\napply Rle_trans with (1 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (1 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H2).\napply Rle_trans with (2 := H2).\napply Rle_trans with (1 := H2).\napply Rle_trans with (1 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2 := H1).\napply Rle_trans with (2Qed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\nintros H4; absurd (0 <= y)%R; auto with real.\nintros H4; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%R; auto with real.\nintros H5; absurd (y <= 0)%RQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (y * x <= 0)%R; auto with real.\napply Rle_ge; apply Rle_ge; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (x * y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; auto.\napply Rlt_le; apply Rlt_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= x * y)%R; auto with real.\napply Rle_trans with (y * x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= y * x)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y <= 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y <= 0)%R; auto with real.\napply Rle_ge; apply Rle_ge; apply Rlt_Rminus; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\nTheorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4642,
                "proof_end_offset": 4880,
                "proof": "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (y < 0)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; auto with real.\napply Rle_ge; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= x * y)%R; auto with real.\nintros H1 H2; absurd (y < 0)%R; auto with real.\napply Rle_lt_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * y)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_leQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (x * y <= 0)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y * x <= 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y <= 0)%R; auto with real.\nintros H3; absurd (y <= 0)%R; auto with real.\nintros H3; absurd (y * y <= 0)%R; auto with real.\nintros H3; absurd (y * y <= 0)%R; auto with real.\napply Rle_ge; apply Rlt_not_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1; absurd (y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= 0)%R; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Zex.v",
                "context": "Require Import ZArith.\nRequire Import PolTac.\n\nOpen Scope Z_scope.\n\nTheorem pols_test1: forall (x y : Z), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : Z), y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : Z), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with zarith.\nQed.\n \nTheorem pols_test4:\n forall (x y : Z),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <= x  * y)%Z.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 326,
                "proof_start_offset": 711,
                "proof_end_offset": 805,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply pred_ext.\nintros.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.\nintros.\napply pred_ext.Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nassert (H := proj2_sig (proj2_sig x y H0)).\nassert (H1 := proj2_sig (proj2_sig y H0)).\nassert (H2 := proj2_sig (proj2_sig x y H1)).\nassert (H3 := proj2_sig (proj2_sig y H2)).\nassert (H3 := proj2_sig (proj2_sig y H3)).\nassert (H3 := proj2_sig (proj2_sig y H3)).\nassert (H3 := proj2_sig (proj2_sig y H3)).\nassert (H4 := proj2_sig (proj2_sig y H3)).\nassert (H5 := proj2_sig (proj2_sig y H3)).\nassert (H6 := proj2_sig (proj2_sig y H4)).\nassert (H7 := proj2_sig (proj2_sig y H4)).\nassert (H6 := proj2_sig (proj2_sig y H4)).\nassert (H7 := proj2_sig (proj2_sig y H4)).\nassert (H7Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\ngeneralize (ars_test x y).\nintros.\nrewrite <- (ars_test x y).\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H2.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply pred_ext.\nintros.\nrewrite H0.\nnow apply pred_ext.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nassert (H := proj2 H).\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2.\napply proj2Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 2 ; rewrite <- (Rmult_1_l x).\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compatQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\napply pred_ext.\nQed."
                ]
            }
        ],
        "angles": [
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \n",
                "context_tokens": 447,
                "proof_start_offset": 1407,
                "proof_end_offset": 1868,
                "proof": "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v)))); auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply orthogonal_sym; apply orthogonal_sym; apply orthogonal_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply Rle_trans with (app one (opp v)) (map (fun x : Elt => sum (fun y : Elt => sum (fun y : Elt => sum (fun y : Elt => sum y y) y) x)) (union (inter x y) v)));\n auto.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *.\nintros.\napply union_inclus with (union a v); auto.\napply union_inclus with (union (single a) (single a));\n auto.\napply union_inclus with (union a (single a)); auto.\napply union_inclus with (union (single a) (single a)));\n auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)));\n auto.\napply union_inclus with (union (single a) (single a)));\n auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)); auto.\napply union_inclus with (union (single a) (single a)); autoQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply Permutation_sym.\napply perm_sym.\napply Permutation_sym.\napply perm_sym.\napply Permutation_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napply perm_sym.\napplyQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nintros u v H; elim H; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold union in |- *; intros.\napply not_comp with (union (union (interaire v) v)) (union (interaire v) v));\n auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (inter (union (interaire v) v)) (union (interaire v) v));\n auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (union (interaire v) v); auto.\napply union_inclus with (union (inter (aire v) v)); auto.\napply union_inclus with (union (inter (aire v) v)); auto.\napply union_inclus with (inter (inter (aire v) v)); auto.\napply unionQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply sym_equal; apply orthonormal_sym; auto.\napply pairwise_orthogonal_sym; auto.\napply pairwise_orthogonal_sym; auto.\napply pairwise_orthogonal_sym; auto.\napply pairwise_orthogonal_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *.\nintros u v H; elim H; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply union_sym; apply union_sym; auto.\napply union_sym; apply union_sym; auto.\napply union_sym; apply union_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply union_sym with (opp v); auto.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \n",
                "context_tokens": 582,
                "proof_start_offset": 1900,
                "proof_end_offset": 2307,
                "proof": "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros u v w H H0 H1 H2; apply sym_equal; apply orthogonal_sym.\napply extension_intro with (cons u v); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros.\napply Permutation_sym with (interaire_disj a v w); auto.\napply perm_sym with (interaire_disj a w); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros u v w H; elim H; clear H.\nintros v w' H; elim H; clear H.\nintros v w' H; elim H; clear H.\nintros v w' H; elim H; clear H; intros H1 H2; elim H2; clear H2.\nintros v w' H; elim H; clear H; intros H1 H2; elim H2; clear H2.\nintros v w' H; elim H; clear H; intros H1 H2; elim H2; clear H2.\nintros w' H; elim H; clear H; intros H1 H2; elim H2; clear H2.\nintros H; elim H; clear H; intros H2 H3; elim H4; clear H4.\nintros v w' H; elim H; clear H; intros H3 H4; elim H4; clear H4.\nintros w' H; elim H; clear H; intros H4 H5; elim H5; clear H5.\nintros v w' H; elim H; clear H; intros H5 H6; elim H6; clear H6.Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros.\napply permineaire_dec with (map (cons u v) w); auto.\napply permineaire_dec with (map (cons u v) w); auto.\napply permineaire_dec with (map (cons u w)) w; auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_dec with (map (cons u w)); auto.\napply permineaire_Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros.\napply sym_equal; apply orthogonal_sym; auto.\napply permineaire_mod with (interaire v w); auto.\napply sym_equal; apply orthogonal_sym; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold parallel in |- *; intros.\napply (interaire_disj_aire_disj_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_aire_disj_aire_disj_aire_aire_disj_aire_aire_disj_aire_disj_aire_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_aire_disj_Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros u v w H H0 H1 H2.\napply interaire_mod with (map (fun x => a) (pt_interaireu x w));\n auto.\napply perm_sym; auto.\napply perm_sym; auto.\napply perm_sym; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros u v w H1 H2; apply (interaire_Next_def x); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros.\napply not_dansaire_ax with (1 := H); auto.\napply not_dansaire_ax with (1 := H); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros.\napply Permutation_sym with (1 := H); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \nLemma orthogonal_colineaire :\n forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 2310,
                "proof_end_offset": 2663,
                "proof": "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold colineaire in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, union in |- *; intros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n assumption.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold coline in |- *; intros.\napply sym_equal; apply interaire_stable with (interaire_transitive a w); auto.\napply sym_equal; apply interaire_stable with (interaire_transitive a w); auto.\napply sym_equal; apply interaire_stable with (interaire_transitive a w); auto.\napply sym_equal; apply interaire_stable with (interaire_transitive a w); auto.\napply sym_equal; apply interaire_stable with (interaire_transitive a w); auto.\napply sym_equal; apply interaire_stable with (inter aire_transitive a w); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, interaire, interaire, interaire, interaire, interaire, interaire, interaire, interaire, interbire, interaire, interbire, interbire, interbire, interb, interaire, interb, interbire, diffbire, interben, interbire, interb, interbire, interb, interbel, interbel, diffcel, interbel,union et diffbel, interb,me,el, en,ut,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,ll,Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffbire, diffaire, diffaire, diffbire, diffbire, diffaire, diffbire, diffbire, diffbire, diffbire, diffbire, diffben, diffbire, diffbel, diffb decompose, diffbse, diffbire, diffben.\n\nLemma diffb_inter_line :\n forall u v w : V, interaire v w -> interaire v w.\nunfold diff in |- *.\nintros.\napply diffb with (inter a w) (inter (diff b w) (inter a w));\n auto.\napply diffb_inter with (inter (diff b w) (inter b w)); auto.\napply diffb_inter with (diff b w); auto.\napply diffb_inter with (diff b w); auto.\napply diffb_inter with (diff b w); auto.\napply diffb_inter with (diff b w); auto.\napply diffb_inter with (Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, union in |- *; intros.\napply (interaire_transitive (interaire_transitive (interaire_transitive (interaire_interaire_inter a))) a w); auto.\napply union_comp with (inter (single a) (single w)); auto.\napply interaire_transitive with (inter (single a) (single w)); auto.\napply union_comp with (single a); auto.\napply union_comp with (inter (single a) (single w)); auto.\napply union_comp with (inter (single a) (single w)); auto.\napply inter_comp with (single a); auto.\napply interaire_transitive with (inter (single a) (single w)); auto.\napply union_comp with (inter (single a) (single w)); auto.\napply union_comp with (inter (single a) (single w)); auto.\napply interaire_transitive with (inter (single a) (single w)); auto.\napply interaire_transitive with (inter (single a) (single w)); auto.\napply union_comp with (inter (single a)Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, interaire, union in |- *; intros.\napply sym_equal; apply interaire_sym; auto.\napply interaire_transitive with (union a w); auto.\napply union_sym; auto.\napply sym_equal; apply interaire_transitive with (inter a w); auto.\napply interaire_transitive with (inter a w); auto.\napply interaire_transitive with (inter a w); auto.\napply union_sym; auto.\napply interaire_transitive with (inter a w); auto.\napply interaire_transitive with (inter a w); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, unionaire, unionaire, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb.\n\nLemma interbire_transitive : forall u v w : V, union (inter a u) (inter a v) (inter a w).\nunfold union, union, union, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb, unionb.\n\napply unionbel_com.\napply unionbel_com.\napply unionbel_com.\napply unionbel_com.\napply unionbel_com.\napply unionbel_com.\napply unionbel_com.Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply H with (inter a v); auto.\napply (interaire_transitive (cons v w)); auto.\napply interaire_transitive with (union (inter a v) (inter a v)); auto.\napply sym_equal; auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, unionaire, interaire, interaire, interaire, interaire, interaire, interaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffbire, diffbse, diffaire, diffbse, diffbire, diffbse, diffbse, diffbire, diffbse, diffbse, diffbse, diffbse, diffben, diffbse, diffbse, diffbse, diffbse, diffbse, diffben.\n\nLemma diffaire_inire :\n forall a x y : V, diffaire x y -> diffaire y (diffaire x y).\nunfold diffaire, diffaire, diffaire, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb, diffb.\n\nEnd Bool.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffaire, diffbire, diffaire, diffaire, diffbire, diffben, diffbeng, diffaire, diffbire, diffben.\n\nLemma diff_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_Ab_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aire_aQed."
                ]
            }
        ],
        "coq-procrastination": [
            {
                "filepath": "./coq_projects/coq-procrastination/src/Procrastination.v",
                "context": " match goal with |-?G =>\n    match type of G with\n    | Prop => mk_begin_defer_helper_Prop ids H\n    | _ => mk_begin_defer_helper_Type ids H\n    end;\n    cut H; subst H; [| now prove_begin_defer_helper]\n  end.\n\n(* Tests *)\nGoal True.\n  mk_begin_defer_helper tt.\n  intro H; eapply H; clear H.\nAbort.\n\nGoal True.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\nGoal nat.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\n(* [end defer] helpers.\n\n   [end defer] is called on the second subgoal produced by [begin defer], of the\n   form [exists a.. z, group a.. z], where [group a.. z] has been\n   instantiated by [defer] into something of the form [P1 /\\ P2 /\\... /\\ Pn /\\\n  ?P], where P1.. Pn are the propositions that have been deferred, and [?P] is\n   the \"accumulator\" evar.\n\n   The role of [end defer] is to close the goal, instantiating [?P] with [True],\n   and removing it from the goal.\n\n   This is done by first applying a lemma of the form:\n\n   ```\n   forall A.. Z (G1 G2 : A ->.. -> Z -> Prop),\n   (forall a.. z, G1 a.. z -> G2 a.. z) ->\n   (exists a.. z, G1 a.. z) ->\n   exists a.. z, G2 a.. z\n   ```\n\n   After applying this lemma, [G2] is unified with the current goal (to clean),\n   and [G1] is introduced as an evar. An auxiliary tactic\n   ([cleanup_conj_goal_core], defined below) is called on the first subgoal, and\n   will discharge it, instantiating [G1] with the cleaned-up goal (i.e [P1 /\\ P2\n   /\\... /\\ Pn]).\n\n   The helpers below help generating and proving this lemma, for any number of\n   variables [a].. [z].\n*)\n\n(* Tactic that proves the lemma above for any arity. *)\nLtac prove_end_defer_helper :=\n  introsType;\n  let P1 := fresh in\n  let P2 := fresh in\n  let H1 := fresh in\n  let H2 := fresh in\n  intros P1 P2 H1 H2;\n  unfold Marker.end_defer in *;\n  repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x);\n  apply H1; auto.\n\n(* Tests. *)\nGoal forall A (P1 P2 : A -> Prop),\n  (forall a, P1 a -> P2 a) ->\n  (exists a, P1 a) ->\n  Marker.end_defer (exists a, P2 a).\nProof. prove_end_defer_helper. Qed.\n\n",
                "context_tokens": 707,
                "proof_start_offset": 14539,
                "proof_end_offset": 14719,
                "proof": "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_end_defer_helper.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros.\n  pose proof (H _ H0).\n  pose proof (H _ H1).\n  pose proof (H _ H0).\n  pose proof (H0 _ H2).\n  pose proof (H1 _ H3).\n  pose proof (H0 _ H3).\n  pose proof (H1 _ H3).\n  pose proof (H1 _ H3).\n  pose proof (H2 _ H3).\n  pose proof (H1 _ H3).\n  pose proof (H3 _ H4).\n  pose proof (H3 _ H4).\n  pose proof (H4 _ H1).\n  pose proof (H1 _ H3).\n  pose proof (H3 _ H4).\n  pose proof (H1 _ H4).\n  pose proof (H3 _ H4).\n  pose proof (H1 _ H4).\n  pose proof (H1 _ H3).\n  pose proof (H1 _ H4).\n  pose proof (H3 _ H4).\n  pose proof (H1 _ H4).\n  pose proof (H3 _ H4).\n  pose proof (H1 _ H4).\n  pose proof (H1 _ H4).\n  pose proofQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n prove_subst.\n (* We use the [induction] tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n\n(* tactic to solve [induction] tactic *)\n(* tactic to solve [induction] tactic *)\n\n(* tactic to solve [induction] tactic *)\n\n(* tactic [revert] tactic *)\n\n(* tactic [revert tactic] *)\n\nTactic Notation \"revert\" tactic(T) :=\n  let T := fresh in\n  let T := fresh in\n  match type of T with\n  | T => fail\n  | T => idtac\n  | T => idtac\n  | T => idtac\n  | T => idtac\n  | T => idtac\n  endQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. intros. pose proof (P2 a b). intros. pose proof (P2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b). intros. pose proof (Q2 b).Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros A B P1 P2 P2 P3 H1 H2;\n  unfold Marker.\n  intros H1 H2; apply H1; auto.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_split. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_subst. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_subst. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_aux. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_induction 1; intros.\n(* Check that the goal is the one of the same form,\n    which is an evar of [P1 /\\ P2 a b] which is not a lemma of the form [P2 b]. *)\n(* Check that [P2 a b] can be used to have a proof of [P2 b] *)\n\nGoal forall A (P : A -> Prop),\n  (exists a, P a /\\ Q2 a b).\nProof. prove_induction 1; intros.\n(* Check that [P2 a b] can be used to solve the goal of the goal *)\n(* Check that [P2 a b] should be solved. *)\nAbort.\n\n(* Test on the goal of the goal is that the goal is to prove that [P2 a b] is not in the goal *)\n\nGoal forall P : nat -> Prop, P -> P -> P.\nProof. intros.\nFail solve_compute. (* Check that [P2 a b] can be solved *)\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_subst_goal_core. Qed."
                ]
            }
        ],
        "tree-automata": [
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nRequire Import EqNat.\nRequire Export Max.\n\nLemma nat_sum : forall n : nat, n = 0 \\/ (exists m : nat, n = S m).\nProof.\n\tsimple induction n. left. reflexivity. intros. right.\n\tsplit with n0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3102,
                "proof_end_offset": 3223,
                "proof": "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nelim (max_le_Sr_0 n m).\nintros.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tapply max_le_antisym.\n\tapply le_n_S.\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_n_S.\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_max_l.\n\tapply le_n_S.\n\tapply le_trans with (m := S (max n0 n))).\n\tapply le_max_r.\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_max_l.\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_max_l.\n\tapply le_n_S.\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_max_r.\n\tapply le_trans with (m := S (max n0 n)).\n\tapply le_max_r.\n\tapply le_trans with (m := S (max nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tapply le_trans with (max (S n0) m).\n\tapply le_trans with (max (S n0) m).\n\tapply le_max_l.\n\tapply le_max_r.\n\tapply le_max_l.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nsimple induction n.\nauto.\nintros.\napply le_trans with (max (S n0) (S m)).\napply le_max_r.\nexact (le_n_S m (max (S n0) m)).\n\texact (le_n_S m (max (S n0) m))).\n\tapply le_max_r.\n\texact (le_n_S m (max (S n0) m)).\n\tapply le_max_l.\n\texact (le_n_S m (max (S n0) m)).\n\tapply le_max_r.\n\texact (le_n_S m (max (S n0) m)).\n\tapply le_max_r.\n\texact (le_n_S m (max (S n0) m)).\n\tapply le_max_r.\n\texact (le_n_S m (max (S n0) m)).\n\tapply le_max_r.\n\texact (le_n_S m (max (S n0) m)).\n\tintro. rewrite H2 in H1. inversionQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\tintros.\n\trewrite H. rewrite H0. rewrite H. rewrite (max_le_S n m). assumption.\n\tintro. rewrite H0. rewrite (max_le_S n m). assumption.\n\trewrite H. rewrite (max_le_S n m). assumption.\n\trewrite H. rewrite (max_le_S n m). assumption.\n\telim H. intros. split. simpl in |- *. elim (le_or_lt n m).\n\tintros. rewrite H0. rewrite H0. rewrite (max_le_S n m). assumption.\n\telim H. intros. split. simpl in |- *. elim (le_or_lt n m).\n\tintros. rewrite H0. rewrite H. rewrite (max_le_S n m). assumption.\n\telim H. intros. split. simpl in |- *. elim (le_or_lt n m).\n\tintros. rewrite H0. rewrite H0. rewrite (max_le_S n m). assumption.\n\telim H. intros. split. simpl in |- *. elim (Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. apply le_n_S.\n\tapply le_trans with (m := n). assumption.\n\tintros. simpl in |- *. apply le_n_S. apply le_n_S.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_n_S. apply le_n_S.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_trans with (m := n). assumption.\n\tapply le_n_S. applyQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tapply max_le_trans with (max (S n0) m).\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_l.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_le_r.\n\tapply max_leQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_Sn m).\n\tintros. apply le_n_S. apply le_n_S.\n\tapply le_trans with (m := n1 + m).\n\tapply le_trans with (m := m + m).\n\tapply le_trans with (m := m + n0).\n\tapply le_n_S. apply le_n_S.\n\tapply le_n_S.\n\tapply le_trans with (m := n0 + m).\n\tapply le_plus_trans with (m := n0 + m).\n\tapply le_n_S. apply le_n_S.\n\tapply le_n_S.\n\tapply le_trans with (m := n1 + m).\n\tapply le_trans with (m := m + n0).\n\tapply le_n_S.\n\tapply le_trans with (m := n0 + m).\n\tapply le_trans with (m := m + n0).\n\tapply le_n_S. apply le_n_S.\n\tapplyQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros.\n\trewrite (plus_comm (S n) m). rewrite (plus_comm m).\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_Sn 0).\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tapply le_S. assumption.\n\tapply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros. apply le_n_S. assumption.\n\tintros.Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tapply max_le_antisym; auto.\n\tapply le_n_S.\n\tapply le_trans with (max n m); trivial.\n\tapply le_trans with (max n m); trivial.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_l.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_l.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_l.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_l.\n\tapply le_trans with (max n m); trivial.\n\tapply leQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3253,
                "proof_end_offset": 3397,
                "proof": "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *.\ntrivial.\nintros.\nsimpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_n.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_n.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_n.\n\tapply plus_O_l.\n\tapply plus_O_n.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_n.\n\tapply plus_O_l.\n\tapply plus_OQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. split; trivial.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simpl in |- *. rewrite H. reflexivity.\n\tintro. simplQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\telim H.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintro.\nelim plus_O_r.\nelim plus_O_r.\nelim plus_O_r.\napply plus_O_r.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\telim plus_O_r.\n\tintros.\n\telim plus_O_r.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\telim plus_n_O.\n\tintros.\n\tapply plus_n_O.\n\tapply H.\n\tapply H.\n\telim plus_n_O.Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n; trivial.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\trewrite plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_le.\n\tapply plus_O_le.\n\tapply plus_O_le.\n\tapply plus_O_le.\n\tapply plus_O_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_le.\n\tapply plus_O_le.\n\tapply plus_le.\n\tapply plus_OQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\nelim (plus_O_r n m). intros.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_r.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tapply plus_O_n.\n\tQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\telim (le_or_lt n 0). intros. exact (le_n_Sn 0).\n\texact (le_n_Sn 0).\n\tapply le_n_S.\n\texact (le_n_Sn 0).\n\telim (le_or_lt n m). intros. exact (le_n_Sn 0).\n\tapply le_n_S.\n\tapply le_n_S.\n\texact (le_n_Sn 0).\n\tapply le_n_S.\n\texact (le_n_Sn 0).\n\tapply le_n_S.\n\texact (le_n_Sn (S n) (le_n_Sn (S n) H2)).\n\tapply le_n_S.\n\texact (le_n_Sn 0).\n\texact (le_n_Sn (S n) (le_n_Sn 0)).\n\tapply le_n_S.\n\texact (le_n_Sn 0).\n\tapply le_n_S.\n\texact (le_n_Sn 0).\n\texact (le_nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\telim (le_n_O n).\n\tintros.\n\telim (le_n_O n).\n\tintros.\n\telim (le_n_O n).\n\tintros.\n\telim (le_n_S m).\n\tintros.\n\telim (le_or_lt (S m) n).\n\tintros.\n\tapply H.\n\trewrite H0.\n\tapply le_n_S.\n\tapply le_n_S.\n\telim (le_or_lt (S m) n).\tintros.\n\tapply H.\n\trewrite H0.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\telim (le_or_lt (S m) n).\tintros.\n\tapply H.\n\telim (le_or_lt (S m) n).\tintros.\n\tapply H.\n\tapply le_n_S.\n\telim (le_or_lt (S m) n).\tintros.\n\tapply H.\n\tapply le_n_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3399,
                "proof_end_offset": 3543,
                "proof": "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *; trivial.\nintros; simpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. rewrite <- plus_O_r. rewrite <- plus_O_r. rewrite <- plus_0_r.\n\trewrite <- plus_O_r. rewrite <- plus_O_r. rewrite <- plus_0_r. rewrite <- plus_O_r.\n\trewrite <- plus_n_O. rewrite <- plus_n_O. reflexivity.\n\tQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\telim (mult_O_r n).\n\tintros.\n\telim H.\n\tintros.\n\telim (mult_O_r n0).\n\tintros.\n\telim (mult_O_r n).\n\tintros.\n\telim H.\n\tintros.\n\telim H0.\n\tintros.\n\trewrite H1.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H0.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H3.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H0.\n\trewrite <- H3.\n\trewrite H2.\n\trewrite H3.\n\trewrite <- H3.\n\trewrite H3.\n\trewrite H3.\n\trewrite H3.\n\trewrite <- H1.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite HQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintro. elim (mult_O_r n). intros. exact H.\n\telim H. intros. exact (mult_O_r n).\n\telim H0. intros. exact (mult_O_r n).\n\telim H0. intros. exact (mult_O_r n).\n\telim H0. intros. exact (mult_O_r n).\n\telim H0. intros. exact (mult_O_r n).\n\telim H1. intros. exact (mult_O_r n).\n\telim H1. intros. exact (mult_O_r n).\n\telim H1. intros. exact (mult_O_r n).\n\telim H1. intros. exact (mult_O_r n).\n\texact (mult_O_l n).\n\telim H1. intros. exact (mult_O_r n).\n\telim H1. intros. exact (mult_O_l n).\n\telim H1. intros. exact (mult_O_r n).\n\telim H1. intros. exact (mult_O_r n).\n\telim HQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\telim (plus_O_r n 0). intros. exact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_l n 0).\n\texact (plus_O_l n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r n 0).\n\texact (plus_O_r (S n) 0).\n\texact (plus_Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\nelim (plus_O_r n). intros. exact H.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_l n). intros. exact H0.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_l n). intros. exact H0.\n\telim (plus_O_l n). intros. exact H0.\n\telim (plus_O_r n). intros. exact H0.\n\telim (plus_O_l n). intros. exact H0.\n\telim (plus_O_l n). intros. exact H1.\n\telim (plus_O_l n). intros. exact H0.\n\telim (plus_O_r n). intros.Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\nelim (le_n_O n).\n\tintro. simpl in |- *. rewrite H. rewrite H. trivial.\n\tintros. rewrite H. trivial.\n\tintros. rewrite H. trivial.\n\tintros. rewrite H. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3545,
                "proof_end_offset": 3788,
                "proof": "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n.\nsimpl in |- *.\nintro.\ncut (m + 0 = m).\nintros.\nrewrite H.\nexact (le_O_n m).\nexact (plus_O_r m).\nsimpl in |- *.\nintros.\nexact (le_plus_r m (m + n0 * m)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |-Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\nelim (le_plus_l _ m). intros.\n\trewrite H. apply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_rQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3790,
                "proof_end_offset": 4019,
                "proof": "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\ncut (n * m = m * n).\ncut (n * S m = S m * n).\nintros.\nrewrite H.\nrewrite H0.\nexact (le_mult_lS m n).\nexact (mult_comm n (S m)).\nexact (mult_comm n m).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. rewrite H. apply le_plus_l.\n\texact (le_plus_l (S n0) (S m)).\n\tsimpl in |- *. intros. rewrite H. apply le_plus_l.\n\texact (le_plus_r (S n0) (S m)).\n\tsimpl in |- *. intros. rewrite H. apply le_plus_l.\n\texact (le_plus_l (S n0) (S m)).\n\tsimpl in |- *. intros. rewrite H. apply le_plus_r.\n\texact (le_plus_r (S m) (S m)).\n\tsimpl in |- *. intros. rewrite H. apply le_plus_l.\n\texact (le_plus_r (S n0) (S m)).\n\tsimpl in |- *. intros. rewrite H. apply le_plus_l.\n\texact (le_plus_r (S n0) (S m)).\n\tsimpl in |- *. intros. rewrite H. apply le_plus_l.\n\texact (le_plus_l (S n0) (SQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |-Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\telim (le_mult_r_S n m). intros.\n\tapply le_mult_l.\n\texact (le_plus_r m (m + n0 * m)).\n\tapply le_mult_r.\n\texact (le_plus_r m (m + n0 * m)).\n\texact (le_plus_r m (n + m0 * m)).\n\texact (le_plus_r m (n + m0 * m)).\n\texact (le_plus_r n m0 (n + m0 * n0)).\n\texact (le_plus_r n m0 (n + m0 * n0)).\n\texact (le_plus_r n m0 (n + m0 * m0 * n)).\n\texact (le_plus_r n0 (n + m0 * m0 * n0)).\n\texact (le_plus_r n m0 (n + m0 * n0 * n1)).\n\texact (le_plus_l n0 (n + m0 * n0 * n1)).\n\texact (le_plus_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. simpl in |- *. rewrite <- H.\n\treflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. simpl in |- *. rewrite H. reflexivity.\n\tintros. simpl in |- *. rewrite H. reflexivity.\n\tintros.Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\tapply le_mult_r.\n\texact (le_plus_l m (n + m)).\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\texact (le_plus_r m (n + m) (n + m)).\n\tapply le_mult_r.\n\texact (le_plus_r n m).\n\tapply le_mult_r.\n\texact (le_plus_l m n).\n\tapply le_mult_r.\n\texact (le_plus_r n m).\n\texact (le_plus_l m n).\n\tapply le_mult_r.\n\texact (le_plus_r n m n).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m n).\n\tQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. rewrite H. apply le_plus_l.\n\texact (le_plus_r n (m + n0 * m)).\n\texact (le_plus_l n0 (m + n0 * m)).\n\texact (le_plus_r n0 (m + n0 * m)).\n\texact (le_plus_l n0 (m + n0 * m)).\n\texact (le_plus_r n0 (m + n0 * m)).\n\texact (le_plus_r n0 (m + n0 * m)).\n\texact (le_plus_r n0 (m + n0 * m)).\n\texact (le_plus_l n0 (m + n0 * m)).\n\texact (le_plus_r n0 (m + n0 * m)).\n\texact (le_plus_r n0 (m + n0 * m0 * m)).\n\texact (le_plus_r n0 (m + n0 * m0 * n)).\n\texact (le_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite H. rewrite H0. reflexivity.\n\tsimpl in |- *. intros. rewrite H. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *. intros. rewrite H. reflexivity.\n\tsimpl in |- *.Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. rewrite H. apply le_mult_r.\n\texact (le_plus_r n m).\n\tapply le_mult_r.\n\texact (le_plus_r m n).\n\texact (le_plus_r n m).\n\tapply le_mult_r.\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_l n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_rQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\trewrite <- (plus_n_Sm n m).\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_l.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4021,
                "proof_end_offset": 4242,
                "proof": "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\ncut (m <= n \\/ n < m).\nintro.\nelim H0; intros.\nleft.\nexact (le_antisym n m H H1).\nright.\nexact (lt_le_S n m H1).\nexact (le_or_lt m n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_or_lt n m); intros.\n\trewrite H. apply le_antisym.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := m); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := m); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := n); trivial.\n\tapply le_trans with (m := m); trivial.\n\tapply le_trans with (m := n); trivial.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_antisym.\n\texact (le_plus_r_S m n).\n\texact (le_plus_l m n).\n\texact (le_plus_r_S m n).\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite H.\n\tapply le_mult_l.\n\texact (le_mult_l n m).\n\texact (le_mult_r n m).\n\texact (le_mult_r n m).\n\texact (le_mult_r n m).\n\texact (le_mult_l n m).\n\texact (le_mult_r n m).\n\texact (le_mult_l m n).\n\texact (le_mult_r n m).\n\texact (le_mult_l n m).\n\texact (le_mult_r n m).\n\texact (le_mult_r n m).\n\texact (le_mult_r n m).\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\telim (le_or_eq m n).\n\tintros.\n\tapply le_mult_l; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_l; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_r; auto.\n\tapply le_mult_l; auto.\n\tapply le_mult_l; auto.\n\tapply le_mult_r; auto.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim H.\n\tintros.\n\telim H0.\n\trewrite <- H0. exact (le_mult_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_l m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_l m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_r_S m n).\n\texact (le_plus_rQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tcase (le_or_lt n m).\n\tintros.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_rQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_or_lt 0 n).\n\tintros.\n\telim H.\n\trewrite H0. rewrite <- H0. apply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapplyQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\tintros H'.\n\tapply le_antisym; exact (le_O_l m).\n\trewrite H'.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapply le_plus_minus_r; trivial.\n\tapply le_trans with (m := S n).\n\tapplyQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_not_le_eq n m).\n\tintros.\n\tapply le_mult_r.\n\texact (le_plus_l n m).\n\texact (le_plus_l n m).\n\texact (le_plus_r n m).\n\tapply le_mult_r.\n\texact (le_plus_r n m).\n\tapply le_mult_r.\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\n\texact (le_plus_r n m).\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_antisym; trivial.\n\tintros.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\nLemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros. cut (m <= n \\/ n < m). intro. elim H0; intros.\n\tleft. exact (le_antisym n m H H1).\n\tright. exact (lt_le_S n m H1).\n\texact (le_or_lt m n).\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4244,
                "proof_end_offset": 5286,
                "proof": "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintro.\nsimple induction m.\nintros.\ncut (n = 0).\nintro.\nrewrite H0; trivial.\nsymmetry in |- *.\nexact (le_n_O_eq n H).\ninduction n as [| n Hrecn].\nintros.\nsimpl in |- *.\nexact (le_O_n (p + n * p)).\nintros.\nsimpl in |- *.\ncut (n = n0 \\/ S n <= n0).\nintro.\ncut (n * p <= n0 * p).\nintro.\nelim H1; intros.\ncut (p <= p).\nintros.\nexact (plus_le_compat p p (n * p) (n0 * p) H4 H2).\nexact (le_n_n p).\ncut (n * p <= S n * p).\ncut (S n * p <= n0 * p).\nintros.\napply (le_trans (p + n * p) (p + S n * p) (p + n0 * p)).\nexact (plus_le_compat p p (n * p) (S n * p) (le_n_n p) H5).\nexact (plus_le_compat p p (S n * p) (n0 * p) (le_n_n p) H4).\nexact (H p H3).\nexact (le_mult_lS n p).\nelim H1; intros.\nrewrite H2.\nexact (le_n_n (n0 * p)).\ncut (n * p <= S n * p).\nintro.\ncut (S n * p <= n0 * p).\nintro.\nexact (le_trans (n * p) (S n * p) (n0 * p) H3 H4).\nexact (H p H2).\nexact (le_mult_lS n p).\ncut (n <= n0).\nintro.\nexact (le_disj n n0 H1).\nexact (le_S_n n n0 H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim H.\n\tintros.\n\telim H.\n\tintros.\n\telim H0.\n\tintros.\n\telim H0.\n\tintros.\n\telim H1.\n\tapply le_mult_l.\n\tapply le_plus_l.\n\texact (le_plus_l m p).\n\texact (le_plus_l p p).\n\texact (le_plus_r p).\n\texact (le_plus_r p).\n\texact (le_plus_r p).\n\texact (le_plus_r p).\n\texact (le_plus_r p).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_antisym.\n\telim H.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\texact (le_plus_l m p).\n\texact (le_plus_r n p).\n\texact (le_plus_l m p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt n m); intros.\n\trewrite H. exact (le_plus_r n m p).\n\texact (le_plus_l n m p).\n\texact (le_plus_l n m p).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite H.\n\trewrite H.\n\trewrite H0.\n\trewrite (plus_O_r p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\n\trewrite (plus_comm p n).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt n m); intros.\n\tright. exact (le_not_le n m H1).\n\telim (le_or_lt n m); intros.\n\tleft. exact (le_not_le n m H1).\n\tright. exact (le_not_le n m H1).\n\telim (le_or_lt n m); intros.\n\tleft. exact (le_not_le n m H1).\n\telim (le_or_lt n m); intros.\n\tright. exact (le_not_le n m H1).\n\tright. exact (le_not_le n m H1).\n\telim (le_or_lt n m); intros.\n\tleft. exact (le_not_le n m H1).\n\telim (le_or_lt n m); intros.\n\tleft. exact (le_not_le n m H1).\n\telim (le_or_lt n m); intros.\n\tright. exact (le_not_le n m H1).\n\tleft. exact (leQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim H.\n\tintros.\n\telim H0.\n\tintros.\n\telim H1.\n\tintros.\n\telim H2.\n\tintros.\n\telim H1.\n\telim H2.\n\tintros.\n\telim H2.\n\tapply le_trans with (m + S p); auto with arith.\n\tapply le_trans with (m + S p); auto with arith.\n\tapply le_plus_l.\n\texact (le_plus_l m p).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\tintros.\n\telim (le_or_lt n m).\n\tintros.\n\telim (le_or_lt n m).\n\tintros.\n\telim (le_or_lt m n).\n\tintros.\n\tapply (H0 (S m) (S n) (S m) H0).\n\tapply le_S.\n\tapply (le_n_S m n H0).\n\tapply le_S.\n\tapply (le_trans (m + n) (m + n) (S m) H0).\n\tapply le_S.\n\tapply (le_trans (m + n) (m + n) H0).\n\tapply le_S.\n\tapply (le_trans (m + n) (m + n) H0).\n\tapply le_S.\n\tapply (le_trans (m + n) (m + n) H0).\n\tapply le_S.\n\tapply (le_trans (m + n) (m + n) (m + n) H0Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt m n); intros.\n\tleft. exact (le_not_le _ _ H).\n\trewrite H.\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\trewrite H.\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\tapply le_antisym.\n\texact (le_not_le _ _ H).\n\tapply le_antisym.\n\texact (le_not_le _ _ H1).\n\tapply le_antisym.\n\texact (le_not_le _ _ _ H).\n\texact (le_not_le _ _ H1).\n\tapply le_antisym.\n\texact (le_notQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt n m); intros.\n\tleft. exact (le_plus_l n p).\n\trewrite (plus_comm p m).\n\trewrite (plus_comm p m).\n\trewrite (plus_comm p m).\n\trewrite (plus_comm m p).\n\tapply le_plus_l.\n\texact (le_plus_r n m).\n\texact (le_plus_l n m).\n\texact (le_plus_r n m).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite <- plus_n_Sm.\n\tapply le_trans with (n * p); trivial.\n\tapply le_mult_r.\n\texact (le_plus_r p).\n\texact (le_plus_r p).\nQed."
                ]
            }
        ],
        "coquelicot": [
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "\n  exact Hl.\nQed.\n\nLemma linear_cont (l : U -> V) (x : U) :\n  is_linear l -> continuous l x.\nProof.\n  intros Hl.\n  apply filterlim_locally_ball_norm => eps.\n  apply locally_le_locally_norm.\n  case: (linear_norm _ Hl) => M Hn.\n  assert (0 < eps / M).\n    apply Rdiv_lt_0_compat.\n    apply cond_pos.\n    apply Hn.\n  exists (mkposreal _ H) => y Hy.\n  rewrite /ball_norm /minus -linear_opp // -linear_plus //.\n  eapply Rle_lt_trans.\n  by apply Hn.\n  evar_last.\n  apply Rmult_lt_compat_l with (2 := Hy).\n  apply Hn.\n  simpl.\n  field.\n  apply Rgt_not_eq, Hn.\nQed.\n\nLemma is_linear_ext (l1 l2 : U -> V) :\n  (forall x, l1 x = l2 x) -> is_linear l1 -> is_linear l2.\nProof.\n  intros Hl Hl1.\n  split.\n  intros ; rewrite -!Hl ; apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\n  case: Hl1 => _ _ [M Hl1].\n  exists M ; split.\n  by apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\nQed.\n\n(** zero in a linear function *)\nLemma is_linear_zero : is_linear (fun _ => zero).\nProof.\n  repeat split.\n  - move => _ _ ; by rewrite plus_zero_l.\n  - move => k _ ; by rewrite scal_zero_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\n",
                "context_tokens": 753,
                "proof_start_offset": 3935,
                "proof_end_offset": 4211,
                "proof": "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nrepeat split.\nmove => x y.\nnow apply opp_plus.\nmove => k x.\napply sym_eq.\napply: scal_opp_r.\nexists 1 ; split.\nexact Rlt_0_1.\nmove => x ; rewrite norm_opp Rmult_1_l.\nby apply Rle_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  apply is_linear_opp.\n  - move => x ; rewrite!linear_opp.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n    rewrite Ropp_0.\n    apply Ropp_le_contravar.\n   Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros.\n  unfold is_linear, is_linear.\n  rewrite <- (opp_involutive (R:=opp_involutive _)).\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  applyQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  split.\n  - move => x y ; rewrite!linear_opp.\n    apply f_equal.\n    exact Rlt_0_1.\n  - apply f_equal.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - apply f_equal.\n    exact Rlt_0_2.\n  - apply f_equal.\n    exact Rlt_0_1.\n  - apply f_equal.\n    exact Rlt_0_2.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x.\n  rewrite!linear_opp.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  applyQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  unfold is_linear.\n  rewrite <- (opp_involutive (-1)).\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_le_contravar.\n  apply Ropp_leQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  apply is_linear_opp.\n  - move=> x y; rewrite!linear_opp.\n    destruct (linear_norm _ Hl1) as [M1 Hn1].\n    exists M1; split.\n      now apply Rplus_le_compat_l.\n      apply M1.\n    - exists 0; split.\n      now apply Rplus_le_compat_l.\n    - exists 0; split.\n      now apply Rplus_le_compat_l.\n    - exists 0; split.\n      now apply Rplus_le_compat_l.\n    - exists 0%R; split.\n      now apply Rplus_le_compat_l.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  unfold is_linear, is_linear, is_linear, is_linear.\n  intros H.\n  apply (linear_mul_lin_linear_opp _ H).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  split.\n  - intros H.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n  - intros H.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.\n    apply Ropp_le_cancel.Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  exact (is_linear_opp (linear_opp (linear_opp (linear_opp (linear_opp (linear_opp (linear_opp (linear_opp (linear_opp (i))) i)))).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nunfold is_linear, is_linear, is_linear, linear.\nrewrite!linear_opp.\nby apply/linear_opp/linear_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": " - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\n",
                "context_tokens": 740,
                "proof_start_offset": 5017,
                "proof_end_offset": 5487,
                "proof": "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_r.\nmove => u v /= ; apply sym_eq, @scal_assoc.\nexists (norm x + 1) ; split.\napply Rplus_le_lt_0_compat.\napply norm_ge_0.\nexact Rlt_0_1.\nmove => k /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\nnow rewrite Rmult_comm ; apply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n unfold is_linear.\n intros k x ; unfold is_linear_char, is_linear_char, is_linear_left.\n split.\n  - exists 0; split ; [ exact Rlt_le| exact Rlt_le].\n    * exists 0%R; split ; [ exact Rlt_le| exact Rlt_le].\n    * exists 0%R; split.\n      * apply /is_linear_opp; split.\n        * rewrite <- Ropp_0; rewrite <- Ropp_0; apply Ropp_le_contravar.\n        rewrite <- Ropp_0; apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        rewrite Ropp_0; apply Ropp_le_contravar.\n        apply Ropp_le_Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nintro x.\napply (is_linear_scal_mul (fun k : K * V => proj1 k x)).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nunfold is_linear.\nsplit.\n - apply f_equal.\n  - apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\n    + apply f_equal.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n intros k x.\n destruct (is_linear_norm k x) as [N [Hn|Hn].\n - now rewrite Hn.\n - intros k x.\n destruct (is_linear_norm k x) as [N [Hn|Hn].\n - rewrite Hn.\n - now rewrite Hn.\n - intros k x.\n destruct (is_linear_norm k x) as [N [Hn|Hn].\n - rewrite Hn.\n - now rewrite Hn.\n - rewrite Hn.\n - now rewrite Hn.\n - intros k x.\n destruct (is_linear_norm k x) as [N [Hn|Hn].\n - rewrite Hn.\n - now rewrite Hn.\n - rewrite Hn.\n - intros k x.\n destruct (is_linear_norm k x) as [N [Hn|Hn].\n - rewrite Hn.\n - now rewrite Hn.\n - rewrite Hn.\n - intros k x.\n destruct (is_linear_norm k x) as [N [Hn|Hn].\n - rewrite Hn.\n - intros k x.\n destruct (is_linear_norm k x) as [N|N].\n - rewrite Hn.Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n intros k.\n destruct (is_linear_norm k) as [k|k].\n  - exists k; split.\n    * now split.\n      * now split.\n  - intros k x.\n    destruct (is_linear_norm k) as [k|k].\n    + exists k; split.\n      * now split.\n      * now split.\n    * intros k x.\n      destruct (is_linear_norm k) as [k|k].\n      * exists k; split.\n        * now split.\n        * now split.\n        * now split.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n intros k.\n destruct (is_linear_ring k) as [k|k].\n - exists k; split.\n  - exists k; split.\n    - exists k; split.\n      * unfold k.\n        now rewrite <- scal_addEr.\n      * apply scal_multE.\n        rewrite <- scal_addEr.\n        apply scal_multE.\n        apply scal_multE.\n        apply f_equal, IH, IH.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n intros k x.\n rewrite <- is_linear_opp, is_linear_opp, is_linear_opp, is_linear_opp,\n  is_linear_opp, opp_involutive, opp_involutive, opp_involutive, opp_involutive,\n    opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive,\n    opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive,\n    opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive,\n    opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive,\n    opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive, opp_involutive.\n\n(** ** Properties of addition *)\n\nLemma opp_opp_distr : forall opp_opp_distr, opp_distr opp_distr.\nProof.\n intros opp_opp_distr.\n rewrite opp_opp_distr, opp_involutive, opp_involutive, opp_involutive, opp_involutiveQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k.\n  apply (is_linear_scal_r k).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x.\n  induction k ; simpl ; try reflexivity.\n  rewrite conj_all_and.\n  rewrite!linear_opp,!linear_opp,!approx_opp,!opp_involutive.\n  rewrite!opp_involutive,!opp_involutive.\n  now rewrite opp_involutive.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nrewrite /is_linear_sum; apply f_equal.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\nLemma is_linear_scal_l (x : V) :\n  is_linear (fun k : K => scal k x).\nProof.\n  split.\n  - move => u v ; by apply @scal_distr_r.\n  - move => u v /= ; apply sym_eq, @scal_assoc.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply norm_ge_0.\n    exact Rlt_0_1.\n    move => k /=.\n    rewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\n    apply Rplus_le_compat.\n    now rewrite Rmult_comm ; apply norm_scal.\n    apply norm_ge_0.\nQed.\n\n(** [fun x => scal k x] is a linear function if [mult] is commutative *)\n",
                "context_tokens": 724,
                "proof_start_offset": 5562,
                "proof_end_offset": 6076,
                "proof": "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_l.\nmove => u v /= ; apply sym_eq ; rewrite !@scal_assoc.\nby rewrite H.\nexists (abs k + 1) ; split.\napply Rplus_le_lt_0_compat.\napply abs_ge_0.\nexact Rlt_0_1.\nmove => x /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\napply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n intros k k.\n apply is_linear_scal_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n intros k k x.\n apply /is_linear_scal_r.\n - intros k k _.\n    apply /is_linear_scal_r.\n    now rewrite add_comm.\n  - intros k k _.\n    apply /is_linear_scal_r.\n    now rewrite add_comm, <-!scal_opp_l, <-scal_opp_l, <-scal_opp_l.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n intros k k x.\n apply is_linear_scal_r.\n - intros k x.\n  apply sym_eq.\n    apply Hx.\n    apply Hx.\n    apply Hx.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\n    apply Hy.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k Hk ; apply is_linear_scal_r.\n  - apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\n  - apply is_linear_scal_r.\n  - apply is_linear_scal_r.\n  - apply is_linear_scal_r.\n    apply is_linear_scal_r.\n    apply is_linear_scal_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n intros k k.\n destruct (is_linear_plus k k) as [k|k].\n - exists k. apply f_equal.\n - intros k _. rewrite <- (scal_0_l k).\n   apply Rplus_le_compat_l.\n   apply pow_le_0_compat.\n   now apply pow_le_0_compat.\n - apply Rplus_le_lt_0_compat.\n   apply pow_le_0_compat.\n   now apply pow_le_0_compat.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k Hk.\n  apply is_linear_scal_r.\n  - move => k k Hk ; apply sym_eq, opp_plus_le_0_compat.\n    exact Hk.\n  - move => k Hk ; apply sym_eq, opp_plus_le_0_compat.\n    exact Hk.\n  - move => k Hk ; apply sym_eq, opp_plus_le_0_compat.\n    exact Hk.\n  - move => k Hk ; apply sym_eq, opp_plus_le_0_compat.\n    exact Hk.\n  - move => k Hk ; apply sym_eq, opp_plus_le_0_compat.\n    exact Hk.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n intros k k.\n rewrite <-!plus_assoc ; apply f_equal.\n apply opp_scal_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k.\n  rewrite <- (decomp_sum (fun k => scal k x) k).\n  apply sum_ext.\n  - intros k Hk.\n    rewrite Hk, sum_cte.\n    apply f_equal.\n    - now apply opp_mult.\n  - intros k Hk.\n    rewrite Hk.\n    apply Rplus_le_compat_l.\n    apply (proj1 (conj Hk)).\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n intros k.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_r.\n apply is_linear_scal_rQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n move=> k.\n rewrite!plus_assoc.\n rewrite (fun x => (k * x)) at 1.\n rewrite <- (scal_multE 0 k).\n apply/eqP; rewrite!scal_multE, add0r.\n apply/eqP; rewrite!opp_plus_assoc.\n apply/eqP; rewrite!opp_opp_r.\n apply/eqP; rewrite -opp_opp_l.\n apply/eqP; rewrite!opp_opp_r.\n apply/eqP; rewrite -opp_opp_l.\n apply/eqP; rewrite -opp_opp_l.\n apply/eqP; rewrite -opp_opp_r.\n apply/eqP; rewrite -opp_opp_r.\n apply/eqP; rewrite -opp_opp_r.\n apply/eqP; rewrite -opp_opp_r.\n apply/eqP; rewrite -opp_involutive.\n apply/eqP; rewrite -opp_opp_r. apply/eqP; rewrite -opp_opp_r.\n apply/eqP; rewrite -opp_opp_r. apply/eqP; rewrite -opp_opp_r.\n apply/eqP; rewrite -opp_opp_Qed."
                ]
            }
        ],
        "fermat4": [
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "\nLemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.\n\nLemma is_sqr_compat : forall k a : Z,\n  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 20559,
                "proof_end_offset": 20779,
                "proof": "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); rewrite H in H0; clear H; rewrite Zmult_assoc in H0; apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H0; clear H0; intros; auto with zarith.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with a; auto.\n  apply divide_trans with b; auto.\n  apply divide_trans with (b * c).\n  apply divide_trans with b; auto.\n  apply divide_trans with (b * c).\n  apply divide_trans with b; auto.\n  apply divide_trans with b; auto.\n  apply divide_trans with b; auto.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n intros; apply divide_trans with (a * b).\n apply divide_trans with (a * c).\n apply divide_trans with (b * c).\n apply divide_trans with (b * c).\n apply divide_trans with (b * c).\n apply divide_trans with (b * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (b * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c * c).\n apply divide_trans with (c *Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c *Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n intros; apply divide_trans with a; auto.\n apply divide_trans with b; auto.\n apply divide_trans with b; auto.\n apply divide_trans with b; auto.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H; elim H0; clear H0; intros;\n    elim H0; clear H0; intros;\n    elim H0; clear H0; intros; elim H0; clear H0; intros;\n      rewrite H2 in H1; elim (le_lt_trans _ _ _ H1);\n        [ rewrite H1 in H1; rewrite <- H1; rewrite (plus_comm c) in H1;\n          auto with zarith | apply (not_le_trans _ _ _ H1) ].\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply (Build_group_on (fun a b c => a * b) (c * b)).\n  apply (Build_group_on (fun a b c => a * b) (c * b)).\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with a; auto.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (a * b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (a * b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c * b * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divideQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (a * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * b).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (c *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 20781,
                "proof_end_offset": 21011,
                "proof": "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0; exists (q0 - q); rewrite H0; ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H in H0; clear H0; rewrite H0 in H0;\n    elim (divide_refl a c (q0 * q)); intro;\n      [ rewrite H1 in H0; elim (divide_refl b c (q0 * q));\n        [ rewrite H1 in H1; rewrite Zmult_0_r in H1; rewrite Zmult_0_r in H1;\n            rewrite Zmult_0_r in H1; rewrite Zmult_0_r in H1;\n            rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1;\n            rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1;\n              rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1;\n              rewrite Zmult_1_l in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1;\n                rewrite Zmult_1_l in H1; rewrite Zmult_1_r in H1;\n                  rewrite Zmult_1_r in H1; rewrite Zmult_Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q0)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H0);\n    rewrite H in H; clear H0; rewrite Zmult_1_r in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_0_r in H0;\n    auto with zarith.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite (Z_div_plus_full a b c q H0); reflexivity.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_assoc in H1;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_assoc in H1; rewrite Zmult_comm in H0;\n    rewrite Zmult_assoc in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H1;\n    rewrite Zmult_1_r in H1; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_1_l in H1;\n    rewrite Zmult_comm in H0; rewrite Zmult_assoc in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_assoc in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H in H; clear H0; rewrite Zmult_assoc;\n    apply (Zdivide_intro a c (q0 * q0)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H in H; clear H0; rewrite Zmult_1_l in H;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_assoc in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_0_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_0_r in H0;\n    rewrite Zmult_comm in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_comm in H0;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros; apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n    apply divide_sum; apply divide_sum; apply divide_sum;\n      apply divide_sum; apply divide_sum; apply divide_sum; apply divide_sum;\n      apply divide_sum; apply divide_Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_assoc;\n    rewrite (Zmult_comm a c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm a c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm a c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm a b q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0); rewrite (Zmult_comm b c q0);\n    rewrite (Zmult_comm b c q0Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_0_l in H0;\n    rewrite Zmult_plus_distr_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_assoc in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_assoc in H0; rewrite Zmult_comm in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_0_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_0_rQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 21013,
                "proof_end_offset": 21297,
                "proof": "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\nintros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a)) in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro; apply Zdivide_intro with (q := q); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    apply divide_mult_l; assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    generalize (divide_mult_r a b q H); clear H0; intro; rewrite H in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H1; rewrite Zmult_1_l in H0;\n      rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n        rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H1;\n          rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n            rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H1;\n            rewrite Zmult_1_l in H0; rewrite Zmult_0_l in H1;\n              rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0;\n                rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n                rewrite Zmult_1_l in H0; rewrite Zmult1_l in H0;\n                  rewrite Zmult_1_l in H1; rewrite Zmult_l in H0;Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    cut (c * a | b + c * b); auto with zarith; clear H1; intro; rewrite H1 in H0;\n    generalize (Z_div_eq _ _ _ H0); clear H0; intro;\n      generalize (Z_div_eq _ _ _ H1); clear H1; intro;\n        generalize (Z_div_eq _ _ _ H0); clear H0; intro;\n          generalize (Z_div_eq _ _ _ H1); clear H1; intro;\n            generalize (Z_div_eq _ _ _ H2); clear H1; intro;\n            generalize (Z_div_eq _ _ _ H2); clear H2; intro;\n            generalize (Z_div_eq _ _ _ H3); clear H3; intro;\n              generalize (Z_div_eq _ _ _ H3); clear H3; intro;\n                generalize (Z_div_eq _ _ _ H1); clear H3; intro;\n                  generalize (Z_div_eq _ _ _ H3); clear H3; intro;\n                  generalize (Z_Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    rewrite H in H; clear H; rewrite Zmult_1_l in H;\n    rewrite Zmult_1_r in H; rewrite Zmult_1_r in H;\n      rewrite Zmult_comm in H; rewrite H; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite <- H0 in H0;\n    rewrite <- (Zmult_1_l c q0); rewrite H0 in H0;\n    rewrite (Zmult_comm c q0); rewrite (Zmult_1_l q0 q0);\n      rewrite (Zmult_comm (c * a) (c * a)); rewrite (Zmult_1_l b c);\n        rewrite (Zmult_comm c q0); rewrite (Zmult_1_l b q0);\n        rewrite (Zmult_1_l c q0); rewrite (Zmult_comm a q0);\n          rewrite (Zmult_1_l c q0); rewrite (Zmult_1_l q0);\n            rewrite (Zmult_comm c q0); rewrite (Zmult_1_l q0 q0);\n              rewrite (Zmult_comm b q0); rewrite (Zmult_1_l q0);\n                rewrite (Zmult_comm a q0); rewrite (Zmult_1_l q0);\n                rewrite (Zmult_comm a q0); rewrite (Zmult_1_l q0);\n                rewrite (Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H1);\n    rewrite H in H; clear H; rewrite Zmult_1_l in H;\n    rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n    rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n      rewrite Zmult_1_l in H; rewrite Zmult_1_r in H;\n        rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n          rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n          rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n            rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n            rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n            rewrite Zmult_1_r in H; rewrite Zmult_1_l in H;\n              rewrite Zmult_1_l in H; rewrite Zmult_0_l in H;\n              rewrite Zmult_1_l in H; rewrite Zmult_1_l in H;\n              rewrite Zmult_1_l in HQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    generalize (divide_mult_r b c (q * a));\n      rewrite <- (divide_mult_r b c (q * a));\n        rewrite <- (divide_mult_r c (q * a)); apply divide_mult_l.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    rewrite H0; rewrite H0; rewrite H1; rewrite H0; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0);\n    replace (c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + c * b + d * b + c * b + c * b + c * b + d * b + c * b + d * b + c * b + c * b + d * b + c * b + c * b + c * b + d * b + c * b + c * b + d * b + c * b + d * b + d * b + d * b + c * b + d * b + d * b + d * b + d * b + d * b + d * b + d * b + d * b + d * b + dQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H in H0; clear H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_0_r in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_r in H0;\n    rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult1_r in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_0_r in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_l in H0;\n    rewrite Zmult1_l in H0; rewrite Zmult1_r in H0;\n    rewrite Zmult_1_l in HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 21299,
                "proof_end_offset": 21412,
                "proof": "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\nintros; elim H; clear H; intros; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; case (z_eq_dec z 0); intros; auto with zarith; clear H; intros;\n    rewrite H in H0; elim (Z_eq_dec z 0); intro;\n      [ rewrite H0 in H1; rewrite H1 in H1; elim (Z_eq_dec z 0);\n        rewrite H1 in H1; rewrite Zmult_1_r in H1;\n        elim (Z_eq_dec z 0); intro;\n          [ rewrite H0 in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_l in H1;\n            rewrite Zmult_1_r in H1; rewrite Zmult_1_l in H1; simpl in H1;\n            auto with zarith; apply Zle_ge; apply (Zlt_reg_pos z 0 1)\n            | apply (Zlt_reg_neg z 0 1) ] ];\n            assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; rewrite <- (divide_0_r z) in H; discriminate H.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; apply divide_refl.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H.\n  change (z = 0) in H; rewrite H; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; elim H; auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H0; rewrite H0; rewrite H; rewrite H; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; rewrite H; rewrite H; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; apply divide_mult_l; apply divide_mult_l; apply divide_mult_r; assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; rewrite <- (divide_0_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_2_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_2_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_2_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_2_r z H).\n  rewrite (divide_1_r z H).\n  rewrite (divide_2_r z H).\n  rewrite (divide_1Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; apply divide_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\nLemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 21414,
                "proof_end_offset": 21759,
                "proof": "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\nintros; cut (2 <> 0); auto with zarith; intro; generalize (Zdivide_bounds _ _ H2 H3); clear H2; simpl; generalize H; generalize H0; generalize H1; elim z; simpl; intros; progress (auto with zarith) || (elimtype False; auto with zarith).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H1 H2; elim H1; clear H1; intros;\n    case (Z_eq_dec z 0); intro; try (cut False; intro; discriminate).\n  apply H1; rewrite <- H2; ring.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0; rewrite H0 in H0; rewrite H1 in H0; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz H0 H1 H2.\n  elim H1; clear H1; intros z Hz H H3; subst; rewrite H1; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H (q,H).\n  rewrite H in H; discriminate H.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 z0 H2;\n    rewrite H2 in H1; elim H2; intros;\n      rewrite <- H2 in H1; try discriminate H1; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 z H2; rewrite H1; apply divide_refl.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0; rewrite H in H0; clear H0 H0; rewrite H in H0;\n    assumption.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 z H2;\n    rewrite H1 in H2;\n    rewrite H2 in H3; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H0; elim H0; clear H0; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 z H2; rewrite H1; rewrite H2; auto with zarith.\nQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ") \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; elim 1; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nelim n.\nauto.\nauto.\nintros n0 H; elim H.\nauto.\nintros n0 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintros n1 H; elim H.\nauto.\nintrosSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nintro.\nauto with arith.\nintros.\nsimpl in |- *.\nauto with arith.\nintros.\nsimpl in |- *.\nauto with arith.\nintros.\nsimpl in |- *.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; simpl in |- *; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction 1; intros; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nelim n; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros; elim n; simpl in |- *; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; elim 1; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; simpl in |- *; auto with arith.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with *.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n m p H; elim H; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n m p H; elim H; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nsimple induction n0; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nsimple induction 1; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros; elim plus_n_O; auto with arith.\nsimple induction 1; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros; apply plus_reg_l with (n := n); auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros n m p.\nelim n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nintros; rewrite plus_n_Sm; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros n m p; elim p; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros n m p; elim p; simpl in |- *; auto with core.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\nrewrite (size_leaf t).\nauto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\ncase (le_or_eq t u); intros H; rewrite H; simpl in |- *; auto with arith.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H; rewrite H; rewrite H0; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\nsimpl in |- *; elim (size t); simpl in |- *; auto with arith.\nintros.\nelim H; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *; auto with arith.\nintros.\nelim H1; simpl in |- *;Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\npattern t at 2 in |- *; rewrite (plus_n_O p); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; rewrite (size_nil t); simpl in |- *; auto with val.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; apply (H t).\napply lt_wf; auto with arith.\nrewrite H; auto with arith.\nrewrite H; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\npattern (size t) at 1 in |- *; rewrite plus_n_O.\nauto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nintros.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nintros; rewrite plus_n_O; auto with arith.\nintros; rewrite plus_n_O; auto with arith.\nSave size_assoc."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "R l3' b'))\n      end\n  | _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 763,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\nProof.\nintros H.\nFail rewrite <- H.\nAbort.\n\n(* This works, but for example of the last lemma of the last lemma. *)\n\nGoal forall (P Q : Prop),\n  P -> Q ->\n  Q ->\n  Q ->\n  Q.\nProof.\nintros H.\nFail rewrite <- H.\nAbort.\n\n(* The last lemma in 8.1 is the first one of the last lemma. *)\n\nGoal forall (P Q : Prop),\n  P -> Q ->\n  Q.\nProof.\nintros H.\nFail rewrite <- H.\nAbort.\n\n(* The second lemma in 8.1 *)\n\nGoal forall (P Q : Prop),\n  P ->\n  Q ->\n  Q ->\n  Q.\nProof.\nintros H.\nFail rewrite <- H.\nAbort.\n\n(* The second lemma in 8.1 *)\n\nGoal forall (P Q : Prop),\n  P ->\n  Q ->\n  Q ->\n  P ->\n  Q.\nProof.\nintros H.\nFail rewrite <- H.\nAbort.\n\n(* The second lemma in 8.3 *)\n\nGoal forall (P Q : Prop),\n  P ->\n  QSave solution'_b.",
                    "Goal solvable b.\nProof.\nintros H'.\nunfold b at 1 in |- *.\napply H'.\nSave solution'_b.",
                    "Goal solvable b.\n\nintros H.\napply H0.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\nintros H.\nFail eapply sub_proper; eauto.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\npattern (L 1) at 1 in |- *.\napply (derives_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Save solution'_b.",
                    "Goal solvable b.\nProof.\nintros H.\nassert (H' : b = b) by (intros H; apply H; apply H; apply H).\nSave solution'_b.",
                    "Goal solvable b.\n\nProof.\nintro H.\nintro H'.\nintro H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.\nintro H'.\napply H'.Save solution'_b.",
                    "Goal solvable b.\n  intros H.\n  apply: (non solvable_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factorSave solution'_b.",
                    "Goal solvable b.\nProof.\npose (i := mod (i + i) mod b) as i.\npose (i := mod (i + i) mod b) as i.\npose (i := mod (i + i) mod b) as i.\npose (i := mod (i + i) mod b) as i.\npose (i := mod (i + i) mod b) as i.\npose (i := mod (i + i) mod b) as i.\npose (i := mod (i + i) mod b) as i.\npose (i := mod b) as i.\npose (i := mod b) as i.\npose (i := mod b) as i.\npose (i := mod b) as j.\npose (i := mod b) as i.\npose (i := mod b) as i.\npose (i := mod b) in j.\npose (i := mod b) as i.\npose (i := mod b) in i.\npose (i := mod b) as i.\npose (i := mod b) in *.\npose (i := mod b) in *.\npose (iSave solution'_b.",
                    "Goal solvable b.\nintros.\nunfold is_char in *.\n\napply (non_char_on_the_bounds _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4); clear H4 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H14 H15 H15 H16 H16 H16 H17 H17 H17 H17 H19 H20 H20 H20 H20 H21 H22 H22 H22 H22 H22 H23 H24 H25 H26 H27 H27 H29 H30 H31 H32 H32 H32 H33 H33 H34 H35 H36 H36 H37 H37 H38 H37 H38 H38 H38 H38 H39 H40 H40 H39 H41 H42 H43 H44 H45 H47 H47 H47 H47 H47 H49 H49 H47 H47 H49 H48 H49 H49 H49 H49 H49 H49 H49 H49 H49 H49 H49)).\n\nDefinition c0 := exists M, exists M, exists M, exists MSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 758,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nunfold Nic Prost in |- *.\nintros a b.\nrewrite <- (Nto_N a b) at 1.\nrewrite <- (Nto_N b b) at 1.\nrewrite <- (Nto_N b b) at 1.\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nreflexivity.\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nreflexivity.\nrewrite <- (Nto_N b).\nreflexivity.\n(* *)\nintros a b.\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nrewrite <- (Nto_N b).\nreflexivity.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\n\nunfold nia Precfrom_1 in |- *.\nsimpl in |- *.\nauto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold is_a, is_a, is_a, is_a, is_a, is_a, and is_a, but is_a, since it is_a, it is_a, since it is_a, since it is_a, since it is_a, it is_a, since it is_a, since it is_a, since it is_a, since it is_a, since it is_a, since it is_a, since it is_a, since it is_a, since it is_a, since it is_a, the other is_a, since it is_a', it is_a', since it is_a', since it is_a', since it is_a, it is_a', since it is_a', since it is_a', since it is_a, and it is_a', since it is_a', since it is_a', since it is_a', since it is_a', since it is_a', since it is_a', since it is_a', it is_a', since it is_a', since it is_a, since it isSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold Nic Environan_2, NicComR in |- *.\nunfold NicComR in |- *.\nunfold NicComR in |- *.\nunfold NicComR in |- *.\nintros r r r; apply STEP with (r := r); auto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold niconth_2.\nintros H1 H2.\napply (H2 H1 H2).\nintros H3.\napply (H2 H3).\nintros.\napply (H3 H4).\nintros.\napply (H4 H1 H).\nintros.\napply (H4 H2).\nintros.\napply (H4 H2).\nintros.\napply (H4 H3).\nintros.\napply (H H3).\nintros.\napply (H5 H4).\nintros.\napply (H1 H4).\nintros.\napply (H4 H3).\nintros.\napply (H5 H3).\nintros.\napply (H1 H3).\nintros.\napply (H4 H4).\nintros.\napply (H4 H).\nintros.\napply (H5 H2).\nintros.\napply (H5 H4).\nintros.\napply (H2 H3).\nintros.\napply (H5 H3).\nintros.\napply (H5 H3).\nintros.\napply (H4 H3).\nintros.\napply (H1 H4Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* In order to reactive proof of the normal form *)\npose proof I.\n(* In order to prove this lemma, we can do this *)\napply.\n(* In order to prove this lemma, we can apply the fact that we can show that the goal is. *)\n\nLemma F_normal_ret_assert_left: forall (P Q:Prop) (s: clauseset),\n  P s ->\n  ~ P s ->\n  ~ P s ->\n  F s.\nProof.\nintros P Q s H0.\ndestruct H0 as [P [Q [s [H0 [H1 H2]]]].\napply H0.\n(* reactive divergence *)\napply star_refl.\n(* reactive divergence *)\napply star_refl.\n(* reactive divergence *)\napply star_refl.\n(* reactive divergence *)\napply star_refl.\n(* reactive divergence *)\napply star_refl.\n(* reactive divergence *)\napply star_trans with (env s (Goes_wrong t))); auto.\n(* reactive divergence *)\napply star_refl.\n(* reactive divergence *)\napply star_trans with (app (Goes_Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold Nic manipulate in |- *.\nintros N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) | idtac].\nintro N; split; [ try (apply normal_ret_assert; simpl in |- *; tauto) |Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold niaitional_1.\nunfold niaitional_1.\n\nsimple induction 1; intros.\napply STEP with (B := 0).\nsimpl in |- *.\nauto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold nicont_1, even_2, even_2, even_3, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_4, even_5, even_4, even_4, even_5, even_4, even_4, even_4, even_4, even_4, even_5, even_8, even_8, even_8, even_4, even_8, even_4, even_8, even_8, even_8, even_8, even_8, even_8, even_8, even_8, even_8, even_8, even_8,Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold has_at_least_1, has_at_least_1.\napply (H mic12369_1).\n\n(* ===> has_at_least_1, has_at_least_1 *)\napply (H mic12369_2).\n\n(* ===> has_at_least_2, has_at_least_2 *)\napply (H mic12369_2).\n(* ===> has_at_least_2, has_at_least_2 *)\napply (H mic12369_1).\n\n(* ===> has_at_least_1, has_at_least_2 *)\napply (H mic12369_1).\n\n(* ===> has_at_least_2, has_at_least_2, has_at_least_2 *)\napply (H mic12369_1).\n\n(* ===> has_at_least_2, has_at_least_2 *)\napply (H mic12369_2).\n\n(* ===> has_at_least_2, has_at_least_2 *)\napply (H mic12369_2).\n\n(* ===> has_at_least_2Save microban_1_solution."
                ]
            }
        ],
        "goedel": [
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": "\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 9996,
                "proof_end_offset": 10123,
                "proof": "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.\napply cpair.Qed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros a b.\nunfold codeAnd in *.\ndestruct a as [ | a b c].\nrewrite b in *.\nrewrite b in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewrite c in *.\nrewriteQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10202,
                "proof_end_offset": 10332,
                "proof": "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b.\nunfold codeAnd.\ndestruct (f a b) ; simpl.\nreflexivity.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold codeAnd.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrectQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\nLemma codeAndCorrect :\n forall a b : Formula,\n codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.\n\nDefinition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10406,
                "proof_end_offset": 10536,
                "proof": "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeAnd ; intros.\napply codeQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_map.\nrewrite <-!map_Qed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b.\nunfold codeAnd in *.\ndestruct (eval_dec a b) as [ | a b | b c].\nreflexivity.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nsplit.\nintros.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.Qed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "\napply cPairPi2IsPR.\napply pi2_2IsPR.\napply eqIsPR.\napply pi3_3IsPR.\napply pi1_3IsPR.\napply switchIsPR.\napply switchIsPR.\napply\n filter1100IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 12173,
                "proof_end_offset": 12326,
                "proof": "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply isPR 5.\napply codeSubTermIsPR.\napply isPR 4.\napply codeSubTermIsPR.\napply isPR 4.\napply codeSubTermIsPR.\napply isPR 5.\napply codeSubvs_2IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR.\napply codeSubvs_IsPR.\napply isPR 5.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR 4.\napply codeSubvs_IsPR.\napply isPR.\napply codeSubvs_IsPR.\napply: isPR 4.\napply codeSubvs_IsPR.\napply isPRQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply isPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_2IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_IsPR.\napply result_Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nunfold isPR 6 codeSubvs.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napplyQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairCoPC.\napply cPairQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply isPR 5 emptyFunc.\napply cPairCons.\napply cPairFreeL.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\napply cPairCons.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isL.\napply/isQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply cPairCoTermIsPR.\napply cPairCoAlgebraIsPR.\napply cPairCoAlgebraIsPR.\napply cPairCoAlgebraIsPR.\napply cPairCoAlgebraIsPR.\napply cPairCoAlgebraIsPR.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\nLemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 12328,
                "proof_end_offset": 12484,
                "proof": "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi2IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubequality in |- *.\napply ap2_2IsPR.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napply cPairSub.\napplyQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose1_2IsPR.\napply codeSubTermsIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubterm in |- *.\napply ap1_2IsPR.\napply cPairSub1.\napply cPairSub1.\napply cPairSub2.\napply cPairSub1.\napply cPairSub1.\napply cPairSub2.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub2.\napply cPairSub1.\napply cPairSub1.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub2.\napply cPairSub1.\napply cPairSub1.\napply cPairSub2.\napply cPairSub1.\napply cPairSub2.\napply cPairSub2.\napply cPairSub1.\napply cPairSubQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose2_2IsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTermsIsPR 3 codeSubvs.\napply argIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose1_2IsPR.\napply codeSubTermsIsPR.\napply codeSubTermsIsPR.\napply codeSubTermsIsPR.\napply codeSubtypIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubtyp in |- *.\napply compose2_2IsPR.\napply codeSubTermsIsPR.\napply codeSubTermsIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose2_2IsPR.\napply codeSubTermIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose2_2IsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubSub.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubTermIsPR.\napply codeSubvs_IsPR.\napply codeSubequalityIsPR.\napply codeSubQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubtyp in |- *.\napply compose1_2IsL.\napply cPairPi1IsPR.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 226,
                "proof_end_offset": 385,
                "proof": "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nAdmitted.\n\nDefinition test (n : nat) : Prop :=\n  match n with\n  | O => False\n  | S n => match n with\n               | O => False\n               | S n' => n' = S n'\n               end\n  end.\n\nLemma test : forall n : nat, ~ {n : nat | n = 0} + {n : nat | n = 0}.\nAdmitted.\n\nLemma test2 : forall n : nat, {n : nat | n = 0} + {n : nat | n = 0}.\nAdmitted.\n\nLemma test3 : forall n : nat, {n : nat | n = 0} + {n : nat | n = 0}.\nAdmitted.\n\nLemma test4 : forall n : nat, {n = 0} + {n : nat | n = 0}.\nAdmitted.\n\nLemma test6 : forall n : nat, n = 0.\nAdmitted.\n\nLemma test6 : forall n : nat, n = 0.\nAdmitted.\n\nLemma test6 : forall n : nat, n = 0.\nAdmitted.\n\nLemma test6 : forall n : nat, n = 0.\nAdmitted.\n\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\ncase b.\n- by move=> a b; elim: b.\n- by move=> b; apply: (IHn b).\n- by move=> b; apply: (IHn b).\n- by move=> b; apply: (IHn b).\n- by move=> b; apply: (IHn b).\n- by move=> b; apply: (IHn b).\n- by move=> b; apply: (IHn b).\n- by move=> b; apply: (IHn b).\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  apply (well_founded_induction_type (fun n => a = b)).\n  intros n a b.\n  induction n.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction n.\n  - left. apply (exity n).\n    apply (exity n).\n    apply exity.\n    apply exity.\n  - right. apply (exity n).\n    apply exity.\n  - right. apply (exity n).\n    apply exity.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nAdmitted.\n\nFixpoint pick_mem (n : nat) : option nat :=\n  match n with\n  | O => nat\n  | S n' => pick_mem n'\n  end.\n\nFixpoint pick_mem (n : nat) (a : exp) : Prop :=\n  match a with\n  | O => a\n  | S n' => pick_mem n' a\n  end.\n\nDefinition pick_mem (n : nat) (a : exp) : Prop :=\n  match a with\n  | O => a\n  | S n' => pick_mem n' a\n  end.\n\nFixpoint pick_mem (n : nat) (a : exp) : Prop :=\n  match a with\n  | O => a\n  | S n' => pick_mem n' a\n  end.\n\nFixpoint pick_mem (n : nat) (a : exp) : Prop :=\n  match a with\n  | O => a\n  | S n' => pick_mem n' a\n  end.\n\nFixpoint pick_mem (n : nat) (a : exp) : Prop :=\n  match a with\n  | O => a\n  | S n' => pick_mem n' a\n  end.Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  refine (exist _ (fun a => a = b /\\ a = b)).\n  refine (exist _ (fun a => a = b /\\ a = b)).\n  refine (exist _ (fun a => a = b /\\ a = b)).\n  refine (exist _ (fun a => a = b /\\ a = b)).\n  refine (exist _ (fun a => a = b /\\ a = b)).\n  refine (exist _ (fun a => a = b /\\ a = b /\\ a = b)).\n  refine (exist _ (fun a => a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b) _).\n  refine (exist _ (fun a => a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b) _).\n  refine (exist _ (fun a => a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b) _).\n  refine (exist _ (fun a => a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b /\\ a = b) _).\n  refine (exist _ (fun a => a = b /\\ a = b /\\ aDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction n.\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (* 0 *)\n  simpl in |- *.\n  apply (fun x => a = x).\n  (*Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nrefine\n  match n as n return (a = b) with\n  | O => a\n  | S n' => a\n  end.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  refine (exist (fun n : nat => a = S n) (fun n : nat => a = S n) a b).\n  intros n a b.\n  refine (exist (fun n : nat => a = S n) (fun n : nat => a = S n)).\n  intros n a b.\n  refine (exist (fun n : nat => a = S n) (fun n : nat => a = S n)).\n  exact (fun n : nat => a = S n).\n  exact (fun n : nat => a = S n).\n  exact (fun n : nat => a = S n).\n  exact (fun n : nat => a = S n).\n  exact (fun n : nat => a = S n).\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nrefine (fun x : nat => a = x /\\ a = b).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ a = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ a = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ x = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ b = x).\nrefine (fun x : nat => a = x /\\ b = x /\\ b = x).\nrefine (fun x : nat => a = x \\/ b = x /\\ b = x).\nrefine (fun x : nat =>Defined."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\n",
                "context_tokens": 134,
                "proof_start_offset": 387,
                "proof_end_offset": 569,
                "proof": "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (eq_refl a).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = c).\nexact (fun c : nat => match c return nat with end).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = c).\nexact (fun c : nat => match c with | O => 0 end).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (eq_refl (eq_refl a)).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n.\nexact (fun c : nat => n = 0).\nexact (fun c : nat => n = 0).\nexact (fun c : nat => n = 0).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = c).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros n.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\nLemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.\n\n",
                "context_tokens": 197,
                "proof_start_offset": 571,
                "proof_end_offset": 810,
                "proof": "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nsymmetry in |- *.\napply H.\nsimpl in |- *.\nintros.\napply Hrecn.\nsimpl in H.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (eq_ind (fun n : nat => n = n) (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym n)))) (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym n)))) (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym n)))) (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym n)))) (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym n)))) (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym (eq_sym n)))) (eq_sym (eq_sym (eq_sym (eq_Qed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = c).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (eq_refl b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (H a).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (eq_sym a).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (fun c : nat => let c := p in c).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " unfold not in |- *; intros; elim b0.\ninversion H.\nreflexivity.\ninduction (b r r0).\nassert\n (forall (f g : Relations L) (p : f = g) (ts : Terms (arity L (inl _ f)))\n    (ss : Terms (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 8985,
                "proof_end_offset": 9141,
                "proof": "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n intros A B.\n induction A; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros; auto.\n induction B; simpl; intros;Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros A B.\n  unfold lt_depth in |- *.\n  unfold lt_depth in |- *.\n  split.\n  apply le_trans with (log2 A B).\n  apply le_trans with (log2 A B).\n  apply le_max_r.\n  apply le_max_r.\n  apply le_max_r.\n  apply le_max_r.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  induction A ; induction 1; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A.\ninduction A.\n simpl.\ninduction B.\napply IHn.\napply IHtl.\napply IHtl.\napply IHtl.\napply IHtl.\napply IHtl.\napply IHtl.\napply IHtl.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B H.\napply lt_irrefl.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nunfold lt_depth, le_depth in *.\ninduction A; simpl in |- *; intros; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros A B.\n  induction A as [| A' IH]; simpl; auto.\n  apply IH.\n  induction A' as [| A' IH]; simpl; auto.\n  destruct IH.\n  destruct IH.\n  destruct IH.\n  destruct IH.\n  destruct IH.\n  simpl in *.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.\n  intros.\n  apply IH.\n  split.Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nelim (classic (P (P (fun x => P (proj1_sig x))) (P (fun x => P (proj1_sig x))) H); intros.\napply H.\napply H0.\napply H1.\napply H1.\napply H1.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  induction A; simpl; intros; auto.\n  rewrite H0; simpl; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros A B.\n  unfold lt_depth in H.\n  elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H;\n    auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": "s (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 9143,
                "proof_end_offset": 9299,
                "proof": "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (log (S (max (depth A) (depth B))) (depth (depth B))).\napply lt_max_r.\napply le_max_l.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ".\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 9301,
                "proof_end_offset": 9401,
                "proof": "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (max (depth A) (depth B))).\napply lt_max_r.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 9403,
                "proof_end_offset": 9523,
                "proof": "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_trans with (S v).\napply lt_n_Sm.\napply le_max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 9525,
                "proof_end_offset": 9687,
                "proof": "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros A B C H.\napply le_trans with (le_n_Sm A C); auto.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C.\nelim (le_or_lt A B C).\nauto.\nintros A B C.\nelim (le_or_lt B C).\nauto.\nintros A B.\nelim (le_or_lt B C).\nauto.\nintros A1 B1 B2.\nelim (le_or_lt B C).\nauto.\nintros A2 B2.\nelim (le_or_lt B C).\nauto.\nintros A1 B2.\nelim (le_or_lt B1 B1).\nauto.\nintros A3 B3.\nelim (le_or_lt B1 B2).\nauto.\nintros A4 B4.\nelim (le_or_lt B1 B1).\nauto.\nintros A5 B5.\nelim (le_or_lt B1 B2).\nauto.\nintros A6 B5.\nelim (le_or_lt B1 B1).\nauto.\nintros A6 B7.\nelim (le_or_lt B1 B1).\nauto.\nintros AQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C H.\ncase (le_gt_dec A B C); intro.\napply le_trans with B; trivial.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_le_n_Sm.\napply lt_le_trans with B; auto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C H.\nassert (H' : forall A' : DistApproxTree A, lt_depth A' (exist H' A' H)) by (apply lt_le_weak; assumption).\nassert (H' : forall A' : DistApproxTree A, lt_depth A' (exist H' A' H)) by (apply lt_le_weak; assumption).\nassert (H' := H).\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_Qed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_le_trans with (2 := H).\napply lt_le_trans with (2 := H0).\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weakQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_trans with (S (log2 B)); auto.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros A B C.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\napply lt_le_max_r.\napply le_max_r.\napply lt_le_max_r.\napply le_max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ") f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma eqDepth :\n forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 9689,
                "proof_end_offset": 10147,
                "proof": "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H n.\ninduction n as [| n Hrecn].\nintros.\napply H.\nintros.\nunfold lt_depth in H1.\nrewrite <- (le_n_O_eq _ H0) in H1.\nelim (lt_n_O _ H1).\nintros.\napply H.\nintros.\napply Hrecn.\napply lt_n_Sm_le.\napply lt_le_trans with (depth b).\napply H1.\napply H0.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply lt_irrefl.\napply lt_trans with (1 := H).\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weakDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold hereditary in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_r.\napply le_max_r.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold depth in |- *.\nintros.\napply le_trans with (S (fun a : Stream => forall b : Stream, lt_depth a b -> P b)).\napply lt_wf.\nintros a H.\napply le_trans with (S (fun a : Stream => forall b : Stream, lt_depth a b -> P b)).\napply lt_wf.\nintros b H.\napply le_wf.\nintros b H0.\napply le_trans with (S b); auto with arith.\napply le_max_l.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold depth in |- *.\nintros.\nrewrite <- H.\napply le_trans with (P a).\napply le_max_r.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold hereditary in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (P a).\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_S.\napply le_n_S.\napply le_trans with (P a).\napply le_n_Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply lt_irrefl.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\ndestruct n; destruct b; simpl in *; try discriminate;\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *; try discriminate);\ntry (destruct 1; simpl in *;Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply le_trans with (P n); auto.\napply lt_le_weak; auto.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H1 H2.\napply lt_wf_ind with (P:=fun _ => True); auto.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\nunfoldnormG_depth in |- *.\ninduction n.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\nDefined."
                ]
            }
        ],
        "zorns-lemma": [
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " Import Eqdep.\napply inj_pair2 in H2.\ndestruct H2.\napply H3.\nQed.\n\nLemma ord_le_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta <= gamma -> alpha <= gamma.\nProof.\ninduction alpha.\ninduction beta.\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4386,
                "proof_end_offset": 4594,
                "proof": "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_incl; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_incl.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_incl; assumption.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with (ord_le_trans beta).\napply ord_le_trans with (ord_le_trans beta).\napplyQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": ".\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4596,
                "proof_end_offset": 4786,
                "proof": "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial; apply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with (ord_spec x); trivial.\napply ord_le_Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_compat; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta;Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta;Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4788,
                "proof_end_offset": 4941,
                "proof": "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta;Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_lt_le_trans with beta; trivial.\napply ord_lt_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_incl; apply ord_le_incl; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_incl; assumption.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta;Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_lt_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_lt_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans withQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_incl; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\nLemma ord_lt_respects_succ: forall alpha beta:Ordinal,\n  alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4943,
                "proof_end_offset": 7301,
                "proof": "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\ninduction alpha.\ninduction beta.\ndestruct (IHalpha beta) as [|[|]].\nleft; apply ord_lt_respects_succ; trivial.\nright; left.\nsplit.\napply ord_le_respects_succ; apply H.\napply ord_le_respects_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial;\napply ord_le_trans with beta;Qed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with beta; trivial;\napply ord_le_trans with (ord_ord o); trivial;\napply ord_le_Qed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_trans with (ordQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial;\n apply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial; apply ord_le_trans with beta;\n apply ord_le_compat; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\n\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\n\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\n\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\n\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 7303,
                "proof_end_offset": 7689,
                "proof": "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nred; intro alpha.\ninduction alpha.\nconstructor.\nintros beta ?.\napply ord_le_respects_succ_converse in H.\nconstructor; intros gamma ?.\ndestruct IHalpha.\napply H1.\napply ord_lt_le_trans with beta; trivial.\nconstructor; intros alpha ?.\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [j].\ndestruct (H j).\napply H1; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit; intros [n|n].\nintro.\nunfold ord_sub in H.\nunfold ord_ord in H.\napply ord_lt_trans with (o n); trivial.\napply ord_le_sup.\napply ord_le_trans with (o n); trivial.\napply ord_le_sup.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit; intros.\ndestruct H.\ndestruct H.\nsplit.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_sup.\napply ord_le_trans with (o i); trivial.\napply ord_le_sup.\napply ord_le_trans with (o i); trivial.\napply ord_le_sup.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply well_founded_ind_induction with (wf := wf_sort); intros; trivial.\napply well_founded_ind_induction.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_induction_wf; intros.\napplyQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintro.\ndestruct (H (ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_wf ord_Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply wf_lex_wf.\nintros x y.\napply well_founded_lex_wf.\napply wf_lex_wf.\napply well_founded_lex_wf.\napply well_founded_lex_wf.\nintros x y.\napply well_founded_lex_wf.\nintros y z.\napply well_founded_lex_wf.\napply well_founded_lex_wf.\nintros x y.\napply well_founded_lex_wf.\nintros.\ndestruct H as [i].\napply well_founded_lex_wf.\nintros i0.\napply well_founded_lex_wf.\napply well_founded_lex_wf.\napply well_founded_lex_wf.\nintros x y.\napply well_founded_lex_wf.\napply well_founded_lex_wf.\nintros.\ndestruct H0 as [i].\napply well_founded_lex_wf.\napply well_founded_lex_wf.\napply well_founded_lex_wf.\nintros x y.\napply well_founded_lex_wf.\nintros.\ndestruct H0 as [i].Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit.\napply well_founded_lt_wf_compat.\napply well_founded_lt_wf_compat.\napply well_founded_lt_wf_compat.\napply well_founded_lt_wf_compat.\napply well_founded_lt_wf_compat.\napply well_founded_lt_wf_compat.\napply well_founded_lt_compat.\napply well_founded_lt_wf.\napply well_founded_lt_compat.\napply well_founded_lt_compat.\napply well_founded_lt_wf_compat.\napply well_founded_lt_compat.\napply well_founded_lt_compat.\napply well_founded_lt_compat_incl.\napply well_founded_lt_compat.\napply well_founded_lt_compat_incl.\napply well_founded_lt_compat.\napply well_founded_lt_incl_compat.\napply well_founded_lt_compat.\napply well_founded_lt_incl.\napply well_founded_lt_compat.\napply well_founded_lt_compat.\napply well_founded_lt_compat.Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintro; apply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply wellfounded_induction; intros; auto.\napply well_founded_induction; intros; auto.\napply well_founded_Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nunfold well_founded.\nsplit.\napply well_founded_ind.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_induction.\nintros.\ndestruct (H0 i).\nleft.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_incl; assumption.\napply ord_le_trans with (o i); trivial.\napply ord_le_incl; assumption.\napply ord_le_trans with (o i); trivial.\napply ord_le_incl; assumption.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit.\napply well_founded_induction_wf; intros; apply well_founded_induction_wf.\napply well_founded_induction; intros; apply well_induction_wf.\napply well_induction_wf; intros.\napply well_founded_induction_wf; intros; apply well_founded_induction; intros; apply well_induction_wf.\napply well_induction_wf; intros.\napply well_founded_induction; intros; apply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros; apply well_induction_wf; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros; apply well_induction_wf; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros.\napply well_induction_wf; intros.\napply well_induction_wf; intros.\napply well_induction_wf; intros.\napply well_founded_induction; intros; apply well_induction_wf;Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nunfold well_founded; intros.\ndestruct H as [x H].\nsplit; apply I.\nunfold ord_enum in H.\ndestruct H as [i].\nsplit; apply I.\nunfold ord_enum in H.\ndestruct H as [i].\nsplit; apply I.\nunfold ord_enum in H.\ndestruct (H i (ord_trans H0)) as [[i] | H].\napply ord_le_trans with (o i); trivial.\napply ord_le_trans with (o i); trivial.\napply ord_le_sup.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\n",
                "context_tokens": 226,
                "proof_start_offset": 778,
                "proof_end_offset": 1010,
                "proof": "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintros x H.\ngeneralize (Empty_set_is_empty (Ensemble U)); intro H'.\napply H'.\nauto.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Empty_set in H.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set in |- *; intuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\napply empty_family_union.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\n",
                "context_tokens": 305,
                "proof_start_offset": 1059,
                "proof_end_offset": 1278,
                "proof": "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nintros.\nunfold Same_set in *.\nintuition.\nelim H0.\nintros.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans with (empty F); auto with *.\napply Trans withQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nexists x0; auto with *.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\nsplit; intros.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H1.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Included in |- *.\nintuition.\napply H1.\napply H0.\napply H1.\napply H1.\napply H2.\napply H1.\napply H2.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros; apply Extensionality_Ensembles.\nunfold Same_set in H.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nintros.\nunfold Same_set.\nunfold Included in H0.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in H.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Included.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\nLemma subfamily_union: forall F G:Family T, Included F G ->\n  Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.\n\n",
                "context_tokens": 374,
                "proof_start_offset": 1280,
                "proof_end_offset": 1506,
                "proof": "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nconstructor.\ndestruct H0.\nintros.\napply H0.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nintros.\ndestruct H0.\napply H.\napply H0.\napply H.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H1.\napply H2.\napply H0.\napply H2.\napply H1.\napply H0.\napply H0.\napply H2.\napply H0.\napply H1.\napply H2.\napply H2.\napply H0.\napply H0.\napply H2.\napply H2.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H2.\napply H2.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply H.\napply H0.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nsplit.\nintros.\napply H.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nsplit.\nintros.\napply H.\nintros.\napply H0.\nintros.\napply H1.\napply H1.\napply H0.\nintros.\napply H1.\napply H1.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set in *.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nintros.\ndestruct H0.\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nintros.\ndestruct H0.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nintros.\nsplit.\napply H0.\nintros.\napply H.\nintros.\napply H.\napply H1.\nintros.\napply H1.\napply H1.\napply H0.\nintros.\napply H1.\napply H1.\nintros.\napply H1.\napply H.\nintros.\napply H1.\napply H1.\napply H1.\napply H2.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply H0.\napply H1.\napply H1.\napply H2.\napply H2.\napply H1.\napply H1.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set in H.\nintuition.\nintros.\ndestruct H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\nQed."
                ]
            }
        ],
        "coqrel": [
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "inter_refl : typeclass_instances.\n\nLemma rel_inter_corefl_l {A} (R1 R2: rel A A):\n  Coreflexive R1 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6671,
                "proof_end_offset": 6793,
                "proof": "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  unfold rel_impl.\n  intros.\n  destruct (rel_impl_trans R1 R2 x y) as [x y].\n  destruct (rel_iff_trans R2 R3 x y) as [x1 y1].\n  destruct (rel_iff_trans R2 R3 x y1) as [x2 y2].\n  destruct (rel_iff_trans R2 R3 x y2) as [x3 y4].\n  destruct (rel_iff_trans R2 R3 x y4) as [x5 y5].\n  destruct (rel_iff_trans R3 x y5) as [x6 y7].\n  destruct (rel_iff_trans R3 x y5) as [x6 y8].\n  destruct (rel_iff_trans R3 x y5) as [x6 y8].\n  destruct (rel_iff_trans R1 R3 x y5) as [x8 y8].\n  destruct (rel_iff_trans R2 R3 x y5) as [x8 y9].\n  destruct (rel_iff_trans R3 x y9) as [x10 y10].\n  destruct (Qed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros R1 R2 x y [Hxy1 Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [y1 [Hxy2 Hxy3]].\n  destruct (rel_impl_assoc R1 R2 x y) as [y2 [Hxy3 Hxy4]].\n  destruct (rel_impl_assoc R2 R3 x y) as [y3 [Hxy4 Hxy4]].\n  destruct (rel_impl_assoc R1 R2 x y) as [y5 [Hy5 Hxy5]].\n  destruct (rel_impl_assoc R2 R3 x y5) as [y6 [Hy6 Hxy5]].\n  destruct (rel_impl_assoc R1 R2 x y5) as [y6 [Hy7 Hy8]].\n  destruct (rel_impl_assoc R1 R2 x y5) as [y8 [Hy8 Hy8]].\n  destruct (rel_impl_assoc R2 R3 x y5) as [y8 [Hy8 Hy8]].\n  destruct (rel_impl_assoc R1 R3 x y8 y9) as [y10 [Hy8 Hy8]].\n  destruct (rel_impl_Qed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  eapply rel_impl_rintro.\n  apply rel_and_rel_l.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros H x y [Hxy1 Hxy2]; split; assumption.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros R1 R2 x y [Hxy1 Hxy2].\n  etransitivity; eassumption.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  eapply rel_impl_rintro; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 6891,
                "proof_end_offset": 7009,
                "proof": "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros R1 R2 x y [Hxy1 Hxy2] [Hxy1 Hxy2] [Hxy2 Hxy3].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy|Hxy1 Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy1 Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy2|Hxy2 Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy1 Hxy2].\n  destruct (rel_impl_assoc R2 R2 x y) as [Hxy2|Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy2|Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy2|Hxy2].\n  destruct (rel_impl_assoc R2 R2 x y) as [Hxy2|Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy2|Hxy2].\n  destruct (rel_impl_assoc R1 R2 x y) as [Hxy2Qed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  eapply rel_impl_rel_choice; eauto.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply rel_impl_rel_choice.\n  intros.\n  eapply relQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros; unfold rel_impl.\n  intros; unfold rel_impl.\n  intros; split; unfold rel_impl in H.\n  intros; split; unfold rel_impl in H.\n  apply rel_rel_choice.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 7147,
                "proof_end_offset": 7239,
                "proof": "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros; split; intros; auto.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  unfold rel_dec; firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  unfold rel_rel, rel_impl, rel_rel, rel_impl.\n  intros.\n  split; intros.\n  apply rel_trans with (rel x y); auto.\n  apply rel_trans with (rel x y); auto.\n  apply rel_trans with (rel y y); auto.\n  apply rel_trans with (rel y y); auto.\n  apply rel_trans with (rel y y); auto.\n  apply rel_trans with (rel y y); auto.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  unfold rel_impl; unfold rel_bot; unfold rel_bot;\n  intuition.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros x y [Hxy|Hxy]; auto.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros. apply rel_trans with (R:=fun x y => R x y).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y => R y x).\n  apply rel_trans with (R:=fun x y =>Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 7326,
                "proof_end_offset": 7416,
                "proof": "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros x y P H.\n  apply H.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  unfold rel_rel; unfold rel_bot; unfold rel_bot;\n  intros.\n  destruct x; destruct y; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 7595,
                "proof_end_offset": 7683,
                "proof": "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y [Hxy Hyz]; split; assumption.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y.\n  unfold RIntro.\n  apply H.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  unfold rel_top in *.\n  split; intros.\n  destruct H.\n  apply H0.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  unfold rel_dec; destruct x; destruct y; simpl; intuition.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y H; apply H; apply H0; auto.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y H.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y H.\n  destruct (rel_top_l x y H) as [H0|H0].\n  exists x0; split; assumption.\n  destruct (rel_top_l x y H) as [H0|H0].\n  exists x0; split; assumption.\n  destruct (rel_top_r x y H) as [H0|H0].\n  exists x0; split; assumption.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y [Hxy|Hxy]; split; trivial.\n  apply rel_top_trans with y; trivial.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  unfold rel_top.\n  intros.\n  unfold rel_top.\n  split; intros.\n  apply H; auto.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  unfold rel_top in *.\n  destruct (rel_dec x y); [left|right]; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8747,
                "proof_end_offset": 8901,
                "proof": "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  unfold eqrel.\n  split; firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8903,
                "proof_end_offset": 9058,
                "proof": "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\nLemma rel_compose_id_right {A B} (R: rel A B):\n  eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 9060,
                "proof_end_offset": 9315,
                "proof": "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel, rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold eqrel.\n  split; intros x y; firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " sum_rel R R (inl a) (inl b).\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n(** There is an issue with the following. *)\n\nGoal\n  forall A (a b: A) (R: rel A A) (f: A -> A) (p: A -> Prop),\n    Monotonic f (R ++> R) ->\n    Monotonic p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\n",
                "context_tokens": 685,
                "proof_start_offset": 2211,
                "proof_end_offset": 2462,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  apply (H (fun a => a) (fun a => a)) in H.\n  rewrite H.\n  auto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rewrite <- H.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B RA RB Hop x y.\n  apply (Hop x y).\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rewrite <- (H _ H).\n  rewrite <- (H _ H0).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H1 _ H2).\n  rewrite <- (H0 _ H0).\n  rewrite <- (H1 _ H2).\n  rewrite <- (H0 _ H2).\n  rewrite <- (H1 _ H2).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H1 _ H2).\n  rewrite (H2 _ H2).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H0 _ H1).\n  rewrite <- (H0 _ H2).\n  rewrite (H0 _ H2).\n  rewrite <- (H1 _ H1).\n  rewrite (H0 _ H2).\n  rewrite <- (H1 _ H2).\n  rewrite <- (H1 _ H2).\n  rewrite <- (H0 _ H2).\n  rewrite <- (H1 _ H2).\n  rewrite (H0 _ H2).\n  rewrite (H1 _ HQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B RA R x y f g x y f g Heq.\n  simpl.\n  rewrite <- Heq.\n  rewrite <- Heq.\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rewrite <- (R x) at 1.\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite <- (R x).\n  rewrite (R x).\n  rewrite (R x).\n  auto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  unfold f.\n  destruct (rel_choice (fun x => x) (fun y => x)) as [[a b] | ]; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 2464,
                "proof_end_offset": 2664,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2666,
                "proof_end_offset": 2819,
                "proof": "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- R.\n  rewrite <- R.\n  rewrite <- R.\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1.\n  apply (R x y) at 1Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- (R (eq_refl _)).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (Req_refl).\n  rewrite <- (ReqQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- (R_equiv R).\n  rewrite <- (R_equiv R).\n  rewrite <- (R_equiv R).\n  rewrite <- (R_equiv R).\n  rewrite <- (R_equiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (Requiv R).\n  rewrite <- (RequivQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold flip.\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n  rewrite <- (R a).\n Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) at 1.\n  rewrite <- (R_rel R) atQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold uncurry.\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=fun b x => x)).\n  rewrite <- (R_prod (A:=A) (B:=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 2821,
                "proof_end_offset": 2999,
                "proof": "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\n",
                "context_tokens": 715,
                "proof_start_offset": 3599,
                "proof_end_offset": 3825,
                "proof": "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\nintros A R f C x y Hf Hxy.\nFail rauto.\npose proof @f_equal_relim.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x1 y0 H1 H2.\n  case H1; intro H3; subst x1; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nintros A B C R f x1 y H0.\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (f y := fun x => f y).\npose (g y := fun x => g y).\npose (g y := fun x => f y).\npose (g y := fun x => g y).\npose (f y := fun x => g y).\npose (g y := fun x => g y).\n\n(** [rel_curry] is a morphism of the function [f]. *)\n\nGoal forall {A B} (R : rel A B) (f : A -> BQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x y Px Py.\n  pose proof (rel_curry (R --> eq) (R' --> eq) (fun x => x)).\n  unfold R'.\n  rewrite (rel_curry (R --> eq) (fun x => x)).\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x y Hxy.\n  pose proof (eq_rect_eq A B R) as Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x1 y1 x2 y2.\n  apply (H (fun y => f x1 y1) y2) x1 y2).\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  unfold f.\n  apply f_equal.\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x y H.\n  apply (H (f x) (R y)).\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x1 y0 H1 H2.\n  pose proof (R _ _ _ H2).\n  pose proof (R _ _ _ H2).\n  pose proof (R _ _ _ _ H3).\n  pose proof (R _ _ _ H3).\n  pose proof (R _ _ _ H4).\n  pose proof (R _ _ _ H4).\n  pose proof (R _ _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4).\n  pose proof (R _ _ H4Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x y H.\n  unfold Gen in *.\n  apply f.\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C R f x1 y Hx Hy.\n  generalize (eq_rect _ _ _ _ _ _ _ _ _ (proj1 Hx)).\n  intros x y Hx Hy.\n  generalize (eq_rect _ _ _ _ _ _ _ _ (proj2 Hx)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ _ _ (proj2 Hx)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ _ _ (proj2 Hx)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ _ (proj2 Hx)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ _ (proj2 Hy)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ (proj2 Hy)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ (proj2 Hy)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ (proj1 Hy)).\n  intros y Hy.\n  generalize (eq_rect _ _ _ _ (proj2 Hy)).\n  intros Hy.\n  generalize (eq_rect _ _ _ _ (proj2 Hy)).\n  intros Hy.\n  generalize (eq_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ") (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3953,
                "proof_end_offset": 4077,
                "proof": "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\nintros A R x y Hxy Hyy.\nmonotonicity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nintros A R x y Hx Hxy.\nexact (H x y Hx Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H x y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H x Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hxy).\nexact (H y Hy Hxy).\nexact (H y Hxy).\nexact (H y Hy Hxy).\nexact (H y Hy Hxy).\nexact (H y Hxy).\nexact (H y Hxy).\nexact (H y Hxy).\nexact (H y Hxy).\nexact (H y Hxy).\nexact (Hy Hxy).\nexact (Hy Hxy).\nexact (Hy Hxy).\nexact (Hy Hxy).\nexact (Hy Hxy).\nexact (Hy Hxy).\nexact (Hy Hxy).\nexactQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nintros A R x y Hx Hy.\npose proof @f_equal_restr A R x y Hx Hy.\npose proof @f_equal_restr A R x y Hy Hy.\nrewrite Hx at 1.\nrewrite Hx at 1.\nrewrite Hx at 1.\nrewrite Hy at 1.\nauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hf Hxy.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nintros A R x y H.\nFail rewrite <- H.\nAbort.\n\n(* This used to solve this in the [H] tactic to apply the hypothesis\n  hypothesis. *)\n\nGoal forall x y : A, R x y -> False.\nintros x y H.\nsetoid_rewrite H.\nAbort.\n\n(* This used to fail with the goal of the hypothesis [H]\n  to be able to use the hypothesis [H] tactic. *)\n\nGoal forall x y : A, R x y -> False.\nintros x y H.\nsetoid_rewrite H.\nAbort.\n\n(* This used to solve the goal of the goal of the hypothesis [H]\n  to destruct the hypothesis [H] tactic. *)\n\nGoal forall x y : A, R x y -> False.\nintros x y H.\nsetoid_rewrite H.\nAbort.\n\n(* This used to solve the goal of the form [H] tactic. *)\n\nGoal forall x y : A, R x y -> False.\nintros x y H.\nsetoid_rewrite H.\nAbort.\n\n(* This used to fail with Coq 8.8.3 and 8.4 *)\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hx Hy.\n  apply (H (fun x y => eq_refl x) (H y)); auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hf Hxy.\n  apply (H x y Hf Hxy).\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hf Hxy.\n  specialize (H x y H).\n  rewrite <- Hxy.\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nintros A R x y Hf Hxy.\nsetoid x y.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nintros A R x y Hxy.\nFail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hf Hxy.\n  rewrite Hxy.\n  apply f_equal2 with (f y). auto.\n  pose proof @f_equal_pairT2 A R x y f H.\n  rewrite <- (f_equal H).\n  apply g_equal2 with (f y). auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 4556,
                "proof_end_offset": 4698,
                "proof": "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\nintros A R f Hf.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x.\n  rewrite <- (R tt) at 1.\n  apply f.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  apply (R x y Hxy).\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  specialize (H x y Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H.\n  apply (f_equal_project (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R)).\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f g x y Hxy.\n  apply f.\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  rewrite (flip_ext A R f (R x) (R y)).\n  rewrite (flip_ext A R f (R y)).\n  rewrite (flip_ext A R f (R y)).\n  rewrite (flip_ext A R f (R y)).\n  rewrite (flip_ext A R f (R y)).\n  rewrite (flip_ext A R f (R y)).\n  rewrite (flip_ext A R f (R y)).\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  rewrite <- Hxy.\n  rewrite <- Hxy.\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  rewrite (Reflexive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Symmetric _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Symmetric _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n  rewrite (Transitive _ x y Hxy).\n Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  setoid_rewrite (R x) in Hxy.\n  setoid_rewrite (R x) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoid_rewrite (R y) in Hxy.\n  setoidQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f g x y Hxy.\n  apply f.\n  apply f.\n  apply f.\n  apply f.\n  apply f.\n  apply f.\n  apply f.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4997,
                "proof_end_offset": 5177,
                "proof": "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\nintros A R R' f Hf HR.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf'.\n  rewrite Hf in *.\n  apply f_equal_commutes.\n  apply f_equal_commutes.\n  apply f_equal_commutes.\n  apply f_equal_commutes.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  rewrite (flip_ext A R f Hf).\n  rewrite (flip_ext A R f Hf).\n  setoid_rewrite Hf.\n  setoid_rewrite Hf.\n  setoid_rewrite Hf.\n  setoid_rewrite Hf.\n  setoid_rewrite Hf.\n  setoid_rewrite Hf.\n  setoid_rewrite Hf.\n  setoid_rewrite Hf. setoid_rewrite Hf.\n  setoid_rewrite Hf. setoid_rewrite Hf.\n  setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_rewrite Hf. setoid_Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R f Hf.\n  rewrite <- Hf.\n  rewrite <- Hf.\n  rewrite <- Hf.\n  assumption.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R f Hf.\n  rewrite (flip_left (R'==>R)).\n  apply (flip_left (R'==>R)).\n  apply (flip_right (R'==>R')).\n  apply (flip_right (R'==>R)).\n  apply (flip_right (R'==>R)).\n  apply (flip_right (R'==>R')).\n  apply (flip_right (R'==>R)).\n  apply (flip_right (R'==>R')).\n  apply (flip_right (R'==>R'))).\n  apply (flip_right (R'==>R')).\n  apply (flip_left (R'==>R')).\n  apply (flip_right (R'==>R')).\n  apply (flip_right (R'==>R')) (R'==>R')).\n  apply (flip_left (R'==>R')).\n  apply (flip_left (R'==>R') (R'==>R')).\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  split.\n  - intros H.\n    destruct H.\n    apply H.\n    apply H0.\n    apply H1.\n    apply H.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  split.\n  - intros H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  unfold complement in *.\n  apply f.\n  intros x y z Hxy Hyz.\n  apply (H x y z Hxy).\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  transitivity (R' ==> flip R') as Hf.\n  - unfold flip.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in Hf.\n    apply (R' ==> flip R') in HfQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rewrite (flip_morphism (R' ++> flip R') f Hf).\n  rewrite (flip_morphism (R' ++> flip R') f Hf).\n  rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R')) f Hf.\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R')) f Hf.\n  setoid_rewrite (flip_morphism (R'==> flip R')) f Hf.\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R')) f Hf.\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).\n  setoid_rewrite (flip_morphism (R'==> flip R') f Hf).Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  apply (H (R'==>R')).\n  apply (H (R'==>R')).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 5968,
                "proof_end_offset": 6181,
                "proof": "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\nintros A B C R f a1 a2 b c Hf Ha.\nmonotonicity; rauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C a1 a2 b c.\n  split; intros H; inversion H; auto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c.\n  destruct (R a1 a2 b c).\n  + apply R.\n    * apply R.\n    * apply R.\n    * apply R.\n    * apply R.\n    * apply R.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D R f g.\n  destruct (R x y) as [R1 R2].\n  destruct (R1 x y) as [R3 R4].\n  exists R4.\n  exists R4.\n  exists R4.\n  exists R1.\n  split.\n  apply R1.\n  assumption.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  apply (R' a1 b c (R' a1 b c (R' a2 b c (R' a2 b c (R' b c (R' a1 b c (R' b c (R' b c (R' a1 b c (R' b' c (R' b' (R' b' c (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' (R' b' (R' b' (R' b' (R' b' (R' b' (R' b' (R' (R' b' (R' b' (R' b' (R' b'R' (R' b' (R' b' (R' b' (R' (R' b' R' (R' b'Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  unfold symmetric, transitive, transitive.\n  intros.\n  destruct (H _ _ _ H1).\n  destruct (H _ _ H2).\n  destruct (H0 _ _ H2).\n  destruct (H0 _ _ H2).\n  destruct (H0 _ _ H3).\n  destruct (H0 _ _ H3).\n  destruct (H1 _ _ H3).\n  destruct (H2 _ _ H3).\n  destruct (H3 _ _ H3).\n  destruct (H3 _ _ H4).\n  destruct (H3 _ _ H3).\n  destruct (H4 _ _ H4).\n  destruct (H4 _ _ H3).\n  destruct (H4 _ _ H4).\n  destruct (H5 _ _ H3).\n  destruct (H4 _ _ H4).\n  destruct (H5 _ _ H4).\n  destruct (H5 _ _ H4).\n  destruct (H5 _ _ H4).\n  destruct (H5 _ _ H4).\n  destruct (H6 _ _ H4).\n  destruct (H5 _ _ H3).\n  destruct (H5 _ _ H4).\n  destruct (HQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  rauto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  destruct (R a1 b c) as (f,Hf).\n  destruct (R b c) as (f,Hf).\n  destruct (R b c) as (f,Hf).\n  destruct (Hf f) as (f', Hf).\n  destruct (Hf f' b' c) as (f'', Hf).\n  destruct (Hf f'' b' c) as (f'', Hf).\n  destruct (Hf f'' b'' c) as (f'', Hf').\n  destruct (Hf f'' b'' c) as (f'', Hf'').\n  destruct (Hf f'' b'' c) as (f'', Hf'').\n  destruct (Hf f'' b'' c) as (f'', Hf'').\n  destruct (Hf f'' b'' c) as (f'', Hf'').\n  exists (f'', Hf'').\n  split; [apply Hf; assumption | apply Hf''; assumption].\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent induction f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent induction f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent f.\n  dependent induction f.\n  dependent f.\n  dependent induction f.\n  dependent fQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  destruct (rel_and_')#1 as [R' [f' Hf]].\n  exists R'.\n  split.\n  - apply (R' a2 b c).\n    * apply (R' a1 b c).\n    * apply (R' a2 b c).\n    * apply (R' a2 b c).\n    * apply (R' a2 b c).\n    * apply (R' a2 b c).\n    * apply (R' a2 b c).\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hb.\n  generalize dependent f.\n  induction a1; intros.\n  - simpl.\n    destruct (R a1 b1 c) as [t1 t2].\n    destruct (R a2 b c) as [t3 t4].\n    destruct (R a1 b c) as [t5 t5].\n    destruct (R a1 b c) as [t6 t6].\n    destruct (R a1 b c) as [t6 t6].\n    destruct (R a1 b c) as [t6 t7].\n    destruct (R a1 b c) as [t6 t7].\n    destruct (R a1 b c) as [t6 t7].\n    destruct (R a1 b c) as [t6 t7].\n    destruct (R a1 b c) as [t6 t7].\n    destruct (R a1 b c) as [t6 t7].\n    destruct (R a1 b c) as [t7 t8].\n    destruct (R a1 b c) as [t8 t9].\n    destruct (R a1 b c) as [t6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 6183,
                "proof_end_offset": 6385,
                "proof": "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 R1 R2 R HR12 x y.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Hb.\n  generalize (H x y H0); clear H H0.\n  induction H0; intros x y H0 H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H2.\n  inversion H1; subst; clear H2.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst; clear H1.\n  inversion H1; subst;Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 f b c Hf Hb.\n  transitivity (R a1 b c); auto.\n  transitivity (R a1 b c); auto.\n  transitivity (R a1 b c); auto.\n  transitivity (R a2 b c); auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 f a1 a2 b c Hf Hb.\n  apply (H (R1 a2 b c Hf)).\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Hb.\n  case (R a1 b c Hf Hb) as (b, Hb).\n  destruct (R a2 b c Hf Hb) as (b', Hb').\n  destruct (R a2 b c Hf Hb') as (b'', Hb').\n  destruct (R a2 b c Hf Hb') as (c'', Hb').\n  destruct (R a2 b c Hf Hb') as (d'', Hb').\n  exists (a1'', Hb').\n  destruct (R a2 b c Hf Hb') as (d'', Hb').\n  destruct (R a2 b c Hf Hb') as (d'', Hb').\n  destruct (R a2 b c Hf Hb') as (d'', Hb'').\n  destruct (R a2 b c Hf Hb'') as (d'', Hb'').\n  destruct (R a2 b c Hf Hb'') as (d'', Hb'').\n  destruct (R a2 b c Hf Hb') as (d'', Hb'').\n  destruct (R a2 b c Hf Hb'') as (d'', Hb'').\n  destruct (R a2 b c Hf) as (d'', Hb'').\n  destruct (RQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Hb.\n  destruct (rel_and_Verun_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_un_Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Hb.\n  generalize (H _ _ Hf); clear H.\n  intros A3 A4.\n  destruct (rel_and_distrib_l A3 R1 a3 b c Hf Hb) as (f1 & Hf2 & Hf3 & Hf3 & Hf4 & Hf4).\n  exists (f a1 b c); exists (f a2 b c); split; eauto;\n  clear H.\n  intros A5.\n  destruct (rel_and_distrib_l A4 R2 a1 b c Hf Hb) as (f1 & Hf1 & Hf2 & Hf3 & Hf4).\n  exists (f a1 b c); split; eauto;\n  clear H.\n  intros A6.\n  destruct (rel_and_distrib_l A4 R2 a1 b c Hf Hb) as (f1 & Hf2 & Hf3 & Hf4).\n  exists (f a1 b c); split; eauto;\n  clear H.\n  intros A7.\n  destruct (rel_and_distrib_r A5 R1 a1 b c Hf Hb) as (f1 &Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a2 b c Hf Hb.\n  destruct (R a1 b c Hf Ha Hb) as (y,(H1,H2)).\n  exists y; split; auto.\n  exists y; split; auto.\n  exists y; split; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Ha.\n  destruct (R (R' a1 b c Hf)) as [R [R' R'].\n  rewrite R' in *.\n  destruct (R' (R' a2 b c Hf)) as [R' [R' R'].\n  rewrite R' in *.\n  destruct (R' (R' a2 b c Hf)) as [R' [R' R']].\n  rewrite R'.\n  rewrite R'.\n  rewrite R'.\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Hb.\n  generalize (H _ _ Hf); clear H H.\n  intros x y Hx Hy Hxy.\n  split; intros H1 H2.\n  + apply (H x y H1 H2).\n  + apply (H x y H1 H2).\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R f a1 a2 b c Hf Hb.\n  destruct (rel_and_PR R R R R) as [R1 R2].\n  exists R1.\n  split.\n  + apply R1; auto.\n  + apply R2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6615,
                "proof_end_offset": 6735,
                "proof": "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 x2 y2 y3 y4.\n  generalize dependent f.\n  induction x1; destruct y2; destruct y3; simpl in *; intros; subst; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  generalize (H (x1, y1) (x2, y2) (x1, y2) (x1, y2) (x2, y2));\n  intros.\n  rewrite H0 in H.\n  inversion H.\n  reflexivity.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H1 H2.\n  exists (x1, y1); auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  rewrite <- (R1 x1 y1) in H.\n  inversion H; subst; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  split; intros x1 x2 y2 y3.\n  split; intros x3 y3 y4.\n  split; intros x5 y5.\n  split; intros x6 y7.\n  split; intros x7 y8.\n  split; intros x8 y9.\n  split; intros x9 y10.\n  split; intros x10 y11.\n  split; intros x12 y12.\n  split; intros x12 y13.\n  split; intros x12 y13.\n  split; intros x13 y14.\n  split; intros x15 y15.\n  split; intros x15 y16.\n  split; intros x15 y17.\n  split; intros x15 y15.\n  split; intros x15 y15.\n  split; intros x16 y15.\n  split; intros x15 y17.\n  split; intros x15 y16.\n  split; intros x15 y17.\n  split; intros x15 y18.\n  split; intros x15 y15.\n  split; intros x15 y15.\n  split; intros x16 y18.\n  split; intros x15 y18.Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  rewrite (R1 x1 y2 y1).\n  reflexivity.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  generalize (y1, y2);intro H; clear H; subst.\n  split; intros H1 H2; inversion H2.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  destruct (x1, y1); destruct (y2, y2); auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H1 H2.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H2 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H2 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H2 in H1.\n  rewrite H3 in H1.\n  rewrite H1 in H1.\n  rewrite H3Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 6885,
                "proof_end_offset": 7143,
                "proof": "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\nrewrite HR12.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 HR12 x y.\n  split.\n  - unfold R1, R2.\n    apply R1.\n    apply R2.\n    assumption.\n  - unfold R1, R2.\n    apply R1.\n    apply R2.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 HR12 x y.\n  rewrite <- (R1 x y).\n  rewrite <- (R2 x y).\n  rewrite <- (R2 x y).\n  rewrite <- (R3 x y).\n  rewrite <- (R3 x y).\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 HR12 x y.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rewrite H.\n  apply H.\n  assumption.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 C1 C2 R1 R2 HR12 x y.\n  rewrite <- (R1), (R2), (R3).\n  rewrite <- (R3), (R3), (R5).\n  rewrite <- (R5).\n  rewrite (R1), (R3), (R6).\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H0.\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rewrite <- (R1 x y H).\n  rewrite <- (R2 x y H).\n  rewrite <- (R2 x y H).\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 D1 D2.\n  rewrite <- (R1 x), <- (R2 x), <- (R1 x), <- (R2 x), <- (R1 y), <- (R2 x), <- (R2 x), <- (R1 x), <- (R2 x), (R2 y), <- (R2 y), <- (R2 x), (R2 x), (R1 y), <- (R2 y), (R2 y), <- (R2 x), (R1 y), <- (R2 y).\n  intros.\n  rewrite <- (R1 x), <- (R2 x), <- (R2 x), <- (R2 y), <- (R2 y), <- (R2 x), (R2 y), (R2 x), <- (R2 y).\n  intros.\n  rewrite <- (R1 x), <- (R2 x), <- (R2 y), (R2 x), <- (R3 y), (R3 y).\n  intros.\n  rewrite <- (R1 x), <- (R2 x), <- (R2 x), (R2 yQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 HR12.\n  split; auto.\n  + apply R1; auto.\n  + apply R2; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2.\n  destruct (R1 A2 B1 C2) as [R1 R2].\n  destruct (R2 A1 B2 C1) as [R3 R4].\n  destruct (R3 A2 B2 C2) as [R4 R5].\n  destruct (R5 A2 B1 B2 C2) as [R6].\n  destruct (R6 A2 B2 C2) as [R7].\n  destruct (R6 A1 B2 C1) as [R8].\n  destruct (R7 A1 B2 C2) as [R8].\n  destruct (R8 A1 B1 C2) as [R9].\n  destruct (R9 A1 B2 C2) as [R9].\n  destruct (R9 A1 B2 C2) as [R9].\n  destruct (R9 A2 B2 C2) as [R8].\n  destruct (R9 A2 B2 C2) as [R9].\n  destruct (R9 A2 B2 C2) as [R9].\n  destruct (R9 A1 B2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8058,
                "proof_end_offset": 8174,
                "proof": "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\nintros.\nrstep.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\n  apply H0.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros x y z t H.\n  rewrite H in H.\n  rewrite <- H in H.\n  assumption.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros R S T.\n  apply R.\n  apply R.\n  apply R.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rewrite <- (R_refl R).\n  reflexivity.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ": rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 8703,
                "proof_end_offset": 8872,
                "proof": "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rewrite (IHl1 l2 x y z t).\n  rewrite (IHl2 l2 x y t).\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rewrite <- (Permutation_app_iff_nil A B R R') in H1.\n  apply list_rel_eq_refl.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B R l1 l2 x y Hx Hx Hy.\n  rewrite Hx, Hy.\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rewrite <- (Permutation_app_comm _ _ H).\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  transitivity (list_rel R' l1 l2); auto.\n  eapply IHl1; eauto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply H.\n  apply H0.\n  apply H1.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  transitivity (R' (R' ++ l1) (y :: l2) (y :: l2)).\n  apply H.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8967,
                "proof_end_offset": 9084,
                "proof": "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite <- (assoc_reverse (R^~ x) y).\n  rewrite <- (assoc_reverse (R^~ x) y).\n  rewrite <- (assoc_reverse (R^~ x) y).\n  rewrite <- (assoc_reverse (R^~ y)).\n  rewrite <- (assoc_reverse (R^~ x) y).\n  rewrite <- (assoc_reverse (R^~ x) y).\n  reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite <- H0.\n  auto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H.\n  apply H0.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite (R _ H).\n  reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H0.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold R.\n  rewrite <- (RprojT1 f).\n  rewrite <- (RprojT2 f).\n  rewrite <- (RprojT1 f).\n  auto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite H0.\n  reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  eapply rel_pull_right_Rel; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 9180,
                "proof_end_offset": 9343,
                "proof": "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply H0.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite H.\n  apply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f R H1 H2.\n  rewrite <- H1.\n  apply H2.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply H.\n  eauto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f R x y H.\n  rewrite (H (g x) (g y)).\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite <- (R @@ f).\n  rewrite <- (R @@ f).\n  rewrite <- (RprojT1 f).\n  rewrite <- (RprojT1 f).\n  rewrite (RprojT2 f).\n  reflexivity.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply rel_pull_3.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ", opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\nLemma rel_pull_2:\n  forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y,\n    Monotonic g (\u22a4 ==> R @@ f) ->\n    (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_all] *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 9367,
                "proof_end_offset": 9486,
                "proof": "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_ex_intro x); auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_ex_intro _ _ H).\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  exists (x0 a).\n  intros.\n  destruct H0.\n  intuition.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_ex1 (R x) (rforall a, req a x) (rforall a, req a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a, joins a x) (rforall a,Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_compat_r x).\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_all_1 _ _ H).\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_ex_intro x).\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros; eapply rel_all_2; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n",
                "context_tokens": 600,
                "proof_start_offset": 7145,
                "proof_end_offset": 7615,
                "proof": "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B xb xb xb yb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  intros.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H0.\n  rewrite <- H0.\n  auto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B xa xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  by rewrite? xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  intros?b' xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite! xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  by (intros?b' xb xb xb xb xb xb xb xb xb xb xbQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rewrite <- H.\n  rewrite H.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <-Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rewrite <- (andp_com (R1:=R1) (R2:=R2) (R2:=R2) (R3:=R3) (R3:=R3) (R4:=R3) (R4:=R5) (R5:=R6) (R7:=R7) (R6:=R7) (R7:=R7) (R7:=R7) (R7:=R7) (R8:=R8) (R8:=R8) (R8:=R8) (R8:=R8) (R8:=R8) (R8:=R9) (R8:=R8) (R8:=R8) (R9:=R9) (R8:=R8) (R9:=R9) (R8:=R8) (R9:=R8) (R8:=R8) (R9:=R9) (R8:=R9) (R9:=R9) (R9:=R8) (R9:=R9) (R9:=R9) (R10:=R9) (R10:=RQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite!xb; rewrite!xb; rewrite! xb; auto.\n  rewrite! xb; auto.\n  rewrite! xb; auto.\n  rewrite! xb; auto.\n  rewrite! xb; auto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb xb.\n  rewrite!!!xb.\n  apply (proof_irrelevance (QB:=Q)) with (Q:=Q) by auto with typeclass_instances.\n  rewrite <-! xb.\n  apply (proof_irrelevance (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q':=Q) (Q:=Q) (Q) (Q':=Q) (Q':=Q) (Q') (Q':=Q) (Q':=Q) (Q) (Q':=Q') (Q').\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B x y Hx Hyb.\n  rewrite <- (corable_andp _ _ Hxb).\n  rewrite <- (corable_andp _ _ Hxb).\n  rewrite (corable_andp _ _ Hxb).\n  rewrite <- (corable_andp _ _ Hxb).\n  rewrite (corable_andp _ _ Hxb).\n  rewrite <- (corable_sepcon _ _ Hxb).\n  rewrite (corable_andp _ _ Hxb).\n  rewrite (corable_andp _ _ Hxb).\n  rewrite (corable_sepcon _ _ Hxb).\n  rewrite (corable_sepcon _ _ Hxb).\n  rewrite <- (corable_sepcon_andp _ _ Hxb).\n  rewrite <- (corable_sepcon _ _ Hxb).\n  rewrite (corable_sepcon _ _ Hxb).\n  rewrite <- (corable_sepcon_andp _ _ Hxb).\n  rewrite (corable_sepcon _ _ Hxb).\n  rewrite (corable_sepcon _ _ (corable_sepcon _ _ Hxb)).\n  rewrite <- (corable_sepcon _ _ _ Hxb).\n  rewrite corable_andp_sepcon1 by auto.\n  rewrite (corable_sepcon _ _ _ (corable_sepcon _ _ _ Hxb)).\n  rewrite (corable_sepcon_Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B xa1 xb2 yb2 xb1 xb2 xb2 xb2 xb3 xb2 xb3.\n  rewrite! xb1.\n  rewrite! xb2.\n  rewrite! xb2.\n  rewrite! xb1.\n  rewrite! xb2.\n  rewrite! xb1.\n  rewrite! xb2.\n  rewrite! xb2.\n  rewrite! xb1.\n  auto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rewrite <- (rel_prod (R:=fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0)).\n  rewrite <- (rel_prod (R:=fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0)).\n  rewrite <- (rel_prod (R:=fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0)).\n  rewrite <- (rel_prod (R:=fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0)).\n  rewrite <- (rel_prod (R:=fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0)).\n  rewrite <- (rel_prod (R:=fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B x x.\n  rewrite <- (R2 {| B := A := B |}.\n  rewrite (R2 {| B := A; f := B |}.\n  rewrite (R1 {| B := A; f := B |}.\n  rewrite (R2 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R1 {| B := A; f := B |}.\n  rewrite (R2 {| B := B := B |}.\n  rewrite (R2 {| B := B := B |}.\n  rewrite (R3 {| B := B := B |}.\n  rewrite (R1 {| B := B := A |}.\n  rewrite (R3 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R1 {| B := B := A |}.\n  rewrite (R3 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R1 {| B := B := B |}.\n  rewrite (R2 {| B := B := BQed."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intro n.\n  exists 1.\n  apply (pred_n_O (S n)).\n  exists 1.\n  apply (pred_n_O (S n)).\n  apply (pred_n_O (S n)).\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply le_trans with (Zabs n).\n apply le_n_Sn.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n cut (exists q:nat, (exists m : nat, m = (q - m)).\n intro.\n exists (q - m).\n exists (q - m).\n rewrite <- H.\n rewrite <- H.\n rewrite <- H0.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n destruct (le_gt_dec n 1).\n left.\n left.\n apply two_power_pos.\n right.\n assumption.\n right.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintro n.\ncase (le_gt_dec n 1).\ncase (le_gt_dec n 1).\nintro.\nright.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_leQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n   intros.\n   elim H.\n   intros.\n   apply H.\n   intros.\n   apply H.\n   intros.\n   apply H.\n   intros.\n   apply H0.\n   intros.\n   apply H1.\n   intros.\n   apply H0.\n   intros.\n   apply H1.\n   intros.\n   apply H.\n   intros.\n   apply H1.\n   intros.\n   apply H0.\n   intros.\n   apply H0.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H0.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H0.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   intros.\n   apply H1.\n   introsQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n rewrite <- two_power_nat_O.\n apply two_power_nat_S.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n; case n.\n left; reflexivity.\n right; reflexivity.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n.\n case n; simpl in |- *.\n intro.\n left.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply (le_trans _ _ H).\n apply le_trans with (m := n).\n apply le_n_S.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  apply succ_le_lin_r.\n  apply lt_le_weak.\n  apply lt_le_weak.\n  apply lt_le_weak.\n  apply lt_le_weak.\n  apply lt_le_weak.\n  apply lt_le_weak.\n  apply lt_le_weak.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim H.\n  intros.\n  elim (le_gt_dec n (S n) 1).\n  left.\n  elim H0.\n  intros.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists n.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim H.\n  left.\n  reflexivity.\n  right.\n  reflexivity.\n  right.\n  reflexivity.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_gt_dec n 1).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  exists (pred (pred n)).\n  simpl in |- *.\n  replace (pred (pred n)) with (pred (pred n)).\n  auto with arith.\n  apply le_pred_n.\n  exact H2.\n  exact H0.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  exists (pred (pred n)).\n  simpl in |- *.\n  rewrite H0.\n  rewrite H1.\n  apply le_pred_n.\n  exact H0.\n  exact H0.\n  exact H0.\n  exact H0.\n  exact H0.\n  exact H0.\n  exact H0.\n  exact H0.\n  exact H0.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  exists (S (pred (pred (pred n))).\n  auto with arith.\n  exists (S (pred n)).\n  elim H.\n  intros.\n  exists (S (pred (pred n))).\n  auto with arith.\n  exists (pred (pred (pred n))).\n  auto with arith.\n  exists (S (pred (pred n))).\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim H.\n  intros.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim (le_gt_dec n 1).\n  left; apply lt_le_weak.\n  right; apply lt_le_weak.\n  right; apply lt_le_weak.\n  apply lt_le_weak.\n  left; apply lt_le_weak.\n  right; apply lt_le_weak.\n  left; apply lt_le_weak.\n  left; apply lt_le_weak.\n  right; apply lt_le_weak.\n  right; apply lt_le_weak.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  apply one_min_div.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intro.\n  unfold abs in |- *.\n  exists (Zabs (Fnum a)).\n  exists (Zabs (Fnum a)).\n  split.\n  rewrite <- H.\n  apply (Zabs_pos a).\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with 1.\n  apply Zle_ge.\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with 1.\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with 1.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with 1.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with 1.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with 1.\n  apply Zlt_le_weak.\n  apply Zgt_lt.\n  apply Zlt_le_weak.\n  apply Zgt_lt_trans with 1.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  applyQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  destruct a.\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intro.\n  elim (le_gt_dec a 0); auto with arith.\n  elim (le_gt_dec a 0); auto with arith.\n  elim (le_gt_dec a 1); auto with arith.\n  elim (le_gt_dec a 1); auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intro.\n  elim (dec_total a 0).\n  exists 1.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1.\n  split.\n  auto with arith.\n  exists 1Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  rewrite <- (Zabs_eq a).\n  apply Zlt_le_weak.\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  apply (gcd_refl a).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists (a * a).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists (a, (a, a)).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  apply Zlt_le_weak.\n  apply Zle_refl.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\n  exists (a * a).\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  destruct (le_gt_dec a c) as [H|H].\n  left.\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  elim H.\n  exists (a * b).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply mod_trans with (a * b).\n  apply mod_trans with (a * b).\n  apply mod_trans with (b * b).\n  apply mod_trans with (a * b).\n  apply mod_trans with (b * c).\n  apply mod_trans with (a * b).\n  apply mod_trans with (b * c).\n  apply mod_trans with (b * c).\n  apply mod_trans with (b * b).\n  apply mod_trans with (b * c).\n  apply mod_trans with (b * c).\n  apply mod_sym.\n  apply mod_trans with (b * c).\n  apply mod_trans with (c * c).\n  apply mod_refl.\n  apply mod_trans with (c * b).\n  apply mod_trans with (b * c).\n  apply mod_trans with (c * b).\n  apply mod_trans with (b * c).\n  apply mod_sym.\n  apply mod_trans with (c * b).\n  apply mod_trans with (b * c).\n  apply mod_trans with (b * c).\n  apply mod_trans with (b * c).\n  apply mod_Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  destruct (le_gt_dec a b) as [H|H].\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros a b c H.\n  apply (divide_trans (gcd a b) (gcd b c)).\n  apply (divide_trans (gcd a c) (gcd b c)); auto with arith.\n  apply divide_trans with (gcd a b); auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply (divide_trans _ _ (gcd_refl a b) (gcd_refl b c)).\n  apply mod_trans with (gcd a b); auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply mod_le_trans with (a * b).\n  apply mod_le_trans with (a * b).\n  apply mod_divide_l.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (a * b).\n  apply mod_divide_l.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (b * b).\n  apply mod_divide_r.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (a * b).\n  apply mod_divide_r.\n  apply mod_trans with (b * b).\n  apply mod_divide_r.\n  apply mod_trans with (b * b).\n  apply mod_divide_r.\n  apply mod_trans with (b * bQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  case (le_gt_dec a b); auto with arith.\n  case (le_gt_dec c a); auto with arith.\n  apply (le_gt_dec a c); auto with arith.\n  apply (le_gt_dec a c); auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  destruct (le_gt_dec a b) as [Ha|Hb].\n  generalize (divide_0_r _ Hb).\n  destruct (divide_0_r _ Hb).\n  exists (a/b).\n  auto with arith.\n  exists (a/b).\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H;intro q'; elim H0;intro q'; elim q';intro q''; elim q';intro q''; elim q'';\nintros q' H1 q' H2.\n  exists (q' * q').\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H;intro q;intro q; elim q;intro q; intro.\n  rewrite H2 in H1.\n  exists (q' * q').\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  case (divide_dec a b); intros.\n  rewrite H0.\n  auto with arith.\n  apply le_trans with (a * a).\n  apply le_trans with (a * a).\n  apply le_trans with a.\n  apply le_trans with a.\n  apply le_trans with a.\n  apply le_trans with (a * a).\n  apply le_trans with (a * b).\n  apply le_trans with a.\n  apply le_trans with (a * b).\n  apply le_trans with (a * b).\n  apply le_trans with a.\n  apply le_trans with (a * b).\n  apply le_trans with b.\n  apply le_trans with (a * b).\n  apply le_trans with a.\n  apply le_trans with (b * b).\n  apply le_trans with (a * b).\n  apply le_trans with (a * b).\n  apply le_trans with b.\n  apply le_trans with (a * b).\n  apply le_trans with (a * b).\n  apply le_trans with (a * b).\n  apply le_trans with b.\n  apply leQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  red.\n  exists (a+b).\n  auto with arith.\n  exists (a+b).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  red.\n  exists (q * a).\n  auto with arith.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  exists (q * q).\n  rewrite H.\n  auto with arith.\n  auto with arith.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  red.\n  exists (q * a).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  red.\n  exists (a+b).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H;intro q; intro.\n  rewrite H2; auto with arith.\n  exists (q' * q').\n  rewrite H.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  destruct (le_gt_dec a b); auto with arith.\n  exists 0.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros x y z t H.\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm z t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).\nrewrite (mult_comm t).Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite (mult_comm x y z).\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite (mult_comm x z).\n rewrite (mult_comm y z).\n rewrite (mult_comm x z).\n rewrite (mult_comm x z).\n rewrite (mult_comm y z).\n rewrite (mult_comm z).\n rewrite (mult_comm x z).\n rewrite (mult_comm y z).\n rewrite (mult_comm z).\n rewrite (mult_comm x z).\n rewrite (mult_comm y z).\n rewrite (mult_comm x z).\n rewrite (mult_comm x z).\n rewrite (mult_comm y z).\n rewrite (mult_comm y z).\n rewrite (mult_comm z).\n rewrite (mult_comm y z).\n rewrite (mult_comm z).\n rewrite (mult_comm z).\n rewrite (mult_comm y z).\n rewrite (mult_comm x z).\n rewrite (mult_comm y z).\n rewrite (mult_comm y z).\n rewrite (mult_comm x z).\n rewrite (mult_comm y zQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite <- plus_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_comm.\n  rewrite (mult_comm y).\n  rewrite (mult_comm x).\n  rewrite (mult_comm x).\n  rewrite mult_comm.\n  rewrite (mult_comm x).\n  rewrite mult_comm.\n  rewrite (mult_comm y).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_comm.\n  rewrite (mult_comm y).\n  rewrite (mult_comm x).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm x).\n  rewrite (mult_comm y).\n  rewrite mult_comm.\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm x).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  rewrite (mult_comm yQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x.\nsimpl.\nintro;rewrite mult_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\napply mult_le_compat_r in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.\nrewrite plus_comm in H.Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  assert (x*z*t = (x*z*t) \\/ (x*z*t = (x*z*t)).\n  apply mult_lemma3;intro;auto with arith.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  simpl in H0.\n  omega.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x.\nsimpl.\n trivial.\nsimpl.\nintros.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.\nsimpl.\nintros.\nrewrite mult_comm.Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n intros.\n generalize (mult_lemma3 x y z t);intro.\n elim H;intro;intros; (auto || elim H; auto || elim H; auto).\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros;destruct x;destruct y;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;destruct z;simpl;destruct z;simpl;destruct z;simpl;try destruct z;destruct z;simpl;try destruct z;simpl;try destruct z;simpl;try destruct z;simpl;try destruct z;simpl;try destruct z;try destruct t;simpl;try destruct i;simpl;try destruct t;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;try destruct i;simpl;tryQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y;intros;rewrite mult_comm;simpl;f_equal.\n  rewrite mult_comm;rewrite mult_comm;rewrite (mult_comm y z);trivial.\n  rewrite mult_comm;rewrite (mult_comm y z);trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma1;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma1;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma1;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma1;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma1;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma1;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  elim (mult_lemma1 a b);intro H; elim H;intros;auto with arith.\n  intros b H.\n  rewrite mult_comm;apply mult_comm;apply mult_comm;apply mult_comm.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply plus_le_compat_r;auto with arith.\n  apply mult_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply mult_le_compat_r;auto with arith.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply mult_lemma1;trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  elim (mult_comm a b).\n  trivial.\n  trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  generalize (mult_lemma2 n a b); intros.\n  rewrite <- (mult_n_O a b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (mult_n_O b);intro.\n  rewrite <- (multQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  intros.\n  trivial.\n  simpl.\n  intros.\n  trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply plus_le_compat;auto.\n  apply le_lt_trans with a;auto.\n  apply plus_le_compat;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n case (le_lt_dec y z);intro.\n rewrite (minus_lemma1 y z l);rewrite mult_comm;simpl;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_equal;f_Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2;assumption.\n  apply plus_minus_lemma2;assumption.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma1 y z l);rewrite mult_comm;simpl;rewrite minus_plus;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_plus;trivial;auto with arith.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma1; assumption.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma1 with (y:=z).\n  trivial.\n  apply plus_minus_lemma2 with (y:=z).\n  trivial.\n  apply plus_minus_lemma1 with (y:=z).\n  trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n apply plus_minus_lemma2; auto with arith.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n apply plus_minus_lemma2;auto with arith.\n apply plus_minus_lemma1;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (minus_minus z y z).\n  rewrite (minus_minus z y z).\n  rewrite (minus_minus z y);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;apply plus_comm;auto with *.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply plus_minus_lemma2;assumption.\n  assumption.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (minus_minus_lemma2 y z l);rewrite (plus_minus_lemma2 y z l);rewrite (plus_minus_lemma1 y z l);assumption.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_minus_lemma1 y z l);rewrite (plus_minus_lemma1 y z l);rewrite (plus_minus_lemma1 y z l);trivial;auto with arith.\n  rewrite plus_comm;rewrite (mult_comm y z);rewrite (mult_comm y z);trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply plus_minus_lemma2;trivial.\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y z);try (auto with arith).\n  rewrite plus_minus_lemma2;rewrite <- minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_minus_lemma1 x y z l);rewrite plus_comm;simpl;rewrite minus_minus;trivial;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y z);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_minus z y z);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y z);trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_minus z y);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;simpl;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite (plus_minus_lemma2 y z);trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply minus_plus;auto with arith.\n  assert (x+z==z).\n  rewrite (minus_minus z y);auto with arith.\n  rewrite minus_plus;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply plus_minus_lemma2 with (x:=z).\n  trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply minus_lt_eq.\n  rewrite minus_plus;trivial.\n  rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  destruct (le_lt_dec b a);intro.\n  rewrite (minus_le_minus b a);trivial.\n  intros.\n  rewrite (minus_le_minus b a);trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nintros.\nrewrite mult_n_O.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_leQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n unfold mult in |- *.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n applyQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_integral_l with (n := n) (n := n); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n simple induction n; intros.\n simpl in |- *.\n rewrite mult_assoc_reverse.\n rewrite <- plus_n_O.\n rewrite mult_assoc_reverse.\n rewrite plus_assoc.\n rewrite <- plus_n_O.\n rewrite plus_comm.\n rewrite mult_plus_distr_l.\n rewrite mult_comm.\n rewrite plus_comm.\n rewrite <- mult_plus_distr_r.\n rewrite plus_comm.\n rewrite <- plus_assoc.\n rewrite plus_comm.\n rewrite <- plus_assoc.\n rewrite (mult_comm (n + m)).\n rewrite (mult_comm (n + m)).\n rewrite mult_plus_distr_r.\n rewrite mult_assoc.\n rewrite (mult_comm (n + m)).\n rewrite (mult_comm (n + m)).\n rewrite mult_assoc.\n rewrite <- plus_comm.\n rewrite plus_assoc.\n rewrite (mult_comm (n + m)).\n rewrite (mult_comm (n + m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n + m)).\n rewrite mult_comm.\n rewrite <- mult_assoc.\n rewrite (mult_Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite <- (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite <- (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite <- (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply plus_le_compat_r.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_comm.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_plus_distr_r.\n rewrite mult_assoc.\n rewrite mult_plus_distr_r.\n rewrite mult_comm.\n rewrite mult_plus_distr_r.\n rewrite mult_comm.\n rewrite mult_plus_distr_r.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_comm.\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n * m)).\n rewrite mult_assoc.\n rewrite (mult_comm (n *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply multQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n apply mult_lemma2.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_lemma1; auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_lQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  intros.\n  rewrite <- H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  intros.\n  apply mult_lemma2.\n  intros.\n  apply mult_lemma3.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  destruct n.\n  left.\n  apply mult_lemma3; auto with arith.\n  elim H0; trivial.\n  right.\n  apply mult_lemma3; auto with arith.\n  elim H0; trivial.\n  right.\n  apply mult_lemma3; auto with arith.\n  elim H0; trivial.\n  left.\n  apply mult_lemma1; auto with arith.\n  left.\n  apply mult_lemma1; auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma3.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  replace (m + (n + m))) with (S (m + n)).\n  auto with arith.\n  rewrite plus_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  assumption.\n  apply mult_lemma1.\n  apply mult_lemma3.\n  assumption.\n  apply mult_lemma3.\n  assumption.\n  apply mult_lemma3.\n  assumption.\n  apply mult_lemma3.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma3; auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma3.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  replace (n * m) with (S (S (n + m))).\n  rewrite mult_comm.\n  trivial.\nQed."
                ]
            }
        ]
    }
}