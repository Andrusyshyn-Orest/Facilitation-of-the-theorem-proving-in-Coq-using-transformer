{
    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 459,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 495,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 586,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 660,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 704,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 745,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed."
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 53,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 188,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 256,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 348,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed."
            },
            {   "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 328,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 358,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 418,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 451,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 503,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 585,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 679,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 698,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 716,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 746,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "                   \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 738,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 748,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "on n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 742,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 754,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "e x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 739,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "nts.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 739,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 729,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 729,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 739,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "uition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 723,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 723,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed."
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 640,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 680,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": ", [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "e_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "--------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "nd that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "t for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 740,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (* ! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (* ! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 747,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (* ! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (* ! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with ... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (* ! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 745,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros ? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 711,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros ? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 745,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros ? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 735,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros ? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ft_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 691,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h ?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h ?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h ?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h ?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "plit. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h ?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 717,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ap_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 739,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 750,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 754,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 754,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros ? ? ? ? ? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "pper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 727,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ")\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ngth e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 739,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 729,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 746,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 755,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 748,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup ? ?.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 736,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 754,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 753,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n ?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 742,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros ? ? ? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2 ? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1 ? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 739,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros ? ? ? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2 ? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1 ? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 751,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros ? ? ? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2 ? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1 ? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 725,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros ? ? ? ? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros ? ? ? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2 ? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1 ? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 735,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros ? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [ ? ? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros ? ? ? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2 ? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1 ? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 731,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h ? ];\n      generalize (osub_Some_inversion h); intros [ ? [ ? ? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ ? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [ ? [ ? ? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 723,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h ? ];\n      generalize (osub_Some_inversion h); intros [ ? [ ? ? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ ? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [ ? [ ? ? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros ? hf ? ? hs. intros ? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [ ? ? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 753,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h ? ];\n      generalize (osub_Some_inversion h); intros [ ? [ ? ? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ ? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [ ? [ ? ? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros ? hf ? ? hs. intros ? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [ ? ? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ ? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [ ? [ ? ? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros ? hf ? ? hs. intros ? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [ ? ? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 724,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros ? hf ? ? hs. intros ? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [ ? ? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 716,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 742,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "oncatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ist A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat . (replicate . a)] is just an iterated version of [insert . a]. *)\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed."
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab != z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 588,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "t Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab != z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this != n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "th the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab != z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this != n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "S s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab != z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this != n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "l.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab != z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this != n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "ab != z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this != n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m ,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m , *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "kip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m ,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m , *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ")\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "up (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "ms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 750,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "ilter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "Statelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 582,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 604,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 628,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "n soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed."
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 90,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 268,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 373,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 571,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 157,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 72,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 168,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 243,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 340,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 450,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed."
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 508,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 561,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 650,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 752,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ".\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "nstruction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 753,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ".\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 745,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 492,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "n |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "ns, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 722,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 603,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": ".                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                 *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "orall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "to with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 738,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "exists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "c.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 747,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "Qed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 752,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 471,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 544,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 599,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 667,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 752,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 750,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "      *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 737,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "m; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "s  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 752,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed."
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros ? ? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [? ?]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 300,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros ? ? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [? ?]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 328,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros ? ? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [? ?]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 365,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros ? ? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [? ?]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 402,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros ? ? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [? ?]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros ? ? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 451,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed."
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 666,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 688,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 741,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "y (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 753,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "pl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 753,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "dZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 580,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 640,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 705,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 747,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 750,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 654,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 678,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 745,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 745,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "*************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 745,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 745,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "emma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 754,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "Z y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 750,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed."
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "t represents [VY].  This is\nexpressed in [upd] and [get] below. *)\nDefinition Env:= (Z*Z)%type.\n\nDefinition upd (A:Type): (ExVar A) -> A -> Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 745,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "e): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 748,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "ing is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x ?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "educes cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed."
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 656,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 738,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 738,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 747,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 744,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                  \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 744,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "ire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 744,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "orem fold_left_eta :\n forall l a f1,\n (forall a b, In b l -> f a b = f1 a b) -> fold_left f l a = fold_left f1 l a.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H a0 f1 H0.\nrewrite H0; auto.\nQed.\n \nTheorem fold_left_map :\n forall (C : Type) a l (k : C -> B),\n fold_left f (map k l) a = fold_left (fun a b => f a (k b)) l a.\nProof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map, ... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 740,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " l; simpl in |- *; auto.\nintros a l0 H a0 f1 H0.\nrewrite H0; auto.\nQed.\n \nTheorem fold_left_map :\n forall (C : Type) a l (k : C -> B),\n fold_left f (map k l) a = fold_left (fun a b => f a (k b)) l a.\nProof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map, ... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 742,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 721,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 725,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 725,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 506,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 535,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed."
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 560,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed."
            }
        ]
    }
}
