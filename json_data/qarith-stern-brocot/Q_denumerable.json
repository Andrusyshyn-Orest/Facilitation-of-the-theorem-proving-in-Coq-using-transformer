{
    "filename": "Q_denumerable.v",
    "coq_project": "qarith-stern-brocot",
    "vernac_cmds": [
        [
            "Definition identity (A:Set) := fun a:A=> a.",
            "VernacDefinition",
            "4961ef7f61b34dcc896d44d089cb808f3ed5c2d5"
        ],
        [
            "Definition compose (A B C:Set) (g:B->C) (f:A->B) := fun a:A=>g(f a).",
            "VernacDefinition",
            "3031de469f16dfe43d48b5713d6d4abe6249db73"
        ],
        [
            "Section Denumerability.",
            "VernacBeginSection",
            "61ca5d7af4c6aae886c30c921bf7ac2f12c9437c"
        ],
        [
            "Definition same_cardinality (A:Set) (B:Set) := {f:A->B & { g:B->A | (forall b,(compose _ _ _ f g) b= (identity B) b) /\\ forall a,(compose _ _ _ g f) a = (identity A) a}}.",
            "VernacDefinition",
            "18152a7e657a9f5a33aa6b5774cbaa9e971e29a8"
        ],
        [
            "Definition is_denumerable A := same_cardinality A nat.",
            "VernacDefinition",
            "2f7e637e29e0f57c9060788b3a0f6df84dd492ef"
        ],
        [
            "Lemma same_cardinality_transitive:forall A B C, same_cardinality A B -> same_cardinality B C -> same_cardinality A C.",
            "VernacStartTheoremProof",
            "9e45a1f4e9e57b09921d68c3f3b6d323185b7b7d"
        ],
        [
            "intros A B C [f [g [HAB1 HAB2]]] [h [k [HBC1 HBC2]]]; repeat (match goal with [id1: forall (_:_), compose _ _ _ _ _ _ = identity _ _ |- _ ]=> unfold compose in id1; unfold identity in id1 end); exists (compose _ _ _ h f); exists (compose _ _ _ g k); unfold compose; unfold identity; split; [ intro c; rewrite (HAB1 (k c)) | intro a; rewrite (HBC2 (f a)) ]; trivial.",
            "VernacExtend",
            "1f1a3bc70a7b13f2fc87b82e41746a73bb01599e"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma is_denumerable_transitive:forall A B, is_denumerable A -> same_cardinality B A -> is_denumerable B.",
            "VernacStartTheoremProof",
            "91cd7bb26f1a737fa7ea49d9e5bcd381f70f85a9"
        ],
        [
            "intros A B HA HBA; apply (same_cardinality_transitive B A nat HBA HA).",
            "VernacExtend",
            "88561589881a1aae741c0b1c46e88848bd2ca1e9"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "End Denumerability.",
            "VernacEndSegment",
            "cbfa2a625585304eb1fc57449974a55137968e67"
        ],
        [
            "Require Div2.",
            "VernacRequire",
            "e4676d8921f163155a63a685334d87cba71f48f4"
        ],
        [
            "Require Import ZArith.",
            "VernacRequire",
            "12e7bb35b490128f5b015cdb4af7d2255de07134"
        ],
        [
            "Definition Z_to_nat_i (z:Z) :nat := match z with | Z0 => O | Zpos p => Div2.double (nat_of_P p) | Zneg p => pred (Div2.double (nat_of_P p)) end.",
            "VernacDefinition",
            "3e9708b88588531336d6475d72ebde221bd4ec93"
        ],
        [
            "Lemma odd_pred2n: forall n : nat, Even.odd n -> {p : nat | n = pred (Div2.double p)}.",
            "VernacStartTheoremProof",
            "721d8c709cefefdcd16d69cd9f434f88ec8f2c50"
        ],
        [
            "intros n H_odd; rewrite (Div2.odd_double _ H_odd); exists (S (Div2.div2 n)); generalize (Div2.div2 n); clear n H_odd; intros n; rewrite Div2.double_S; reflexivity.",
            "VernacExtend",
            "d1b8e77d92a0ff0f9737d9b4b975deb589a95d96"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma even_odd_exists_dec:forall n, {p : nat | n = Div2.double p} + {p : nat | n = pred (Div2.double p)}.",
            "VernacStartTheoremProof",
            "e150531c693ff0776b0e3b57d26f433eb9009c11"
        ],
        [
            "intro n; destruct (Even.even_odd_dec n) as [H_parity|H_parity]; [ left; apply (Div2.even_2n _ H_parity) | right; apply (odd_pred2n _ H_parity)].",
            "VernacExtend",
            "f5274d54f12909a820b3d6d246ff8d798e79bbbf"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition nat_to_Z_i (n:nat) := match even_odd_exists_dec n with | inl s => let (k, _) := s in Z_of_nat k | inr s => let (k, _) := s in Z.opp (Z_of_nat k) end.",
            "VernacDefinition",
            "13b548f99855785f973d57db03653a4cbd4ac8f7"
        ],
        [
            "Lemma double_eq_half_eq:forall m n, Div2.double m = Div2.double n -> m =n.",
            "VernacStartTheoremProof",
            "163bd7213fd7fd969a81980816a9f20248ec1e3c"
        ],
        [
            "unfold Div2.double; intros m n; omega.",
            "VernacExtend",
            "cafaa062fbca95754d9703fd0d3af2904b1c6719"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma parity_mismatch_not_eq:forall m n, Even.even m -> Even.odd n -> ~m=n.",
            "VernacStartTheoremProof",
            "bbaa4eba4ccd82beaf80f7822dcc6f04973a1f52"
        ],
        [
            "intros m n H_even H_odd H_eq; subst m; apply (Even.not_even_and_odd n); trivial.",
            "VernacExtend",
            "e3178cf05a844a7d8443f8b3ce98b5da591a3f40"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma even_double:forall n, Even.even (Div2.double n).",
            "VernacStartTheoremProof",
            "a62d84e5bbf0135e64b09a525c176e9380da5fa4"
        ],
        [
            "intro n; unfold Div2.double; replace (n + n) with (2*n); auto with arith; omega.",
            "VernacExtend",
            "d28b9be27b83b859e58ac324304e43891d3eaedd"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma double_S_neq_pred:forall m n, ~Div2.double (S m) = pred (Div2.double n).",
            "VernacStartTheoremProof",
            "d0a19f996b19d0f397a718e3f9d1ba22848d04d6"
        ],
        [
            "intros m [|n].",
            "VernacExtend",
            "71c041c6e53a502c828867dc2855379ed73c6155"
        ],
        [
            "unfold Div2.double; omega.",
            "VernacExtend",
            "b169815edc60cb4e5a58d55a97727cadc57176cf"
        ],
        [
            "apply (parity_mismatch_not_eq (Div2.double (S m)) (pred (Div2.double (S n)))); try apply even_double; replace (pred (Div2.double (S n))) with (S (Div2.double n)); [ constructor; apply even_double | unfold Div2.double; omega].",
            "VernacExtend",
            "24b299841c20ecd4c5d0310ae71516e7fd91ba4b"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma eq_add_pred : forall n m : nat, pred n = pred m -> {n = m} + {n<2/\\m<2}.",
            "VernacStartTheoremProof",
            "ac742238c61cca7a2b709adf9ec017fbad118062"
        ],
        [
            "intros [|[|n]] m; simpl; intros H; try (right; omega); left; rewrite (f_equal S H); symmetry; apply S_pred with 0; omega.",
            "VernacExtend",
            "32c449683f8c9353a92baf4433b5cfd39037547b"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma nat_to_Z_to_nat_i : forall (z:Z), nat_to_Z_i (Z_to_nat_i z) = z.",
            "VernacStartTheoremProof",
            "8ecf48108cd3d09274bb1185773cc450046fcf5f"
        ],
        [
            "intros [|p|p]; unfold nat_to_Z_i.",
            "VernacExtend",
            "adb845a67aad4323fbf95b1dfeefece4b449f33b"
        ],
        [
            "simpl; case (even_odd_exists_dec 0); intros [k Hk]; [transitivity (Z_of_nat 0) |transitivity (Z.opp (Z_of_nat 0)) ]; trivial; try apply (f_equal Z.opp); apply (f_equal Z_of_nat); unfold Div2.double in Hk; omega.",
            "VernacExtend",
            "238a400f2b6ea511a0782c138f57d83484c6b659"
        ],
        [
            "case (even_odd_exists_dec (Z_to_nat_i (Zpos p)) ); intros [k Hk].",
            "VernacExtend",
            "9b856eb355b26c77d6fca2cc600c47aa69c5df8e"
        ],
        [
            "unfold Z_to_nat_i in Hk; rewrite <- (double_eq_half_eq _ _ Hk); symmetry; apply Zpos_eq_Z_of_nat_o_nat_of_P.",
            "VernacExtend",
            "b80d79dae5872450a04129bb9fc7a059a720cbec"
        ],
        [
            "apply False_ind; unfold Z_to_nat_i in Hk; destruct (ZL4 p) as [m Hm]; rewrite Hm in Hk; apply (double_S_neq_pred m k); assumption.",
            "VernacExtend",
            "7e9028cb0b94be921daf06ebc7923512e31d6d0d"
        ],
        [
            "case (even_odd_exists_dec (Z_to_nat_i (Zneg p)) ); intros [k Hk].",
            "VernacExtend",
            "19ea31fa082b10239c006aa8f63ec3cc7e3c7a2a"
        ],
        [
            "unfold Z_to_nat_i in Hk; unfold Div2.double in Hk; destruct (ZL4 p) as [m Hm]; omega.",
            "VernacExtend",
            "8daee520c301dbf9f06b8997589eb795abaef3ee"
        ],
        [
            "unfold Z_to_nat_i in Hk; case (eq_add_pred _ _ Hk).",
            "VernacExtend",
            "b9edfd587e8972027be0d480b7d1f41c9292f40a"
        ],
        [
            "intro Hk'; rewrite <- (double_eq_half_eq _ _ Hk'); symmetry; apply Z.opp_inj; rewrite Zopp_neg; rewrite Z.opp_involutive; apply Zpos_eq_Z_of_nat_o_nat_of_P.",
            "VernacExtend",
            "d0f996562976bcf4bdc7a094d33f615e15d3cc78"
        ],
        [
            "intros [H_nat_p_lt_2 _]; apply False_ind; destruct (ZL4 p) as [m Hm]; rewrite Hm in H_nat_p_lt_2; rewrite Div2.double_S in H_nat_p_lt_2; omega.",
            "VernacExtend",
            "10347151da3521fec39161c19194265961033029"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma Z_to_nat_to_Z_i : forall (n:nat), Z_to_nat_i (nat_to_Z_i n) = n.",
            "VernacStartTheoremProof",
            "732dcb2263aafec977bd2cde5aee59bacb85216c"
        ],
        [
            "intros [|n]; unfold nat_to_Z_i.",
            "VernacExtend",
            "4888ecb3e94be2901b250f81900db1e9662d169f"
        ],
        [
            "case (even_odd_exists_dec 0); intros [k Hk]; transitivity (Z_to_nat_i (Z_of_nat 0)); trivial; apply (f_equal Z_to_nat_i); simpl; unfold Div2.double in Hk; omega.",
            "VernacExtend",
            "755f615e2a783f9baef6cab6eade85953a1cbc12"
        ],
        [
            "case (even_odd_exists_dec (S n)); intros [[|k] Hk]; rewrite Hk; trivial; simpl; [apply (f_equal Div2.double); apply nat_of_P_o_P_of_succ_nat_eq_succ |transitivity (pred (Div2.double (S k))); trivial; apply (f_equal pred); apply (f_equal Div2.double); apply nat_of_P_o_P_of_succ_nat_eq_succ ].",
            "VernacExtend",
            "3d4bcf0d8f502a8fdad4c2afd7a48eba6dc84541"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Theorem Z_is_denumerable:is_denumerable Z.",
            "VernacStartTheoremProof",
            "baf98d701c0391b4c55976d738997297c52c153e"
        ],
        [
            "exists Z_to_nat_i; exists nat_to_Z_i; split; [ apply Z_to_nat_to_Z_i | apply nat_to_Z_to_nat_i ].",
            "VernacExtend",
            "b6973a14d905b57a19bf1a175ac6cab8704d63dc"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Require Import Q_field.",
            "VernacRequire",
            "695132a5c2019c63130a696f873a34dd1b65211d"
        ],
        [
            "Fixpoint positive_to_Qpositive_i (p:positive) : Qpositive := match p with | xI p => nR (positive_to_Qpositive_i p) | xO p => dL (positive_to_Qpositive_i p) | xH => One end.",
            "VernacFixpoint",
            "f1cd534b73d29ddbf138d7797ef42d27241a1521"
        ],
        [
            "Definition Z_to_Q_i (z:Z) := match z with | Z0 => Zero | Zpos p => Qpos (positive_to_Qpositive_i p) | Zneg p => Qneg (positive_to_Qpositive_i p) end.",
            "VernacDefinition",
            "3d55d2af7a5ab4e00fd03d81be2cb534662ef730"
        ],
        [
            "Fixpoint Qpositive_to_positive_i (qp:Qpositive) : positive := match qp with | nR qp => xI (Qpositive_to_positive_i qp) | dL qp => xO (Qpositive_to_positive_i qp) | One => xH end.",
            "VernacFixpoint",
            "1c7a5023278b5edda7bfdbe8ef0d0db99577227a"
        ],
        [
            "Definition Q_to_Z_i (q:Q) := match q with | Zero => Z0 | Qpos qp => Zpos (Qpositive_to_positive_i qp) | Qneg qp => Zneg (Qpositive_to_positive_i qp) end.",
            "VernacDefinition",
            "4a6337674601e5317b869d03377f05d9c74a3eb7"
        ],
        [
            "Lemma Qpositive_to_positive_to_Qpositive_i : forall (p:positive), Qpositive_to_positive_i (positive_to_Qpositive_i p) = p.",
            "VernacStartTheoremProof",
            "0ad552552396ec57f5f3716d8a0a2b336fb83a4f"
        ],
        [
            "intros p; induction p as [p|p|]; trivial; simpl; rewrite IHp; trivial.",
            "VernacExtend",
            "6c50db6bf27e66cc993ba1abdefe3918d6d2eab2"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma positive_to_Qpositive_to_positive_i : forall qp, positive_to_Qpositive_i (Qpositive_to_positive_i qp) = qp.",
            "VernacStartTheoremProof",
            "0fcbfbfbef11976c21f554bc4b736d03630a2ffa"
        ],
        [
            "intros p; induction p as [p|p|]; trivial; simpl; rewrite IHp; trivial.",
            "VernacExtend",
            "6c50db6bf27e66cc993ba1abdefe3918d6d2eab2"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma Q_to_Z_to_Q_i : forall (z:Z), Q_to_Z_i (Z_to_Q_i z) = z.",
            "VernacStartTheoremProof",
            "c1aa5922ef514a49586e434a6318176fedaf258b"
        ],
        [
            "intros [|p|p]; trivial; simpl; rewrite Qpositive_to_positive_to_Qpositive_i; trivial.",
            "VernacExtend",
            "cd8794c1e8fe309bfdce23ecb16d5ab964e75d5e"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma Z_to_Q_to_Z_i : forall (q:Q), Z_to_Q_i (Q_to_Z_i q) = q.",
            "VernacStartTheoremProof",
            "89bb3bd4d2f7aa65364c7bb3dcb8ffd52396f0d5"
        ],
        [
            "intros [|qp|qp]; trivial; simpl; rewrite positive_to_Qpositive_to_positive_i; trivial.",
            "VernacExtend",
            "0426a179e359f78741a9905a5b606d998e6065df"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Theorem Q_is_denumerable: is_denumerable Q.",
            "VernacStartTheoremProof",
            "fe0247108fbdc22aef48448d6d2d20a152bec8f2"
        ],
        [
            "apply is_denumerable_transitive with Z.",
            "VernacExtend",
            "31c3f61d02a079b5e947545dec02b112929e3f5d"
        ],
        [
            "apply Z_is_denumerable.",
            "VernacExtend",
            "dc1d27a38dc31a80d86cabd149c8d3298892f8c3"
        ],
        [
            "exists Q_to_Z_i; exists Z_to_Q_i; split; [ apply Q_to_Z_to_Q_i | apply Z_to_Q_to_Z_i ].",
            "VernacExtend",
            "8fc88b38925d8ac58cb277b79f0f422d2c7b51cc"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ]
    ],
    "proofs": [
        {
            "name": "same_cardinality_transitive",
            "line_nb": 5,
            "steps": [
                {
                    "command": [
                        "intros A B C [f [g [HAB1 HAB2]]] [h [k [HBC1 HBC2]]]; repeat (match goal with [id1: forall (_:_), compose _ _ _ _ _ _ = identity _ _ |- _ ]=> unfold compose in id1; unfold identity in id1 end); exists (compose _ _ _ h f); exists (compose _ _ _ g k); unfold compose; unfold identity; split; [ intro c; rewrite (HAB1 (k c)) | intro a; rewrite (HBC2 (f a)) ]; trivial.",
                        "VernacExtend",
                        "1f1a3bc70a7b13f2fc87b82e41746a73bb01599e"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "is_denumerable_transitive",
            "line_nb": 8,
            "steps": [
                {
                    "command": [
                        "intros A B HA HBA; apply (same_cardinality_transitive B A nat HBA HA).",
                        "VernacExtend",
                        "88561589881a1aae741c0b1c46e88848bd2ca1e9"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "odd_pred2n",
            "line_nb": 15,
            "steps": [
                {
                    "command": [
                        "intros n H_odd; rewrite (Div2.odd_double _ H_odd); exists (S (Div2.div2 n)); generalize (Div2.div2 n); clear n H_odd; intros n; rewrite Div2.double_S; reflexivity.",
                        "VernacExtend",
                        "d1b8e77d92a0ff0f9737d9b4b975deb589a95d96"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "even_odd_exists_dec",
            "line_nb": 18,
            "steps": [
                {
                    "command": [
                        "intro n; destruct (Even.even_odd_dec n) as [H_parity|H_parity]; [ left; apply (Div2.even_2n _ H_parity) | right; apply (odd_pred2n _ H_parity)].",
                        "VernacExtend",
                        "f5274d54f12909a820b3d6d246ff8d798e79bbbf"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "double_eq_half_eq",
            "line_nb": 22,
            "steps": [
                {
                    "command": [
                        "unfold Div2.double; intros m n; omega.",
                        "VernacExtend",
                        "cafaa062fbca95754d9703fd0d3af2904b1c6719"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "parity_mismatch_not_eq",
            "line_nb": 25,
            "steps": [
                {
                    "command": [
                        "intros m n H_even H_odd H_eq; subst m; apply (Even.not_even_and_odd n); trivial.",
                        "VernacExtend",
                        "e3178cf05a844a7d8443f8b3ce98b5da591a3f40"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "even_double",
            "line_nb": 28,
            "steps": [
                {
                    "command": [
                        "intro n; unfold Div2.double; replace (n + n) with (2*n); auto with arith; omega.",
                        "VernacExtend",
                        "d28b9be27b83b859e58ac324304e43891d3eaedd"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "double_S_neq_pred",
            "line_nb": 31,
            "steps": [
                {
                    "command": [
                        "intros m [|n].",
                        "VernacExtend",
                        "71c041c6e53a502c828867dc2855379ed73c6155"
                    ]
                },
                {
                    "command": [
                        "unfold Div2.double; omega.",
                        "VernacExtend",
                        "b169815edc60cb4e5a58d55a97727cadc57176cf"
                    ]
                },
                {
                    "command": [
                        "apply (parity_mismatch_not_eq (Div2.double (S m)) (pred (Div2.double (S n)))); try apply even_double; replace (pred (Div2.double (S n))) with (S (Div2.double n)); [ constructor; apply even_double | unfold Div2.double; omega].",
                        "VernacExtend",
                        "24b299841c20ecd4c5d0310ae71516e7fd91ba4b"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "eq_add_pred",
            "line_nb": 36,
            "steps": [
                {
                    "command": [
                        "intros [|[|n]] m; simpl; intros H; try (right; omega); left; rewrite (f_equal S H); symmetry; apply S_pred with 0; omega.",
                        "VernacExtend",
                        "32c449683f8c9353a92baf4433b5cfd39037547b"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "nat_to_Z_to_nat_i",
            "line_nb": 39,
            "steps": [
                {
                    "command": [
                        "intros [|p|p]; unfold nat_to_Z_i.",
                        "VernacExtend",
                        "adb845a67aad4323fbf95b1dfeefece4b449f33b"
                    ]
                },
                {
                    "command": [
                        "simpl; case (even_odd_exists_dec 0); intros [k Hk]; [transitivity (Z_of_nat 0) |transitivity (Z.opp (Z_of_nat 0)) ]; trivial; try apply (f_equal Z.opp); apply (f_equal Z_of_nat); unfold Div2.double in Hk; omega.",
                        "VernacExtend",
                        "238a400f2b6ea511a0782c138f57d83484c6b659"
                    ]
                },
                {
                    "command": [
                        "case (even_odd_exists_dec (Z_to_nat_i (Zpos p)) ); intros [k Hk].",
                        "VernacExtend",
                        "9b856eb355b26c77d6fca2cc600c47aa69c5df8e"
                    ]
                },
                {
                    "command": [
                        "unfold Z_to_nat_i in Hk; rewrite <- (double_eq_half_eq _ _ Hk); symmetry; apply Zpos_eq_Z_of_nat_o_nat_of_P.",
                        "VernacExtend",
                        "b80d79dae5872450a04129bb9fc7a059a720cbec"
                    ]
                },
                {
                    "command": [
                        "apply False_ind; unfold Z_to_nat_i in Hk; destruct (ZL4 p) as [m Hm]; rewrite Hm in Hk; apply (double_S_neq_pred m k); assumption.",
                        "VernacExtend",
                        "7e9028cb0b94be921daf06ebc7923512e31d6d0d"
                    ]
                },
                {
                    "command": [
                        "case (even_odd_exists_dec (Z_to_nat_i (Zneg p)) ); intros [k Hk].",
                        "VernacExtend",
                        "19ea31fa082b10239c006aa8f63ec3cc7e3c7a2a"
                    ]
                },
                {
                    "command": [
                        "unfold Z_to_nat_i in Hk; unfold Div2.double in Hk; destruct (ZL4 p) as [m Hm]; omega.",
                        "VernacExtend",
                        "8daee520c301dbf9f06b8997589eb795abaef3ee"
                    ]
                },
                {
                    "command": [
                        "unfold Z_to_nat_i in Hk; case (eq_add_pred _ _ Hk).",
                        "VernacExtend",
                        "b9edfd587e8972027be0d480b7d1f41c9292f40a"
                    ]
                },
                {
                    "command": [
                        "intro Hk'; rewrite <- (double_eq_half_eq _ _ Hk'); symmetry; apply Z.opp_inj; rewrite Zopp_neg; rewrite Z.opp_involutive; apply Zpos_eq_Z_of_nat_o_nat_of_P.",
                        "VernacExtend",
                        "d0f996562976bcf4bdc7a094d33f615e15d3cc78"
                    ]
                },
                {
                    "command": [
                        "intros [H_nat_p_lt_2 _]; apply False_ind; destruct (ZL4 p) as [m Hm]; rewrite Hm in H_nat_p_lt_2; rewrite Div2.double_S in H_nat_p_lt_2; omega.",
                        "VernacExtend",
                        "10347151da3521fec39161c19194265961033029"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Z_to_nat_to_Z_i",
            "line_nb": 51,
            "steps": [
                {
                    "command": [
                        "intros [|n]; unfold nat_to_Z_i.",
                        "VernacExtend",
                        "4888ecb3e94be2901b250f81900db1e9662d169f"
                    ]
                },
                {
                    "command": [
                        "case (even_odd_exists_dec 0); intros [k Hk]; transitivity (Z_to_nat_i (Z_of_nat 0)); trivial; apply (f_equal Z_to_nat_i); simpl; unfold Div2.double in Hk; omega.",
                        "VernacExtend",
                        "755f615e2a783f9baef6cab6eade85953a1cbc12"
                    ]
                },
                {
                    "command": [
                        "case (even_odd_exists_dec (S n)); intros [[|k] Hk]; rewrite Hk; trivial; simpl; [apply (f_equal Div2.double); apply nat_of_P_o_P_of_succ_nat_eq_succ |transitivity (pred (Div2.double (S k))); trivial; apply (f_equal pred); apply (f_equal Div2.double); apply nat_of_P_o_P_of_succ_nat_eq_succ ].",
                        "VernacExtend",
                        "3d4bcf0d8f502a8fdad4c2afd7a48eba6dc84541"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Z_is_denumerable",
            "line_nb": 56,
            "steps": [
                {
                    "command": [
                        "exists Z_to_nat_i; exists nat_to_Z_i; split; [ apply Z_to_nat_to_Z_i | apply nat_to_Z_to_nat_i ].",
                        "VernacExtend",
                        "b6973a14d905b57a19bf1a175ac6cab8704d63dc"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Qpositive_to_positive_to_Qpositive_i",
            "line_nb": 64,
            "steps": [
                {
                    "command": [
                        "intros p; induction p as [p|p|]; trivial; simpl; rewrite IHp; trivial.",
                        "VernacExtend",
                        "6c50db6bf27e66cc993ba1abdefe3918d6d2eab2"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "positive_to_Qpositive_to_positive_i",
            "line_nb": 67,
            "steps": [
                {
                    "command": [
                        "intros p; induction p as [p|p|]; trivial; simpl; rewrite IHp; trivial.",
                        "VernacExtend",
                        "6c50db6bf27e66cc993ba1abdefe3918d6d2eab2"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Q_to_Z_to_Q_i",
            "line_nb": 70,
            "steps": [
                {
                    "command": [
                        "intros [|p|p]; trivial; simpl; rewrite Qpositive_to_positive_to_Qpositive_i; trivial.",
                        "VernacExtend",
                        "cd8794c1e8fe309bfdce23ecb16d5ab964e75d5e"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Z_to_Q_to_Z_i",
            "line_nb": 73,
            "steps": [
                {
                    "command": [
                        "intros [|qp|qp]; trivial; simpl; rewrite positive_to_Qpositive_to_positive_i; trivial.",
                        "VernacExtend",
                        "0426a179e359f78741a9905a5b606d998e6065df"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Q_is_denumerable",
            "line_nb": 76,
            "steps": [
                {
                    "command": [
                        "apply is_denumerable_transitive with Z.",
                        "VernacExtend",
                        "31c3f61d02a079b5e947545dec02b112929e3f5d"
                    ]
                },
                {
                    "command": [
                        "apply Z_is_denumerable.",
                        "VernacExtend",
                        "dc1d27a38dc31a80d86cabd149c8d3298892f8c3"
                    ]
                },
                {
                    "command": [
                        "exists Q_to_Z_i; exists Z_to_Q_i; split; [ apply Q_to_Z_to_Q_i | apply Z_to_Q_to_Z_i ].",
                        "VernacExtend",
                        "8fc88b38925d8ac58cb277b79f0f422d2c7b51cc"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        }
    ]
}