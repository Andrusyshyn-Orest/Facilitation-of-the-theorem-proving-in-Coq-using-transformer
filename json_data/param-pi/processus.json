{
    "filename": "processus.v",
    "coq_project": "param-pi",
    "vernac_cmds": [
        [
            "Inductive capa : Set := | Read : capa | Write : capa | Both : capa | Nil : capa.",
            "VernacInductive",
            "26911d74a4a637aa730065d5183c523324ad7240"
        ],
        [
            "Inductive capst : capa -> capa -> Prop := | capst_refl : forall c : capa, capst c c | capst_nil : forall c : capa, capst c Nil | capst_both : forall c : capa, capst Both c.",
            "VernacInductive",
            "ef4ad4be0212f50d97422c26cf7551d505aa9b82"
        ],
        [
            "Parameter type : Set.",
            "VernacAssumption",
            "b0075cd6dd6254ea6d31768dddc1d839d438207e"
        ],
        [
            "Parameter getcap : type -> capa.",
            "VernacAssumption",
            "4895ceb97d61e0eb5cf63e63a3586ce4f9820e48"
        ],
        [
            "Parameter getobj : type -> type.",
            "VernacAssumption",
            "0687e2f24a05b3a96c11eb6e7b4244399bad8dde"
        ],
        [
            "Parameter typest : type -> type -> Prop.",
            "VernacAssumption",
            "f762de545bd1713450d9ad38400b274b5a67387b"
        ],
        [
            "Axiom typest_refl : forall t : type, typest t t.",
            "VernacAssumption",
            "92b005ea80779681954e6a7a3c84581d09e1448d"
        ],
        [
            "Axiom typest_trans : forall t t' : type, typest t t' -> forall t'' : type, typest t' t'' -> typest t t''.",
            "VernacAssumption",
            "a972f3255085c3e640387079aedc0c88fda47a21"
        ],
        [
            "Theorem capst_trans : forall c c' c'' : capa, capst c c' -> capst c' c'' -> capst c c''.",
            "VernacStartTheoremProof",
            "7b777214d4d6552d8e1979fa66891aca9f7c1e7d"
        ],
        [
            "intros c c' c''.",
            "VernacExtend",
            "a1a80dd5aee66ad17f009ecf0965237256c1112b"
        ],
        [
            "intro cst1.",
            "VernacExtend",
            "8526c5251edcbbe9f71e499a287c6d5da4da4cbd"
        ],
        [
            "case cst1.",
            "VernacExtend",
            "183f2616b143a354436ee4b5fda0046ebb029440"
        ],
        [
            "intros; assumption.",
            "VernacExtend",
            "5cc15d3651e27d2e3e1e2b44ec8880d58345a162"
        ],
        [
            "intros k cst.",
            "VernacExtend",
            "96c81cf3c56e5470b7b665a84a9e92afedb49f38"
        ],
        [
            "inversion_clear cst.",
            "VernacExtend",
            "0d979a998ccdc696cb18d43dd955920343093c5a"
        ],
        [
            "apply capst_nil.",
            "VernacExtend",
            "36c7232f822d4f8fcaeec8fb27ed06cea94c94d6"
        ],
        [
            "apply capst_nil.",
            "VernacExtend",
            "36c7232f822d4f8fcaeec8fb27ed06cea94c94d6"
        ],
        [
            "intros; apply capst_both.",
            "VernacExtend",
            "88281b21638d7f5e2db85726cb3c51969c4bf6d4"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Parameter PP : Set.",
            "VernacAssumption",
            "3ac5e244a99d3359d0eb630dab17f1b0cd11a142"
        ],
        [
            "Parameter VV : Set.",
            "VernacAssumption",
            "790536a6010308bb0304225b023da14f0ae107ca"
        ],
        [
            "Axiom PP_decidable : forall p q : PP, {p = q} + {p <> q}.",
            "VernacAssumption",
            "70f2f79f6b9bcce67441f3bfb7a88387bd5bcaf1"
        ],
        [
            "Axiom VV_decidable : forall x y : VV, {x = y} + {x <> y}.",
            "VernacAssumption",
            "fa505bfd71ba8cb0eb6d409ad612a75a884b3da2"
        ],
        [
            "Inductive name : Set := | pname : PP -> name | vname : VV -> name.",
            "VernacInductive",
            "391ad5fefcf491a399e4d710d3b75ceb3308f085"
        ],
        [
            "Inductive proc : Set := | nil : proc | inp : name -> VV -> proc -> proc | out : name -> name -> proc -> proc | par : proc -> proc -> proc | res : VV -> type -> proc -> proc | ban : proc -> proc | sum : proc -> proc -> proc | mat : name -> name -> proc -> proc.",
            "VernacInductive",
            "a22f14b5ca3b2bf10e8ce4503c1a7029fdc0be77"
        ],
        [
            "Definition subs_var_name (n m : name) (x : VV) : name := match n with | pname p => n | vname v => match VV_decidable x v with | left _ => m | right _ => n end end.",
            "VernacDefinition",
            "c77e6c0c60580bb88c7aedd0e71c7ae3111ef276"
        ],
        [
            "Fixpoint subs_var_proc (P : proc) : name -> VV -> proc := fun (n : name) (x : VV) => match P with | nil => nil | inp m v qq => inp (subs_var_name m n x) v match VV_decidable x v with | left _ => qq | right _ => subs_var_proc qq n x end | out m1 m2 qq => out (subs_var_name m1 n x) (subs_var_name m2 n x) (subs_var_proc qq n x) | par qq rr => par (subs_var_proc qq n x) (subs_var_proc rr n x) | res v t qq => res v t match VV_decidable x v with | left _ => qq | right _ => subs_var_proc qq n x end | ban qq => ban (subs_var_proc qq n x) | sum qq rr => sum (subs_var_proc qq n x) (subs_var_proc rr n x) | mat m1 m2 qq => mat (subs_var_name m1 n x) (subs_var_name m2 n x) (subs_var_proc qq n x) end.",
            "VernacFixpoint",
            "6f447d4eafc26879a19081af3383d6e1e74e35d0"
        ],
        [
            "Definition subs_par_name (n m : name) (p : PP) : name := match n with | pname q => match PP_decidable p q with | left _ => m | right _ => n end | vname v => n end.",
            "VernacDefinition",
            "c8a46c717c30789c543d79a5f9c8daa69961efb9"
        ],
        [
            "Fixpoint subs_par_proc (P : proc) : name -> PP -> proc := fun (n : name) (p : PP) => match P with | nil => nil | inp m v qq => inp (subs_par_name m n p) v (subs_par_proc qq n p) | out m1 m2 qq => out (subs_par_name m1 n p) (subs_par_name m2 n p) (subs_par_proc qq n p) | par qq rr => par (subs_par_proc qq n p) (subs_par_proc rr n p) | res v t qq => res v t (subs_par_proc qq n p) | ban qq => ban (subs_par_proc qq n p) | sum qq rr => sum (subs_par_proc qq n p) (subs_par_proc rr n p) | mat m1 m2 qq => mat (subs_par_name m1 n p) (subs_par_name m2 n p) (subs_par_proc qq n p) end.",
            "VernacFixpoint",
            "68cb4cbadc2661d9182e165b015cfd094a6c7924"
        ],
        [
            "Inductive freshname (p : PP) : name -> Prop := | freshp : forall q : PP, p <> q -> freshname p (pname q) | freshv : forall v : VV, freshname p (vname v).",
            "VernacInductive",
            "1ed7f46d91827226d85e84b09c33384d6cd19f7a"
        ],
        [
            "Inductive fresh (p : PP) : proc -> Prop := | frnil : fresh p nil | frinp : forall (m : name) (v : VV) (Q : proc), freshname p m -> fresh p Q -> fresh p (inp m v Q) | frout : forall (m1 m2 : name) (Q : proc), freshname p m1 -> freshname p m2 -> fresh p Q -> fresh p (out m1 m2 Q) | frpar : forall P Q : proc, fresh p P -> fresh p Q -> fresh p (par P Q) | frres : forall (v : VV) (t : type) (Q : proc), fresh p Q -> fresh p (res v t Q) | frban : forall Q : proc, fresh p Q -> fresh p (ban Q) | frsum : forall P Q : proc, fresh p P -> fresh p Q -> fresh p (sum P Q) | frmat : forall (m1 m2 : name) (Q : proc), freshname p m1 -> freshname p m2 -> fresh p Q -> fresh p (mat m1 m2 Q).",
            "VernacInductive",
            "ea36235738ec3fb094484a3b96ed879b3fbd90ae"
        ],
        [
            "Inductive freshvarname (v : VV) : name -> Prop := | freshvp : forall p : PP, freshvarname v (pname p) | freshvv : forall x : VV, v <> x -> freshvarname v (vname x).",
            "VernacInductive",
            "17bd0fa8d0079e229752ae0b240ec1aa0c06fa32"
        ],
        [
            "Inductive freshvar (v : VV) : proc -> Prop := | fvnil : freshvar v nil | fvinp : forall (m : name) (x : VV) (Q : proc), freshvarname v m -> v <> x -> freshvar v Q -> freshvar v (inp m x Q) | fvout : forall (m1 m2 : name) (Q : proc), freshvarname v m1 -> freshvarname v m2 -> freshvar v Q -> freshvar v (out m1 m2 Q) | fvpar : forall P Q : proc, freshvar v P -> freshvar v Q -> freshvar v (par P Q) | fvres : forall (x : VV) (t : type) (Q : proc), v <> x -> freshvar v Q -> freshvar v (res x t Q) | fvban : forall Q : proc, freshvar v Q -> freshvar v (ban Q) | fvsum : forall P Q : proc, freshvar v P -> freshvar v Q -> freshvar v (sum P Q) | fvmat : forall (m1 m2 : name) (Q : proc), freshvarname v m1 -> freshvarname v m2 -> freshvar v Q -> freshvar v (mat m1 m2 Q).",
            "VernacInductive",
            "81c0a2304a6d65decbe09da1a7d783a8bd84c4fb"
        ],
        [
            "Inductive act : Set := | aout : PP -> PP -> act | ainp : PP -> PP -> act | about : PP -> PP -> type -> act | tau : act.",
            "VernacInductive",
            "8218b77237229dcbf83d1abf922cf1a93126e339"
        ],
        [
            "Inductive freshact (p : PP) : act -> Prop := | faout : forall q1 q2 : PP, p <> q1 -> p <> q2 -> freshact p (aout q1 q2) | fainp : forall q1 q2 : PP, p <> q1 -> p <> q2 -> freshact p (ainp q1 q2) | fabout : forall (q1 q2 : PP) (t : type), p <> q1 -> p <> q2 -> freshact p (about q1 q2 t) | ftau : freshact p tau.",
            "VernacInductive",
            "d4c5c2e0e09fc4164c2da03930a079a121cbd407"
        ],
        [
            "Inductive sem : proc -> act -> proc -> Prop := | sinp : forall (p q : PP) (x : VV) (Q : proc), sem (inp (pname p) x Q) (ainp p q) (subs_var_proc Q (pname q) x) | sout : forall (p q : PP) (Q : proc), sem (out (pname p) (pname q) Q) (aout p q) Q | scoml : forall (P P' Q Q' : proc) (p q : PP), sem P (ainp p q) P' -> sem Q (aout p q) Q' -> sem (par P Q) tau (par P' Q') | scomr : forall (P P' Q Q' : proc) (p q : PP), sem P (aout p q) P' -> sem Q (ainp p q) Q' -> sem (par P Q) tau (par P' Q') | sopen : forall (P P' : proc) (p q : PP) (x : VV) (t : type), fresh q P -> p <> q -> sem (subs_var_proc P (pname q) x) (aout p q) P' -> sem (res x t P) (about p q t) P' | sclosel : forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV), fresh q P -> freshvar x P' -> freshvar x Q' -> sem P (ainp p q) P' -> sem Q (about p r t) Q' -> sem (par P Q) tau (res x t (par (subs_par_proc P' (vname x) q) (subs_par_proc Q' (vname x) r))) | scloser : forall (P P' Q Q' : proc) (p q r : PP) (t : type) (x : VV), fresh q P -> freshvar x P' -> freshvar x Q' -> sem P (ainp p q) P' -> sem Q (about p r t) Q' -> sem (par Q P) tau (res x t (par (subs_par_proc Q' (vname x) r) (subs_par_proc P' (vname x) q))) | sres : forall (P P' : proc) (mu : act) (x y : VV) (t : type), (forall q : PP, sem (subs_var_proc P (pname q) x) mu (subs_var_proc P' (pname q) y)) -> sem (res x t P) mu (res y t P') | sban : forall (P P' : proc) (mu : act), sem (par (ban P) P) mu P' -> sem (ban P) mu P' | sparl : forall (P P' Q : proc) (mu : act), (forall (p q : PP) (t : type), mu = about p q t -> fresh q Q) -> sem P mu P' -> sem (par P Q) mu (par P' Q) | sparr : forall (P P' Q : proc) (mu : act), (forall (p q : PP) (t : type), mu = about p q t -> fresh q Q) -> sem P mu P' -> sem (par Q P) mu (par Q P') | ssuml : forall (P P' Q : proc) (mu : act), sem P mu P' -> sem (sum P Q) mu P' | ssumr : forall (P P' Q : proc) (mu : act), sem P mu P' -> sem (sum Q P) mu P' | smat : forall (P P' : proc) (p : PP) (mu : act), sem P mu P' -> sem (mat (pname p) (pname p) P) mu P'.",
            "VernacInductive",
            "f7588512165ce7fb76aed5d4d49bc42711846f12"
        ],
        [
            "Definition env : Type := PP -> type.",
            "VernacDefinition",
            "3afc08fe78929632ab1de6fa7fa1d229e5b6c0fd"
        ],
        [
            "Definition addenv (G : env) (p : PP) (t : type) : env := fun q : PP => match PP_decidable p q with | left _ => t | right _ => G q end.",
            "VernacDefinition",
            "7f64547c64c65707589794f45e0a547cabe37b0e"
        ],
        [
            "Definition envst (G D : env) : Prop := forall p : PP, typest (G p) (D p).",
            "VernacDefinition",
            "da63d220cf7bfdbb74ebd726528f1c9f778eed41"
        ],
        [
            "Definition eqvenv (G D : env) : Prop := forall p : PP, G p = D p.",
            "VernacDefinition",
            "736eefa67251673552a43fff034c1994bffaed63"
        ],
        [
            "Inductive typing : env -> proc -> Prop := | tnil : forall G : env, typing G nil | tinp : forall (G : env) (p : PP) (x : VV) (P : proc), capst (getcap (G p)) Read -> (forall q : PP, fresh q P -> typing (addenv G q (getobj (G p))) (subs_var_proc P (pname q) x)) -> typing G (inp (pname p) x P) | tout : forall (G : env) (p q : PP) (P : proc), capst (getcap (G p)) Write -> typest (G q) (getobj (G p)) -> typing G P -> typing G (out (pname p) (pname q) P) | tpar : forall (G : env) (P Q : proc), typing G P -> typing G Q -> typing G (par P Q) | tres : forall (G : env) (x : VV) (t : type) (P : proc), (forall q : PP, fresh q P -> typing (addenv G q t) (subs_var_proc P (pname q) x)) -> typing G (res x t P) | tban : forall (G : env) (P : proc), typing G P -> typing G (ban P) | tsum : forall (G : env) (P Q : proc), typing G P -> typing G Q -> typing G (sum P Q) | tmat : forall (G : env) (p q : PP) (P : proc), getcap (G p) = Both -> getcap (G q) = Both -> typing G P -> typing G (mat (pname p) (pname q) P).",
            "VernacInductive",
            "4299b00eb130e1c040c24e63cad269242425f3ab"
        ],
        [
            "Definition swap_par (r p q : PP) : PP := match PP_decidable r p with | left _ => q | right _ => match PP_decidable r q with | left _ => p | right _ => r end end.",
            "VernacDefinition",
            "cb373f9c49dfe7471ef259043fdace14f38ec2ec"
        ],
        [
            "Definition swap_name (n : name) (p q : PP) : name := match n with | pname r => match PP_decidable r p with | left _ => pname q | right _ => match PP_decidable r q with | left _ => pname p | right _ => pname r end end | vname x => vname x end.",
            "VernacDefinition",
            "cbda5386e97fb7d20e7d9680dbec5ef4856af827"
        ],
        [
            "Fixpoint swap_proc (P : proc) : PP -> PP -> proc := fun p q : PP => match P with | inp n x p1 => inp (swap_name n p q) x (swap_proc p1 p q) | out n1 n2 p1 => out (swap_name n1 p q) (swap_name n2 p q) (swap_proc p1 p q) | res x t p1 => res x t (swap_proc p1 p q) | par p1 p2 => par (swap_proc p1 p q) (swap_proc p2 p q) | ban p1 => ban (swap_proc p1 p q) | sum p1 p2 => sum (swap_proc p1 p q) (swap_proc p2 p q) | mat n1 n2 p1 => mat (swap_name n1 p q) (swap_name n2 p q) (swap_proc p1 p q) | nil => nil end.",
            "VernacFixpoint",
            "d78528e777883a1fe22acfa8c5f30b12e76c1e78"
        ],
        [
            "Definition swap_env (G : env) (p q : PP) : env := fun r : PP => match PP_decidable p r with | left _ => G q | right _ => match PP_decidable q r with | left _ => G p | right _ => G r end end.",
            "VernacDefinition",
            "007d3c868b63d44a2b1f30be0da0c903f4535a5c"
        ],
        [
            "Axiom different : forall p : PP, exists s : PP, p <> s.",
            "VernacAssumption",
            "43b08c38c63f9b1568c3cb44a0d54a7d7240920d"
        ],
        [
            "Axiom fresh_and_different : forall (p : PP) (P : proc), exists r : PP, fresh r P /\\ p <> r.",
            "VernacAssumption",
            "68f1b03261b436563cf1341009ca12ff51155a42"
        ],
        [
            "Axiom fresh_and_two_different : forall (p q : PP) (P : proc), exists r : PP, fresh r P /\\ p <> r /\\ q <> r.",
            "VernacAssumption",
            "e11f34ff73ca6329d5262093fb8735248fecf779"
        ],
        [
            "Axiom fresh_and_three_different : forall (p q r : PP) (P : proc), exists s : PP, fresh s P /\\ p <> s /\\ q <> s /\\ r <> s.",
            "VernacAssumption",
            "747833bbcbc2f87d44b39196e431a9d6f91c04a3"
        ]
    ],
    "proofs": [
        {
            "name": "capst_trans",
            "line_nb": 8,
            "steps": [
                {
                    "command": [
                        "intros c c' c''.",
                        "VernacExtend",
                        "a1a80dd5aee66ad17f009ecf0965237256c1112b"
                    ]
                },
                {
                    "command": [
                        "intro cst1.",
                        "VernacExtend",
                        "8526c5251edcbbe9f71e499a287c6d5da4da4cbd"
                    ]
                },
                {
                    "command": [
                        "case cst1.",
                        "VernacExtend",
                        "183f2616b143a354436ee4b5fda0046ebb029440"
                    ]
                },
                {
                    "command": [
                        "intros; assumption.",
                        "VernacExtend",
                        "5cc15d3651e27d2e3e1e2b44ec8880d58345a162"
                    ]
                },
                {
                    "command": [
                        "intros k cst.",
                        "VernacExtend",
                        "96c81cf3c56e5470b7b665a84a9e92afedb49f38"
                    ]
                },
                {
                    "command": [
                        "inversion_clear cst.",
                        "VernacExtend",
                        "0d979a998ccdc696cb18d43dd955920343093c5a"
                    ]
                },
                {
                    "command": [
                        "apply capst_nil.",
                        "VernacExtend",
                        "36c7232f822d4f8fcaeec8fb27ed06cea94c94d6"
                    ]
                },
                {
                    "command": [
                        "apply capst_nil.",
                        "VernacExtend",
                        "36c7232f822d4f8fcaeec8fb27ed06cea94c94d6"
                    ]
                },
                {
                    "command": [
                        "intros; apply capst_both.",
                        "VernacExtend",
                        "88281b21638d7f5e2db85726cb3c51969c4bf6d4"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}