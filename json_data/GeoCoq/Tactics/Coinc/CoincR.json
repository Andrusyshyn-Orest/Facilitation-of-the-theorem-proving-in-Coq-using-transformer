{
    "filename": "Tactics/Coinc/CoincR.v",
    "coq_project": "GeoCoq",
    "vernac_cmds": [
        [
            "Require Import Recdef.",
            "VernacRequire",
            "8ffa9cbe33b0c9742b324b18d68b10eb03ac2ead"
        ],
        [
            "Require Import NArith.",
            "VernacRequire",
            "94ad0f31c6e8f77c89e55924450f512e031ec933"
        ],
        [
            "Require Import Sorting.",
            "VernacRequire",
            "4b941088881c86fc9cdf29a554745602ff99df7f"
        ],
        [
            "Require Import GeoCoq.Tactics.Coinc.Permutations.",
            "VernacRequire",
            "07ee61b6f5776ed8a421f09aa851de025605d090"
        ],
        [
            "Require Import GeoCoq.Utils.general_tactics.",
            "VernacRequire",
            "4997169627980ecd4df85076ade24bbc0afef657"
        ],
        [
            "Require Import GeoCoq.Utils.sets.",
            "VernacRequire",
            "683b6258c49d18c9e40d121098acf4ce0c5cd444"
        ],
        [
            "Module SSWP := WPropertiesOn SetOfSetsOfPositiveOrderedType SS.",
            "VernacDefineModule",
            "4968b66414f776bab68fee4e0ba108e62b95e075"
        ],
        [
            "Module SSWEqP := WEqPropertiesOn SetOfSetsOfPositiveOrderedType SS.",
            "VernacDefineModule",
            "a7d3aeffccf341ccab874c083289698734b9be14"
        ],
        [
            "Module Import PosSort := Sort PosOrder.",
            "VernacDefineModule",
            "cde352d316505a82f42a2cbc4feeb9c75d7d9f9c"
        ],
        [
            "Section Coinc_refl.",
            "VernacBeginSection",
            "26663e854a4320a887a18939ce800421db2e9b5c"
        ],
        [
            "Context {AR : Arity}.",
            "VernacContext",
            "876189836b58fdeb048438dc15065115eef50322"
        ],
        [
            "Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.",
            "VernacDefinition",
            "44a91f9264a9eb1f54aa44de3347f1e9114e1cf6"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "exact ((S.mem (fst cp) s) && (S.mem (snd cp) s)).",
            "VernacExtend",
            "e79c8d5e0b72da2b3c9837c42901f8973a232546"
        ],
        [
            "exact ((S.mem (fst cp) s) && (IHm (tailCP cp))).",
            "VernacExtend",
            "6c5dae2e059c81e6bdeeb1e797e145566c014d29"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition pick_variety_aux (s : SS.elt) (t : tST) := pick_variety_auxCP s t.",
            "VernacDefinition",
            "7ca91c51cbf50df808c7c36397f0a6001751417a"
        ],
        [
            "Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).",
            "VernacStartTheoremProof",
            "6aaff1500a571cd873680fe1202da2648715fc52"
        ],
        [
            "induction m; intros s cp; [unfold InCP|]; simpl; split.",
            "VernacExtend",
            "f864efebb51fa9e1fe2445197b70218ae6c3f784"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].",
            "VernacExtend",
            "504dfb9e2c203fc354130aa1c98fc0b8038a8571"
        ],
        [
            "intros p H; do 2 (try (elim H; clear H; intro; subst)); auto.",
            "VernacExtend",
            "9542e4ff65d9df513e3c7aa6adffa00ecc01e273"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intro H; apply andb_true_iff; split; [apply (H (fst cp))|apply (H (snd cp))]; auto.",
            "VernacExtend",
            "c8c7468d15937766a938f782024cb7e56e8d28b4"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].",
            "VernacExtend",
            "504dfb9e2c203fc354130aa1c98fc0b8038a8571"
        ],
        [
            "intros p H; apply InCPOK in H; elim H; clear H; intro HIn; subst; simpl; auto.",
            "VernacExtend",
            "5896bb37bfad73d100a562fa2eb1ed194ce9e8a3"
        ],
        [
            "destruct (IHm s (tailCP cp)) as [H _]; apply H; auto.",
            "VernacExtend",
            "096623290f5be5c738bdd43173e6ca6a336a6ea8"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.",
            "VernacExtend",
            "115dafa762f7e248622bfd5657dd9792031da92a"
        ],
        [
            "intro H; apply andb_true_iff; split; [apply (H (fst cp))|apply IHm; intros p HIn; apply H]; apply InCPOK; auto.",
            "VernacExtend",
            "66a8443f20dd76353ad4e1712e36fe681353b785"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).",
            "VernacStartTheoremProof",
            "59e48f8b00c140276ecad0ddadc521b31736dcfc"
        ],
        [
            "induction m; intros s cp; [unfold InCP|]; simpl; split.",
            "VernacExtend",
            "f864efebb51fa9e1fe2445197b70218ae6c3f784"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intro H; apply andb_false_iff in H; elim H; clear H; intro H; [exists (fst cp)|exists (snd cp)]; auto.",
            "VernacExtend",
            "b724222a9ae39b929ca3195f06699fda05309607"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intro H; destruct H as [p [H Hmem]]; apply andb_false_iff.",
            "VernacExtend",
            "792062bb5e9d26f47abc4024801f60580ebe5d16"
        ],
        [
            "do 2 (try (elim H; clear H; intro H; subst)); intuition.",
            "VernacExtend",
            "0ac1fc9c3af234954a9536ac65d1bf3e5869a46f"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intro H; apply andb_false_iff in H.",
            "VernacExtend",
            "e54f12cab9912f1202fe5021f6f54859a16230c5"
        ],
        [
            "destruct (IHm s (tailCP cp)) as [H' _]; clear IHm; rename H' into IHm.",
            "VernacExtend",
            "477bbf9a046cfd2f700a1799b021f655937e2511"
        ],
        [
            "elim H; clear H; intro Hmem.",
            "VernacExtend",
            "766e4a1ce43fc1926d47272e16d82872dea1424d"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "exists (fst cp); unfold InCP; simpl; auto.",
            "VernacExtend",
            "0e892904e11e1cbf070801ec7f6111fccde9c6eb"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "destruct (IHm Hmem) as [p [HIn Hmem']]; exists p; split; try apply InCPOK; auto.",
            "VernacExtend",
            "4dc67c84ef3daad16f33800bd36903004eaf1dcc"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.",
            "VernacExtend",
            "115dafa762f7e248622bfd5657dd9792031da92a"
        ],
        [
            "intro H; destruct H as [p [HIn Hmem]]; apply InCPOK in HIn; apply andb_false_iff.",
            "VernacExtend",
            "bcaf26b3d34a15eb2ed6252f90e263e472b1d031"
        ],
        [
            "elim HIn; clear HIn; intro HIn; subst; auto.",
            "VernacExtend",
            "71a13a0b29ab67e2731d55e52f1ee22904998c28"
        ],
        [
            "right; apply IHm; exists p; auto.",
            "VernacExtend",
            "f1498d597e3be5555c3a3ce7619be3d5a3981696"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).",
            "VernacStartTheoremProof",
            "a3b4621d796c62a13b86ff966c7dfebdd61cf798"
        ],
        [
            "unfold pick_variety_aux, eqST.",
            "VernacExtend",
            "ee928bc26b90aba79776d3a605d7a2b5c7528cfa"
        ],
        [
            "intros s t1 t2 HEq.",
            "VernacExtend",
            "a4246f21bd42fdc4969a6c98a00e230882116232"
        ],
        [
            "case_eq (pick_variety_auxCP s t1); intro Ht1.",
            "VernacExtend",
            "1afa89444609c76714a7ba17241e95f26628c1f2"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "destruct (pick_variety_auxCP_forallT s t1) as [H1 H2]; clear H2.",
            "VernacExtend",
            "2ae642d540583536b28399b598db845446ddb5a8"
        ],
        [
            "assert (H := H1 Ht1); clear H1; clear Ht1; rename H into Ht1.",
            "VernacExtend",
            "1be0002a17cb37122ce17cf36293edf4ec106d71"
        ],
        [
            "destruct (pick_variety_auxCP_forallT s t2) as [H1 H2]; clear H1.",
            "VernacExtend",
            "fe5c25e65aac4459fa882ee17592fdcfd116b978"
        ],
        [
            "rewrite H2; try reflexivity; clear H2; intros p HIn; apply Ht1.",
            "VernacExtend",
            "da16b41f205a85930963a4120fa5898d773b44a7"
        ],
        [
            "clear Ht1; apply InCPOCP; apply InCPOCP in HIn.",
            "VernacExtend",
            "d1336d45d63ce5da838e6b6ea6937aa627c56aa9"
        ],
        [
            "assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).",
            "VernacExtend",
            "5c3b4c608be404cf878f6018232676e565b284d9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "assert (Ht1 := eqListSortOCP t1).",
            "VernacExtend",
            "a163c2c5b3a0346c4ee734882dcea3e867567466"
        ],
        [
            "assert (Ht2 := eqListSortOCP t2).",
            "VernacExtend",
            "d0467e04f924111032dd8d70f61ecd16c6605867"
        ],
        [
            "apply eqListTrans with (PosSort.sort (CPToList t1)); try assumption.",
            "VernacExtend",
            "aa026a2c26d90bf046f1b6dd5c5e06c5b92a2c23"
        ],
        [
            "apply eqListTrans with (PosSort.sort (CPToList t2)); try assumption.",
            "VernacExtend",
            "8dd8b091770f6562f7fb95c243123831f1b02956"
        ],
        [
            "apply eqListSym; assumption.",
            "VernacExtend",
            "02a399eabe1980e32704f0c10ad09ed14ed13f83"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "clear HEq; rename H into HEq; apply eqListOK in HEq.",
            "VernacExtend",
            "0c23683d665d7b3a65f1c4028c9d9fb353b1f04e"
        ],
        [
            "unfold InCP in *; rewrite HEq; auto.",
            "VernacExtend",
            "9afdea891c067e8e1e76686c95314c592528dfb9"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "destruct (pick_variety_auxCP_existsF s t1) as [H1 H2]; clear H2.",
            "VernacExtend",
            "62ecc4714c3cd1184cabdbe4ad78d5386580c55a"
        ],
        [
            "assert (H := H1 Ht1); clear H1; clear Ht1; rename H into Ht1.",
            "VernacExtend",
            "1be0002a17cb37122ce17cf36293edf4ec106d71"
        ],
        [
            "destruct (pick_variety_auxCP_existsF s t2) as [H1 H2]; clear H1.",
            "VernacExtend",
            "1983fb9517800855f0c120aff60a6225c0015142"
        ],
        [
            "rewrite H2; try reflexivity; clear H2.",
            "VernacExtend",
            "c001041b83aa2356b6f2403f159020b28ab9e223"
        ],
        [
            "destruct Ht1 as [p [HIn Hmem]]; exists p; split; auto.",
            "VernacExtend",
            "dff62663d0bfb291bfb99b8a40bf4b1077c12fcb"
        ],
        [
            "apply InCPOCP; apply InCPOCP in HIn.",
            "VernacExtend",
            "d849ff48837ce978d5e79c1f8722a4a44e49a57b"
        ],
        [
            "assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).",
            "VernacExtend",
            "5c3b4c608be404cf878f6018232676e565b284d9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "assert (Ht1 := eqListSortOCP t1).",
            "VernacExtend",
            "a163c2c5b3a0346c4ee734882dcea3e867567466"
        ],
        [
            "assert (Ht2 := eqListSortOCP t2).",
            "VernacExtend",
            "d0467e04f924111032dd8d70f61ecd16c6605867"
        ],
        [
            "apply eqListTrans with (PosSort.sort (CPToList t1)); try assumption.",
            "VernacExtend",
            "aa026a2c26d90bf046f1b6dd5c5e06c5b92a2c23"
        ],
        [
            "apply eqListTrans with (PosSort.sort (CPToList t2)); try assumption.",
            "VernacExtend",
            "8dd8b091770f6562f7fb95c243123831f1b02956"
        ],
        [
            "apply eqListSym; assumption.",
            "VernacExtend",
            "02a399eabe1980e32704f0c10ad09ed14ed13f83"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "clear HEq; rename H into HEq; apply eqListOK in HEq.",
            "VernacExtend",
            "0c23683d665d7b3a65f1c4028c9d9fb353b1f04e"
        ],
        [
            "unfold InCP in *; rewrite <- HEq; auto.",
            "VernacExtend",
            "a099e3834263a7c2a5d4f7ce743b7406e1c993ee"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition pick_variety (s : SS.elt) (st : STt) := STexists_ (fun t => pick_variety_aux s t) st.",
            "VernacDefinition",
            "1a9b0520252481f1b86aa457f6aeedb7fa8dbda8"
        ],
        [
            "Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.",
            "VernacStartTheoremProof",
            "5f5fd7be88ec92c51aa9cefe0c5031b171f7f3e6"
        ],
        [
            "intros x1 y1 HXY1.",
            "VernacExtend",
            "839d87017942d79600eeec0cf6d4a3a8d53be2f0"
        ],
        [
            "intros x2 y2 HXY2.",
            "VernacExtend",
            "72d0f0e4ccac3df1be118fdffeefc22942a18e41"
        ],
        [
            "rewrite HXY2; clear HXY2; clear x2.",
            "VernacExtend",
            "217a3f73d76b4dbc8476ef7896276ddcfb4900ee"
        ],
        [
            "unfold pick_variety; unfold pick_variety_aux.",
            "VernacExtend",
            "fd1a529a9250cba9a45b63c7bff5b16be81c175a"
        ],
        [
            "unfold STexists_.",
            "VernacExtend",
            "aa1f6030009eee1f61d9239ef34e1efe10216653"
        ],
        [
            "induction y2; try reflexivity.",
            "VernacExtend",
            "9bc7e2e0d8f2744fec2f179d9ae5ab29092a4f47"
        ],
        [
            "rewrite IHy2; clear IHy2.",
            "VernacExtend",
            "7afe3007b352f848316e4117bb07f43e7ba64eef"
        ],
        [
            "assert (HEqMem : forall e, S.mem e x1 = S.mem e y1) by (intro; apply SWP.Dec.F.mem_m; intuition); clear HXY1.",
            "VernacExtend",
            "dc3008b54c8ea1251588e531a5ef635ed83b917b"
        ],
        [
            "assert (HF : forall n a, (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) x1 && S.mem (snd t0) x1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) x1 && F n0 (tailCP t0) end) n a = (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) y1 && S.mem (snd t0) y1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) y1 && F n0 (tailCP t0) end) n a) by (induction n; try (intro; do 2 (rewrite HEqMem); reflexivity); intro ; rewrite HEqMem; rewrite IHn; reflexivity).",
            "VernacExtend",
            "d861c6692d8a787ce452ee8512e2bbd4eec0d785"
        ],
        [
            "unfold pick_variety_auxCP.",
            "VernacExtend",
            "67106bba5b16bd7413870edee1fb640765038106"
        ],
        [
            "rewrite HF; reflexivity.",
            "VernacExtend",
            "09a8f7262bb9604a76e118f7be8c53ae5a1c747c"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).",
            "VernacStartTheoremProof",
            "077f6188f0b1bc2cebbd5b0c06fd70eef13579dc"
        ],
        [
            "intros s1 st.",
            "VernacExtend",
            "1eeb9446660711afc968e9465869d1222504fea6"
        ],
        [
            "intros x y HXY.",
            "VernacExtend",
            "d54666da0000fd8bd617b0c87941a7c833808d02"
        ],
        [
            "assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)) by (apply SWP.inter_equal_2; assumption).",
            "VernacExtend",
            "0e12dc4abbd1b25f3b7b1fb3a45dfb16b2f66ae2"
        ],
        [
            "apply proper_0; auto.",
            "VernacExtend",
            "204981aa8eb8eb4f01d206a72ec76af8a8adfee2"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition exists_witness (f : SS.elt -> bool) (s : SS.t) : option SS.elt := SS.choose (SS.filter f s).",
            "VernacDefinition",
            "f99d3fef0613a4d56fcd4d81c975b5e93b0dc3cf"
        ],
        [
            "Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.",
            "VernacStartTheoremProof",
            "923d5c69f0b91e197eb27eb9bad1f1e735fff3d0"
        ],
        [
            "intros e f s HP H.",
            "VernacExtend",
            "d7e9f08bce61d66800ace0de5491371313df1375"
        ],
        [
            "unfold exists_witness in H.",
            "VernacExtend",
            "459fa409f748633674aff369aeb45f44d99639c4"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_2.",
            "VernacExtend",
            "80188289b4d4e5f1772ae5a93b6f4e37e2065425"
        ],
        [
            "apply SSWEqP.choose_mem_1 in H.",
            "VernacExtend",
            "0a4056de4ac591f1e507854a750a5e35d9ac42a4"
        ],
        [
            "rewrite SSWEqP.filter_mem in H; try assumption.",
            "VernacExtend",
            "eb4e4a44306ec507defbab9f7c603dd055918a73"
        ],
        [
            "apply andb_true_iff in H.",
            "VernacExtend",
            "6be4e13be3cc994beedd2c7e4adabd0a944c1be7"
        ],
        [
            "induction H.",
            "VernacExtend",
            "f8e74d6b42ecd6b509e6a20cee53bb69d051cd07"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition pick_varieties_aux (s1 : SS.elt) (ss : SS.t) (st : STt) : (option (SS.elt * SS.elt)) := match ((exists_witness (fun s2 => let i := S.inter s1 s2 in pick_variety i st)) ss) with | None => None | Some s2 => Some(s1,s2) end.",
            "VernacDefinition",
            "15e3d01dae6d0e7aad387d7d56e0b38880150625"
        ],
        [
            "Definition pick_varieties (ss : SS.t) (st : STt) : (option (SS.elt * SS.elt)) := match (exists_witness (fun s => match (pick_varieties_aux s (SS.remove s ss) st) with | None => false | _ => true end) ss) with | None => None | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st end.",
            "VernacDefinition",
            "9a268a1d0bbcc8e428e39a178f0f4150a7b230cb"
        ],
        [
            "Definition eqop (p1 p2 : option SS.elt) := match p1,p2 with | None, None => True | Some s1, Some s2 => True | _, _ => False end.",
            "VernacDefinition",
            "cad54259d96ea5a3ab063320cf581efe1adb12d3"
        ],
        [
            "Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).",
            "VernacStartTheoremProof",
            "a4c7ca2acd028bb13492a571812e05fdec504fa6"
        ],
        [
            "intros f1 f2 s1 s2.",
            "VernacExtend",
            "3b7bce0621dc1f25c8351f1569b67570fbccf8b7"
        ],
        [
            "intros H1 H2 H3 H4.",
            "VernacExtend",
            "02e7de9b75700099689a8ef93869b0d1fd57e14a"
        ],
        [
            "unfold eqop.",
            "VernacExtend",
            "baabe1f8d91fe4c0a6493014348615004ca05458"
        ],
        [
            "unfold exists_witness in *.",
            "VernacExtend",
            "1703644f67a31d0b01cd01accbf275feb679d701"
        ],
        [
            "assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)) by (apply SSWEqP.MP.Dec.F.filter_ext; assumption).",
            "VernacExtend",
            "bcf646321c4bcca4c014df616549e93bdabb9bb7"
        ],
        [
            "case_eq (SS.choose (SS.filter f1 s1)); case_eq (SS.choose (SS.filter f2 s2)).",
            "VernacExtend",
            "036e4dfbb9b9a096f27ef8931666ed74f992807c"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "intros HCN e HCS.",
            "VernacExtend",
            "8338ca6af148978e7c03b3f41a4e8bbfe9e3fc45"
        ],
        [
            "apply SS.choose_spec1 in HCS.",
            "VernacExtend",
            "54a1c90480daef0b98f9b2a1292f9e58f1a4485c"
        ],
        [
            "apply SS.choose_spec2 in HCN.",
            "VernacExtend",
            "83bb49d8b4c55e389ddbb0d7aaff77eb5f56c35b"
        ],
        [
            "rewrite H in HCS.",
            "VernacExtend",
            "c244d326c16b08387f5891d5315ff32d3b03b199"
        ],
        [
            "apply SSWEqP.MP.empty_is_empty_1 in HCN.",
            "VernacExtend",
            "71eb49e317798a7dcf26de582a513976156cd426"
        ],
        [
            "rewrite HCN in HCS.",
            "VernacExtend",
            "31f31c0077552246097645fa68f81b8cc7fbf36c"
        ],
        [
            "rewrite <- SSWEqP.MP.Dec.F.empty_iff.",
            "VernacExtend",
            "5179eefc13cb4c671cf8faa0d4806ea2eef914bc"
        ],
        [
            "eassumption.",
            "VernacExtend",
            "909bfe8655bf95c07560744f733991163ce6cf7e"
        ],
        [
            "intros e HCS HCN.",
            "VernacExtend",
            "cc15df2a9851ee6b1782d02c1286e0c94189ae2b"
        ],
        [
            "apply SS.choose_spec1 in HCS.",
            "VernacExtend",
            "54a1c90480daef0b98f9b2a1292f9e58f1a4485c"
        ],
        [
            "apply SS.choose_spec2 in HCN.",
            "VernacExtend",
            "83bb49d8b4c55e389ddbb0d7aaff77eb5f56c35b"
        ],
        [
            "rewrite H in HCN.",
            "VernacExtend",
            "9edb71f938de655ffb1d0ac0c5f661588087836a"
        ],
        [
            "apply SSWEqP.MP.empty_is_empty_1 in HCN.",
            "VernacExtend",
            "71eb49e317798a7dcf26de582a513976156cd426"
        ],
        [
            "rewrite HCN in HCS.",
            "VernacExtend",
            "31f31c0077552246097645fa68f81b8cc7fbf36c"
        ],
        [
            "rewrite <- SSWEqP.MP.Dec.F.empty_iff.",
            "VernacExtend",
            "5179eefc13cb4c671cf8faa0d4806ea2eef914bc"
        ],
        [
            "eassumption.",
            "VernacExtend",
            "909bfe8655bf95c07560744f733991163ce6cf7e"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition eqopp (p1 p2 : option (SS.elt * SS.elt)) := match p1,p2 with | None, None => True | Some s1, Some s2 => True | _, _ => False end.",
            "VernacDefinition",
            "5de548d23698259f28d922243cf0137050226215"
        ],
        [
            "Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.",
            "VernacStartTheoremProof",
            "ed8c0be5dea5b34d99bee9a46d3db04c054a52d2"
        ],
        [
            "intros x1 y1 HXY1.",
            "VernacExtend",
            "839d87017942d79600eeec0cf6d4a3a8d53be2f0"
        ],
        [
            "intros x2 y2 HXY2.",
            "VernacExtend",
            "72d0f0e4ccac3df1be118fdffeefc22942a18e41"
        ],
        [
            "intros x3 y3 HXY3.",
            "VernacExtend",
            "54f000983cd9a32ca7a1cb9a1942bb5c75938ed0"
        ],
        [
            "unfold pick_varieties_aux.",
            "VernacExtend",
            "a3a4e834efddca9160598b0575ce4af1812d148f"
        ],
        [
            "rewrite HXY3.",
            "VernacExtend",
            "5b1462afde59f7b21a3eae8d3170a08c32d86132"
        ],
        [
            "assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).",
            "VernacExtend",
            "531050db487f2aab10ccdb7ff605ed2aa1a1190f"
        ],
        [
            "apply proper_2.",
            "VernacExtend",
            "239500027425fb496c426724925002aaaba1a02e"
        ],
        [
            "apply proper_1.",
            "VernacExtend",
            "9bcf09b899868f8792d91207a527659acd15ca76"
        ],
        [
            "apply proper_1.",
            "VernacExtend",
            "9bcf09b899868f8792d91207a527659acd15ca76"
        ],
        [
            "intro; apply proper_0; try reflexivity.",
            "VernacExtend",
            "981cb9faf6e5f3470365e916d1d28dfb06dfb080"
        ],
        [
            "apply SWP.inter_equal_1; assumption.",
            "VernacExtend",
            "7d6cb983ff6965f434d050800140b1494715793c"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2); case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).",
            "VernacExtend",
            "c1a78fe75289018726edb9455c57096048c25ab3"
        ],
        [
            "simpl; intuition.",
            "VernacExtend",
            "2a8f84ed3abedbe9d9fbb80aa4215114cbdbe500"
        ],
        [
            "intros HCN e HCS.",
            "VernacExtend",
            "8338ca6af148978e7c03b3f41a4e8bbfe9e3fc45"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "rewrite HCS in H; rewrite HCN in H.",
            "VernacExtend",
            "a1c2c5fe4336f6255ec49ed40a5c6f168fbd79c1"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "intros e HCS HCN.",
            "VernacExtend",
            "cc15df2a9851ee6b1782d02c1286e0c94189ae2b"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "rewrite HCS in H; rewrite HCN in H.",
            "VernacExtend",
            "a1c2c5fe4336f6255ec49ed40a5c6f168fbd79c1"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.",
            "VernacStartTheoremProof",
            "6d42d9971a297e5833c79b6bc56c46ed0d3ae031"
        ],
        [
            "intros s1 s2 ss st H.",
            "VernacExtend",
            "c27339d1ee4b2a77e48b96a4ddc7798dbd5ef0f0"
        ],
        [
            "unfold pick_varieties in H.",
            "VernacExtend",
            "7d17d58e692eb960b07e24f02fbd057f534c2378"
        ],
        [
            "case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).",
            "VernacExtend",
            "464666ea7da2d4f6cb678035b88a7e6882552f19"
        ],
        [
            "intros e1 HEW1.",
            "VernacExtend",
            "2a567fdfa1687036465e1fef611850045d37fc9f"
        ],
        [
            "rewrite HEW1 in H.",
            "VernacExtend",
            "675a71248c7e01878edf2823776d4e708c05ea35"
        ],
        [
            "unfold pick_varieties_aux in H.",
            "VernacExtend",
            "556f926315b15e367bd30449705a02058dee3e33"
        ],
        [
            "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).",
            "VernacExtend",
            "01129f536557c98f72026be232516552fd4a1323"
        ],
        [
            "intros e2 HEW2.",
            "VernacExtend",
            "1fc16878958b87d1f6f17c6498177d00d77d2623"
        ],
        [
            "rewrite HEW2 in H.",
            "VernacExtend",
            "eb15a01b423c775fe31cb25516074627e7cc25f3"
        ],
        [
            "assert (HEq1 : e1 = s1) by (injection H; intros; assumption).",
            "VernacExtend",
            "eca0a22fbf0e00fb9e046c8d9e079db5eb02db8d"
        ],
        [
            "rewrite HEq1 in *.",
            "VernacExtend",
            "37c5421f284fa2ad1c4d42b884307839417831b3"
        ],
        [
            "assert (HEq2 : e2 = s2) by (injection H; intros; assumption).",
            "VernacExtend",
            "10cc392df03719c33e189136ddd05b3b090309f3"
        ],
        [
            "rewrite HEq2 in *.",
            "VernacExtend",
            "901b7385eb26cebf2c5c7d2cdf91d7a0df36bf69"
        ],
        [
            "apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).",
            "VernacExtend",
            "53932465c83c5fc4da483cfcb6b55cd46e0ea719"
        ],
        [
            "intros x y HXY.",
            "VernacExtend",
            "d54666da0000fd8bd617b0c87941a7c833808d02"
        ],
        [
            "assert (SS.Equal (SS.remove x ss) (SS.remove y ss)) by (apply SSWP.Dec.F.remove_m; try assumption; reflexivity).",
            "VernacExtend",
            "0ffa093fb04731b954184d9445abadd14c4f3509"
        ],
        [
            "assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)) by (apply proper_3; auto).",
            "VernacExtend",
            "8e7a0a1495c391e1a9c3528f038f6d83c2934ea8"
        ],
        [
            "case_eq (pick_varieties_aux x (SS.remove x ss) st); intros; case_eq (pick_varieties_aux y (SS.remove y ss) st); intros.",
            "VernacExtend",
            "3c63a7cd2265a6e31cce081f41cd66f9969abefa"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "rewrite H2 in H1; rewrite H3 in H1.",
            "VernacExtend",
            "d60d017c158b623d3de57a4a7472debbb0bafae4"
        ],
        [
            "unfold eqop in H1; simpl in H1.",
            "VernacExtend",
            "a5f5b655078facd7f0685ddfdae397d40e5c349d"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "rewrite H2 in H1; rewrite H3 in H1.",
            "VernacExtend",
            "d60d017c158b623d3de57a4a7472debbb0bafae4"
        ],
        [
            "unfold eqop in H1; simpl in H1.",
            "VernacExtend",
            "a5f5b655078facd7f0685ddfdae397d40e5c349d"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "intro HEW2.",
            "VernacExtend",
            "d765abbe0b296e489e225764f0cf4941b2608cbc"
        ],
        [
            "rewrite HEW2 in H.",
            "VernacExtend",
            "eb15a01b423c775fe31cb25516074627e7cc25f3"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "intro HEW.",
            "VernacExtend",
            "75beebc8353c6e7b1940af049fb3ad7d4a61baf5"
        ],
        [
            "rewrite HEW in H.",
            "VernacExtend",
            "fac42e5535f2f796d1d2c954dc42cd01dd34d6e7"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).",
            "VernacStartTheoremProof",
            "29ab70a5c342f2b359b6b7798169d1e3cc219053"
        ],
        [
            "intros s1 s2 ss st H.",
            "VernacExtend",
            "c27339d1ee4b2a77e48b96a4ddc7798dbd5ef0f0"
        ],
        [
            "unfold pick_varieties in H.",
            "VernacExtend",
            "7d17d58e692eb960b07e24f02fbd057f534c2378"
        ],
        [
            "case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).",
            "VernacExtend",
            "464666ea7da2d4f6cb678035b88a7e6882552f19"
        ],
        [
            "intros e1 HEW1.",
            "VernacExtend",
            "2a567fdfa1687036465e1fef611850045d37fc9f"
        ],
        [
            "rewrite HEW1 in H.",
            "VernacExtend",
            "675a71248c7e01878edf2823776d4e708c05ea35"
        ],
        [
            "unfold pick_varieties_aux in H.",
            "VernacExtend",
            "556f926315b15e367bd30449705a02058dee3e33"
        ],
        [
            "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).",
            "VernacExtend",
            "01129f536557c98f72026be232516552fd4a1323"
        ],
        [
            "intros e2 HEW2.",
            "VernacExtend",
            "1fc16878958b87d1f6f17c6498177d00d77d2623"
        ],
        [
            "rewrite HEW2 in H.",
            "VernacExtend",
            "eb15a01b423c775fe31cb25516074627e7cc25f3"
        ],
        [
            "assert (HEq1 : e1 = s1) by (injection H; intros; assumption).",
            "VernacExtend",
            "eca0a22fbf0e00fb9e046c8d9e079db5eb02db8d"
        ],
        [
            "rewrite HEq1 in *.",
            "VernacExtend",
            "37c5421f284fa2ad1c4d42b884307839417831b3"
        ],
        [
            "assert (HEq2 : e2 = s2) by (injection H; intros; assumption).",
            "VernacExtend",
            "10cc392df03719c33e189136ddd05b3b090309f3"
        ],
        [
            "rewrite HEq2 in *.",
            "VernacExtend",
            "901b7385eb26cebf2c5c7d2cdf91d7a0df36bf69"
        ],
        [
            "apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).",
            "VernacExtend",
            "68783e190bcb313873d41573dd8a98c43ae3a5f3"
        ],
        [
            "intros x y HXY.",
            "VernacExtend",
            "d54666da0000fd8bd617b0c87941a7c833808d02"
        ],
        [
            "apply proper_1; assumption.",
            "VernacExtend",
            "0769e46a4af2e2ad3ea97622de5c8d069d48437f"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "intro HEW2.",
            "VernacExtend",
            "d765abbe0b296e489e225764f0cf4941b2608cbc"
        ],
        [
            "rewrite HEW2 in H.",
            "VernacExtend",
            "eb15a01b423c775fe31cb25516074627e7cc25f3"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "intro HEW.",
            "VernacExtend",
            "75beebc8353c6e7b1940af049fb3ad7d4a61baf5"
        ],
        [
            "rewrite HEW in H.",
            "VernacExtend",
            "fac42e5535f2f796d1d2c954dc42cd01dd34d6e7"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.",
            "VernacExtend",
            "c381b19511dad27bf15fe01771e87502a53e6441"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).",
            "VernacExtend",
            "512a8cb70b8cece637bbd9d79fe400a16186bb69"
        ],
        [
            "apply SSWP.remove_cardinal_1.",
            "VernacExtend",
            "d3fb399c6dc800565080f6ddf28445ae3aaf00d7"
        ],
        [
            "apply pick_varieties_ok_1 with s2 st.",
            "VernacExtend",
            "b1cbb97c9dd744a0b14a4571f230a22316969f88"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).",
            "VernacExtend",
            "40a70da9bf3a73cb3132dd3b585d310b33ceaa5f"
        ],
        [
            "apply eq_S.",
            "VernacExtend",
            "8ef0b219ea0189c2d80bb55d03c4c9f24beca469"
        ],
        [
            "apply SSWP.remove_cardinal_1.",
            "VernacExtend",
            "d3fb399c6dc800565080f6ddf28445ae3aaf00d7"
        ],
        [
            "apply pick_varieties_ok_2 with st.",
            "VernacExtend",
            "19fd6807283d96a12179dd8a74004c8fc387a31a"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).",
            "VernacExtend",
            "6ddf214d5df1f14c80b31dd5baefeb6a786b1217"
        ],
        [
            "transitivity (S(SS.cardinal (SS.remove s1 ss))); assumption.",
            "VernacExtend",
            "2c3fb6bc531e6d3df65b59af87dca82ccbd4e91a"
        ],
        [
            "elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))); intro HDec.",
            "VernacExtend",
            "8dddb5e44aea6caead8ae3d15ef4e3e31ff0e627"
        ],
        [
            "assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).",
            "VernacExtend",
            "2f285606a5b6ca7472c026ea2fc71ae84a1d84a0"
        ],
        [
            "apply SSWP.add_cardinal_1; assumption.",
            "VernacExtend",
            "bd051711223beec788d3db4fda21c45f77e8d292"
        ],
        [
            "rewrite HR2.",
            "VernacExtend",
            "ffdd15b9ffd74def816cfaea7dddac1b290743a8"
        ],
        [
            "rewrite <- HR1.",
            "VernacExtend",
            "162c9dc20d9b6d43afcfffae0c8dbb00d1133297"
        ],
        [
            "apply le_S;apply le_n.",
            "VernacExtend",
            "f668231be5e47dbadfd8dc6d21bc7e5b062fec36"
        ],
        [
            "assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).",
            "VernacExtend",
            "06136665d964e4e3a8e9a3af54334d9d88538572"
        ],
        [
            "apply SSWP.add_cardinal_2; assumption.",
            "VernacExtend",
            "c2d31a8fa4a1b4dcda0b34809325584a05256433"
        ],
        [
            "rewrite HR2.",
            "VernacExtend",
            "ffdd15b9ffd74def816cfaea7dddac1b290743a8"
        ],
        [
            "rewrite <- HR1.",
            "VernacExtend",
            "162c9dc20d9b6d43afcfffae0c8dbb00d1133297"
        ],
        [
            "apply le_n.",
            "VernacExtend",
            "cd4ea009ba050d55c0c5552f05ee5752a2fad9f9"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.",
            "VernacDefinition",
            "12c3b4787d67a38f950b5d3730fcfbd9cc5c4ec8"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "exact (S.mem (fst cp) s && S.mem (snd cp) s).",
            "VernacExtend",
            "e79c8d5e0b72da2b3c9837c42901f8973a232546"
        ],
        [
            "exact (S.mem (fst cp) s && (IHm (snd cp))).",
            "VernacExtend",
            "544f9494d5846b62e05f22b0b26da8037ed36839"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.",
            "VernacStartTheoremProof",
            "ec960a32511a5aae58a8a7a1a26e6a5d56f588ec"
        ],
        [
            "induction m; unfold memCPAux; unfold nat_rect; reflexivity.",
            "VernacExtend",
            "59e86837915cf137416150257fc34d472638d18f"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).",
            "VernacStartTheoremProof",
            "ba4ad87ccead14fa9480ed3463088a4ab1173159"
        ],
        [
            "intros m cp1 cp2 Hcp s1 s2 Hs.",
            "VernacExtend",
            "bce6e91c739cc8f8904704d44df1935dc688f520"
        ],
        [
            "rewrite Hcp; clear Hcp; clear cp1; rename cp2 into cp.",
            "VernacExtend",
            "df9c9a6dd397c507e20f2bdbabcc37325b3cab65"
        ],
        [
            "unfold memCPAux.",
            "VernacExtend",
            "13c4e9e9e786b5a9b34e2fcd18aae71c78466afc"
        ],
        [
            "assert (H : forall p, S.mem p s1 = S.mem p s2) by (intro p; apply SWP.Dec.F.mem_m; trivial).",
            "VernacExtend",
            "0db0200f35136ca3c1791991edb406aa6f6a8faa"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "simpl; do 2 (rewrite H); reflexivity.",
            "VernacExtend",
            "490bc1845658470db1f72470ddd92afca5521d8d"
        ],
        [
            "simpl; rewrite H; rewrite IHm; reflexivity.",
            "VernacExtend",
            "7db524c5167a6bed287517a8ac95bb2e9943e968"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.",
            "VernacStartTheoremProof",
            "1b9f4fe351649679eefb12638ddcf1205d72c3b5"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "unfold memCPAux.",
            "VernacExtend",
            "13c4e9e9e786b5a9b34e2fcd18aae71c78466afc"
        ],
        [
            "intros cp s e Hmem HIn.",
            "VernacExtend",
            "ca685067b057cb6784d0b869b26e904bd1081074"
        ],
        [
            "unfold InCP in HIn.",
            "VernacExtend",
            "e5d26015d2e77c81bd42744c6bdc7e75b5d74f82"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "rewrite andb_true_iff in Hmem.",
            "VernacExtend",
            "05a6836892cba66ec4c2424e566092d984675276"
        ],
        [
            "do 2 (elim HIn; clear HIn; intro HIn; try (subst; spliter; auto)).",
            "VernacExtend",
            "1b8824d0c09c47ebc5f67b92ff443ecdef7f41d0"
        ],
        [
            "intros cp s e Hmem HIn.",
            "VernacExtend",
            "ca685067b057cb6784d0b869b26e904bd1081074"
        ],
        [
            "apply InCPOK in HIn.",
            "VernacExtend",
            "827e18e8f2c3cb87bf159d43eae1b086072ea3d1"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "simpl in Hmem.",
            "VernacExtend",
            "3f0d477edf114dff7e49365e925a6a25ccb7b581"
        ],
        [
            "rewrite andb_true_iff in Hmem.",
            "VernacExtend",
            "05a6836892cba66ec4c2424e566092d984675276"
        ],
        [
            "spliter.",
            "VernacExtend",
            "fab9e3eab81eb4c88790dca05ccb5bd23a4d6dd0"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "apply IHm with (tailCP cp); try assumption.",
            "VernacExtend",
            "d64b741906b831c2ddf6d11a63373426bb833438"
        ],
        [
            "simpl in Hmem.",
            "VernacExtend",
            "3f0d477edf114dff7e49365e925a6a25ccb7b581"
        ],
        [
            "rewrite andb_true_iff in Hmem.",
            "VernacExtend",
            "05a6836892cba66ec4c2424e566092d984675276"
        ],
        [
            "spliter.",
            "VernacExtend",
            "fab9e3eab81eb4c88790dca05ccb5bd23a4d6dd0"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.",
            "VernacStartTheoremProof",
            "15fe7cc59b99f7cbe138e05c66e314615d0e7bd4"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "unfold memCPAux.",
            "VernacExtend",
            "13c4e9e9e786b5a9b34e2fcd18aae71c78466afc"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "intros cp s H.",
            "VernacExtend",
            "a7405790c69d26de5f50e910760ae178b734269d"
        ],
        [
            "rewrite andb_true_iff.",
            "VernacExtend",
            "2e0a0ffca5d243f404153bc36ad3db5c01c2e4b5"
        ],
        [
            "assert (HIn1 : InCP (fst cp) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "33cd1ea3be42ebcb486dd2565d08ac95b74120c4"
        ],
        [
            "assert (HIn2 : InCP (snd cp) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "88ba55fb9d350b5af188a19072fa22706fab204b"
        ],
        [
            "split; apply H; assumption.",
            "VernacExtend",
            "b898465dc5fc9b5f7fc65b3bcd149b82da5191e1"
        ],
        [
            "intros cp s H.",
            "VernacExtend",
            "a7405790c69d26de5f50e910760ae178b734269d"
        ],
        [
            "rewrite memCPAuxHdTl.",
            "VernacExtend",
            "374c485b4bd6b8f694800e512eeaf5dad2aef2f8"
        ],
        [
            "rewrite andb_true_iff.",
            "VernacExtend",
            "2e0a0ffca5d243f404153bc36ad3db5c01c2e4b5"
        ],
        [
            "assert (HIn : InCP (fst cp) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "512262af16b3c93e69838ad31c4f2d700ce4ddf3"
        ],
        [
            "split; try (apply H; assumption); clear HIn.",
            "VernacExtend",
            "47a7ad8728c27bbffff164ccfa20aa28667ce9e3"
        ],
        [
            "apply IHm.",
            "VernacExtend",
            "aa76f2273bef46821b36b49418f7132330cc05f1"
        ],
        [
            "intros e HIn.",
            "VernacExtend",
            "4376b87e7e7aeaba492e6fe1c2ad3aada03aeb9b"
        ],
        [
            "apply H.",
            "VernacExtend",
            "4b47b71ad0f800d57cbdc591d68949e07decb540"
        ],
        [
            "apply InCPOK.",
            "VernacExtend",
            "dfa8a6a6faa3c43183de0c1b249004a0d6c0786b"
        ],
        [
            "right.",
            "VernacExtend",
            "27e417a3497755767e1a1d6ba87753ecddaee6b7"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.",
            "VernacStartTheoremProof",
            "5ca9321a1e268f58ece613041d4878713edc51a1"
        ],
        [
            "intros m cp s Hmemcp.",
            "VernacExtend",
            "f582e74bb038bef1bb8c94eb92191c0727a25724"
        ],
        [
            "apply memMemCPAuxOK.",
            "VernacExtend",
            "8828f577392acb3a4f618f68f56aadf08b65ab72"
        ],
        [
            "intros e HIn.",
            "VernacExtend",
            "4376b87e7e7aeaba492e6fe1c2ad3aada03aeb9b"
        ],
        [
            "apply memCPAuxOK with (S m) cp; try assumption.",
            "VernacExtend",
            "d6d8e312f34edd9de2794040a2ae562a7a72bfe4"
        ],
        [
            "apply InCPOK.",
            "VernacExtend",
            "dfa8a6a6faa3c43183de0c1b249004a0d6c0786b"
        ],
        [
            "right; assumption.",
            "VernacExtend",
            "4b9041b9a9d920fdce6d3e18e05e4d1a743614d5"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition memCP (cp : cartesianPower positive (S (S (S n)))) (s : SS.elt) := memCPAux (S n) cp s.",
            "VernacDefinition",
            "97529fc22763e2d6940163b4aa2f9f4d19f35a6d"
        ],
        [
            "Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.",
            "VernacStartTheoremProof",
            "1ce1c6c3c6a1e4499839df9add767effeeff3ea4"
        ],
        [
            "apply memCPAuxProperOK.",
            "VernacExtend",
            "43903a781e11b014746daecc02f9b1d728767fee"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memMemCPOK : forall cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.",
            "VernacStartTheoremProof",
            "d3153e3b6f948440b5b1737a2a5976f90ed58347"
        ],
        [
            "apply memMemCPAuxOK.",
            "VernacExtend",
            "8828f577392acb3a4f618f68f56aadf08b65ab72"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.",
            "VernacStartTheoremProof",
            "af0ca8009f21f0daef82eee5dc2c08553482a04f"
        ],
        [
            "intros p s x Hmem Hmemcp.",
            "VernacExtend",
            "f47010e4afa3a3b20a5489cfea2afe23b4da8726"
        ],
        [
            "apply memMemCPOK.",
            "VernacExtend",
            "81c4056d801300449f059600c08a4b63c9e230d1"
        ],
        [
            "intros e HIn.",
            "VernacExtend",
            "4376b87e7e7aeaba492e6fe1c2ad3aada03aeb9b"
        ],
        [
            "apply InCPOK in HIn.",
            "VernacExtend",
            "827e18e8f2c3cb87bf159d43eae1b086072ea3d1"
        ],
        [
            "simpl in HIn.",
            "VernacExtend",
            "af19e5789c5bd9adae0bce08955f8a2a5a9a0a1c"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "subst; assumption.",
            "VernacExtend",
            "7e743ec2514456ab315be0cfedd9ae3caf020d0d"
        ],
        [
            "apply memCPAuxOK with n x; assumption.",
            "VernacExtend",
            "d789b78afceb625938d7b45a04f0d782a4dbd237"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition test_coinc (ss : SS.t) (st : STt) (cp : cartesianPower positive (S (S (S n)))) : bool := let newss := identify_varieties ss st in SS.exists_ (fun s => memCP cp s) newss.",
            "VernacDefinition",
            "feb2a43ea1309082cf449ce4ec1d7d0d36254784"
        ],
        [
            "Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.",
            "VernacStartTheoremProof",
            "3cfb3b370af792de865327fb9762276e6428e439"
        ],
        [
            "intros s1 s2 m cp.",
            "VernacExtend",
            "1a66e7efab753c1afc769a1cda87095a9112f4a9"
        ],
        [
            "induction m; simpl; do 2 (rewrite andb_true_iff); intro Hhtspa.",
            "VernacExtend",
            "a082509bfc327cfc414c4aca07b8a7d596a3341a"
        ],
        [
            "do 2 (rewrite SWP.FM.inter_b in Hhtspa).",
            "VernacExtend",
            "706436f8d09f0eede50ffb530ef55b97c0c6173b"
        ],
        [
            "do 2 (rewrite andb_true_iff in Hhtspa).",
            "VernacExtend",
            "8fb8d3b778e6ff09a135488d7a706a5c864d0631"
        ],
        [
            "tauto.",
            "VernacExtend",
            "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
        ],
        [
            "destruct Hhtspa as [Hmem Hhtspa].",
            "VernacExtend",
            "751c14709413f6e428878ef2b968c7167b1e165c"
        ],
        [
            "rewrite SWP.FM.inter_b in Hmem.",
            "VernacExtend",
            "7e5d90c415678b8c4844b2bf37002a50d6b71971"
        ],
        [
            "rewrite andb_true_iff in Hmem.",
            "VernacExtend",
            "05a6836892cba66ec4c2424e566092d984675276"
        ],
        [
            "split; try (spliter; assumption).",
            "VernacExtend",
            "a6154d1e3d7ff72721b03c149001b51f51c3e91f"
        ],
        [
            "apply IHm; assumption.",
            "VernacExtend",
            "28e948b98405d2301427861e7997ec5ddc733b85"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.",
            "VernacStartTheoremProof",
            "b8e293175d36eea25e06e4b3ad68688a42d95870"
        ],
        [
            "intros s1 s2 m cp.",
            "VernacExtend",
            "1a66e7efab753c1afc769a1cda87095a9112f4a9"
        ],
        [
            "induction m; simpl; do 2 (rewrite andb_true_iff); intro Hhtspa.",
            "VernacExtend",
            "a082509bfc327cfc414c4aca07b8a7d596a3341a"
        ],
        [
            "do 2 (rewrite SWP.FM.inter_b in Hhtspa).",
            "VernacExtend",
            "706436f8d09f0eede50ffb530ef55b97c0c6173b"
        ],
        [
            "do 2 (rewrite andb_true_iff in Hhtspa).",
            "VernacExtend",
            "8fb8d3b778e6ff09a135488d7a706a5c864d0631"
        ],
        [
            "tauto.",
            "VernacExtend",
            "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
        ],
        [
            "destruct Hhtspa as [Hmem Hhtspa].",
            "VernacExtend",
            "751c14709413f6e428878ef2b968c7167b1e165c"
        ],
        [
            "rewrite SWP.FM.inter_b in Hmem.",
            "VernacExtend",
            "7e5d90c415678b8c4844b2bf37002a50d6b71971"
        ],
        [
            "rewrite andb_true_iff in Hmem.",
            "VernacExtend",
            "05a6836892cba66ec4c2424e566092d984675276"
        ],
        [
            "split; try (spliter; assumption).",
            "VernacExtend",
            "a6154d1e3d7ff72721b03c149001b51f51c3e91f"
        ],
        [
            "apply IHm; assumption.",
            "VernacExtend",
            "28e948b98405d2301427861e7997ec5ddc733b85"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).",
            "VernacDefinition",
            "10a4e5cf3eee5beab64ebb0c694f45e1cd68b274"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "exact (interp cp).",
            "VernacExtend",
            "6b1941c68000b3ffc21a8d3bac0de2e38c8dc6c6"
        ],
        [
            "clear IHm.",
            "VernacExtend",
            "f146c476dfe2496aa8dbd81475d23c7e79471842"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "exact (interp (headCP cp)).",
            "VernacExtend",
            "cdb55640373e08b31c97b38351186f6718b06256"
        ],
        [
            "exact (interp (tailCP cp)).",
            "VernacExtend",
            "808a98427e441fbf912f7f7c5f2d48e1a3ecbf9c"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "exact (interp (headCP cp)).",
            "VernacExtend",
            "cdb55640373e08b31c97b38351186f6718b06256"
        ],
        [
            "exact (IHm (tailCP cp)).",
            "VernacExtend",
            "660bc9b2ab210f36ff1cd0f561c59b2b2ff90206"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).",
            "VernacStartTheoremProof",
            "af27b5c9f3a3aa74728c3ea134558049211d5670"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "unfold interp_CP; unfold nat_rect; simpl; reflexivity.",
            "VernacExtend",
            "da362bb844f474aed5b50ff4b24ff3e822b46349"
        ],
        [
            "induction m; unfold interp_CP; unfold nat_rect; simpl; reflexivity.",
            "VernacExtend",
            "b0ff195588dafa3f66c057a7007b6fbee0da490e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).",
            "VernacStartTheoremProof",
            "71776e7744f70ba5591a3353d416c110cd3d2288"
        ],
        [
            "induction m; unfold interp_CP; unfold nat_rect; simpl; reflexivity.",
            "VernacExtend",
            "b0ff195588dafa3f66c057a7007b6fbee0da490e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).",
            "VernacStartTheoremProof",
            "7db7f9fb15c80b8e0a538a42fd1f86e413c03001"
        ],
        [
            "induction m; intros cp interp.",
            "VernacExtend",
            "cdbfe98194b23eb62b5f36e8c6aba6991ae90383"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "induction m; try (clear IHm0).",
            "VernacExtend",
            "3e7089333002926e786dbe33f9d42a2e42ca5d11"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "rewrite CPToListOK.",
            "VernacExtend",
            "eef100557e9be0c6aaae82db33eb1f15d005d960"
        ],
        [
            "rewrite <- interp_CPHdOK.",
            "VernacExtend",
            "5d2da9c6fbe2f8afa24f11ed029a603e7fc4c9cf"
        ],
        [
            "rewrite <- interp_CPTlOK.",
            "VernacExtend",
            "46a4aa46ac7d9859dca557a9c9f5d2ea467df11c"
        ],
        [
            "rewrite IHm.",
            "VernacExtend",
            "bf73c511f9e37493a929521561a4b35798c2f374"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Context {COP : Coinc_predicates AR}.",
            "VernacContext",
            "2cb990ea2c9da6c0db62dd95e53f10648406aa2f"
        ],
        [
            "Definition ss_ok (ss : SS.t) (interp: positive -> COINCpoint) := forall s, SS.mem s ss = true -> forall cp, memCP cp s = true -> app coinc (interp_CP cp interp).",
            "VernacDefinition",
            "284d8d0b0958dfb1bc93a9e44da2d91b2c61aa0b"
        ],
        [
            "Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.",
            "VernacStartTheoremProof",
            "e1a164b7afbbc40a622d220f3961f1e74edf7c13"
        ],
        [
            "intros cp x interp.",
            "VernacExtend",
            "b0b8f8e9c0d248204b66a404201b5725ca092bbf"
        ],
        [
            "apply CP_ind; simpl; reflexivity.",
            "VernacExtend",
            "aaee9b56a120ea0c39fc48226cebecec3e1290cb"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).",
            "VernacStartTheoremProof",
            "bd52a473a64d239c89b225296a1d05c4ae5b2970"
        ],
        [
            "intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.",
            "VernacExtend",
            "08a5c5597e4dd6f222dff4f597deb585a7c03c3c"
        ],
        [
            "apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)); try (simpl; reflexivity).",
            "VernacExtend",
            "d2ffba286eab905b8aab0e67de7a3e1ae0fd3089"
        ],
        [
            "assert (Hmemcp : memCPAux n x s1 = true) by (apply pick_variety_aux_memCPAux1 with s2; assumption).",
            "VernacExtend",
            "b0247131b98ca5d819d731b0ecb6ebb64f511317"
        ],
        [
            "unfold ss_ok in HSSOK.",
            "VernacExtend",
            "fb79fe79a7cd485afafe217a6d2f820cd3005093"
        ],
        [
            "rewrite consHdInterpOK.",
            "VernacExtend",
            "98cbd596a571620a602acbc2d2d85dd1fc8b5653"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_1 in HIn.",
            "VernacExtend",
            "72a24f43f7bf3cf4547eece58fce7881a0de80cf"
        ],
        [
            "apply HSSOK with s1; try assumption.",
            "VernacExtend",
            "970ab1185d894edd7cc80aa7c71c19df7910cdb9"
        ],
        [
            "apply memCPConsHd; assumption.",
            "VernacExtend",
            "9f189af709fde17aade00daedd4d12ed442120d4"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).",
            "VernacStartTheoremProof",
            "af7a925dce51d5cc4a6c22ee59869d3c6eda1ee9"
        ],
        [
            "intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.",
            "VernacExtend",
            "08a5c5597e4dd6f222dff4f597deb585a7c03c3c"
        ],
        [
            "apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)); try (simpl; reflexivity).",
            "VernacExtend",
            "d2ffba286eab905b8aab0e67de7a3e1ae0fd3089"
        ],
        [
            "assert (Hmemcp : memCPAux n x s2 = true) by (apply pick_variety_aux_memCPAux2 with s1; assumption).",
            "VernacExtend",
            "a6c3a3883eb9ba2c3e7afbb8f77afcdfba982be6"
        ],
        [
            "unfold ss_ok in HSSOK.",
            "VernacExtend",
            "fb79fe79a7cd485afafe217a6d2f820cd3005093"
        ],
        [
            "rewrite consHdInterpOK.",
            "VernacExtend",
            "98cbd596a571620a602acbc2d2d85dd1fc8b5653"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_1 in HIn.",
            "VernacExtend",
            "72a24f43f7bf3cf4547eece58fce7881a0de80cf"
        ],
        [
            "apply HSSOK with s2; try assumption.",
            "VernacExtend",
            "6b059b0628b94dd1c649706c31ba3b5e49e01529"
        ],
        [
            "apply memCPConsHd; assumption.",
            "VernacExtend",
            "9f189af709fde17aade00daedd4d12ed442120d4"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).",
            "VernacStartTheoremProof",
            "02f9c391e63dcb238f2d29a144b1745ef799dff4"
        ],
        [
            "induction m; intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.",
            "VernacExtend",
            "08cfc59d2407a26875f43296d7b3b3b4db9d694a"
        ],
        [
            "unfold pred_conj_aux.",
            "VernacExtend",
            "bd1b5bf6d11f97aee66c41b847bbeb2dd45b0aff"
        ],
        [
            "unfold nat_rect.",
            "VernacExtend",
            "1b4ce131edbf45d22d55e9871509740d1bf39d55"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "assert (HIn : InCP (headCP cp) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "004b17a0a4a1715d6ccf8c26585ef6fad3733eea"
        ],
        [
            "assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true) by (apply memCPAuxOK with 1 cp; assumption).",
            "VernacExtend",
            "93f67030142098363c2bc983e870138272137d53"
        ],
        [
            "rewrite SWP.FM.union_b in HElim.",
            "VernacExtend",
            "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
        ],
        [
            "apply orb_true_iff in HElim.",
            "VernacExtend",
            "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
        ],
        [
            "elim HElim; clear HElim; intro HElim.",
            "VernacExtend",
            "588d1e900b6f6f32fb617753805c9df2cf5623a9"
        ],
        [
            "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
            "VernacExtend",
            "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
        ],
        [
            "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
            "VernacExtend",
            "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "assert (HIn : InCP (headCP (tailCP cp)) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "39d1901bb3cbca87c1be888f9388c10b8093d25c"
        ],
        [
            "assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true) by (apply memCPAuxOK with 1 cp; assumption).",
            "VernacExtend",
            "819e2c58e19373efa096221d997a58e595a3f979"
        ],
        [
            "rewrite SWP.FM.union_b in HElim.",
            "VernacExtend",
            "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
        ],
        [
            "apply orb_true_iff in HElim.",
            "VernacExtend",
            "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
        ],
        [
            "elim HElim; clear HElim; intro HElim.",
            "VernacExtend",
            "588d1e900b6f6f32fb617753805c9df2cf5623a9"
        ],
        [
            "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
            "VernacExtend",
            "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
        ],
        [
            "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
            "VernacExtend",
            "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
        ],
        [
            "assert (HIn : InCP (tailCP (tailCP cp)) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "29916a3673e99289b60ee1a60ebcf3421f49ea3c"
        ],
        [
            "assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true) by (apply memCPAuxOK with 1 cp; assumption).",
            "VernacExtend",
            "3475484b3e2acd12673e1c8c638e4b04bc2da626"
        ],
        [
            "rewrite SWP.FM.union_b in HElim.",
            "VernacExtend",
            "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
        ],
        [
            "apply orb_true_iff in HElim.",
            "VernacExtend",
            "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
        ],
        [
            "elim HElim; clear HElim; intro HElim.",
            "VernacExtend",
            "588d1e900b6f6f32fb617753805c9df2cf5623a9"
        ],
        [
            "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
            "VernacExtend",
            "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
        ],
        [
            "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
            "VernacExtend",
            "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
        ],
        [
            "rewrite pcaHdTl.",
            "VernacExtend",
            "c71cf03407ff29266d5d9397122c59144cf18e8b"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "assert (HIn : InCP (headCP cp) cp) by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "004b17a0a4a1715d6ccf8c26585ef6fad3733eea"
        ],
        [
            "assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true) by (apply memCPAuxOK with (S (S m)) cp; assumption).",
            "VernacExtend",
            "b277a463e0d837ae675a6ca0661f5491417d476c"
        ],
        [
            "rewrite SWP.FM.union_b in HElim.",
            "VernacExtend",
            "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
        ],
        [
            "apply orb_true_iff in HElim.",
            "VernacExtend",
            "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
        ],
        [
            "elim HElim; clear HElim; intro HElim.",
            "VernacExtend",
            "588d1e900b6f6f32fb617753805c9df2cf5623a9"
        ],
        [
            "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
            "VernacExtend",
            "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
        ],
        [
            "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
            "VernacExtend",
            "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
        ],
        [
            "rewrite <- interp_CPTlOK.",
            "VernacExtend",
            "46a4aa46ac7d9859dca557a9c9f5d2ea467df11c"
        ],
        [
            "apply IHm with s1 s2 ss; try assumption.",
            "VernacExtend",
            "3fee55db2ce2c734e3b50a6d870bea6b87ac0c2d"
        ],
        [
            "apply memCPAuxTlOK.",
            "VernacExtend",
            "178231dafed6b8aa635364f61a1a69c66b40700e"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition st_ok (st : STt) (interp: positive -> COINCpoint) := forall t, STmem t st = true -> app wd (interp_CP t interp).",
            "VernacDefinition",
            "8ddf7a00daa0fbdf0976eee3eeb20062f92d4def"
        ],
        [
            "Context {COT : Coinc_theory AR COP}.",
            "VernacContext",
            "a7ab9d6e61caa57bd45193de967d339fad6ff078"
        ],
        [
            "Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.",
            "VernacStartTheoremProof",
            "3e90e8c3ee90885c5b3e198ada0dc86560755048"
        ],
        [
            "intros ss st interp HSS HST.",
            "VernacExtend",
            "567597c695cc818366e419d03835e9332dfecb31"
        ],
        [
            "apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)); try assumption.",
            "VernacExtend",
            "4198b86add52116ab44a79b82f2191fe5b1ee403"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "clear HSS; clear HST; clear ss; clear st.",
            "VernacExtend",
            "47a0535cbe5469899baa441ca062d9e6b271e474"
        ],
        [
            "intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.",
            "VernacExtend",
            "202c25238d4a68cb9f4804b486297ff77cb68498"
        ],
        [
            "assert (Hs1 := Hs1s2).",
            "VernacExtend",
            "1d076d52efd1bda2306d2b1f7185f7c789b68ff9"
        ],
        [
            "assert (Hs2 := Hs1s2).",
            "VernacExtend",
            "c0f3eb5889fb11059657441feda89d7e37be0f22"
        ],
        [
            "apply pick_varieties_ok_1 in Hs1.",
            "VernacExtend",
            "97901999c7d143882942ef911d9bf400ab399c8c"
        ],
        [
            "apply pick_varieties_ok_2 in Hs2.",
            "VernacExtend",
            "4a9467b2c7ce6d65d5830565cb346f8e2d17bb2d"
        ],
        [
            "apply SSWEqP.MP.Dec.F.remove_3 in Hs2.",
            "VernacExtend",
            "3985d9154a90d7757821032512480f524c36a6d5"
        ],
        [
            "apply H; try assumption; clear H.",
            "VernacExtend",
            "a7ec549376a2150d1b6ea67dee838f43a974bac6"
        ],
        [
            "intros s Hmem cp Hmemcp.",
            "VernacExtend",
            "f0a5d3e60d60b9f4879fc6942350efe53e68e3b3"
        ],
        [
            "unfold newss in Hmem; clear newss.",
            "VernacExtend",
            "b36b9e0370bb94dd1f2ca5cc3402954aab4d6686"
        ],
        [
            "elim (SS.E.eq_dec auxset s); intro HEq.",
            "VernacExtend",
            "b2c761d42425bed6131f9d60eabfe8ba3958a43f"
        ],
        [
            "assert (HEq' : memCP cp auxset = memCP cp s) by (apply memCPProper; trivial).",
            "VernacExtend",
            "89c66e4131a810e07da58713e02baafa5176baab"
        ],
        [
            "rewrite <- HEq in *; rewrite <- HEq' in *; clear HEq; clear HEq'; clear s.",
            "VernacExtend",
            "7bcc6a1ded92bb3303e6a740190d6381b7bf1747"
        ],
        [
            "unfold varieties in Hs1s2; clear varieties.",
            "VernacExtend",
            "35e86eb8db913792b0f3608c4fced31202f7460f"
        ],
        [
            "unfold pick_varieties in Hs1s2.",
            "VernacExtend",
            "347be449b30290f8da72a7bfbba70f88e521706d"
        ],
        [
            "case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss); try (intro HEW; rewrite HEW in *; discriminate).",
            "VernacExtend",
            "dc443a437e373c130bf9857cd8b37de96969768c"
        ],
        [
            "intros e1 HEW; rewrite HEW in *; clear HEW.",
            "VernacExtend",
            "3671673a853db03ae6104b5472244a9ac1b5428e"
        ],
        [
            "unfold pick_varieties_aux in *.",
            "VernacExtend",
            "b636b4fa5f3d90f0bdd00c0f8fbf0947ab4cf8e0"
        ],
        [
            "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)); try (intro HEW; rewrite HEW in *; discriminate).",
            "VernacExtend",
            "4cde6db5f0a70775eccffdfc374191829090ae5e"
        ],
        [
            "intros e2 HEW; rewrite HEW in *.",
            "VernacExtend",
            "47be0ca085b3027620cbf091b5fec956f599a204"
        ],
        [
            "injection Hs1s2; intros He2s2 He1s1.",
            "VernacExtend",
            "01d70efc2a12e414c6d05cf09dc847427b726603"
        ],
        [
            "rewrite He2s2 in *; rewrite He1s1 in *; clear He2s2; clear He1s1; clear Hs1s2; clear e2; clear e1.",
            "VernacExtend",
            "c9eaffffd66a902b494837fcc475e003ef42cced"
        ],
        [
            "case_eq (pick_variety (S.inter s1 s2) st).",
            "VernacExtend",
            "9f3b79e2533bb1bcdef587100182708e43ce6417"
        ],
        [
            "clear HEW; intro HEW.",
            "VernacExtend",
            "4f60ba4d217be0dfefacfe1a21742d9df52cd035"
        ],
        [
            "unfold pick_variety in HEW.",
            "VernacExtend",
            "6a7f910ea81b81c82426bad0ac53fcb1e9f672fc"
        ],
        [
            "apply STexists_mem_4 in HEW; try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity); try (apply proper_00).",
            "VernacExtend",
            "17e9a7abc4f2d6aa7e854078a5f059eeac107d7d"
        ],
        [
            "destruct HEW as [x [HmemST1 HmemST2]].",
            "VernacExtend",
            "c913398643627e86850719598ef8334e6b103ed6"
        ],
        [
            "apply HST in HmemST1.",
            "VernacExtend",
            "8e50e6e6e0c48eaba5dd16e6c3b5d6eacab319b5"
        ],
        [
            "apply coinc_n with (interp_CP x interp); try assumption.",
            "VernacExtend",
            "9b51691d670a4b3879ffb449c70cd8b6bcb6ee3d"
        ],
        [
            "unfold pred_conj.",
            "VernacExtend",
            "255945ded758bc96765908b2d7ccfdf1ae1460bf"
        ],
        [
            "apply mca_pick_variety_aux_pca with s1 s2 ss; assumption.",
            "VernacExtend",
            "eeba88d4cbe089714c2b02bd09c0c9ebabe2de8b"
        ],
        [
            "intro HEW2; unfold exists_witness in *; apply SS.choose_spec1 in HEW.",
            "VernacExtend",
            "9f01c140321c5a5428f83a46f45f2110c6b12faf"
        ],
        [
            "apply SSWEqP.MP.Dec.F.filter_2 in HEW; try apply proper_1.",
            "VernacExtend",
            "aeb74612cff293b177182ba4c28f09cbeb1e9258"
        ],
        [
            "rewrite HEW2 in *; discriminate.",
            "VernacExtend",
            "8faefd49d2b473b32298731166ef1a6f84e2dba4"
        ],
        [
            "rewrite SSWP.Dec.F.add_neq_b in Hmem; try assumption.",
            "VernacExtend",
            "abdc2fe773563f21bf6c4c23c98ddd627dee9b1d"
        ],
        [
            "apply HSS with s.",
            "VernacExtend",
            "1b3a35f0918adfc81aa20767006923cabcbfd0c5"
        ],
        [
            "unfold auxsetofsets in *.",
            "VernacExtend",
            "bca999ab88df92629ac7e40a7beacbdf85adf2b3"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_2 in Hmem.",
            "VernacExtend",
            "4ea1c0bf685aa2b8dedb99d475f45de4b5496a5a"
        ],
        [
            "do 2 (apply SSWEqP.MP.Dec.F.remove_3 in Hmem).",
            "VernacExtend",
            "a2d63db9c289f4a45d0f5717fdbf31327a76ac92"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_1.",
            "VernacExtend",
            "fb831ce8c5315b134cfbeda745acfebb053443cf"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).",
            "VernacStartTheoremProof",
            "6b1ef484b960e30fddbfb34cbed64daae7dbd617"
        ],
        [
            "intros ss st interp cp HSS HST HTC.",
            "VernacExtend",
            "593c0eee418753ed3a460a131440b18b6bf631b3"
        ],
        [
            "unfold test_coinc in *.",
            "VernacExtend",
            "407062c8b7cac204311e1a5c8d041e6bec36300c"
        ],
        [
            "assert (HSS2 : ss_ok (identify_varieties ss st) interp) by (apply identify_varieties_ok; assumption).",
            "VernacExtend",
            "99e5935eba298b8e9e2b9ef9dcb32fe35323505f"
        ],
        [
            "unfold ss_ok in HSS2.",
            "VernacExtend",
            "204a6dd5fd023bd6313de89aeae9a30eddd0053e"
        ],
        [
            "apply SSWEqP.MP.Dec.F.exists_2 in HTC.",
            "VernacExtend",
            "cd006ef68fda57ea980ba7098b94a726e0ade89f"
        ],
        [
            "unfold SS.Exists in HTC.",
            "VernacExtend",
            "ec920acf4d8cbbe710154d4e05e47f9343108f43"
        ],
        [
            "destruct HTC as [s [HIn Hmem]].",
            "VernacExtend",
            "4a7b50894af394d75d0e271f4fd78848280d916b"
        ],
        [
            "apply HSS2 with s.",
            "VernacExtend",
            "bd88746dbf37c30a3c64f49e6c0b46aafef16cfe"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_1.",
            "VernacExtend",
            "fb831ce8c5315b134cfbeda745acfebb053443cf"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "intros x y Hxy.",
            "VernacExtend",
            "44bac6ec66dd54c6c1d048cac4ab63f977af73cf"
        ],
        [
            "apply memCPProper; trivial.",
            "VernacExtend",
            "dd9155336a4c9228c59e567c1896e3d4daa6042c"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ss_ok_empty : forall interp, ss_ok SS.empty interp.",
            "VernacStartTheoremProof",
            "f148356eaeac53f23f4b44a45831245bd5bc7698"
        ],
        [
            "intros interp ss Hmem1 cp Hmem2.",
            "VernacExtend",
            "b647ab19ec8902ea683dea0fa3ec827a0a94b16a"
        ],
        [
            "rewrite SSWEqP.MP.Dec.F.empty_b in Hmem1.",
            "VernacExtend",
            "3bd4795da9e066cda7bb69aa70d0e37fac66b0e2"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma st_ok_empty : forall interp, st_ok STempty interp.",
            "VernacStartTheoremProof",
            "9f3aaad1ecc6971c48f1af863448cdc059033302"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "unfold st_ok.",
            "VernacExtend",
            "607a40a63ea68f3f4082ffa8c490e9269208bfdc"
        ],
        [
            "intros t Ht.",
            "VernacExtend",
            "9b73bd01b7eab131fc4e1775831ff0e7de378f43"
        ],
        [
            "rewrite STempty_b in Ht.",
            "VernacExtend",
            "29fe053587cc02a6d2f35abf6b1d56d30efd5699"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.",
            "VernacDefinition",
            "29e43f643ad4195a781c37e9732b3550289b2514"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "exact S.empty.",
            "VernacExtend",
            "78077b73bcea78e6b1be4cdb3d22fcc87c2d3707"
        ],
        [
            "induction m.",
            "VernacExtend",
            "6f6279e892ad221278939a9b429a59edaeeb1676"
        ],
        [
            "exact (S.add cp S.empty).",
            "VernacExtend",
            "b48ae6d9447c0774781e47498b95ae9a3a0217c4"
        ],
        [
            "exact (S.add (headCP cp) (IHm (tailCP cp))).",
            "VernacExtend",
            "9fcf541250b2a5b816f090e3b07095bf091c9796"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))), CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).",
            "VernacStartTheoremProof",
            "4ce00fa5de4d9b33bb7657288751471232ac00d4"
        ],
        [
            "simpl; reflexivity.",
            "VernacExtend",
            "929257572def0332e6c079b4ed3a916720086e3a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.",
            "VernacStartTheoremProof",
            "1b81a595aef8cf3fd6461831a679809372b0431c"
        ],
        [
            "induction m; intros e cp Hmem.",
            "VernacExtend",
            "0961f175162bebde920f2303a07a52af16244491"
        ],
        [
            "unfold InCP.",
            "VernacExtend",
            "df1188e79a6d40e6ab2452b5fd80a8a17374515e"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "left.",
            "VernacExtend",
            "06dad9fc5698018f3f1213205145fec906c612b1"
        ],
        [
            "rewrite <- SWP.singleton_equal_add in Hmem.",
            "VernacExtend",
            "08e9f263912b2bdf4647870138c3731e1685aa1b"
        ],
        [
            "apply SWP.Dec.F.mem_2 in Hmem.",
            "VernacExtend",
            "0227239728b342f45fbf5f593fc7432cbe62f164"
        ],
        [
            "apply SWP.Dec.F.singleton_1.",
            "VernacExtend",
            "8a8167c3b6580285ab4ac6ecddb9b45802aaa2c5"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "apply InCPOK.",
            "VernacExtend",
            "dfa8a6a6faa3c43183de0c1b249004a0d6c0786b"
        ],
        [
            "rewrite CPToSSHdTl in Hmem.",
            "VernacExtend",
            "9c2bf3e85f7f83de4c32c864bfe89e10082279fc"
        ],
        [
            "rewrite SWP.Dec.F.add_b in Hmem.",
            "VernacExtend",
            "47f66e1ee14fa44089c5409b6167d43842fbeeef"
        ],
        [
            "rewrite <- SWP.Dec.F.singleton_b in Hmem.",
            "VernacExtend",
            "f07e7c4ab09470189adfa98c63850cfe057b8190"
        ],
        [
            "apply orb_true_iff in Hmem.",
            "VernacExtend",
            "1903c84db13730338aecb54e7707f79472e80c92"
        ],
        [
            "elim Hmem; clear Hmem; intro Hmem.",
            "VernacExtend",
            "3cbdd738d11353c13413120de946f91c9d030a65"
        ],
        [
            "left.",
            "VernacExtend",
            "06dad9fc5698018f3f1213205145fec906c612b1"
        ],
        [
            "apply SWP.Dec.F.mem_2 in Hmem.",
            "VernacExtend",
            "0227239728b342f45fbf5f593fc7432cbe62f164"
        ],
        [
            "apply SWP.Dec.F.singleton_1 in Hmem.",
            "VernacExtend",
            "7399e73ae246e4c8f3d865383dabd4ee3b0f3b9b"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "right.",
            "VernacExtend",
            "27e417a3497755767e1a1d6ba87753ecddaee6b7"
        ],
        [
            "apply IHm.",
            "VernacExtend",
            "aa76f2273bef46821b36b49418f7132330cc05f1"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.",
            "VernacStartTheoremProof",
            "c43a1874b887327188bec31f5cafc1be0f1dffcd"
        ],
        [
            "induction m'.",
            "VernacExtend",
            "1ced59db95b6d7b6aa7f735b4697def37b2374b9"
        ],
        [
            "induction m; intros cp cp' e s HEq Hmem HIn.",
            "VernacExtend",
            "8ffe6fd1387adcc9f9abda524a31e4637c0e3e27"
        ],
        [
            "unfold InCP in *.",
            "VernacExtend",
            "22e3fff8ac2b9a905975046cb784ffd11dbcccd4"
        ],
        [
            "simpl in *.",
            "VernacExtend",
            "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
        ],
        [
            "apply andb_true_iff in Hmem.",
            "VernacExtend",
            "7ed2fde31d2cf6565212646245765770d4355cfb"
        ],
        [
            "destruct Hmem as [Hmem1 Hmem2].",
            "VernacExtend",
            "6771c483e69a3289f8bf8194df2255c6ddfa4dac"
        ],
        [
            "assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.",
            "VernacExtend",
            "22f4ec1802eb2e61560f41f12c857a934918a5da"
        ],
        [
            "assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.",
            "VernacExtend",
            "3dde71d7c1c099425eb4f39cda7db6e3f94e0a0c"
        ],
        [
            "rewrite SWP.Dec.F.add_b in Hmem1.",
            "VernacExtend",
            "1a102777822764ea91cbefab5f21fccbf0f74078"
        ],
        [
            "rewrite <- SWP.Dec.F.singleton_b in Hmem1.",
            "VernacExtend",
            "83ac74444d946511221b6a60775cdeefc838b0d6"
        ],
        [
            "assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.",
            "VernacExtend",
            "1104da3395913c372fa79aee72dea1e89f0c69e3"
        ],
        [
            "rewrite SWP.Dec.F.add_b in Hmem2.",
            "VernacExtend",
            "4b8c291da8ef6d3d54c55c157917c34e341e90a8"
        ],
        [
            "rewrite <- SWP.Dec.F.singleton_b in Hmem2.",
            "VernacExtend",
            "76003df6191190a384d3c799ced8d11a42fe16d5"
        ],
        [
            "assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.",
            "VernacExtend",
            "5dae319eeda3276afe549650bdf00b69980c11a2"
        ],
        [
            "apply orb_true_iff in Hmem1.",
            "VernacExtend",
            "83bef5bc3a2435c1e50e18981847802df8d90aa8"
        ],
        [
            "apply orb_true_iff in Hmem2.",
            "VernacExtend",
            "8e4d7d29b8cc2e1e13f653d3237411ab747a3bb3"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.",
            "VernacExtend",
            "506cba28b9501bf2768abab2c1d169d8e9c46e85"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.",
            "VernacExtend",
            "5bd01a0fb04bb75b58b1d854af3cc6d8c32a9ba8"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.",
            "VernacExtend",
            "97174b0d58cffd4d678d0b13be7069dc2d17d5fb"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "2d81b5ab80c366bd94fd1b38105964af28ed52b6"
        ],
        [
            "assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.",
            "VernacExtend",
            "36bd538c8d0760a95ade70bd97b2dff67f275924"
        ],
        [
            "apply memCPToSSOK.",
            "VernacExtend",
            "6a20b80ef22ea03d50a649b26acaafb4ec83a1a0"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "unfold InCP in HIn.",
            "VernacExtend",
            "e5d26015d2e77c81bd42744c6bdc7e75b5d74f82"
        ],
        [
            "simpl in HIn.",
            "VernacExtend",
            "af19e5789c5bd9adae0bce08955f8a2a5a9a0a1c"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.",
            "VernacExtend",
            "97174b0d58cffd4d678d0b13be7069dc2d17d5fb"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "130b8d3e149d184cbbc916b65ea9721b7e71178c"
        ],
        [
            "assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.",
            "VernacExtend",
            "66b8da5a847b6415a684d4faf77f2df08a2bb93e"
        ],
        [
            "apply memCPToSSOK.",
            "VernacExtend",
            "6a20b80ef22ea03d50a649b26acaafb4ec83a1a0"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "intros cp cp' e s HEq Hmem HIn.",
            "VernacExtend",
            "465cf06858793064854652f081923bdde90d441f"
        ],
        [
            "apply InCPOK in HIn.",
            "VernacExtend",
            "827e18e8f2c3cb87bf159d43eae1b086072ea3d1"
        ],
        [
            "elim HIn; clear HIn; intro HIn.",
            "VernacExtend",
            "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.",
            "VernacExtend",
            "95f340e2e408daea1b06cc10bb73f00ee5bc82c3"
        ],
        [
            "assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).",
            "VernacExtend",
            "2d81b5ab80c366bd94fd1b38105964af28ed52b6"
        ],
        [
            "assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.",
            "VernacExtend",
            "93214bfb808aca7957eb14055be8391aedfebb73"
        ],
        [
            "apply memCPToSSOK.",
            "VernacExtend",
            "6a20b80ef22ea03d50a649b26acaafb4ec83a1a0"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "apply IHm' with (tailCP cp') s; try assumption.",
            "VernacExtend",
            "cf26a9af534b14e24a05c1b003d3191f1254761e"
        ],
        [
            "apply memCPAuxTlOK; assumption.",
            "VernacExtend",
            "62741557808a1ad9292975a6c53d7efcaeaa03c4"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).",
            "VernacStartTheoremProof",
            "a2572110fdad1cb6a569c2e959704296a08769af"
        ],
        [
            "unfold incl.",
            "VernacExtend",
            "bc668a228fabc181ca6e5d6b8b8a0673a10724dc"
        ],
        [
            "intros cp cp' s HEq Hmem e HIn.",
            "VernacExtend",
            "11915f7548c5daf61ab5dc46e567a77a5f8c7fc3"
        ],
        [
            "assert (H := CPToSSOKAux cp cp' e s HEq Hmem).",
            "VernacExtend",
            "301544c4688f3f3827c16843e1d7ffb31ebb4dfd"
        ],
        [
            "unfold InCP in H.",
            "VernacExtend",
            "384c81b3ba928a759a694c5d4809854fc6ebc044"
        ],
        [
            "apply H; assumption.",
            "VernacExtend",
            "7904d623a02884c927ef4e8b66c90cb12eee7c7a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).",
            "VernacStartTheoremProof",
            "ced5d208b8eaada24646fa753259283ad912b212"
        ],
        [
            "intros cp HDup.",
            "VernacExtend",
            "7e80bd5acc0f4b10babe129dd4a79a65eed55cbf"
        ],
        [
            "apply NotNoDupDup in HDup; try apply Pos.eq_dec.",
            "VernacExtend",
            "a136df9ff2ff41cf1d3eac11b156ff215b074b55"
        ],
        [
            "destruct HDup as [e [l1 [l2 [HEq HIn]]]].",
            "VernacExtend",
            "d9d2dca5b4fd1f2b5a2db952b83e4e0e312de523"
        ],
        [
            "apply in_split in HIn.",
            "VernacExtend",
            "a2913997515114d5b720ea5dbf665aabd00d038c"
        ],
        [
            "destruct HIn as [l3 [l4 HEq']].",
            "VernacExtend",
            "cfcde5c77282ffe3c8632cc4cbe8c2c7b5bc4d88"
        ],
        [
            "assert (HPerm := Permutation.Permutation_middle l1 l2 e).",
            "VernacExtend",
            "5d264c929fba09d7b4f6eb5452ff2f0c3cb40d9c"
        ],
        [
            "rewrite <- HEq in HPerm; clear HEq.",
            "VernacExtend",
            "49dace5f2b760bc64dec48c50b4f8f64cc579fc4"
        ],
        [
            "rewrite HEq' in HPerm; clear HEq'; clear l1; clear l2; rename l3 into l1; rename l4 into l2.",
            "VernacExtend",
            "673d792405db37ed00e98a927029a05cf0ccb6a5"
        ],
        [
            "assert (HPerm' := Permutation.Permutation_middle l1 l2 e).",
            "VernacExtend",
            "c6d916cdd409940656c0401a6a1df21297f15143"
        ],
        [
            "apply (Permutation.perm_skip e) in HPerm'.",
            "VernacExtend",
            "86ecb83ae1311f3c23c05369f2b0d76df765cc3e"
        ],
        [
            "assert (HPerm'' := Permutation.perm_trans HPerm' HPerm); clear HPerm; clear HPerm'; rename HPerm'' into HPerm.",
            "VernacExtend",
            "55960fecd3e18534248ba4fef69618e011208f7d"
        ],
        [
            "rewrite <- CPLOK with (e :: e :: l1 ++ l2) e in HPerm.",
            "VernacExtend",
            "cafab183de69de4d20f90a0f266fea6eb163dad8"
        ],
        [
            "exists e; exists (l1 ++ l2); assumption.",
            "VernacExtend",
            "3f8edc5806640112d71b9bb3c2412869b538792b"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.",
            "VernacStartTheoremProof",
            "e5d29c9121d26d30dd88bc988919ade8d8846d02"
        ],
        [
            "intros cp H.",
            "VernacExtend",
            "31eddc63b04b18e21914823cb10987b538b83761"
        ],
        [
            "apply CoappDupPerm in H.",
            "VernacExtend",
            "a9a1d3bdb149b1961e29faf824daf17556a96b43"
        ],
        [
            "destruct H as [e[l HPerm]].",
            "VernacExtend",
            "88225040a280a949af1f750f301e2131586021b5"
        ],
        [
            "assert (Hl := Permutation.Permutation_length HPerm).",
            "VernacExtend",
            "aa490c41488e5000249cbc2644fa6c41dc3dc8ae"
        ],
        [
            "rewrite CPLOK in Hl.",
            "VernacExtend",
            "e6e87c553c541068e294a27dd7cf167772cffa08"
        ],
        [
            "rewrite <- lengthOfCPToList in Hl.",
            "VernacExtend",
            "80aa7d3ee0885e4000e51ed5fb4cbce71c730dfb"
        ],
        [
            "induction l; try (simpl in Hl; discriminate); clear IHl.",
            "VernacExtend",
            "4737e2b83d927cb5a4db22766011e9d1598c354e"
        ],
        [
            "exists e; exists (a :: l); exists (length l); exists (ListToCP (e :: e :: a :: l) e).",
            "VernacExtend",
            "ed0b332fd881ca9d84a2dc88e64eb8ba0f825738"
        ],
        [
            "split; try assumption.",
            "VernacExtend",
            "7aec98fbbf52695c4dbe780a98e3c8166b58320f"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "split; reflexivity.",
            "VernacExtend",
            "4dcd3619ac711de01342cf915900e96e80b675e1"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).",
            "VernacStartTheoremProof",
            "f2ac789e1c9060b41323dbb1445af087606e3629"
        ],
        [
            "intros cp interp H.",
            "VernacExtend",
            "a30359b5925d1d2d3c08b239613643c5ff7aca75"
        ],
        [
            "apply CoappDupAux in H.",
            "VernacExtend",
            "26b698478466d6981a04ccd5abe9798213a9116c"
        ],
        [
            "destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].",
            "VernacExtend",
            "573bd8d451d1ce61cb9acfabf5ac1f0235d05d20"
        ],
        [
            "assert (Hmn := Permutation.Permutation_length HPerm).",
            "VernacExtend",
            "e683f102363be263129ec8fc04b3d12c54587daa"
        ],
        [
            "apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.",
            "VernacExtend",
            "ebd9be6d9e900e0742929c5d7316efcede9d1551"
        ],
        [
            "do 2 (rewrite <- interp_CPOK in HPerm).",
            "VernacExtend",
            "241718b5f40aecef5376dff5595df442fc5caa61"
        ],
        [
            "do 2 (rewrite <- lengthOfCPToList in Hmn).",
            "VernacExtend",
            "fcfa10e9dc77d2fb766433faa26d85cab12de42a"
        ],
        [
            "do 3 (apply eq_add_S in Hmn).",
            "VernacExtend",
            "50a7af4073363a6bb709066f39a9061b69bde174"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "apply PermCoincOK with (interp_CP cp' interp); try assumption; clear HPerm.",
            "VernacExtend",
            "128e74699df8158935ba2b4e8126c843c82865d2"
        ],
        [
            "apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).",
            "VernacExtend",
            "7a8cda5a6739bcb08a778b0b4d8df1db18927572"
        ],
        [
            "rewrite Hsnd.",
            "VernacExtend",
            "a234f971061984852a59dbcb8bf83cf94af811e1"
        ],
        [
            "apply coinc_bd.",
            "VernacExtend",
            "beadba634c3ba7147802a4d8905a02cf37af298d"
        ],
        [
            "rewrite <- interp_CPHdOK.",
            "VernacExtend",
            "5d2da9c6fbe2f8afa24f11ed029a603e7fc4c9cf"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "rewrite <- interp_CPTlOK.",
            "VernacExtend",
            "46a4aa46ac7d9859dca557a9c9f5d2ea467df11c"
        ],
        [
            "rewrite <- interp_CPHdOK.",
            "VernacExtend",
            "5d2da9c6fbe2f8afa24f11ed029a603e7fc4c9cf"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "do 2 (rewrite <- interp_CPTlOK).",
            "VernacExtend",
            "76517228a51e5612a37549bf86370d5d1f27627e"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.",
            "VernacStartTheoremProof",
            "1026dc6931cb32f06c52b3b87fb5ef322550ca43"
        ],
        [
            "intros cp ss interp HCoapp HSS.",
            "VernacExtend",
            "752208012aa841510e85d0c1c8e4ce82e284f489"
        ],
        [
            "unfold ss_ok.",
            "VernacExtend",
            "8b3f387759ffd21aaf87d3780206a5d7e605ad5e"
        ],
        [
            "intros s Hs.",
            "VernacExtend",
            "260fb9c070371bcc61b105a76ad6e9ca0d4ab0f1"
        ],
        [
            "intros cp' Hmem.",
            "VernacExtend",
            "1e90816d1077d65efef682d89ad0bd68e8d1d4c6"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_2 in Hs.",
            "VernacExtend",
            "05db75943d6076f2dff931feaee57239262da7b2"
        ],
        [
            "apply SSWEqP.MP.Dec.F.add_iff in Hs.",
            "VernacExtend",
            "366b613f20a3f563268332c002057f2598446c57"
        ],
        [
            "elim Hs; clear Hs; intro Hs.",
            "VernacExtend",
            "92006cb883d25d3133a8294e7a05b03bd5366eae"
        ],
        [
            "assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).",
            "VernacExtend",
            "eda792f7aa3b7c2acacac3e1015f0b90db232d0e"
        ],
        [
            "elim HDup; clear HDup; intro HDup.",
            "VernacExtend",
            "c422cc91436befe2b3ee378a86f21cc51f23921c"
        ],
        [
            "assert (Hincl := CPToSSOK cp cp' s Hs Hmem).",
            "VernacExtend",
            "08390988c03875bc232d39d180028c03f3e20bde"
        ],
        [
            "assert (Hlength : length (CPToList cp') = length (CPToList cp)) by (do 2 (rewrite <- lengthOfCPToList); reflexivity).",
            "VernacExtend",
            "a37e579b90e8919c191fcd23e62f73bbd56ceab5"
        ],
        [
            "assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).",
            "VernacExtend",
            "ba3d518bec64d60282eb2677e316d8d401bd9ea3"
        ],
        [
            "apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.",
            "VernacExtend",
            "ebd9be6d9e900e0742929c5d7316efcede9d1551"
        ],
        [
            "do 2 (rewrite <- interp_CPOK in HPerm); clear HDup; clear Hincl; clear Hlength.",
            "VernacExtend",
            "b571bba5ca962c7a87c33a27ca2816322eac305c"
        ],
        [
            "apply Permutation.Permutation_sym in HPerm.",
            "VernacExtend",
            "2bac89f9a95cdaf27594a08fe9ee0b76ebffd010"
        ],
        [
            "apply PermCoincOK with (interp_CP cp interp); assumption.",
            "VernacExtend",
            "9ab92e157c4f1da0c967ac26f39a9db2b01d1061"
        ],
        [
            "apply CoappDup; assumption.",
            "VernacExtend",
            "5fcfc984f13686b286fd3be6360f3ba134d17257"
        ],
        [
            "unfold ss_ok in HSS.",
            "VernacExtend",
            "0c6f6735f17e5226ced7397bdd7b7242c8c9ee11"
        ],
        [
            "apply HSS with s; try assumption.",
            "VernacExtend",
            "f73c5471a2919f0565074ae204c4d35abb013082"
        ],
        [
            "apply SSWEqP.MP.Dec.F.mem_1; assumption.",
            "VernacExtend",
            "1384be09bdae5e6a6a9b9a52a4a0818cf5817db8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.",
            "VernacStartTheoremProof",
            "2d3f4fba96e3b0b00fb348659d7263dd0b2ee336"
        ],
        [
            "intros cp st interp HWd HST.",
            "VernacExtend",
            "d89b87881ff2e02d95242a70c015ce9c3e801dec"
        ],
        [
            "unfold st_ok.",
            "VernacExtend",
            "607a40a63ea68f3f4082ffa8c490e9269208bfdc"
        ],
        [
            "intros cp' Hmem.",
            "VernacExtend",
            "1e90816d1077d65efef682d89ad0bd68e8d1d4c6"
        ],
        [
            "apply STadd_iff in Hmem.",
            "VernacExtend",
            "41128f1218f7edaa1a1f507275a0d3e5ad7778ac"
        ],
        [
            "elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].",
            "VernacExtend",
            "154228b65a2ef9e454af3fc1398024a998282a39"
        ],
        [
            "assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).",
            "VernacExtend",
            "2151eaddaab9b2fe132ef146ec0e8bca3eed35d6"
        ],
        [
            "assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).",
            "VernacExtend",
            "ec6c4257200aca127970c2210a15d3e951f3839b"
        ],
        [
            "apply eqListOK in Hmem.",
            "VernacExtend",
            "274ce5611a74c5c8c45693a70308d5596c5ec145"
        ],
        [
            "rewrite Hmem in Hcp.",
            "VernacExtend",
            "ec0efd84945ae1b12e229a67f7296cd5f3d36f14"
        ],
        [
            "apply PermWdOK with (interp_CP cp interp); try assumption.",
            "VernacExtend",
            "4e343c2ff28134620cf8868db564abe392472e8e"
        ],
        [
            "do 2 (rewrite interp_CPOK).",
            "VernacExtend",
            "d297d93146e45f765441dcdbafa7b5d9d6d9d2d2"
        ],
        [
            "apply Permutation.Permutation_map.",
            "VernacExtend",
            "c3801509092065da95658bfbd8be090ef9269cc2"
        ],
        [
            "transitivity (PosSort.sort (CPToList cp')); try assumption.",
            "VernacExtend",
            "1b053234df5f883830525d640254181a3ef37bcf"
        ],
        [
            "apply Permutation.Permutation_sym; assumption.",
            "VernacExtend",
            "4c6ad6dd07e554db59c4525749d61f7fbf5ef739"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition list_assoc_inv := (fix list_assoc_inv_rec (A:Type) (B:Set) (eq_dec:forall e1 e2:B, {e1 = e2} + {e1 <> e2}) (lst : list (prodT A B)) {struct lst} : B -> A -> A := fun (key:B) (default:A) => match lst with | nil => default | cons (pairT v e) l => match eq_dec e key with | left _ => v | right _ => list_assoc_inv_rec A B eq_dec l key default end end).",
            "VernacDefinition",
            "b1695451fbc01fc5badcfbf2ad2b3662826bfdec"
        ],
        [
            "Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.",
            "VernacStartTheoremProof",
            "dde6075226b6df59fd701ed72f708db2097a4495"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition interp (lvar : list (COINCpoint * positive)) (Default : COINCpoint) : positive -> COINCpoint := fun p => list_assoc_inv COINCpoint positive positive_dec lvar p Default.",
            "VernacDefinition",
            "360854fe13c8c6275288b45cd69ee66d36dc7d5a"
        ],
        [
            "End Coinc_refl.",
            "VernacEndSegment",
            "235d8d2274c4240e1184a512fb1400df745c2626"
        ],
        [
            "Ltac add_to_distinct_list x xs := match xs with | nil => constr:(x::xs) | x::_ => fail 1 | ?y::?ys => let zs := add_to_distinct_list x ys in constr:(y::zs) end.",
            "VernacExtend",
            "675093eab7960f3ebb4a379a05813540125613dd"
        ],
        [
            "Ltac collect_points_list Tpoint xs := match goal with | N : Tpoint |- _ => let ys := add_to_distinct_list N xs in collect_points_list Tpoint ys | _ => xs end.",
            "VernacExtend",
            "8ccc2fa22a404f3cd822b6fdb7b423d2f77c2e7a"
        ],
        [
            "Ltac collect_points Tpoint := collect_points_list Tpoint (@nil Tpoint).",
            "VernacExtend",
            "573cb3e55f7995317c7352c138a4cf9f73d1803c"
        ],
        [
            "Ltac number_aux Tpoint lvar cpt := match constr:(lvar) with | nil => constr:(@nil (prodT Tpoint positive)) | cons ?H ?T => let scpt := eval vm_compute in (Pos.succ cpt) in let lvar2 := number_aux Tpoint T scpt in constr:(cons (@pairT Tpoint positive H cpt) lvar2) end.",
            "VernacExtend",
            "03030a969220d603f80b2bdae719a089710bbe01"
        ],
        [
            "Ltac number Tpoint lvar := number_aux Tpoint lvar (1%positive).",
            "VernacExtend",
            "b97c1a7126ddec262c924e4edb51be8918e4390a"
        ],
        [
            "Ltac build_numbered_points_list Tpoint := let lvar := collect_points Tpoint in number Tpoint lvar.",
            "VernacExtend",
            "f0b1c33fe5f724108d604681fa65ad9851fde40d"
        ],
        [
            "Ltac List_assoc Tpoint elt lst := match constr:(lst) with | nil => fail | (cons (@pairT Tpoint positive ?X1 ?X2) ?X3) => match constr:(elt = X1) with | (?X1 = ?X1) => constr:(X2) | _ => List_assoc Tpoint elt X3 end end.",
            "VernacExtend",
            "6553ddcee7368786b7036a6e0986f913b6567080"
        ],
        [
            "Definition Tagged P : Prop := P.",
            "VernacDefinition",
            "a045c0913541f6dc5ac15a5251b8a617d9177dfe"
        ],
        [
            "Lemma PropToTagged : forall P : Prop, P -> Tagged P.",
            "VernacStartTheoremProof",
            "a50197c9d74a8a7d4bc60c43e6ad50297d0aa7e1"
        ],
        [
            "trivial.",
            "VernacExtend",
            "6704630005ea37c1f66f817f0d3cb83967ca08c5"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ]
    ],
    "proofs": [
        {
            "name": "pick_variety_auxCP",
            "line_nb": 11,
            "steps": [
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "exact ((S.mem (fst cp) s) && (S.mem (snd cp) s)).",
                        "VernacExtend",
                        "e79c8d5e0b72da2b3c9837c42901f8973a232546"
                    ]
                },
                {
                    "command": [
                        "exact ((S.mem (fst cp) s) && (IHm (tailCP cp))).",
                        "VernacExtend",
                        "6c5dae2e059c81e6bdeeb1e797e145566c014d29"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "proper_00",
            "line_nb": 63,
            "steps": [
                {
                    "command": [
                        "unfold pick_variety_aux, eqST.",
                        "VernacExtend",
                        "ee928bc26b90aba79776d3a605d7a2b5c7528cfa"
                    ]
                },
                {
                    "command": [
                        "intros s t1 t2 HEq.",
                        "VernacExtend",
                        "a4246f21bd42fdc4969a6c98a00e230882116232"
                    ]
                },
                {
                    "command": [
                        "case_eq (pick_variety_auxCP s t1); intro Ht1.",
                        "VernacExtend",
                        "1afa89444609c76714a7ba17241e95f26628c1f2"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "destruct (pick_variety_auxCP_forallT s t1) as [H1 H2]; clear H2.",
                        "VernacExtend",
                        "2ae642d540583536b28399b598db845446ddb5a8"
                    ]
                },
                {
                    "command": [
                        "assert (H := H1 Ht1); clear H1; clear Ht1; rename H into Ht1.",
                        "VernacExtend",
                        "1be0002a17cb37122ce17cf36293edf4ec106d71"
                    ]
                },
                {
                    "command": [
                        "destruct (pick_variety_auxCP_forallT s t2) as [H1 H2]; clear H1.",
                        "VernacExtend",
                        "fe5c25e65aac4459fa882ee17592fdcfd116b978"
                    ]
                },
                {
                    "command": [
                        "rewrite H2; try reflexivity; clear H2; intros p HIn; apply Ht1.",
                        "VernacExtend",
                        "da16b41f205a85930963a4120fa5898d773b44a7"
                    ]
                },
                {
                    "command": [
                        "clear Ht1; apply InCPOCP; apply InCPOCP in HIn.",
                        "VernacExtend",
                        "d1336d45d63ce5da838e6b6ea6937aa627c56aa9"
                    ]
                },
                {
                    "command": [
                        "assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).",
                        "VernacExtend",
                        "5c3b4c608be404cf878f6018232676e565b284d9"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "assert (Ht1 := eqListSortOCP t1).",
                        "VernacExtend",
                        "a163c2c5b3a0346c4ee734882dcea3e867567466"
                    ]
                },
                {
                    "command": [
                        "assert (Ht2 := eqListSortOCP t2).",
                        "VernacExtend",
                        "d0467e04f924111032dd8d70f61ecd16c6605867"
                    ]
                },
                {
                    "command": [
                        "apply eqListTrans with (PosSort.sort (CPToList t1)); try assumption.",
                        "VernacExtend",
                        "aa026a2c26d90bf046f1b6dd5c5e06c5b92a2c23"
                    ]
                },
                {
                    "command": [
                        "apply eqListTrans with (PosSort.sort (CPToList t2)); try assumption.",
                        "VernacExtend",
                        "8dd8b091770f6562f7fb95c243123831f1b02956"
                    ]
                },
                {
                    "command": [
                        "apply eqListSym; assumption.",
                        "VernacExtend",
                        "02a399eabe1980e32704f0c10ad09ed14ed13f83"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "clear HEq; rename H into HEq; apply eqListOK in HEq.",
                        "VernacExtend",
                        "0c23683d665d7b3a65f1c4028c9d9fb353b1f04e"
                    ]
                },
                {
                    "command": [
                        "unfold InCP in *; rewrite HEq; auto.",
                        "VernacExtend",
                        "9afdea891c067e8e1e76686c95314c592528dfb9"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "destruct (pick_variety_auxCP_existsF s t1) as [H1 H2]; clear H2.",
                        "VernacExtend",
                        "62ecc4714c3cd1184cabdbe4ad78d5386580c55a"
                    ]
                },
                {
                    "command": [
                        "assert (H := H1 Ht1); clear H1; clear Ht1; rename H into Ht1.",
                        "VernacExtend",
                        "1be0002a17cb37122ce17cf36293edf4ec106d71"
                    ]
                },
                {
                    "command": [
                        "destruct (pick_variety_auxCP_existsF s t2) as [H1 H2]; clear H1.",
                        "VernacExtend",
                        "1983fb9517800855f0c120aff60a6225c0015142"
                    ]
                },
                {
                    "command": [
                        "rewrite H2; try reflexivity; clear H2.",
                        "VernacExtend",
                        "c001041b83aa2356b6f2403f159020b28ab9e223"
                    ]
                },
                {
                    "command": [
                        "destruct Ht1 as [p [HIn Hmem]]; exists p; split; auto.",
                        "VernacExtend",
                        "dff62663d0bfb291bfb99b8a40bf4b1077c12fcb"
                    ]
                },
                {
                    "command": [
                        "apply InCPOCP; apply InCPOCP in HIn.",
                        "VernacExtend",
                        "d849ff48837ce978d5e79c1f8722a4a44e49a57b"
                    ]
                },
                {
                    "command": [
                        "assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).",
                        "VernacExtend",
                        "5c3b4c608be404cf878f6018232676e565b284d9"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "assert (Ht1 := eqListSortOCP t1).",
                        "VernacExtend",
                        "a163c2c5b3a0346c4ee734882dcea3e867567466"
                    ]
                },
                {
                    "command": [
                        "assert (Ht2 := eqListSortOCP t2).",
                        "VernacExtend",
                        "d0467e04f924111032dd8d70f61ecd16c6605867"
                    ]
                },
                {
                    "command": [
                        "apply eqListTrans with (PosSort.sort (CPToList t1)); try assumption.",
                        "VernacExtend",
                        "aa026a2c26d90bf046f1b6dd5c5e06c5b92a2c23"
                    ]
                },
                {
                    "command": [
                        "apply eqListTrans with (PosSort.sort (CPToList t2)); try assumption.",
                        "VernacExtend",
                        "8dd8b091770f6562f7fb95c243123831f1b02956"
                    ]
                },
                {
                    "command": [
                        "apply eqListSym; assumption.",
                        "VernacExtend",
                        "02a399eabe1980e32704f0c10ad09ed14ed13f83"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "clear HEq; rename H into HEq; apply eqListOK in HEq.",
                        "VernacExtend",
                        "0c23683d665d7b3a65f1c4028c9d9fb353b1f04e"
                    ]
                },
                {
                    "command": [
                        "unfold InCP in *; rewrite <- HEq; auto.",
                        "VernacExtend",
                        "a099e3834263a7c2a5d4f7ce743b7406e1c993ee"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "proper_0",
            "line_nb": 104,
            "steps": [
                {
                    "command": [
                        "intros x1 y1 HXY1.",
                        "VernacExtend",
                        "839d87017942d79600eeec0cf6d4a3a8d53be2f0"
                    ]
                },
                {
                    "command": [
                        "intros x2 y2 HXY2.",
                        "VernacExtend",
                        "72d0f0e4ccac3df1be118fdffeefc22942a18e41"
                    ]
                },
                {
                    "command": [
                        "rewrite HXY2; clear HXY2; clear x2.",
                        "VernacExtend",
                        "217a3f73d76b4dbc8476ef7896276ddcfb4900ee"
                    ]
                },
                {
                    "command": [
                        "unfold pick_variety; unfold pick_variety_aux.",
                        "VernacExtend",
                        "fd1a529a9250cba9a45b63c7bff5b16be81c175a"
                    ]
                },
                {
                    "command": [
                        "unfold STexists_.",
                        "VernacExtend",
                        "aa1f6030009eee1f61d9239ef34e1efe10216653"
                    ]
                },
                {
                    "command": [
                        "induction y2; try reflexivity.",
                        "VernacExtend",
                        "9bc7e2e0d8f2744fec2f179d9ae5ab29092a4f47"
                    ]
                },
                {
                    "command": [
                        "rewrite IHy2; clear IHy2.",
                        "VernacExtend",
                        "7afe3007b352f848316e4117bb07f43e7ba64eef"
                    ]
                },
                {
                    "command": [
                        "assert (HEqMem : forall e, S.mem e x1 = S.mem e y1) by (intro; apply SWP.Dec.F.mem_m; intuition); clear HXY1.",
                        "VernacExtend",
                        "dc3008b54c8ea1251588e531a5ef635ed83b917b"
                    ]
                },
                {
                    "command": [
                        "assert (HF : forall n a, (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) x1 && S.mem (snd t0) x1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) x1 && F n0 (tailCP t0) end) n a = (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) y1 && S.mem (snd t0) y1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) y1 && F n0 (tailCP t0) end) n a) by (induction n; try (intro; do 2 (rewrite HEqMem); reflexivity); intro ; rewrite HEqMem; rewrite IHn; reflexivity).",
                        "VernacExtend",
                        "d861c6692d8a787ce452ee8512e2bbd4eec0d785"
                    ]
                },
                {
                    "command": [
                        "unfold pick_variety_auxCP.",
                        "VernacExtend",
                        "67106bba5b16bd7413870edee1fb640765038106"
                    ]
                },
                {
                    "command": [
                        "rewrite HF; reflexivity.",
                        "VernacExtend",
                        "09a8f7262bb9604a76e118f7be8c53ae5a1c747c"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "proper_1",
            "line_nb": 117,
            "steps": [
                {
                    "command": [
                        "intros s1 st.",
                        "VernacExtend",
                        "1eeb9446660711afc968e9465869d1222504fea6"
                    ]
                },
                {
                    "command": [
                        "intros x y HXY.",
                        "VernacExtend",
                        "d54666da0000fd8bd617b0c87941a7c833808d02"
                    ]
                },
                {
                    "command": [
                        "assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)) by (apply SWP.inter_equal_2; assumption).",
                        "VernacExtend",
                        "0e12dc4abbd1b25f3b7b1fb3a45dfb16b2f66ae2"
                    ]
                },
                {
                    "command": [
                        "apply proper_0; auto.",
                        "VernacExtend",
                        "204981aa8eb8eb4f01d206a72ec76af8a8adfee2"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "exists_witness_ok",
            "line_nb": 124,
            "steps": [
                {
                    "command": [
                        "intros e f s HP H.",
                        "VernacExtend",
                        "d7e9f08bce61d66800ace0de5491371313df1375"
                    ]
                },
                {
                    "command": [
                        "unfold exists_witness in H.",
                        "VernacExtend",
                        "459fa409f748633674aff369aeb45f44d99639c4"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_2.",
                        "VernacExtend",
                        "80188289b4d4e5f1772ae5a93b6f4e37e2065425"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.choose_mem_1 in H.",
                        "VernacExtend",
                        "0a4056de4ac591f1e507854a750a5e35d9ac42a4"
                    ]
                },
                {
                    "command": [
                        "rewrite SSWEqP.filter_mem in H; try assumption.",
                        "VernacExtend",
                        "eb4e4a44306ec507defbab9f7c603dd055918a73"
                    ]
                },
                {
                    "command": [
                        "apply andb_true_iff in H.",
                        "VernacExtend",
                        "6be4e13be3cc994beedd2c7e4adabd0a944c1be7"
                    ]
                },
                {
                    "command": [
                        "induction H.",
                        "VernacExtend",
                        "f8e74d6b42ecd6b509e6a20cee53bb69d051cd07"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "proper_3",
            "line_nb": 164,
            "steps": [
                {
                    "command": [
                        "intros x1 y1 HXY1.",
                        "VernacExtend",
                        "839d87017942d79600eeec0cf6d4a3a8d53be2f0"
                    ]
                },
                {
                    "command": [
                        "intros x2 y2 HXY2.",
                        "VernacExtend",
                        "72d0f0e4ccac3df1be118fdffeefc22942a18e41"
                    ]
                },
                {
                    "command": [
                        "intros x3 y3 HXY3.",
                        "VernacExtend",
                        "54f000983cd9a32ca7a1cb9a1942bb5c75938ed0"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties_aux.",
                        "VernacExtend",
                        "a3a4e834efddca9160598b0575ce4af1812d148f"
                    ]
                },
                {
                    "command": [
                        "rewrite HXY3.",
                        "VernacExtend",
                        "5b1462afde59f7b21a3eae8d3170a08c32d86132"
                    ]
                },
                {
                    "command": [
                        "assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).",
                        "VernacExtend",
                        "531050db487f2aab10ccdb7ff605ed2aa1a1190f"
                    ]
                },
                {
                    "command": [
                        "apply proper_2.",
                        "VernacExtend",
                        "239500027425fb496c426724925002aaaba1a02e"
                    ]
                },
                {
                    "command": [
                        "apply proper_1.",
                        "VernacExtend",
                        "9bcf09b899868f8792d91207a527659acd15ca76"
                    ]
                },
                {
                    "command": [
                        "apply proper_1.",
                        "VernacExtend",
                        "9bcf09b899868f8792d91207a527659acd15ca76"
                    ]
                },
                {
                    "command": [
                        "intro; apply proper_0; try reflexivity.",
                        "VernacExtend",
                        "981cb9faf6e5f3470365e916d1d28dfb06dfb080"
                    ]
                },
                {
                    "command": [
                        "apply SWP.inter_equal_1; assumption.",
                        "VernacExtend",
                        "7d6cb983ff6965f434d050800140b1494715793c"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2); case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).",
                        "VernacExtend",
                        "c1a78fe75289018726edb9455c57096048c25ab3"
                    ]
                },
                {
                    "command": [
                        "simpl; intuition.",
                        "VernacExtend",
                        "2a8f84ed3abedbe9d9fbb80aa4215114cbdbe500"
                    ]
                },
                {
                    "command": [
                        "intros HCN e HCS.",
                        "VernacExtend",
                        "8338ca6af148978e7c03b3f41a4e8bbfe9e3fc45"
                    ]
                },
                {
                    "command": [
                        "simpl in *.",
                        "VernacExtend",
                        "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
                    ]
                },
                {
                    "command": [
                        "rewrite HCS in H; rewrite HCN in H.",
                        "VernacExtend",
                        "a1c2c5fe4336f6255ec49ed40a5c6f168fbd79c1"
                    ]
                },
                {
                    "command": [
                        "simpl in *.",
                        "VernacExtend",
                        "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "intros e HCS HCN.",
                        "VernacExtend",
                        "cc15df2a9851ee6b1782d02c1286e0c94189ae2b"
                    ]
                },
                {
                    "command": [
                        "simpl in *.",
                        "VernacExtend",
                        "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
                    ]
                },
                {
                    "command": [
                        "rewrite HCS in H; rewrite HCN in H.",
                        "VernacExtend",
                        "a1c2c5fe4336f6255ec49ed40a5c6f168fbd79c1"
                    ]
                },
                {
                    "command": [
                        "simpl in *.",
                        "VernacExtend",
                        "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pick_varieties_ok_1",
            "line_nb": 191,
            "steps": [
                {
                    "command": [
                        "intros s1 s2 ss st H.",
                        "VernacExtend",
                        "c27339d1ee4b2a77e48b96a4ddc7798dbd5ef0f0"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties in H.",
                        "VernacExtend",
                        "7d17d58e692eb960b07e24f02fbd057f534c2378"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).",
                        "VernacExtend",
                        "464666ea7da2d4f6cb678035b88a7e6882552f19"
                    ]
                },
                {
                    "command": [
                        "intros e1 HEW1.",
                        "VernacExtend",
                        "2a567fdfa1687036465e1fef611850045d37fc9f"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW1 in H.",
                        "VernacExtend",
                        "675a71248c7e01878edf2823776d4e708c05ea35"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties_aux in H.",
                        "VernacExtend",
                        "556f926315b15e367bd30449705a02058dee3e33"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).",
                        "VernacExtend",
                        "01129f536557c98f72026be232516552fd4a1323"
                    ]
                },
                {
                    "command": [
                        "intros e2 HEW2.",
                        "VernacExtend",
                        "1fc16878958b87d1f6f17c6498177d00d77d2623"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW2 in H.",
                        "VernacExtend",
                        "eb15a01b423c775fe31cb25516074627e7cc25f3"
                    ]
                },
                {
                    "command": [
                        "assert (HEq1 : e1 = s1) by (injection H; intros; assumption).",
                        "VernacExtend",
                        "eca0a22fbf0e00fb9e046c8d9e079db5eb02db8d"
                    ]
                },
                {
                    "command": [
                        "rewrite HEq1 in *.",
                        "VernacExtend",
                        "37c5421f284fa2ad1c4d42b884307839417831b3"
                    ]
                },
                {
                    "command": [
                        "assert (HEq2 : e2 = s2) by (injection H; intros; assumption).",
                        "VernacExtend",
                        "10cc392df03719c33e189136ddd05b3b090309f3"
                    ]
                },
                {
                    "command": [
                        "rewrite HEq2 in *.",
                        "VernacExtend",
                        "901b7385eb26cebf2c5c7d2cdf91d7a0df36bf69"
                    ]
                },
                {
                    "command": [
                        "apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).",
                        "VernacExtend",
                        "53932465c83c5fc4da483cfcb6b55cd46e0ea719"
                    ]
                },
                {
                    "command": [
                        "intros x y HXY.",
                        "VernacExtend",
                        "d54666da0000fd8bd617b0c87941a7c833808d02"
                    ]
                },
                {
                    "command": [
                        "assert (SS.Equal (SS.remove x ss) (SS.remove y ss)) by (apply SSWP.Dec.F.remove_m; try assumption; reflexivity).",
                        "VernacExtend",
                        "0ffa093fb04731b954184d9445abadd14c4f3509"
                    ]
                },
                {
                    "command": [
                        "assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)) by (apply proper_3; auto).",
                        "VernacExtend",
                        "8e7a0a1495c391e1a9c3528f038f6d83c2934ea8"
                    ]
                },
                {
                    "command": [
                        "case_eq (pick_varieties_aux x (SS.remove x ss) st); intros; case_eq (pick_varieties_aux y (SS.remove y ss) st); intros.",
                        "VernacExtend",
                        "3c63a7cd2265a6e31cce081f41cd66f9969abefa"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "rewrite H2 in H1; rewrite H3 in H1.",
                        "VernacExtend",
                        "d60d017c158b623d3de57a4a7472debbb0bafae4"
                    ]
                },
                {
                    "command": [
                        "unfold eqop in H1; simpl in H1.",
                        "VernacExtend",
                        "a5f5b655078facd7f0685ddfdae397d40e5c349d"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "rewrite H2 in H1; rewrite H3 in H1.",
                        "VernacExtend",
                        "d60d017c158b623d3de57a4a7472debbb0bafae4"
                    ]
                },
                {
                    "command": [
                        "unfold eqop in H1; simpl in H1.",
                        "VernacExtend",
                        "a5f5b655078facd7f0685ddfdae397d40e5c349d"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "intro HEW2.",
                        "VernacExtend",
                        "d765abbe0b296e489e225764f0cf4941b2608cbc"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW2 in H.",
                        "VernacExtend",
                        "eb15a01b423c775fe31cb25516074627e7cc25f3"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "intro HEW.",
                        "VernacExtend",
                        "75beebc8353c6e7b1940af049fb3ad7d4a61baf5"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW in H.",
                        "VernacExtend",
                        "fac42e5535f2f796d1d2c954dc42cd01dd34d6e7"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pick_varieties_ok_2",
            "line_nb": 226,
            "steps": [
                {
                    "command": [
                        "intros s1 s2 ss st H.",
                        "VernacExtend",
                        "c27339d1ee4b2a77e48b96a4ddc7798dbd5ef0f0"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties in H.",
                        "VernacExtend",
                        "7d17d58e692eb960b07e24f02fbd057f534c2378"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).",
                        "VernacExtend",
                        "464666ea7da2d4f6cb678035b88a7e6882552f19"
                    ]
                },
                {
                    "command": [
                        "intros e1 HEW1.",
                        "VernacExtend",
                        "2a567fdfa1687036465e1fef611850045d37fc9f"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW1 in H.",
                        "VernacExtend",
                        "675a71248c7e01878edf2823776d4e708c05ea35"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties_aux in H.",
                        "VernacExtend",
                        "556f926315b15e367bd30449705a02058dee3e33"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).",
                        "VernacExtend",
                        "01129f536557c98f72026be232516552fd4a1323"
                    ]
                },
                {
                    "command": [
                        "intros e2 HEW2.",
                        "VernacExtend",
                        "1fc16878958b87d1f6f17c6498177d00d77d2623"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW2 in H.",
                        "VernacExtend",
                        "eb15a01b423c775fe31cb25516074627e7cc25f3"
                    ]
                },
                {
                    "command": [
                        "assert (HEq1 : e1 = s1) by (injection H; intros; assumption).",
                        "VernacExtend",
                        "eca0a22fbf0e00fb9e046c8d9e079db5eb02db8d"
                    ]
                },
                {
                    "command": [
                        "rewrite HEq1 in *.",
                        "VernacExtend",
                        "37c5421f284fa2ad1c4d42b884307839417831b3"
                    ]
                },
                {
                    "command": [
                        "assert (HEq2 : e2 = s2) by (injection H; intros; assumption).",
                        "VernacExtend",
                        "10cc392df03719c33e189136ddd05b3b090309f3"
                    ]
                },
                {
                    "command": [
                        "rewrite HEq2 in *.",
                        "VernacExtend",
                        "901b7385eb26cebf2c5c7d2cdf91d7a0df36bf69"
                    ]
                },
                {
                    "command": [
                        "apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).",
                        "VernacExtend",
                        "68783e190bcb313873d41573dd8a98c43ae3a5f3"
                    ]
                },
                {
                    "command": [
                        "intros x y HXY.",
                        "VernacExtend",
                        "d54666da0000fd8bd617b0c87941a7c833808d02"
                    ]
                },
                {
                    "command": [
                        "apply proper_1; assumption.",
                        "VernacExtend",
                        "0769e46a4af2e2ad3ea97622de5c8d069d48437f"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "intro HEW2.",
                        "VernacExtend",
                        "d765abbe0b296e489e225764f0cf4941b2608cbc"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW2 in H.",
                        "VernacExtend",
                        "eb15a01b423c775fe31cb25516074627e7cc25f3"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "intro HEW.",
                        "VernacExtend",
                        "75beebc8353c6e7b1940af049fb3ad7d4a61baf5"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW in H.",
                        "VernacExtend",
                        "fac42e5535f2f796d1d2c954dc42cd01dd34d6e7"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "identify_varieties_tcc",
            "line_nb": 251,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).",
                        "VernacExtend",
                        "512a8cb70b8cece637bbd9d79fe400a16186bb69"
                    ]
                },
                {
                    "command": [
                        "apply SSWP.remove_cardinal_1.",
                        "VernacExtend",
                        "d3fb399c6dc800565080f6ddf28445ae3aaf00d7"
                    ]
                },
                {
                    "command": [
                        "apply pick_varieties_ok_1 with s2 st.",
                        "VernacExtend",
                        "b1cbb97c9dd744a0b14a4571f230a22316969f88"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).",
                        "VernacExtend",
                        "40a70da9bf3a73cb3132dd3b585d310b33ceaa5f"
                    ]
                },
                {
                    "command": [
                        "apply eq_S.",
                        "VernacExtend",
                        "8ef0b219ea0189c2d80bb55d03c4c9f24beca469"
                    ]
                },
                {
                    "command": [
                        "apply SSWP.remove_cardinal_1.",
                        "VernacExtend",
                        "d3fb399c6dc800565080f6ddf28445ae3aaf00d7"
                    ]
                },
                {
                    "command": [
                        "apply pick_varieties_ok_2 with st.",
                        "VernacExtend",
                        "19fd6807283d96a12179dd8a74004c8fc387a31a"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).",
                        "VernacExtend",
                        "6ddf214d5df1f14c80b31dd5baefeb6a786b1217"
                    ]
                },
                {
                    "command": [
                        "transitivity (S(SS.cardinal (SS.remove s1 ss))); assumption.",
                        "VernacExtend",
                        "2c3fb6bc531e6d3df65b59af87dca82ccbd4e91a"
                    ]
                },
                {
                    "command": [
                        "elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))); intro HDec.",
                        "VernacExtend",
                        "8dddb5e44aea6caead8ae3d15ef4e3e31ff0e627"
                    ]
                },
                {
                    "command": [
                        "assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).",
                        "VernacExtend",
                        "2f285606a5b6ca7472c026ea2fc71ae84a1d84a0"
                    ]
                },
                {
                    "command": [
                        "apply SSWP.add_cardinal_1; assumption.",
                        "VernacExtend",
                        "bd051711223beec788d3db4fda21c45f77e8d292"
                    ]
                },
                {
                    "command": [
                        "rewrite HR2.",
                        "VernacExtend",
                        "ffdd15b9ffd74def816cfaea7dddac1b290743a8"
                    ]
                },
                {
                    "command": [
                        "rewrite <- HR1.",
                        "VernacExtend",
                        "162c9dc20d9b6d43afcfffae0c8dbb00d1133297"
                    ]
                },
                {
                    "command": [
                        "apply le_S;apply le_n.",
                        "VernacExtend",
                        "f668231be5e47dbadfd8dc6d21bc7e5b062fec36"
                    ]
                },
                {
                    "command": [
                        "assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).",
                        "VernacExtend",
                        "06136665d964e4e3a8e9a3af54334d9d88538572"
                    ]
                },
                {
                    "command": [
                        "apply SSWP.add_cardinal_2; assumption.",
                        "VernacExtend",
                        "c2d31a8fa4a1b4dcda0b34809325584a05256433"
                    ]
                },
                {
                    "command": [
                        "rewrite HR2.",
                        "VernacExtend",
                        "ffdd15b9ffd74def816cfaea7dddac1b290743a8"
                    ]
                },
                {
                    "command": [
                        "rewrite <- HR1.",
                        "VernacExtend",
                        "162c9dc20d9b6d43afcfffae0c8dbb00d1133297"
                    ]
                },
                {
                    "command": [
                        "apply le_n.",
                        "VernacExtend",
                        "cd4ea009ba050d55c0c5552f05ee5752a2fad9f9"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "memCPAux",
            "line_nb": 276,
            "steps": [
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "exact (S.mem (fst cp) s && S.mem (snd cp) s).",
                        "VernacExtend",
                        "e79c8d5e0b72da2b3c9837c42901f8973a232546"
                    ]
                },
                {
                    "command": [
                        "exact (S.mem (fst cp) s && (IHm (snd cp))).",
                        "VernacExtend",
                        "544f9494d5846b62e05f22b0b26da8037ed36839"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "memCPAuxHdTl",
            "line_nb": 281,
            "steps": [
                {
                    "command": [
                        "induction m; unfold memCPAux; unfold nat_rect; reflexivity.",
                        "VernacExtend",
                        "59e86837915cf137416150257fc34d472638d18f"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memCPAuxProperOK",
            "line_nb": 284,
            "steps": [
                {
                    "command": [
                        "intros m cp1 cp2 Hcp s1 s2 Hs.",
                        "VernacExtend",
                        "bce6e91c739cc8f8904704d44df1935dc688f520"
                    ]
                },
                {
                    "command": [
                        "rewrite Hcp; clear Hcp; clear cp1; rename cp2 into cp.",
                        "VernacExtend",
                        "df9c9a6dd397c507e20f2bdbabcc37325b3cab65"
                    ]
                },
                {
                    "command": [
                        "unfold memCPAux.",
                        "VernacExtend",
                        "13c4e9e9e786b5a9b34e2fcd18aae71c78466afc"
                    ]
                },
                {
                    "command": [
                        "assert (H : forall p, S.mem p s1 = S.mem p s2) by (intro p; apply SWP.Dec.F.mem_m; trivial).",
                        "VernacExtend",
                        "0db0200f35136ca3c1791991edb406aa6f6a8faa"
                    ]
                },
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "simpl; do 2 (rewrite H); reflexivity.",
                        "VernacExtend",
                        "490bc1845658470db1f72470ddd92afca5521d8d"
                    ]
                },
                {
                    "command": [
                        "simpl; rewrite H; rewrite IHm; reflexivity.",
                        "VernacExtend",
                        "7db524c5167a6bed287517a8ac95bb2e9943e968"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memMemCPAuxOK",
            "line_nb": 315,
            "steps": [
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "unfold memCPAux.",
                        "VernacExtend",
                        "13c4e9e9e786b5a9b34e2fcd18aae71c78466afc"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "intros cp s H.",
                        "VernacExtend",
                        "a7405790c69d26de5f50e910760ae178b734269d"
                    ]
                },
                {
                    "command": [
                        "rewrite andb_true_iff.",
                        "VernacExtend",
                        "2e0a0ffca5d243f404153bc36ad3db5c01c2e4b5"
                    ]
                },
                {
                    "command": [
                        "assert (HIn1 : InCP (fst cp) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "33cd1ea3be42ebcb486dd2565d08ac95b74120c4"
                    ]
                },
                {
                    "command": [
                        "assert (HIn2 : InCP (snd cp) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "88ba55fb9d350b5af188a19072fa22706fab204b"
                    ]
                },
                {
                    "command": [
                        "split; apply H; assumption.",
                        "VernacExtend",
                        "b898465dc5fc9b5f7fc65b3bcd149b82da5191e1"
                    ]
                },
                {
                    "command": [
                        "intros cp s H.",
                        "VernacExtend",
                        "a7405790c69d26de5f50e910760ae178b734269d"
                    ]
                },
                {
                    "command": [
                        "rewrite memCPAuxHdTl.",
                        "VernacExtend",
                        "374c485b4bd6b8f694800e512eeaf5dad2aef2f8"
                    ]
                },
                {
                    "command": [
                        "rewrite andb_true_iff.",
                        "VernacExtend",
                        "2e0a0ffca5d243f404153bc36ad3db5c01c2e4b5"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (fst cp) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "512262af16b3c93e69838ad31c4f2d700ce4ddf3"
                    ]
                },
                {
                    "command": [
                        "split; try (apply H; assumption); clear HIn.",
                        "VernacExtend",
                        "47a7ad8728c27bbffff164ccfa20aa28667ce9e3"
                    ]
                },
                {
                    "command": [
                        "apply IHm.",
                        "VernacExtend",
                        "aa76f2273bef46821b36b49418f7132330cc05f1"
                    ]
                },
                {
                    "command": [
                        "intros e HIn.",
                        "VernacExtend",
                        "4376b87e7e7aeaba492e6fe1c2ad3aada03aeb9b"
                    ]
                },
                {
                    "command": [
                        "apply H.",
                        "VernacExtend",
                        "4b47b71ad0f800d57cbdc591d68949e07decb540"
                    ]
                },
                {
                    "command": [
                        "apply InCPOK.",
                        "VernacExtend",
                        "dfa8a6a6faa3c43183de0c1b249004a0d6c0786b"
                    ]
                },
                {
                    "command": [
                        "right.",
                        "VernacExtend",
                        "27e417a3497755767e1a1d6ba87753ecddaee6b7"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memCPAuxTlOK",
            "line_nb": 336,
            "steps": [
                {
                    "command": [
                        "intros m cp s Hmemcp.",
                        "VernacExtend",
                        "f582e74bb038bef1bb8c94eb92191c0727a25724"
                    ]
                },
                {
                    "command": [
                        "apply memMemCPAuxOK.",
                        "VernacExtend",
                        "8828f577392acb3a4f618f68f56aadf08b65ab72"
                    ]
                },
                {
                    "command": [
                        "intros e HIn.",
                        "VernacExtend",
                        "4376b87e7e7aeaba492e6fe1c2ad3aada03aeb9b"
                    ]
                },
                {
                    "command": [
                        "apply memCPAuxOK with (S m) cp; try assumption.",
                        "VernacExtend",
                        "d6d8e312f34edd9de2794040a2ae562a7a72bfe4"
                    ]
                },
                {
                    "command": [
                        "apply InCPOK.",
                        "VernacExtend",
                        "dfa8a6a6faa3c43183de0c1b249004a0d6c0786b"
                    ]
                },
                {
                    "command": [
                        "right; assumption.",
                        "VernacExtend",
                        "4b9041b9a9d920fdce6d3e18e05e4d1a743614d5"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memCPProper",
            "line_nb": 345,
            "steps": [
                {
                    "command": [
                        "apply memCPAuxProperOK.",
                        "VernacExtend",
                        "43903a781e11b014746daecc02f9b1d728767fee"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memMemCPOK",
            "line_nb": 348,
            "steps": [
                {
                    "command": [
                        "apply memMemCPAuxOK.",
                        "VernacExtend",
                        "8828f577392acb3a4f618f68f56aadf08b65ab72"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memCPConsHd",
            "line_nb": 351,
            "steps": [
                {
                    "command": [
                        "intros p s x Hmem Hmemcp.",
                        "VernacExtend",
                        "f47010e4afa3a3b20a5489cfea2afe23b4da8726"
                    ]
                },
                {
                    "command": [
                        "apply memMemCPOK.",
                        "VernacExtend",
                        "81c4056d801300449f059600c08a4b63c9e230d1"
                    ]
                },
                {
                    "command": [
                        "intros e HIn.",
                        "VernacExtend",
                        "4376b87e7e7aeaba492e6fe1c2ad3aada03aeb9b"
                    ]
                },
                {
                    "command": [
                        "apply InCPOK in HIn.",
                        "VernacExtend",
                        "827e18e8f2c3cb87bf159d43eae1b086072ea3d1"
                    ]
                },
                {
                    "command": [
                        "simpl in HIn.",
                        "VernacExtend",
                        "af19e5789c5bd9adae0bce08955f8a2a5a9a0a1c"
                    ]
                },
                {
                    "command": [
                        "elim HIn; clear HIn; intro HIn.",
                        "VernacExtend",
                        "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
                    ]
                },
                {
                    "command": [
                        "subst; assumption.",
                        "VernacExtend",
                        "7e743ec2514456ab315be0cfedd9ae3caf020d0d"
                    ]
                },
                {
                    "command": [
                        "apply memCPAuxOK with n x; assumption.",
                        "VernacExtend",
                        "d789b78afceb625938d7b45a04f0d782a4dbd237"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pick_variety_aux_memCPAux1",
            "line_nb": 362,
            "steps": [
                {
                    "command": [
                        "intros s1 s2 m cp.",
                        "VernacExtend",
                        "1a66e7efab753c1afc769a1cda87095a9112f4a9"
                    ]
                },
                {
                    "command": [
                        "induction m; simpl; do 2 (rewrite andb_true_iff); intro Hhtspa.",
                        "VernacExtend",
                        "a082509bfc327cfc414c4aca07b8a7d596a3341a"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite SWP.FM.inter_b in Hhtspa).",
                        "VernacExtend",
                        "706436f8d09f0eede50ffb530ef55b97c0c6173b"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite andb_true_iff in Hhtspa).",
                        "VernacExtend",
                        "8fb8d3b778e6ff09a135488d7a706a5c864d0631"
                    ]
                },
                {
                    "command": [
                        "tauto.",
                        "VernacExtend",
                        "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
                    ]
                },
                {
                    "command": [
                        "destruct Hhtspa as [Hmem Hhtspa].",
                        "VernacExtend",
                        "751c14709413f6e428878ef2b968c7167b1e165c"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.FM.inter_b in Hmem.",
                        "VernacExtend",
                        "7e5d90c415678b8c4844b2bf37002a50d6b71971"
                    ]
                },
                {
                    "command": [
                        "rewrite andb_true_iff in Hmem.",
                        "VernacExtend",
                        "05a6836892cba66ec4c2424e566092d984675276"
                    ]
                },
                {
                    "command": [
                        "split; try (spliter; assumption).",
                        "VernacExtend",
                        "a6154d1e3d7ff72721b03c149001b51f51c3e91f"
                    ]
                },
                {
                    "command": [
                        "apply IHm; assumption.",
                        "VernacExtend",
                        "28e948b98405d2301427861e7997ec5ddc733b85"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pick_variety_aux_memCPAux2",
            "line_nb": 374,
            "steps": [
                {
                    "command": [
                        "intros s1 s2 m cp.",
                        "VernacExtend",
                        "1a66e7efab753c1afc769a1cda87095a9112f4a9"
                    ]
                },
                {
                    "command": [
                        "induction m; simpl; do 2 (rewrite andb_true_iff); intro Hhtspa.",
                        "VernacExtend",
                        "a082509bfc327cfc414c4aca07b8a7d596a3341a"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite SWP.FM.inter_b in Hhtspa).",
                        "VernacExtend",
                        "706436f8d09f0eede50ffb530ef55b97c0c6173b"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite andb_true_iff in Hhtspa).",
                        "VernacExtend",
                        "8fb8d3b778e6ff09a135488d7a706a5c864d0631"
                    ]
                },
                {
                    "command": [
                        "tauto.",
                        "VernacExtend",
                        "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
                    ]
                },
                {
                    "command": [
                        "destruct Hhtspa as [Hmem Hhtspa].",
                        "VernacExtend",
                        "751c14709413f6e428878ef2b968c7167b1e165c"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.FM.inter_b in Hmem.",
                        "VernacExtend",
                        "7e5d90c415678b8c4844b2bf37002a50d6b71971"
                    ]
                },
                {
                    "command": [
                        "rewrite andb_true_iff in Hmem.",
                        "VernacExtend",
                        "05a6836892cba66ec4c2424e566092d984675276"
                    ]
                },
                {
                    "command": [
                        "split; try (spliter; assumption).",
                        "VernacExtend",
                        "a6154d1e3d7ff72721b03c149001b51f51c3e91f"
                    ]
                },
                {
                    "command": [
                        "apply IHm; assumption.",
                        "VernacExtend",
                        "28e948b98405d2301427861e7997ec5ddc733b85"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "interp_CP",
            "line_nb": 386,
            "steps": [
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "exact (interp cp).",
                        "VernacExtend",
                        "6b1941c68000b3ffc21a8d3bac0de2e38c8dc6c6"
                    ]
                },
                {
                    "command": [
                        "clear IHm.",
                        "VernacExtend",
                        "f146c476dfe2496aa8dbd81475d23c7e79471842"
                    ]
                },
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "split.",
                        "VernacExtend",
                        "55abc140132bd88981001ac656020469a8d503eb"
                    ]
                },
                {
                    "command": [
                        "exact (interp (headCP cp)).",
                        "VernacExtend",
                        "cdb55640373e08b31c97b38351186f6718b06256"
                    ]
                },
                {
                    "command": [
                        "exact (interp (tailCP cp)).",
                        "VernacExtend",
                        "808a98427e441fbf912f7f7c5f2d48e1a3ecbf9c"
                    ]
                },
                {
                    "command": [
                        "split.",
                        "VernacExtend",
                        "55abc140132bd88981001ac656020469a8d503eb"
                    ]
                },
                {
                    "command": [
                        "exact (interp (headCP cp)).",
                        "VernacExtend",
                        "cdb55640373e08b31c97b38351186f6718b06256"
                    ]
                },
                {
                    "command": [
                        "exact (IHm (tailCP cp)).",
                        "VernacExtend",
                        "660bc9b2ab210f36ff1cd0f561c59b2b2ff90206"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "interp_CPHdOK",
            "line_nb": 398,
            "steps": [
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "unfold interp_CP; unfold nat_rect; simpl; reflexivity.",
                        "VernacExtend",
                        "da362bb844f474aed5b50ff4b24ff3e822b46349"
                    ]
                },
                {
                    "command": [
                        "induction m; unfold interp_CP; unfold nat_rect; simpl; reflexivity.",
                        "VernacExtend",
                        "b0ff195588dafa3f66c057a7007b6fbee0da490e"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "interp_CPTlOK",
            "line_nb": 403,
            "steps": [
                {
                    "command": [
                        "induction m; unfold interp_CP; unfold nat_rect; simpl; reflexivity.",
                        "VernacExtend",
                        "b0ff195588dafa3f66c057a7007b6fbee0da490e"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "interp_CPOK",
            "line_nb": 406,
            "steps": [
                {
                    "command": [
                        "induction m; intros cp interp.",
                        "VernacExtend",
                        "cdbfe98194b23eb62b5f36e8c6aba6991ae90383"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "induction m; try (clear IHm0).",
                        "VernacExtend",
                        "3e7089333002926e786dbe33f9d42a2e42ca5d11"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "rewrite CPToListOK.",
                        "VernacExtend",
                        "eef100557e9be0c6aaae82db33eb1f15d005d960"
                    ]
                },
                {
                    "command": [
                        "rewrite <- interp_CPHdOK.",
                        "VernacExtend",
                        "5d2da9c6fbe2f8afa24f11ed029a603e7fc4c9cf"
                    ]
                },
                {
                    "command": [
                        "rewrite <- interp_CPTlOK.",
                        "VernacExtend",
                        "46a4aa46ac7d9859dca557a9c9f5d2ea467df11c"
                    ]
                },
                {
                    "command": [
                        "rewrite IHm.",
                        "VernacExtend",
                        "bf73c511f9e37493a929521561a4b35798c2f374"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "consHdInterpOK",
            "line_nb": 422,
            "steps": [
                {
                    "command": [
                        "intros cp x interp.",
                        "VernacExtend",
                        "b0b8f8e9c0d248204b66a404201b5725ca092bbf"
                    ]
                },
                {
                    "command": [
                        "apply CP_ind; simpl; reflexivity.",
                        "VernacExtend",
                        "aaee9b56a120ea0c39fc48226cebecec3e1290cb"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ss_ok_inter_ok1",
            "line_nb": 426,
            "steps": [
                {
                    "command": [
                        "intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.",
                        "VernacExtend",
                        "08a5c5597e4dd6f222dff4f597deb585a7c03c3c"
                    ]
                },
                {
                    "command": [
                        "apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)); try (simpl; reflexivity).",
                        "VernacExtend",
                        "d2ffba286eab905b8aab0e67de7a3e1ae0fd3089"
                    ]
                },
                {
                    "command": [
                        "assert (Hmemcp : memCPAux n x s1 = true) by (apply pick_variety_aux_memCPAux1 with s2; assumption).",
                        "VernacExtend",
                        "b0247131b98ca5d819d731b0ecb6ebb64f511317"
                    ]
                },
                {
                    "command": [
                        "unfold ss_ok in HSSOK.",
                        "VernacExtend",
                        "fb79fe79a7cd485afafe217a6d2f820cd3005093"
                    ]
                },
                {
                    "command": [
                        "rewrite consHdInterpOK.",
                        "VernacExtend",
                        "98cbd596a571620a602acbc2d2d85dd1fc8b5653"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_1 in HIn.",
                        "VernacExtend",
                        "72a24f43f7bf3cf4547eece58fce7881a0de80cf"
                    ]
                },
                {
                    "command": [
                        "apply HSSOK with s1; try assumption.",
                        "VernacExtend",
                        "970ab1185d894edd7cc80aa7c71c19df7910cdb9"
                    ]
                },
                {
                    "command": [
                        "apply memCPConsHd; assumption.",
                        "VernacExtend",
                        "9f189af709fde17aade00daedd4d12ed442120d4"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ss_ok_inter_ok2",
            "line_nb": 436,
            "steps": [
                {
                    "command": [
                        "intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.",
                        "VernacExtend",
                        "08a5c5597e4dd6f222dff4f597deb585a7c03c3c"
                    ]
                },
                {
                    "command": [
                        "apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)); try (simpl; reflexivity).",
                        "VernacExtend",
                        "d2ffba286eab905b8aab0e67de7a3e1ae0fd3089"
                    ]
                },
                {
                    "command": [
                        "assert (Hmemcp : memCPAux n x s2 = true) by (apply pick_variety_aux_memCPAux2 with s1; assumption).",
                        "VernacExtend",
                        "a6c3a3883eb9ba2c3e7afbb8f77afcdfba982be6"
                    ]
                },
                {
                    "command": [
                        "unfold ss_ok in HSSOK.",
                        "VernacExtend",
                        "fb79fe79a7cd485afafe217a6d2f820cd3005093"
                    ]
                },
                {
                    "command": [
                        "rewrite consHdInterpOK.",
                        "VernacExtend",
                        "98cbd596a571620a602acbc2d2d85dd1fc8b5653"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_1 in HIn.",
                        "VernacExtend",
                        "72a24f43f7bf3cf4547eece58fce7881a0de80cf"
                    ]
                },
                {
                    "command": [
                        "apply HSSOK with s2; try assumption.",
                        "VernacExtend",
                        "6b059b0628b94dd1c649706c31ba3b5e49e01529"
                    ]
                },
                {
                    "command": [
                        "apply memCPConsHd; assumption.",
                        "VernacExtend",
                        "9f189af709fde17aade00daedd4d12ed442120d4"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mca_pick_variety_aux_pca",
            "line_nb": 446,
            "steps": [
                {
                    "command": [
                        "induction m; intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.",
                        "VernacExtend",
                        "08cfc59d2407a26875f43296d7b3b3b4db9d694a"
                    ]
                },
                {
                    "command": [
                        "unfold pred_conj_aux.",
                        "VernacExtend",
                        "bd1b5bf6d11f97aee66c41b847bbeb2dd45b0aff"
                    ]
                },
                {
                    "command": [
                        "unfold nat_rect.",
                        "VernacExtend",
                        "1b4ce131edbf45d22d55e9871509740d1bf39d55"
                    ]
                },
                {
                    "command": [
                        "split.",
                        "VernacExtend",
                        "55abc140132bd88981001ac656020469a8d503eb"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (headCP cp) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "004b17a0a4a1715d6ccf8c26585ef6fad3733eea"
                    ]
                },
                {
                    "command": [
                        "assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true) by (apply memCPAuxOK with 1 cp; assumption).",
                        "VernacExtend",
                        "93f67030142098363c2bc983e870138272137d53"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.FM.union_b in HElim.",
                        "VernacExtend",
                        "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in HElim.",
                        "VernacExtend",
                        "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
                    ]
                },
                {
                    "command": [
                        "elim HElim; clear HElim; intro HElim.",
                        "VernacExtend",
                        "588d1e900b6f6f32fb617753805c9df2cf5623a9"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
                    ]
                },
                {
                    "command": [
                        "split.",
                        "VernacExtend",
                        "55abc140132bd88981001ac656020469a8d503eb"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (headCP (tailCP cp)) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "39d1901bb3cbca87c1be888f9388c10b8093d25c"
                    ]
                },
                {
                    "command": [
                        "assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true) by (apply memCPAuxOK with 1 cp; assumption).",
                        "VernacExtend",
                        "819e2c58e19373efa096221d997a58e595a3f979"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.FM.union_b in HElim.",
                        "VernacExtend",
                        "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in HElim.",
                        "VernacExtend",
                        "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
                    ]
                },
                {
                    "command": [
                        "elim HElim; clear HElim; intro HElim.",
                        "VernacExtend",
                        "588d1e900b6f6f32fb617753805c9df2cf5623a9"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (tailCP (tailCP cp)) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "29916a3673e99289b60ee1a60ebcf3421f49ea3c"
                    ]
                },
                {
                    "command": [
                        "assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true) by (apply memCPAuxOK with 1 cp; assumption).",
                        "VernacExtend",
                        "3475484b3e2acd12673e1c8c638e4b04bc2da626"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.FM.union_b in HElim.",
                        "VernacExtend",
                        "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in HElim.",
                        "VernacExtend",
                        "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
                    ]
                },
                {
                    "command": [
                        "elim HElim; clear HElim; intro HElim.",
                        "VernacExtend",
                        "588d1e900b6f6f32fb617753805c9df2cf5623a9"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
                    ]
                },
                {
                    "command": [
                        "rewrite pcaHdTl.",
                        "VernacExtend",
                        "c71cf03407ff29266d5d9397122c59144cf18e8b"
                    ]
                },
                {
                    "command": [
                        "split.",
                        "VernacExtend",
                        "55abc140132bd88981001ac656020469a8d503eb"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (headCP cp) cp) by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "004b17a0a4a1715d6ccf8c26585ef6fad3733eea"
                    ]
                },
                {
                    "command": [
                        "assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true) by (apply memCPAuxOK with (S (S m)) cp; assumption).",
                        "VernacExtend",
                        "b277a463e0d837ae675a6ca0661f5491417d476c"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.FM.union_b in HElim.",
                        "VernacExtend",
                        "f8f4914eae7a41e08c88b68b3bcf058aa31cba5d"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in HElim.",
                        "VernacExtend",
                        "8ca8964e0d09fdae0cbe02ece66a095c0e884a21"
                    ]
                },
                {
                    "command": [
                        "elim HElim; clear HElim; intro HElim.",
                        "VernacExtend",
                        "588d1e900b6f6f32fb617753805c9df2cf5623a9"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok1 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "3eb56f0747436f44c08be37e70d0dcffb7818f4a"
                    ]
                },
                {
                    "command": [
                        "apply ss_ok_inter_ok2 with ss s1 s2; assumption.",
                        "VernacExtend",
                        "dde5c4cb28c49d07aab331ef351c7d6174fe52a8"
                    ]
                },
                {
                    "command": [
                        "rewrite <- interp_CPTlOK.",
                        "VernacExtend",
                        "46a4aa46ac7d9859dca557a9c9f5d2ea467df11c"
                    ]
                },
                {
                    "command": [
                        "apply IHm with s1 s2 ss; try assumption.",
                        "VernacExtend",
                        "3fee55db2ce2c734e3b50a6d870bea6b87ac0c2d"
                    ]
                },
                {
                    "command": [
                        "apply memCPAuxTlOK.",
                        "VernacExtend",
                        "178231dafed6b8aa635364f61a1a69c66b40700e"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "identify_varieties_ok",
            "line_nb": 489,
            "steps": [
                {
                    "command": [
                        "intros ss st interp HSS HST.",
                        "VernacExtend",
                        "567597c695cc818366e419d03835e9332dfecb31"
                    ]
                },
                {
                    "command": [
                        "apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)); try assumption.",
                        "VernacExtend",
                        "4198b86add52116ab44a79b82f2191fe5b1ee403"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "clear HSS; clear HST; clear ss; clear st.",
                        "VernacExtend",
                        "47a0535cbe5469899baa441ca062d9e6b271e474"
                    ]
                },
                {
                    "command": [
                        "intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.",
                        "VernacExtend",
                        "202c25238d4a68cb9f4804b486297ff77cb68498"
                    ]
                },
                {
                    "command": [
                        "assert (Hs1 := Hs1s2).",
                        "VernacExtend",
                        "1d076d52efd1bda2306d2b1f7185f7c789b68ff9"
                    ]
                },
                {
                    "command": [
                        "assert (Hs2 := Hs1s2).",
                        "VernacExtend",
                        "c0f3eb5889fb11059657441feda89d7e37be0f22"
                    ]
                },
                {
                    "command": [
                        "apply pick_varieties_ok_1 in Hs1.",
                        "VernacExtend",
                        "97901999c7d143882942ef911d9bf400ab399c8c"
                    ]
                },
                {
                    "command": [
                        "apply pick_varieties_ok_2 in Hs2.",
                        "VernacExtend",
                        "4a9467b2c7ce6d65d5830565cb346f8e2d17bb2d"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.remove_3 in Hs2.",
                        "VernacExtend",
                        "3985d9154a90d7757821032512480f524c36a6d5"
                    ]
                },
                {
                    "command": [
                        "apply H; try assumption; clear H.",
                        "VernacExtend",
                        "a7ec549376a2150d1b6ea67dee838f43a974bac6"
                    ]
                },
                {
                    "command": [
                        "intros s Hmem cp Hmemcp.",
                        "VernacExtend",
                        "f0a5d3e60d60b9f4879fc6942350efe53e68e3b3"
                    ]
                },
                {
                    "command": [
                        "unfold newss in Hmem; clear newss.",
                        "VernacExtend",
                        "b36b9e0370bb94dd1f2ca5cc3402954aab4d6686"
                    ]
                },
                {
                    "command": [
                        "elim (SS.E.eq_dec auxset s); intro HEq.",
                        "VernacExtend",
                        "b2c761d42425bed6131f9d60eabfe8ba3958a43f"
                    ]
                },
                {
                    "command": [
                        "assert (HEq' : memCP cp auxset = memCP cp s) by (apply memCPProper; trivial).",
                        "VernacExtend",
                        "89c66e4131a810e07da58713e02baafa5176baab"
                    ]
                },
                {
                    "command": [
                        "rewrite <- HEq in *; rewrite <- HEq' in *; clear HEq; clear HEq'; clear s.",
                        "VernacExtend",
                        "7bcc6a1ded92bb3303e6a740190d6381b7bf1747"
                    ]
                },
                {
                    "command": [
                        "unfold varieties in Hs1s2; clear varieties.",
                        "VernacExtend",
                        "35e86eb8db913792b0f3608c4fced31202f7460f"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties in Hs1s2.",
                        "VernacExtend",
                        "347be449b30290f8da72a7bfbba70f88e521706d"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss); try (intro HEW; rewrite HEW in *; discriminate).",
                        "VernacExtend",
                        "dc443a437e373c130bf9857cd8b37de96969768c"
                    ]
                },
                {
                    "command": [
                        "intros e1 HEW; rewrite HEW in *; clear HEW.",
                        "VernacExtend",
                        "3671673a853db03ae6104b5472244a9ac1b5428e"
                    ]
                },
                {
                    "command": [
                        "unfold pick_varieties_aux in *.",
                        "VernacExtend",
                        "b636b4fa5f3d90f0bdd00c0f8fbf0947ab4cf8e0"
                    ]
                },
                {
                    "command": [
                        "case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)); try (intro HEW; rewrite HEW in *; discriminate).",
                        "VernacExtend",
                        "4cde6db5f0a70775eccffdfc374191829090ae5e"
                    ]
                },
                {
                    "command": [
                        "intros e2 HEW; rewrite HEW in *.",
                        "VernacExtend",
                        "47be0ca085b3027620cbf091b5fec956f599a204"
                    ]
                },
                {
                    "command": [
                        "injection Hs1s2; intros He2s2 He1s1.",
                        "VernacExtend",
                        "01d70efc2a12e414c6d05cf09dc847427b726603"
                    ]
                },
                {
                    "command": [
                        "rewrite He2s2 in *; rewrite He1s1 in *; clear He2s2; clear He1s1; clear Hs1s2; clear e2; clear e1.",
                        "VernacExtend",
                        "c9eaffffd66a902b494837fcc475e003ef42cced"
                    ]
                },
                {
                    "command": [
                        "case_eq (pick_variety (S.inter s1 s2) st).",
                        "VernacExtend",
                        "9f3b79e2533bb1bcdef587100182708e43ce6417"
                    ]
                },
                {
                    "command": [
                        "clear HEW; intro HEW.",
                        "VernacExtend",
                        "4f60ba4d217be0dfefacfe1a21742d9df52cd035"
                    ]
                },
                {
                    "command": [
                        "unfold pick_variety in HEW.",
                        "VernacExtend",
                        "6a7f910ea81b81c82426bad0ac53fcb1e9f672fc"
                    ]
                },
                {
                    "command": [
                        "apply STexists_mem_4 in HEW; try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity); try (apply proper_00).",
                        "VernacExtend",
                        "17e9a7abc4f2d6aa7e854078a5f059eeac107d7d"
                    ]
                },
                {
                    "command": [
                        "destruct HEW as [x [HmemST1 HmemST2]].",
                        "VernacExtend",
                        "c913398643627e86850719598ef8334e6b103ed6"
                    ]
                },
                {
                    "command": [
                        "apply HST in HmemST1.",
                        "VernacExtend",
                        "8e50e6e6e0c48eaba5dd16e6c3b5d6eacab319b5"
                    ]
                },
                {
                    "command": [
                        "apply coinc_n with (interp_CP x interp); try assumption.",
                        "VernacExtend",
                        "9b51691d670a4b3879ffb449c70cd8b6bcb6ee3d"
                    ]
                },
                {
                    "command": [
                        "unfold pred_conj.",
                        "VernacExtend",
                        "255945ded758bc96765908b2d7ccfdf1ae1460bf"
                    ]
                },
                {
                    "command": [
                        "apply mca_pick_variety_aux_pca with s1 s2 ss; assumption.",
                        "VernacExtend",
                        "eeba88d4cbe089714c2b02bd09c0c9ebabe2de8b"
                    ]
                },
                {
                    "command": [
                        "intro HEW2; unfold exists_witness in *; apply SS.choose_spec1 in HEW.",
                        "VernacExtend",
                        "9f01c140321c5a5428f83a46f45f2110c6b12faf"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.filter_2 in HEW; try apply proper_1.",
                        "VernacExtend",
                        "aeb74612cff293b177182ba4c28f09cbeb1e9258"
                    ]
                },
                {
                    "command": [
                        "rewrite HEW2 in *; discriminate.",
                        "VernacExtend",
                        "8faefd49d2b473b32298731166ef1a6f84e2dba4"
                    ]
                },
                {
                    "command": [
                        "rewrite SSWP.Dec.F.add_neq_b in Hmem; try assumption.",
                        "VernacExtend",
                        "abdc2fe773563f21bf6c4c23c98ddd627dee9b1d"
                    ]
                },
                {
                    "command": [
                        "apply HSS with s.",
                        "VernacExtend",
                        "1b3a35f0918adfc81aa20767006923cabcbfd0c5"
                    ]
                },
                {
                    "command": [
                        "unfold auxsetofsets in *.",
                        "VernacExtend",
                        "bca999ab88df92629ac7e40a7beacbdf85adf2b3"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_2 in Hmem.",
                        "VernacExtend",
                        "4ea1c0bf685aa2b8dedb99d475f45de4b5496a5a"
                    ]
                },
                {
                    "command": [
                        "do 2 (apply SSWEqP.MP.Dec.F.remove_3 in Hmem).",
                        "VernacExtend",
                        "a2d63db9c289f4a45d0f5717fdbf31327a76ac92"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_1.",
                        "VernacExtend",
                        "fb831ce8c5315b134cfbeda745acfebb053443cf"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_coinc_ok",
            "line_nb": 537,
            "steps": [
                {
                    "command": [
                        "intros ss st interp cp HSS HST HTC.",
                        "VernacExtend",
                        "593c0eee418753ed3a460a131440b18b6bf631b3"
                    ]
                },
                {
                    "command": [
                        "unfold test_coinc in *.",
                        "VernacExtend",
                        "407062c8b7cac204311e1a5c8d041e6bec36300c"
                    ]
                },
                {
                    "command": [
                        "assert (HSS2 : ss_ok (identify_varieties ss st) interp) by (apply identify_varieties_ok; assumption).",
                        "VernacExtend",
                        "99e5935eba298b8e9e2b9ef9dcb32fe35323505f"
                    ]
                },
                {
                    "command": [
                        "unfold ss_ok in HSS2.",
                        "VernacExtend",
                        "204a6dd5fd023bd6313de89aeae9a30eddd0053e"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.exists_2 in HTC.",
                        "VernacExtend",
                        "cd006ef68fda57ea980ba7098b94a726e0ade89f"
                    ]
                },
                {
                    "command": [
                        "unfold SS.Exists in HTC.",
                        "VernacExtend",
                        "ec920acf4d8cbbe710154d4e05e47f9343108f43"
                    ]
                },
                {
                    "command": [
                        "destruct HTC as [s [HIn Hmem]].",
                        "VernacExtend",
                        "4a7b50894af394d75d0e271f4fd78848280d916b"
                    ]
                },
                {
                    "command": [
                        "apply HSS2 with s.",
                        "VernacExtend",
                        "bd88746dbf37c30a3c64f49e6c0b46aafef16cfe"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_1.",
                        "VernacExtend",
                        "fb831ce8c5315b134cfbeda745acfebb053443cf"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "intros x y Hxy.",
                        "VernacExtend",
                        "44bac6ec66dd54c6c1d048cac4ab63f977af73cf"
                    ]
                },
                {
                    "command": [
                        "apply memCPProper; trivial.",
                        "VernacExtend",
                        "dd9155336a4c9228c59e567c1896e3d4daa6042c"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ss_ok_empty",
            "line_nb": 552,
            "steps": [
                {
                    "command": [
                        "intros interp ss Hmem1 cp Hmem2.",
                        "VernacExtend",
                        "b647ab19ec8902ea683dea0fa3ec827a0a94b16a"
                    ]
                },
                {
                    "command": [
                        "rewrite SSWEqP.MP.Dec.F.empty_b in Hmem1.",
                        "VernacExtend",
                        "3bd4795da9e066cda7bb69aa70d0e37fac66b0e2"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "st_ok_empty",
            "line_nb": 557,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "unfold st_ok.",
                        "VernacExtend",
                        "607a40a63ea68f3f4082ffa8c490e9269208bfdc"
                    ]
                },
                {
                    "command": [
                        "intros t Ht.",
                        "VernacExtend",
                        "9b73bd01b7eab131fc4e1775831ff0e7de378f43"
                    ]
                },
                {
                    "command": [
                        "rewrite STempty_b in Ht.",
                        "VernacExtend",
                        "29fe053587cc02a6d2f35abf6b1d56d30efd5699"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "CPToSS",
            "line_nb": 564,
            "steps": [
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "exact S.empty.",
                        "VernacExtend",
                        "78077b73bcea78e6b1be4cdb3d22fcc87c2d3707"
                    ]
                },
                {
                    "command": [
                        "induction m.",
                        "VernacExtend",
                        "6f6279e892ad221278939a9b429a59edaeeb1676"
                    ]
                },
                {
                    "command": [
                        "exact (S.add cp S.empty).",
                        "VernacExtend",
                        "b48ae6d9447c0774781e47498b95ae9a3a0217c4"
                    ]
                },
                {
                    "command": [
                        "exact (S.add (headCP cp) (IHm (tailCP cp))).",
                        "VernacExtend",
                        "9fcf541250b2a5b816f090e3b07095bf091c9796"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "CPToSSHdTl",
            "line_nb": 571,
            "steps": [
                {
                    "command": [
                        "simpl; reflexivity.",
                        "VernacExtend",
                        "929257572def0332e6c079b4ed3a916720086e3a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "memCPToSSOK",
            "line_nb": 574,
            "steps": [
                {
                    "command": [
                        "induction m; intros e cp Hmem.",
                        "VernacExtend",
                        "0961f175162bebde920f2303a07a52af16244491"
                    ]
                },
                {
                    "command": [
                        "unfold InCP.",
                        "VernacExtend",
                        "df1188e79a6d40e6ab2452b5fd80a8a17374515e"
                    ]
                },
                {
                    "command": [
                        "simpl in *.",
                        "VernacExtend",
                        "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
                    ]
                },
                {
                    "command": [
                        "left.",
                        "VernacExtend",
                        "06dad9fc5698018f3f1213205145fec906c612b1"
                    ]
                },
                {
                    "command": [
                        "rewrite <- SWP.singleton_equal_add in Hmem.",
                        "VernacExtend",
                        "08e9f263912b2bdf4647870138c3731e1685aa1b"
                    ]
                },
                {
                    "command": [
                        "apply SWP.Dec.F.mem_2 in Hmem.",
                        "VernacExtend",
                        "0227239728b342f45fbf5f593fc7432cbe62f164"
                    ]
                },
                {
                    "command": [
                        "apply SWP.Dec.F.singleton_1.",
                        "VernacExtend",
                        "8a8167c3b6580285ab4ac6ecddb9b45802aaa2c5"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "apply InCPOK.",
                        "VernacExtend",
                        "dfa8a6a6faa3c43183de0c1b249004a0d6c0786b"
                    ]
                },
                {
                    "command": [
                        "rewrite CPToSSHdTl in Hmem.",
                        "VernacExtend",
                        "9c2bf3e85f7f83de4c32c864bfe89e10082279fc"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.Dec.F.add_b in Hmem.",
                        "VernacExtend",
                        "47f66e1ee14fa44089c5409b6167d43842fbeeef"
                    ]
                },
                {
                    "command": [
                        "rewrite <- SWP.Dec.F.singleton_b in Hmem.",
                        "VernacExtend",
                        "f07e7c4ab09470189adfa98c63850cfe057b8190"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in Hmem.",
                        "VernacExtend",
                        "1903c84db13730338aecb54e7707f79472e80c92"
                    ]
                },
                {
                    "command": [
                        "elim Hmem; clear Hmem; intro Hmem.",
                        "VernacExtend",
                        "3cbdd738d11353c13413120de946f91c9d030a65"
                    ]
                },
                {
                    "command": [
                        "left.",
                        "VernacExtend",
                        "06dad9fc5698018f3f1213205145fec906c612b1"
                    ]
                },
                {
                    "command": [
                        "apply SWP.Dec.F.mem_2 in Hmem.",
                        "VernacExtend",
                        "0227239728b342f45fbf5f593fc7432cbe62f164"
                    ]
                },
                {
                    "command": [
                        "apply SWP.Dec.F.singleton_1 in Hmem.",
                        "VernacExtend",
                        "7399e73ae246e4c8f3d865383dabd4ee3b0f3b9b"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "right.",
                        "VernacExtend",
                        "27e417a3497755767e1a1d6ba87753ecddaee6b7"
                    ]
                },
                {
                    "command": [
                        "apply IHm.",
                        "VernacExtend",
                        "aa76f2273bef46821b36b49418f7132330cc05f1"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "CPToSSOKAux",
            "line_nb": 597,
            "steps": [
                {
                    "command": [
                        "induction m'.",
                        "VernacExtend",
                        "1ced59db95b6d7b6aa7f735b4697def37b2374b9"
                    ]
                },
                {
                    "command": [
                        "induction m; intros cp cp' e s HEq Hmem HIn.",
                        "VernacExtend",
                        "8ffe6fd1387adcc9f9abda524a31e4637c0e3e27"
                    ]
                },
                {
                    "command": [
                        "unfold InCP in *.",
                        "VernacExtend",
                        "22e3fff8ac2b9a905975046cb784ffd11dbcccd4"
                    ]
                },
                {
                    "command": [
                        "simpl in *.",
                        "VernacExtend",
                        "5f89d9715fcf9b11bc0d0aadc658e9b10c47b606"
                    ]
                },
                {
                    "command": [
                        "apply andb_true_iff in Hmem.",
                        "VernacExtend",
                        "7ed2fde31d2cf6565212646245765770d4355cfb"
                    ]
                },
                {
                    "command": [
                        "destruct Hmem as [Hmem1 Hmem2].",
                        "VernacExtend",
                        "6771c483e69a3289f8bf8194df2255c6ddfa4dac"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.",
                        "VernacExtend",
                        "22f4ec1802eb2e61560f41f12c857a934918a5da"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.",
                        "VernacExtend",
                        "3dde71d7c1c099425eb4f39cda7db6e3f94e0a0c"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.Dec.F.add_b in Hmem1.",
                        "VernacExtend",
                        "1a102777822764ea91cbefab5f21fccbf0f74078"
                    ]
                },
                {
                    "command": [
                        "rewrite <- SWP.Dec.F.singleton_b in Hmem1.",
                        "VernacExtend",
                        "83ac74444d946511221b6a60775cdeefc838b0d6"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.",
                        "VernacExtend",
                        "1104da3395913c372fa79aee72dea1e89f0c69e3"
                    ]
                },
                {
                    "command": [
                        "rewrite SWP.Dec.F.add_b in Hmem2.",
                        "VernacExtend",
                        "4b8c291da8ef6d3d54c55c157917c34e341e90a8"
                    ]
                },
                {
                    "command": [
                        "rewrite <- SWP.Dec.F.singleton_b in Hmem2.",
                        "VernacExtend",
                        "76003df6191190a384d3c799ced8d11a42fe16d5"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.",
                        "VernacExtend",
                        "5dae319eeda3276afe549650bdf00b69980c11a2"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in Hmem1.",
                        "VernacExtend",
                        "83bef5bc3a2435c1e50e18981847802df8d90aa8"
                    ]
                },
                {
                    "command": [
                        "apply orb_true_iff in Hmem2.",
                        "VernacExtend",
                        "8e4d7d29b8cc2e1e13f653d3237411ab747a3bb3"
                    ]
                },
                {
                    "command": [
                        "elim HIn; clear HIn; intro HIn.",
                        "VernacExtend",
                        "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
                    ]
                },
                {
                    "command": [
                        "subst.",
                        "VernacExtend",
                        "ccc9cb848804101be22a0bb6c324861981c5c7f1"
                    ]
                },
                {
                    "command": [
                        "elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.",
                        "VernacExtend",
                        "506cba28b9501bf2768abab2c1d169d8e9c46e85"
                    ]
                },
                {
                    "command": [
                        "elim HIn; clear HIn; intro HIn.",
                        "VernacExtend",
                        "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
                    ]
                },
                {
                    "command": [
                        "subst.",
                        "VernacExtend",
                        "ccc9cb848804101be22a0bb6c324861981c5c7f1"
                    ]
                },
                {
                    "command": [
                        "elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.",
                        "VernacExtend",
                        "5bd01a0fb04bb75b58b1d854af3cc6d8c32a9ba8"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "elim HIn; clear HIn; intro HIn.",
                        "VernacExtend",
                        "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.",
                        "VernacExtend",
                        "97174b0d58cffd4d678d0b13be7069dc2d17d5fb"
                    ]
                },
                {
                    "command": [
                        "subst.",
                        "VernacExtend",
                        "ccc9cb848804101be22a0bb6c324861981c5c7f1"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "2d81b5ab80c366bd94fd1b38105964af28ed52b6"
                    ]
                },
                {
                    "command": [
                        "assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.",
                        "VernacExtend",
                        "36bd538c8d0760a95ade70bd97b2dff67f275924"
                    ]
                },
                {
                    "command": [
                        "apply memCPToSSOK.",
                        "VernacExtend",
                        "6a20b80ef22ea03d50a649b26acaafb4ec83a1a0"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "unfold InCP in HIn.",
                        "VernacExtend",
                        "e5d26015d2e77c81bd42744c6bdc7e75b5d74f82"
                    ]
                },
                {
                    "command": [
                        "simpl in HIn.",
                        "VernacExtend",
                        "af19e5789c5bd9adae0bce08955f8a2a5a9a0a1c"
                    ]
                },
                {
                    "command": [
                        "elim HIn; clear HIn; intro HIn.",
                        "VernacExtend",
                        "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.",
                        "VernacExtend",
                        "97174b0d58cffd4d678d0b13be7069dc2d17d5fb"
                    ]
                },
                {
                    "command": [
                        "subst.",
                        "VernacExtend",
                        "ccc9cb848804101be22a0bb6c324861981c5c7f1"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "130b8d3e149d184cbbc916b65ea9721b7e71178c"
                    ]
                },
                {
                    "command": [
                        "assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.",
                        "VernacExtend",
                        "66b8da5a847b6415a684d4faf77f2df08a2bb93e"
                    ]
                },
                {
                    "command": [
                        "apply memCPToSSOK.",
                        "VernacExtend",
                        "6a20b80ef22ea03d50a649b26acaafb4ec83a1a0"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "intros cp cp' e s HEq Hmem HIn.",
                        "VernacExtend",
                        "465cf06858793064854652f081923bdde90d441f"
                    ]
                },
                {
                    "command": [
                        "apply InCPOK in HIn.",
                        "VernacExtend",
                        "827e18e8f2c3cb87bf159d43eae1b086072ea3d1"
                    ]
                },
                {
                    "command": [
                        "elim HIn; clear HIn; intro HIn.",
                        "VernacExtend",
                        "cef04187d87fabdc6f0f5eae89abdfdcc53a6913"
                    ]
                },
                {
                    "command": [
                        "subst.",
                        "VernacExtend",
                        "ccc9cb848804101be22a0bb6c324861981c5c7f1"
                    ]
                },
                {
                    "command": [
                        "assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.",
                        "VernacExtend",
                        "95f340e2e408daea1b06cc10bb73f00ee5bc82c3"
                    ]
                },
                {
                    "command": [
                        "assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).",
                        "VernacExtend",
                        "2d81b5ab80c366bd94fd1b38105964af28ed52b6"
                    ]
                },
                {
                    "command": [
                        "assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.",
                        "VernacExtend",
                        "93214bfb808aca7957eb14055be8391aedfebb73"
                    ]
                },
                {
                    "command": [
                        "apply memCPToSSOK.",
                        "VernacExtend",
                        "6a20b80ef22ea03d50a649b26acaafb4ec83a1a0"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "apply IHm' with (tailCP cp') s; try assumption.",
                        "VernacExtend",
                        "cf26a9af534b14e24a05c1b003d3191f1254761e"
                    ]
                },
                {
                    "command": [
                        "apply memCPAuxTlOK; assumption.",
                        "VernacExtend",
                        "62741557808a1ad9292975a6c53d7efcaeaa03c4"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "CPToSSOK",
            "line_nb": 650,
            "steps": [
                {
                    "command": [
                        "unfold incl.",
                        "VernacExtend",
                        "bc668a228fabc181ca6e5d6b8b8a0673a10724dc"
                    ]
                },
                {
                    "command": [
                        "intros cp cp' s HEq Hmem e HIn.",
                        "VernacExtend",
                        "11915f7548c5daf61ab5dc46e567a77a5f8c7fc3"
                    ]
                },
                {
                    "command": [
                        "assert (H := CPToSSOKAux cp cp' e s HEq Hmem).",
                        "VernacExtend",
                        "301544c4688f3f3827c16843e1d7ffb31ebb4dfd"
                    ]
                },
                {
                    "command": [
                        "unfold InCP in H.",
                        "VernacExtend",
                        "384c81b3ba928a759a694c5d4809854fc6ebc044"
                    ]
                },
                {
                    "command": [
                        "apply H; assumption.",
                        "VernacExtend",
                        "7904d623a02884c927ef4e8b66c90cb12eee7c7a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "CoappDupPerm",
            "line_nb": 657,
            "steps": [
                {
                    "command": [
                        "intros cp HDup.",
                        "VernacExtend",
                        "7e80bd5acc0f4b10babe129dd4a79a65eed55cbf"
                    ]
                },
                {
                    "command": [
                        "apply NotNoDupDup in HDup; try apply Pos.eq_dec.",
                        "VernacExtend",
                        "a136df9ff2ff41cf1d3eac11b156ff215b074b55"
                    ]
                },
                {
                    "command": [
                        "destruct HDup as [e [l1 [l2 [HEq HIn]]]].",
                        "VernacExtend",
                        "d9d2dca5b4fd1f2b5a2db952b83e4e0e312de523"
                    ]
                },
                {
                    "command": [
                        "apply in_split in HIn.",
                        "VernacExtend",
                        "a2913997515114d5b720ea5dbf665aabd00d038c"
                    ]
                },
                {
                    "command": [
                        "destruct HIn as [l3 [l4 HEq']].",
                        "VernacExtend",
                        "cfcde5c77282ffe3c8632cc4cbe8c2c7b5bc4d88"
                    ]
                },
                {
                    "command": [
                        "assert (HPerm := Permutation.Permutation_middle l1 l2 e).",
                        "VernacExtend",
                        "5d264c929fba09d7b4f6eb5452ff2f0c3cb40d9c"
                    ]
                },
                {
                    "command": [
                        "rewrite <- HEq in HPerm; clear HEq.",
                        "VernacExtend",
                        "49dace5f2b760bc64dec48c50b4f8f64cc579fc4"
                    ]
                },
                {
                    "command": [
                        "rewrite HEq' in HPerm; clear HEq'; clear l1; clear l2; rename l3 into l1; rename l4 into l2.",
                        "VernacExtend",
                        "673d792405db37ed00e98a927029a05cf0ccb6a5"
                    ]
                },
                {
                    "command": [
                        "assert (HPerm' := Permutation.Permutation_middle l1 l2 e).",
                        "VernacExtend",
                        "c6d916cdd409940656c0401a6a1df21297f15143"
                    ]
                },
                {
                    "command": [
                        "apply (Permutation.perm_skip e) in HPerm'.",
                        "VernacExtend",
                        "86ecb83ae1311f3c23c05369f2b0d76df765cc3e"
                    ]
                },
                {
                    "command": [
                        "assert (HPerm'' := Permutation.perm_trans HPerm' HPerm); clear HPerm; clear HPerm'; rename HPerm'' into HPerm.",
                        "VernacExtend",
                        "55960fecd3e18534248ba4fef69618e011208f7d"
                    ]
                },
                {
                    "command": [
                        "rewrite <- CPLOK with (e :: e :: l1 ++ l2) e in HPerm.",
                        "VernacExtend",
                        "cafab183de69de4d20f90a0f266fea6eb163dad8"
                    ]
                },
                {
                    "command": [
                        "exists e; exists (l1 ++ l2); assumption.",
                        "VernacExtend",
                        "3f8edc5806640112d71b9bb3c2412869b538792b"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "CoappDupAux",
            "line_nb": 672,
            "steps": [
                {
                    "command": [
                        "intros cp H.",
                        "VernacExtend",
                        "31eddc63b04b18e21914823cb10987b538b83761"
                    ]
                },
                {
                    "command": [
                        "apply CoappDupPerm in H.",
                        "VernacExtend",
                        "a9a1d3bdb149b1961e29faf824daf17556a96b43"
                    ]
                },
                {
                    "command": [
                        "destruct H as [e[l HPerm]].",
                        "VernacExtend",
                        "88225040a280a949af1f750f301e2131586021b5"
                    ]
                },
                {
                    "command": [
                        "assert (Hl := Permutation.Permutation_length HPerm).",
                        "VernacExtend",
                        "aa490c41488e5000249cbc2644fa6c41dc3dc8ae"
                    ]
                },
                {
                    "command": [
                        "rewrite CPLOK in Hl.",
                        "VernacExtend",
                        "e6e87c553c541068e294a27dd7cf167772cffa08"
                    ]
                },
                {
                    "command": [
                        "rewrite <- lengthOfCPToList in Hl.",
                        "VernacExtend",
                        "80aa7d3ee0885e4000e51ed5fb4cbce71c730dfb"
                    ]
                },
                {
                    "command": [
                        "induction l; try (simpl in Hl; discriminate); clear IHl.",
                        "VernacExtend",
                        "4737e2b83d927cb5a4db22766011e9d1598c354e"
                    ]
                },
                {
                    "command": [
                        "exists e; exists (a :: l); exists (length l); exists (ListToCP (e :: e :: a :: l) e).",
                        "VernacExtend",
                        "ed0b332fd881ca9d84a2dc88e64eb8ba0f825738"
                    ]
                },
                {
                    "command": [
                        "split; try assumption.",
                        "VernacExtend",
                        "7aec98fbbf52695c4dbe780a98e3c8166b58320f"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "split; reflexivity.",
                        "VernacExtend",
                        "4dcd3619ac711de01342cf915900e96e80b675e1"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "CoappDup",
            "line_nb": 685,
            "steps": [
                {
                    "command": [
                        "intros cp interp H.",
                        "VernacExtend",
                        "a30359b5925d1d2d3c08b239613643c5ff7aca75"
                    ]
                },
                {
                    "command": [
                        "apply CoappDupAux in H.",
                        "VernacExtend",
                        "26b698478466d6981a04ccd5abe9798213a9116c"
                    ]
                },
                {
                    "command": [
                        "destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].",
                        "VernacExtend",
                        "573bd8d451d1ce61cb9acfabf5ac1f0235d05d20"
                    ]
                },
                {
                    "command": [
                        "assert (Hmn := Permutation.Permutation_length HPerm).",
                        "VernacExtend",
                        "e683f102363be263129ec8fc04b3d12c54587daa"
                    ]
                },
                {
                    "command": [
                        "apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.",
                        "VernacExtend",
                        "ebd9be6d9e900e0742929c5d7316efcede9d1551"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite <- interp_CPOK in HPerm).",
                        "VernacExtend",
                        "241718b5f40aecef5376dff5595df442fc5caa61"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite <- lengthOfCPToList in Hmn).",
                        "VernacExtend",
                        "fcfa10e9dc77d2fb766433faa26d85cab12de42a"
                    ]
                },
                {
                    "command": [
                        "do 3 (apply eq_add_S in Hmn).",
                        "VernacExtend",
                        "50a7af4073363a6bb709066f39a9061b69bde174"
                    ]
                },
                {
                    "command": [
                        "subst.",
                        "VernacExtend",
                        "ccc9cb848804101be22a0bb6c324861981c5c7f1"
                    ]
                },
                {
                    "command": [
                        "apply PermCoincOK with (interp_CP cp' interp); try assumption; clear HPerm.",
                        "VernacExtend",
                        "128e74699df8158935ba2b4e8126c843c82865d2"
                    ]
                },
                {
                    "command": [
                        "apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).",
                        "VernacExtend",
                        "7a8cda5a6739bcb08a778b0b4d8df1db18927572"
                    ]
                },
                {
                    "command": [
                        "rewrite Hsnd.",
                        "VernacExtend",
                        "a234f971061984852a59dbcb8bf83cf94af811e1"
                    ]
                },
                {
                    "command": [
                        "apply coinc_bd.",
                        "VernacExtend",
                        "beadba634c3ba7147802a4d8905a02cf37af298d"
                    ]
                },
                {
                    "command": [
                        "rewrite <- interp_CPHdOK.",
                        "VernacExtend",
                        "5d2da9c6fbe2f8afa24f11ed029a603e7fc4c9cf"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "rewrite <- interp_CPTlOK.",
                        "VernacExtend",
                        "46a4aa46ac7d9859dca557a9c9f5d2ea467df11c"
                    ]
                },
                {
                    "command": [
                        "rewrite <- interp_CPHdOK.",
                        "VernacExtend",
                        "5d2da9c6fbe2f8afa24f11ed029a603e7fc4c9cf"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite <- interp_CPTlOK).",
                        "VernacExtend",
                        "76517228a51e5612a37549bf86370d5d1f27627e"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "collect_coincs",
            "line_nb": 707,
            "steps": [
                {
                    "command": [
                        "intros cp ss interp HCoapp HSS.",
                        "VernacExtend",
                        "752208012aa841510e85d0c1c8e4ce82e284f489"
                    ]
                },
                {
                    "command": [
                        "unfold ss_ok.",
                        "VernacExtend",
                        "8b3f387759ffd21aaf87d3780206a5d7e605ad5e"
                    ]
                },
                {
                    "command": [
                        "intros s Hs.",
                        "VernacExtend",
                        "260fb9c070371bcc61b105a76ad6e9ca0d4ab0f1"
                    ]
                },
                {
                    "command": [
                        "intros cp' Hmem.",
                        "VernacExtend",
                        "1e90816d1077d65efef682d89ad0bd68e8d1d4c6"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_2 in Hs.",
                        "VernacExtend",
                        "05db75943d6076f2dff931feaee57239262da7b2"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.add_iff in Hs.",
                        "VernacExtend",
                        "366b613f20a3f563268332c002057f2598446c57"
                    ]
                },
                {
                    "command": [
                        "elim Hs; clear Hs; intro Hs.",
                        "VernacExtend",
                        "92006cb883d25d3133a8294e7a05b03bd5366eae"
                    ]
                },
                {
                    "command": [
                        "assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).",
                        "VernacExtend",
                        "eda792f7aa3b7c2acacac3e1015f0b90db232d0e"
                    ]
                },
                {
                    "command": [
                        "elim HDup; clear HDup; intro HDup.",
                        "VernacExtend",
                        "c422cc91436befe2b3ee378a86f21cc51f23921c"
                    ]
                },
                {
                    "command": [
                        "assert (Hincl := CPToSSOK cp cp' s Hs Hmem).",
                        "VernacExtend",
                        "08390988c03875bc232d39d180028c03f3e20bde"
                    ]
                },
                {
                    "command": [
                        "assert (Hlength : length (CPToList cp') = length (CPToList cp)) by (do 2 (rewrite <- lengthOfCPToList); reflexivity).",
                        "VernacExtend",
                        "a37e579b90e8919c191fcd23e62f73bbd56ceab5"
                    ]
                },
                {
                    "command": [
                        "assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).",
                        "VernacExtend",
                        "ba3d518bec64d60282eb2677e316d8d401bd9ea3"
                    ]
                },
                {
                    "command": [
                        "apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.",
                        "VernacExtend",
                        "ebd9be6d9e900e0742929c5d7316efcede9d1551"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite <- interp_CPOK in HPerm); clear HDup; clear Hincl; clear Hlength.",
                        "VernacExtend",
                        "b571bba5ca962c7a87c33a27ca2816322eac305c"
                    ]
                },
                {
                    "command": [
                        "apply Permutation.Permutation_sym in HPerm.",
                        "VernacExtend",
                        "2bac89f9a95cdaf27594a08fe9ee0b76ebffd010"
                    ]
                },
                {
                    "command": [
                        "apply PermCoincOK with (interp_CP cp interp); assumption.",
                        "VernacExtend",
                        "9ab92e157c4f1da0c967ac26f39a9db2b01d1061"
                    ]
                },
                {
                    "command": [
                        "apply CoappDup; assumption.",
                        "VernacExtend",
                        "5fcfc984f13686b286fd3be6360f3ba134d17257"
                    ]
                },
                {
                    "command": [
                        "unfold ss_ok in HSS.",
                        "VernacExtend",
                        "0c6f6735f17e5226ced7397bdd7b7242c8c9ee11"
                    ]
                },
                {
                    "command": [
                        "apply HSS with s; try assumption.",
                        "VernacExtend",
                        "f73c5471a2919f0565074ae204c4d35abb013082"
                    ]
                },
                {
                    "command": [
                        "apply SSWEqP.MP.Dec.F.mem_1; assumption.",
                        "VernacExtend",
                        "1384be09bdae5e6a6a9b9a52a4a0818cf5817db8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "collect_wds",
            "line_nb": 729,
            "steps": [
                {
                    "command": [
                        "intros cp st interp HWd HST.",
                        "VernacExtend",
                        "d89b87881ff2e02d95242a70c015ce9c3e801dec"
                    ]
                },
                {
                    "command": [
                        "unfold st_ok.",
                        "VernacExtend",
                        "607a40a63ea68f3f4082ffa8c490e9269208bfdc"
                    ]
                },
                {
                    "command": [
                        "intros cp' Hmem.",
                        "VernacExtend",
                        "1e90816d1077d65efef682d89ad0bd68e8d1d4c6"
                    ]
                },
                {
                    "command": [
                        "apply STadd_iff in Hmem.",
                        "VernacExtend",
                        "41128f1218f7edaa1a1f507275a0d3e5ad7778ac"
                    ]
                },
                {
                    "command": [
                        "elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].",
                        "VernacExtend",
                        "154228b65a2ef9e454af3fc1398024a998282a39"
                    ]
                },
                {
                    "command": [
                        "assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).",
                        "VernacExtend",
                        "2151eaddaab9b2fe132ef146ec0e8bca3eed35d6"
                    ]
                },
                {
                    "command": [
                        "assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).",
                        "VernacExtend",
                        "ec6c4257200aca127970c2210a15d3e951f3839b"
                    ]
                },
                {
                    "command": [
                        "apply eqListOK in Hmem.",
                        "VernacExtend",
                        "274ce5611a74c5c8c45693a70308d5596c5ec145"
                    ]
                },
                {
                    "command": [
                        "rewrite Hmem in Hcp.",
                        "VernacExtend",
                        "ec0efd84945ae1b12e229a67f7296cd5f3d36f14"
                    ]
                },
                {
                    "command": [
                        "apply PermWdOK with (interp_CP cp interp); try assumption.",
                        "VernacExtend",
                        "4e343c2ff28134620cf8868db564abe392472e8e"
                    ]
                },
                {
                    "command": [
                        "do 2 (rewrite interp_CPOK).",
                        "VernacExtend",
                        "d297d93146e45f765441dcdbafa7b5d9d6d9d2d2"
                    ]
                },
                {
                    "command": [
                        "apply Permutation.Permutation_map.",
                        "VernacExtend",
                        "c3801509092065da95658bfbd8be090ef9269cc2"
                    ]
                },
                {
                    "command": [
                        "transitivity (PosSort.sort (CPToList cp')); try assumption.",
                        "VernacExtend",
                        "1b053234df5f883830525d640254181a3ef37bcf"
                    ]
                },
                {
                    "command": [
                        "apply Permutation.Permutation_sym; assumption.",
                        "VernacExtend",
                        "4c6ad6dd07e554db59c4525749d61f7fbf5ef739"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "positive_dec",
            "line_nb": 746,
            "steps": [
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "PropToTagged",
            "line_nb": 759,
            "steps": [
                {
                    "command": [
                        "trivial.",
                        "VernacExtend",
                        "6704630005ea37c1f66f817f0d3cb83967ca08c5"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}