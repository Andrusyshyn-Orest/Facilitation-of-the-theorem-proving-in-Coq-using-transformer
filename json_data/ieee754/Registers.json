{
    "filename": "Registers.v",
    "coq_project": "ieee754",
    "vernac_cmds": [
        [
            "Require Import Bool.",
            "VernacRequire",
            "a27d9a6c92262b970381301472e9a1100c206680"
        ],
        [
            "Require Import Omega.",
            "VernacRequire",
            "72dd903de5f3320ef9d302d79812066579ed9cdb"
        ],
        [
            "Section registers.",
            "VernacBeginSection",
            "7c5cbff7b9996c4716dd409a1c26e20b244335f4"
        ],
        [
            "Inductive register : nat -> Set := | regO : register 0 | regS : forall m : nat, bool -> register m -> register (S m).",
            "VernacInductive",
            "7dc4bb0bdf970c6c2e65385e32cd3941d69b73a9"
        ],
        [
            "Definition register_zero := nat_rec register regO (fun m : nat => regS m false).",
            "VernacDefinition",
            "86f81ead5f57f5bc1940216cef9406a7de1ab03c"
        ],
        [
            "Definition register_max := nat_rec register regO (fun m : nat => regS m true).",
            "VernacDefinition",
            "e147fe149a895a90c8f3b2bf1a2e4e31a383eebd"
        ],
        [
            "Fixpoint is_register_zero (n : nat) (x : register n) {struct x} : bool := match x with | regO => true | regS m b y => if b then false else is_register_zero m y end.",
            "VernacFixpoint",
            "055fe109cceefc933e6bfd3cb40ea35c9b818b85"
        ],
        [
            "Definition is_register_max (n : nat) (x : register n) := match x with | regO => true | regS m b y => if b then is_register_zero m y else false end.",
            "VernacDefinition",
            "3aec10a811de5c8af4880aef424caedb55114593"
        ],
        [
            "Fixpoint entier_of_register (n : nat) (x : register n) {struct x} : N := match x with | regO => 0%N | regS m b y => if b then Ndouble_plus_one (entier_of_register m y) else Ndouble (entier_of_register m y) end.",
            "VernacFixpoint",
            "8d0984de12302d1ff3b9ab2a945176464dc412ad"
        ],
        [
            "Definition Z_of_register (n : nat) (x : register n) := BinInt.Z_of_N (entier_of_register n x).",
            "VernacDefinition",
            "b80bb68df9211971730fc09d9b5a0cc1c54ff229"
        ],
        [
            "Definition sign_of (b : bool) := if b then 1%Z else (-1)%Z.",
            "VernacDefinition",
            "88a8b0b30f6fddbf32b4334627c14641c6f7af26"
        ],
        [
            "Fixpoint register_of_pos (n : nat) (x : positive) {struct x} : register n := match n as x return (register x) with | O => regO | S m => match x with | xH => regS m true (register_zero m) | xI y => regS m true (register_of_pos m y) | xO y => regS m false (register_of_pos m y) end end.",
            "VernacFixpoint",
            "b15e0475ebf19d74ea2b2a5a080547a735afcda1"
        ],
        [
            "Definition register_of_entier (n : nat) (x : N) := match x return (register n) with | N0 => register_zero n | Npos p => register_of_pos n p end.",
            "VernacDefinition",
            "d4d30536d764ca6530200c30c42dd75de9c01cf1"
        ],
        [
            "Definition register_of_Z (n : nat) (z : Z) : register n := register_of_entier n (BinInt.Zabs_N z).",
            "VernacDefinition",
            "e251fbf7384786d153cfef50ca0c1846e6bc71f8"
        ],
        [
            "Lemma register_of_entier_bij2 : forall (n : nat) (x : register n), register_of_entier n (entier_of_register n x) = x.",
            "VernacStartTheoremProof",
            "ef28a59fc959cd18de073608a5f3cf01a4c0d08d"
        ],
        [
            "simple induction x; [ reflexivity | intros m b r; elim b; [ simpl in |- *; unfold Ndouble_plus_one in |- *; elim (entier_of_register m r); intros; rewrite <- H; reflexivity | simpl in |- *; unfold Ndouble in |- *; elim (entier_of_register m r); intros; rewrite <- H; reflexivity ] ].",
            "VernacExtend",
            "2f472ac725cbc326f885efc4f113044496a91582"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint register_compare (n : nat) (x : register n) (m : nat) (y : register m) {struct y} : Datatypes.comparison := match x with | regO => if is_register_zero m y then Datatypes.Eq else Datatypes.Lt | regS n' b_x x' => match y with | regO => if is_register_zero n x then Datatypes.Eq else Datatypes.Gt | regS m' b_y y' => match register_compare n' x' m' y' with | Datatypes.Eq => if b_x then if b_y then Datatypes.Eq else Datatypes.Gt else if b_y then Datatypes.Lt else Datatypes.Eq | Datatypes.Gt => Datatypes.Gt | Datatypes.Lt => Datatypes.Lt end end end.",
            "VernacFixpoint",
            "0d56648f87fd36d0352e078e2ee5d7694ffcada1"
        ],
        [
            "Definition reg_compare (n : nat) (x y : register n) := register_compare n x n y.",
            "VernacDefinition",
            "fbec6d2cac729552417ad753d586cd284621ee73"
        ],
        [
            "End registers.",
            "VernacEndSegment",
            "6021f3c53211fc4761721d9ea895551e8a3a2983"
        ]
    ],
    "proofs": [
        {
            "name": "register_of_entier_bij2",
            "line_nb": 14,
            "steps": [
                {
                    "command": [
                        "simple induction x; [ reflexivity | intros m b r; elim b; [ simpl in |- *; unfold Ndouble_plus_one in |- *; elim (entier_of_register m r); intros; rewrite <- H; reflexivity | simpl in |- *; unfold Ndouble in |- *; elim (entier_of_register m r); intros; rewrite <- H; reflexivity ] ].",
                        "VernacExtend",
                        "2f472ac725cbc326f885efc4f113044496a91582"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}