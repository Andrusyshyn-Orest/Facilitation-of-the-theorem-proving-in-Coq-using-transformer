{
    "filename": "src/StringOT.v",
    "coq_project": "QuickChick",
    "vernac_cmds": [
        [
            "Require Import OrderedType.",
            "VernacRequire",
            "0570fbfcbf725d35a8db5f66bfbba69ef0f09ff2"
        ],
        [
            "Require Import Bool.",
            "VernacRequire",
            "a27d9a6c92262b970381301472e9a1100c206680"
        ],
        [
            "Module BoolOT <: OrderedType.",
            "VernacDefineModule",
            "4e08c1c21262a9bf86194e3f99ffde303bd7718c"
        ],
        [
            "Definition t := bool.",
            "VernacDefinition",
            "b9f16635509d954330956ba75184af9b7e88c2c4"
        ],
        [
            "Definition eq := @Logic.eq bool.",
            "VernacDefinition",
            "33c74eae080d9344de81a56302b6e3a57bf923f5"
        ],
        [
            "Definition eq_refl := @Logic.eq_refl bool.",
            "VernacDefinition",
            "c4f517834ac0fca1318917632ebd42b799b69bc2"
        ],
        [
            "Definition eq_sym := @Logic.eq_sym bool.",
            "VernacDefinition",
            "ba63313a15411ecd653262f49734a22c128ec5dd"
        ],
        [
            "Definition eq_trans := @Logic.eq_trans bool.",
            "VernacDefinition",
            "2318957f30002227c8bd8a801f6150f8f1a15e2c"
        ],
        [
            "Definition eq_dec := bool_dec.",
            "VernacDefinition",
            "e035dc913d4763b1ee35aac3bc2fb1538ba8e14b"
        ],
        [
            "Definition lt (b1 b2 : bool) : Prop := b1 = false /\\ b2 = true.",
            "VernacDefinition",
            "65d5f2f379b469343b76b60279826bdf243116f4"
        ],
        [
            "Theorem lt_trans : forall x y z : bool, lt x y -> lt y z -> lt x z.",
            "VernacStartTheoremProof",
            "b2184ceb319f6ca74dcd5e0fdde4d565accb8c20"
        ],
        [
            "unfold lt; tauto.",
            "VernacExtend",
            "f4358452015d1605e7b80ebd7fe9c6af213d2a6e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem lt_not_eq : forall x y : bool, lt x y -> ~ eq x y.",
            "VernacStartTheoremProof",
            "361f0a304f3cae9f75bde3c138f331323c0bb275"
        ],
        [
            "unfold lt, eq; intuition; congruence.",
            "VernacExtend",
            "56ef7943469c47c41a407ba53168d299b56d25ad"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem compare : forall x y : bool, Compare lt eq x y.",
            "VernacStartTheoremProof",
            "86b58ae2a968446e2ad12eac7b58d3f02fb60fc2"
        ],
        [
            "unfold lt, eq; repeat (let b := fresh in intros b; destruct b); [apply EQ | apply GT | apply LT | apply EQ]; auto.",
            "VernacExtend",
            "bebe0d9ef892659304ef0c8888591cfc2a788d1b"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End BoolOT.",
            "VernacEndSegment",
            "e442960abfe686ac24fffaa31be8fe1c05ba3d10"
        ],
        [
            "Require Import Ascii NArith.",
            "VernacRequire",
            "ccb3809c02913c40c5489d96f8deec442015bf98"
        ],
        [
            "Module AsciiOT <: OrderedType.",
            "VernacDefineModule",
            "70b0f9f06db5911d5bd1ab1194b56c3b14afc4da"
        ],
        [
            "Definition t := ascii.",
            "VernacDefinition",
            "830aece31a9824209eb5fe6924555e248aeed6a8"
        ],
        [
            "Definition eq := @Logic.eq ascii.",
            "VernacDefinition",
            "79dde5d522cd28c525fd15a8767400dfd80cb5f1"
        ],
        [
            "Definition eq_refl := @Logic.eq_refl ascii.",
            "VernacDefinition",
            "87a1c4dadfcfcda740450eeec60f7b77c3b513c1"
        ],
        [
            "Definition eq_sym := @Logic.eq_sym ascii.",
            "VernacDefinition",
            "064531a2773636a6e7ecdbdd6fdf40178fdbcd33"
        ],
        [
            "Definition eq_trans := @Logic.eq_trans ascii.",
            "VernacDefinition",
            "8a4f7d87a9c25d06c8a9fc2342783baf25b5450a"
        ],
        [
            "Definition eq_dec := ascii_dec.",
            "VernacDefinition",
            "5ad9abc53cb2af7f6bd3dc507824083f64c8c409"
        ],
        [
            "Definition lt (c d : ascii) : Prop := (N_of_ascii c < N_of_ascii d)%N.",
            "VernacDefinition",
            "ea5cf034bbee4da97df7936d5d14c782a83c695f"
        ],
        [
            "Theorem lt_trans : forall c d e : ascii, lt c d -> lt d e -> lt c e.",
            "VernacStartTheoremProof",
            "38236976e8116e41adcc6190c76c04e7ba479135"
        ],
        [
            "intros until 0; unfold lt; apply N.lt_trans.",
            "VernacExtend",
            "b11c9339086e373b4b7cbdb6c80ac028c0886233"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem lt_not_eq : forall c d : ascii, lt c d -> ~ eq c d.",
            "VernacStartTheoremProof",
            "8c01ea971abbe5bbea538498165134fb308163cf"
        ],
        [
            "unfold lt, eq; red; intros; assert (N_of_ascii c = N_of_ascii d) as eq' by (f_equal; assumption); generalize dependent eq'; apply N.lt_neq; assumption.",
            "VernacExtend",
            "3a7467867be2e17027c930395aa4ee5d72d1f1e8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem compare : forall c d : t, Compare lt eq c d.",
            "VernacStartTheoremProof",
            "45364ca26c93345e88a62665c532df4c80f69f07"
        ],
        [
            "unfold lt, eq; intros; remember (N_of_ascii c ?= N_of_ascii d)%N as C; symmetry in HeqC; destruct C; [ apply EQ; replace c with (ascii_of_N (N_of_ascii c)) by apply ascii_N_embedding; replace d with (ascii_of_N (N_of_ascii d)) by apply ascii_N_embedding; f_equal; apply N.compare_eq | apply LT | apply GT; apply N.gt_lt]; assumption.",
            "VernacExtend",
            "332bbcbb68f1504b201baf6ea431909955ce642a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End AsciiOT.",
            "VernacEndSegment",
            "1468cc7e57c32a90547710eb767f9fd5fe7882e3"
        ],
        [
            "Require Import Coq.Strings.String.",
            "VernacRequire",
            "5c887f44cc52e2a2db22e7cb04fefdce0c1d84f0"
        ],
        [
            "Module StringOT <: OrderedType.",
            "VernacDefineModule",
            "2f0c096ede020b25bbbce159647a759c95743990"
        ],
        [
            "Definition t := string.",
            "VernacDefinition",
            "ccafaaf34f8c7078d11e1b17292a5e2fb0170e88"
        ],
        [
            "Definition eq := @Logic.eq string.",
            "VernacDefinition",
            "caa611473c59220e5d236ffca0cd7e834e806498"
        ],
        [
            "Definition eq_refl := @Logic.eq_refl string.",
            "VernacDefinition",
            "4677f6611f70dfae507559474dfe702d54ee1917"
        ],
        [
            "Definition eq_sym := @Logic.eq_sym string.",
            "VernacDefinition",
            "6f34b2159958999ebdd0fde43ee6393930332de1"
        ],
        [
            "Definition eq_trans := @Logic.eq_trans string.",
            "VernacDefinition",
            "6cd8c10dcc7c4513daac566d946a0350f4a9220e"
        ],
        [
            "Definition eq_dec := string_dec.",
            "VernacDefinition",
            "cf0aa1ce5e04b64091e259bed08e1694a4a9da6d"
        ],
        [
            "Inductive SOrdering := SLT | SEQ | SGT.",
            "VernacInductive",
            "aa47435057203ce9e52b73d404ecafd503ea8050"
        ],
        [
            "Fixpoint strcmp (s1 s2 : string) : SOrdering := match s1, s2 with | EmptyString, EmptyString => SEQ | EmptyString, String _ _ => SLT | String _ _, EmptyString => SGT | String ch1 s1', String ch2 s2' => match AsciiOT.compare ch1 ch2 with | LT _ => SLT | EQ _ => strcmp s1' s2' | GT _ => SGT end end.",
            "VernacFixpoint",
            "959c978e24fc851e82493eb408cea0eeacb919c3"
        ],
        [
            "Definition lt (s1 s2 : string) := strcmp s1 s2 = SLT.",
            "VernacDefinition",
            "75d807421ebf6bc6c61e2ec38a80fe47d5a48ba8"
        ],
        [
            "Local Ltac do_ascii_lt_trans := match goal with | [ _ : AsciiOT.lt ?c1 ?c2 , _ : AsciiOT.lt ?c2 ?c3 |- _ ] => assert (AsciiOT.lt c1 c3) by (eapply AsciiOT.lt_trans; eauto) end.",
            "VernacExtend",
            "8cfebb0a97a5ba699ba567ee1ef069d19d81fd33"
        ],
        [
            "Local Ltac not_ascii_lt_refl := match goal with | [ _ : AsciiOT.lt ?c ?c |- _ ] => assert (c <> c) by (apply AsciiOT.lt_not_eq; assumption); congruence end.",
            "VernacExtend",
            "a80ae034e0e704d4aaf45dc54addd5ef6a17d95e"
        ],
        [
            "Theorem lt_trans : forall s1 s2 s3 : string, lt s1 s2 -> lt s2 s3 -> lt s1 s3.",
            "VernacStartTheoremProof",
            "d5461bc0f343f209b124cb3ec3acd5d690032c0b"
        ],
        [
            "unfold lt; intros s1 s2; generalize dependent s1; induction s2 as [| c2 s2'].",
            "VernacExtend",
            "0ff27f2334801ce445de477376a6923f3dffb5dc"
        ],
        [
            "destruct s1; [trivial | simpl; congruence].",
            "VernacExtend",
            "e8ae94c48838468207f0ad04293751b7eb1023b6"
        ],
        [
            "destruct s1 as [| c1 s1']; simpl.",
            "VernacExtend",
            "d7e8c21ba252cbdf6d3f392b40ff1a139e518ccd"
        ],
        [
            "destruct s3; [congruence | trivial].",
            "VernacExtend",
            "a5223c183966ae1c8e54dfe41c0b3386b2c2504e"
        ],
        [
            "destruct s3 as [| c3 s3']; [congruence |].",
            "VernacExtend",
            "f50ebcd0d308c85e1a90ffaeeeaab9ca83048e81"
        ],
        [
            "destruct (AsciiOT.compare c1 c2) as [? | ? | ?] eqn:?; destruct (AsciiOT.compare c2 c3) as [? | ? | ?] eqn:?; destruct (AsciiOT.compare c1 c3) as [? | ? | ?] eqn:?; unfold AsciiOT.eq in *; subst; solve [ apply IHs2' | congruence | repeat (try not_ascii_lt_refl; do_ascii_lt_trans) ].",
            "VernacExtend",
            "84f6f34ea25ea29789c16de1389352f09723c04a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem lt_not_eq : forall s1 s2 : string, lt s1 s2 -> ~ eq s1 s2.",
            "VernacStartTheoremProof",
            "89e7738675fba4e120f446a78356b0825859edff"
        ],
        [
            "unfold lt, eq; induction s1 as [| c1 s1'].",
            "VernacExtend",
            "9d52d663ef3838a1c5a6b64929f13f97093cb67e"
        ],
        [
            "destruct s2; simpl; congruence.",
            "VernacExtend",
            "cc45986a3d0c795574f5f0035d1233a099ca54b2"
        ],
        [
            "destruct s2 as [| c2 s2']; simpl.",
            "VernacExtend",
            "9d0c4acad48bf4f6d3969f87213a713b000e0e94"
        ],
        [
            "congruence.",
            "VernacExtend",
            "d8c818f6cffeaee6a722a71acc77f2d6e5199eb9"
        ],
        [
            "destruct (AsciiOT.compare c1 c2) as [? | ? | ?] eqn:?; intros Hc Heq; inversion Heq.",
            "VernacExtend",
            "6de2c3a499fac063ba51d8df68afd9df683b9975"
        ],
        [
            "subst; not_ascii_lt_refl.",
            "VernacExtend",
            "1810ce9927977ef419e3f378294444f1bf990c41"
        ],
        [
            "apply IHs1' in Hc; apply Hc; assumption.",
            "VernacExtend",
            "5e3bc588fcf27619a23ea9f3fc8e2a075a2b8101"
        ],
        [
            "congruence.",
            "VernacExtend",
            "d8c818f6cffeaee6a722a71acc77f2d6e5199eb9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem compare : forall s1 s2 : t, Compare lt eq s1 s2.",
            "VernacStartTheoremProof",
            "22e01f6adf95fc373da89ce9330796354cbca665"
        ],
        [
            "unfold lt, eq; induction s1 as [| c1 s1'].",
            "VernacExtend",
            "9d52d663ef3838a1c5a6b64929f13f97093cb67e"
        ],
        [
            "destruct s2; [apply EQ | apply LT]; auto.",
            "VernacExtend",
            "d18ee913ad752af5cf73d050c45b78eb2033abde"
        ],
        [
            "destruct s2 as [| c2 s2']; [apply GT; auto | ].",
            "VernacExtend",
            "06cfd28f3e8f111153cffd0dfb8a5c98806dd575"
        ],
        [
            "destruct (AsciiOT.compare c1 c2) as [? | ? | ?] eqn:Hcmp.",
            "VernacExtend",
            "450142701ec8894e808e6134a4433441c94523b8"
        ],
        [
            "apply LT; simpl; rewrite Hcmp; auto.",
            "VernacExtend",
            "799a00a7b338f0a0f6e96a33f8efed4381867fc1"
        ],
        [
            "unfold AsciiOT.eq in *; subst.",
            "VernacExtend",
            "778f2c973b09b69330b27b37641c064305d12038"
        ],
        [
            "destruct (IHs1' s2'); [apply LT | apply EQ | apply GT]; first [ simpl; rewrite Hcmp; assumption | subst; reflexivity ].",
            "VernacExtend",
            "ddd231208dc9f907d34831852bec92b04711908f"
        ],
        [
            "apply GT; simpl.",
            "VernacExtend",
            "4c4d1a410f6e8d084ebb63bbd342a7de7d100373"
        ],
        [
            "destruct (AsciiOT.compare c2 c1) as [? | ? | ?] eqn:Hcmp'.",
            "VernacExtend",
            "f8762af91ecca19f862edf5942e81d0fd6d622da"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "unfold AsciiOT.eq in *; subst; not_ascii_lt_refl.",
            "VernacExtend",
            "1cde2c4fcbcdb311c72037e723e640c697808a28"
        ],
        [
            "do_ascii_lt_trans; not_ascii_lt_refl.",
            "VernacExtend",
            "55defb1667526e3a41a8b09e238d3eba490ee1d5"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End StringOT.",
            "VernacEndSegment",
            "f4ab75c413705236e8950315d76939cf0694addc"
        ]
    ],
    "proofs": [
        {
            "name": "lt_trans",
            "line_nb": 10,
            "steps": [
                {
                    "command": [
                        "unfold lt; tauto.",
                        "VernacExtend",
                        "f4358452015d1605e7b80ebd7fe9c6af213d2a6e"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "lt_not_eq",
            "line_nb": 13,
            "steps": [
                {
                    "command": [
                        "unfold lt, eq; intuition; congruence.",
                        "VernacExtend",
                        "56ef7943469c47c41a407ba53168d299b56d25ad"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "compare",
            "line_nb": 16,
            "steps": [
                {
                    "command": [
                        "unfold lt, eq; repeat (let b := fresh in intros b; destruct b); [apply EQ | apply GT | apply LT | apply EQ]; auto.",
                        "VernacExtend",
                        "bebe0d9ef892659304ef0c8888591cfc2a788d1b"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}