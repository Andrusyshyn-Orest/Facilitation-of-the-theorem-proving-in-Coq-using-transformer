{
    "filename": "src/Procrastination.v",
    "coq_project": "coq-procrastination",
    "vernac_cmds": [
        [
            "Module Marker.",
            "VernacDefineModule",
            "e1caddf4839fd9b037c1f96dcd03c1556d732212"
        ],
        [
            "Definition end_defer (P : Type) := P.",
            "VernacDefinition",
            "035dbf8777abaac7bcdc9e12750215bb709e2d44"
        ],
        [
            "Definition group (P : Prop) := P.",
            "VernacDefinition",
            "7ad3fe42b7b07a3433455cc55d01f9cab2ee70b8"
        ],
        [
            "Lemma group_fold : forall (P: Prop), P -> group P.",
            "VernacStartTheoremProof",
            "ed6ce6bf43a5641f8fcad7cffc4aae25a9ce7a45"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Ltac find_group := match goal with | H : group _ |- _ => constr:(H) end.",
            "VernacExtend",
            "fa84de32c8ccd401575d1057190fe03b7507fab5"
        ],
        [
            "End Marker.",
            "VernacEndSegment",
            "fe685fd3d0aa38b0550c4d7da54d22b1876b47c9"
        ],
        [
            "Global Opaque Marker.group.",
            "VernacSetOpacity",
            "27c0d1faba77e0a7af28baff18a4c0c92cbf74b8"
        ],
        [
            "Module MkHelperLemmas.",
            "VernacDefineModule",
            "f148839fe945ef4db1e342e5537496e2d9dfee63"
        ],
        [
            "Ltac transparent_assert name type := unshelve refine (let name := _ : type in _).",
            "VernacExtend",
            "371fff49e57dc4fcc4dd405de7adcbda6318390e"
        ],
        [
            "Inductive Boxer := | boxer : forall A : Type, A -> Boxer.",
            "VernacInductive",
            "c3b47e046e660451f5c3b553d81f522e8a73a519"
        ],
        [
            "Arguments boxer : clear implicits.",
            "VernacArguments",
            "5d9632beb0f84da9be88c257fe4baa6637b73daa"
        ],
        [
            "Ltac ids_nb ids := lazymatch ids with | tt => constr:(O) | (fun x => _) => let ids' := eval cbv beta in (ids tt) in let n := ids_nb ids' in constr:(S n) end.",
            "VernacExtend",
            "0eb5f9e7556bcc03b1615c0ef6d4785906f4c60d"
        ],
        [
            "Ltac iter_idents ids tac := lazymatch ids with | tt => idtac | (fun x => _) => tac x; iter_idents ltac:(eval cbv beta in (ids tt)) tac end.",
            "VernacExtend",
            "6b98c0367a047a358cb97df3e5773fec69813ba7"
        ],
        [
            "Ltac print_ids ids := lazymatch ids with | tt => idtac | (fun x => _) => let ids' := eval cbv beta in (ids tt) in idtac x; print_ids ids' end.",
            "VernacExtend",
            "6237625a157cce77d382e824d8d8231046334f71"
        ],
        [
            "Ltac mk_forall varty goalty n cont := lazymatch n with | O => cont (@nil Boxer) | S ?n' => let X := fresh in refine (forall (X : varty), _ : goalty); mk_forall varty goalty n' ltac:(fun x => cont (cons (boxer varty X) x)) end.",
            "VernacExtend",
            "aff7ccd3446a84179c156a3aa08d5ba270a445f7"
        ],
        [
            "Ltac mk_forall_tys vartys goalty cont := lazymatch vartys with | nil => cont (@nil Boxer) | cons (boxer _ ?ty) ?tys => let X := fresh in refine (forall (X : ty), _ : goalty); mk_forall_tys tys goalty ltac:(fun x => cont (cons (boxer ty X) x)) end.",
            "VernacExtend",
            "2fe5be18ec81e04c6ce346c01e1f5395e4a821ee"
        ],
        [
            "Ltac mk_arrow vars goalty := lazymatch vars with | nil => idtac | cons (boxer _ ?v) ?vs => refine (v -> _ : goalty); mk_arrow vs goalty end.",
            "VernacExtend",
            "1aaec830fc0e1c2564ee15702a52dbbc6a969e8e"
        ],
        [
            "Ltac mk_app f vars goalty := lazymatch vars with | nil => exact f | cons (boxer _ ?v) ?vs => refine (_ v : goalty); let x := fresh \"x\" in intro x; mk_app (f x) vs goalty end.",
            "VernacExtend",
            "cc60569c22638854593e7cb2b6ffafadfadec8a5"
        ],
        [
            "Ltac mk_sigT_sig ids goalty cont := lazymatch ids with | tt => cont (@nil Boxer) | (fun x => tt) => let X := fresh x in refine (sig (fun X => _) : goalty); cont (cons (@boxer _ X) (@nil Boxer)) | (fun x => _) => let ids' := eval cbv beta in (ids tt) in let X := fresh x in refine (sigT (fun X => _) : goalty); mk_sigT_sig ids' goalty ltac:(fun x => cont (cons (@boxer _ X) x)) end.",
            "VernacExtend",
            "a874caeff90557e9a305417357547d90e9b7dc93"
        ],
        [
            "Ltac mk_exists ids goalty cont := lazymatch ids with | tt => cont (@nil Boxer) | (fun x => _) => let ids' := eval cbv beta in (ids tt) in let X := fresh x in refine (exists X, _ : goalty); mk_exists ids' goalty ltac:(fun x => cont (cons (@boxer _ X) x)) end.",
            "VernacExtend",
            "3719f77a1eff5b3186907bd57770446b77a3f7cd"
        ],
        [
            "Ltac introsType := repeat ( match goal with | |- forall (_ : Type), _ => intro end ).",
            "VernacExtend",
            "c65953b8baf69df9f0fd114002aa9c673144d173"
        ],
        [
            "Ltac prove_begin_defer_helper := introsType; let H := fresh in intros ? ? ? H; unfold Marker.end_defer in *; repeat (let x := fresh \"x\" in destruct H as (x & H)); eauto using Marker.group_fold.",
            "VernacExtend",
            "3dd7d16d8098ae59c099a208e66209973fac06cc"
        ],
        [
            "Goal forall (g : Prop) (P : Type), (Marker.group g -> P) -> Marker.end_defer g -> P.",
            "VernacDefinition",
            "eaa18dada70c843002e305f7b3b8921bb16f5bbb"
        ],
        [
            "prove_begin_defer_helper.",
            "VernacExtend",
            "477375f22c4aebea0b8549a6ec277851bb843c88"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Goal forall A (g : A -> Prop) (P : Prop), (forall a, Marker.group (g a) -> P) -> Marker.end_defer (exists a, g a) -> P.",
            "VernacDefinition",
            "63df2b8cca6049166617ff6ae94639772aee6a77"
        ],
        [
            "prove_begin_defer_helper.",
            "VernacExtend",
            "477375f22c4aebea0b8549a6ec277851bb843c88"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Goal forall A B (g : A -> B -> Prop) (P : Prop), (forall a b, Marker.group (g a b) -> P) -> Marker.end_defer (exists a b, g a b) -> P.",
            "VernacDefinition",
            "7f2763e2502d2e8e62f13af78c88609eccd0d761"
        ],
        [
            "prove_begin_defer_helper.",
            "VernacExtend",
            "477375f22c4aebea0b8549a6ec277851bb843c88"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Goal forall A B (g : A -> B -> Prop) (P : Type), (forall a b, Marker.group (g a b) -> P) -> Marker.end_defer {a : A & { b | g a b } } -> P.",
            "VernacDefinition",
            "8a44fca9a469dca764d755a66b8ddd49547d4c5e"
        ],
        [
            "prove_begin_defer_helper.",
            "VernacExtend",
            "477375f22c4aebea0b8549a6ec277851bb843c88"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Ltac mk_begin_defer_helper_aux n G Pty mk_exists := transparent_assert G Type; [ mk_forall Type Type n ltac:(fun L => let g_ty := fresh \"g_ty\" in transparent_assert g_ty Type; [ mk_arrow L Type; exact Prop | simpl in g_ty]; let g := fresh \"g\" in refine (forall (g : g_ty), _ : Type); subst g_ty; let P := fresh \"P\" in refine (forall (P : Pty), _ : Type); let H1 := fresh \"H1\" in transparent_assert H1 Type; [ mk_forall_tys L Type ltac:(fun l => let g_args := fresh in transparent_assert g_args Prop; [ mk_app g l Prop | simpl in g_args]; refine (Marker.group g_args -> P : Type) ) | simpl in H1]; let H2 := fresh \"H2\" in transparent_assert H2 Type; [ refine (Marker.end_defer _ : Type); mk_exists n ltac:(fun l => mk_app g l Prop) | simpl in H2]; exact (H1 -> H2 -> P) ) | simpl in G].",
            "VernacExtend",
            "f13d48161f95c2e6d461104f120e1030dfe6f182"
        ],
        [
            "Ltac mk_begin_defer_helper_Type ids G := let n := ids_nb ids in mk_begin_defer_helper_aux n G Type ltac:(fun n cont => mk_sigT_sig ids Type cont).",
            "VernacExtend",
            "1a942113f1c33a6441ce7c4ab4c0b754264dd826"
        ],
        [
            "Ltac mk_begin_defer_helper_Prop ids G := let n := ids_nb ids in mk_begin_defer_helper_aux n G Prop ltac:(fun n cont => mk_exists ids Prop cont).",
            "VernacExtend",
            "27f5aef827fae9fc10729ee34eac6ebe5a1cccf9"
        ],
        [
            "Ltac mk_begin_defer_helper ids := let H := fresh in match goal with |- ?G => match type of G with | Prop => mk_begin_defer_helper_Prop ids H | _ => mk_begin_defer_helper_Type ids H end; cut H; subst H; [| now prove_begin_defer_helper] end.",
            "VernacExtend",
            "a7485b52fa5dcb1d31e51418b5edfd027e8c39e1"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "mk_begin_defer_helper tt.",
            "VernacExtend",
            "c79717a7177df731bf36f690c96287df851584eb"
        ],
        [
            "intro H; eapply H; clear H.",
            "VernacExtend",
            "a334bb4646839b28e16e2573dab1fc51cf6184c1"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "mk_begin_defer_helper (fun a b c : unit => tt).",
            "VernacExtend",
            "a4f7b5e6fe3ee64cc1e2697fa924b56b7ec80107"
        ],
        [
            "intro H; eapply H; clear H.",
            "VernacExtend",
            "a334bb4646839b28e16e2573dab1fc51cf6184c1"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal nat.",
            "VernacDefinition",
            "a8db164c1059e8d4b06471138a9befc607a4915a"
        ],
        [
            "mk_begin_defer_helper (fun a b c : unit => tt).",
            "VernacExtend",
            "a4f7b5e6fe3ee64cc1e2697fa924b56b7ec80107"
        ],
        [
            "intro H; eapply H; clear H.",
            "VernacExtend",
            "a334bb4646839b28e16e2573dab1fc51cf6184c1"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Ltac prove_end_defer_helper := introsType; let P1 := fresh in let P2 := fresh in let H1 := fresh in let H2 := fresh in intros P1 P2 H1 H2; unfold Marker.end_defer in *; repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x); apply H1; auto.",
            "VernacExtend",
            "c26edfd0b3c25303c9b745b62ef0b36cd40177b9"
        ],
        [
            "Goal forall A (P1 P2 : A -> Prop), (forall a, P1 a -> P2 a) -> (exists a, P1 a) -> Marker.end_defer (exists a, P2 a).",
            "VernacDefinition",
            "5ed7007a49a2df98c1952904e673ddcbc6d0af7f"
        ],
        [
            "prove_end_defer_helper.",
            "VernacExtend",
            "5d13a09324a5d0382563a211707798f49d28f810"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).",
            "VernacDefinition",
            "14540f8852026bf7ee53bc178e40f47d5290ad38"
        ],
        [
            "prove_end_defer_helper.",
            "VernacExtend",
            "5d13a09324a5d0382563a211707798f49d28f810"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Goal forall A (P1 P2 : A -> Prop), (forall a, P1 a -> P2 a) -> { a | P1 a } -> Marker.end_defer { a | P2 a }.",
            "VernacDefinition",
            "68e5adcde7066fdfa03cf50a82c219921c05f9e8"
        ],
        [
            "prove_end_defer_helper.",
            "VernacExtend",
            "5d13a09324a5d0382563a211707798f49d28f810"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Ltac mk_end_defer_helper_aux n G mk_exists := transparent_assert G Type; [ mk_forall Type Type n ltac:(fun L => let P_ty := fresh \"P_ty\" in transparent_assert P_ty Type; [ mk_arrow L Type; exact Prop | simpl in P_ty ]; let P1 := fresh \"P1\" in let P2 := fresh \"P2\" in refine (forall (P1 P2 : P_ty), _ : Type); subst P_ty; let H1 := fresh \"H1\" in transparent_assert H1 Type; [ mk_forall_tys L Type ltac:(fun l => refine (_ -> _ : Type); [ mk_app P1 l Type | mk_app P2 l Type ] ) | simpl in H1 ]; refine (H1 -> _ -> Marker.end_defer _ : Type); [ mk_exists n ltac:(fun l => mk_app P1 l Prop) | mk_exists n ltac:(fun l => mk_app P2 l Prop) ] ) | simpl in G].",
            "VernacExtend",
            "cd712bc4abefe7000323aa60b960333263d56253"
        ],
        [
            "Ltac mk_end_defer_helper_Type ids G := let n := ids_nb ids in mk_end_defer_helper_aux n G ltac:(fun n cont => mk_sigT_sig ids Type cont).",
            "VernacExtend",
            "ce9632e6e66f0110a93fc1351154362ce1d128e6"
        ],
        [
            "Ltac mk_end_defer_helper_Prop ids G := let n := ids_nb ids in mk_end_defer_helper_aux n G ltac:(fun n cont => mk_exists ids Prop cont).",
            "VernacExtend",
            "b7c5ff99b81ed8b5ada23ef2d607851a565a7a19"
        ],
        [
            "Ltac mk_end_defer_helper ids := let H := fresh in match goal with |- Marker.end_defer ?G => match type of G with | Prop => mk_end_defer_helper_Prop ids H | _ => mk_end_defer_helper_Type ids H end; cut H; subst H; [| prove_end_defer_helper ] end.",
            "VernacExtend",
            "80bcfa73d7dc78bb50458f343af5e3c8d2482252"
        ],
        [
            "Goal Marker.end_defer nat.",
            "VernacDefinition",
            "418f0ce4d5f7e3ba9c5eeb31c6d3d8d3a78374cc"
        ],
        [
            "mk_end_defer_helper (fun x y z : unit => tt).",
            "VernacExtend",
            "75cb61d435d6721d2f2ec9d16aa96deee12eab52"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal Marker.end_defer True.",
            "VernacDefinition",
            "2fa8e19cc8bbef239be2d6630105f8ef3ba8c8e3"
        ],
        [
            "mk_end_defer_helper (fun x y z : unit => tt).",
            "VernacExtend",
            "75cb61d435d6721d2f2ec9d16aa96deee12eab52"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "End MkHelperLemmas.",
            "VernacEndSegment",
            "80a2d4b62e8fe95b48b4326ac535cef9a46d5e5d"
        ],
        [
            "Ltac specialize_helper_types H ids := MkHelperLemmas.iter_idents ids ltac:(fun _ => let e := fresh in evar (e : Type); specialize (H e); subst e ).",
            "VernacExtend",
            "092f2783ccb43b43b2a0fe02d0c86ee886db0831"
        ],
        [
            "Ltac mkrefine_group ids := lazymatch ids with | tt => uconstr:(_) | (fun x => _) => let ids' := eval cbv beta in (ids tt) in let ret := mkrefine_group ids' in uconstr:(fun x => ret) end.",
            "VernacExtend",
            "b18f73f2e1ce21a288935a006b469fede5266398"
        ],
        [
            "Ltac specialize_helper_group H ids := let group_uconstr := mkrefine_group ids in let g := fresh in refine (let g := group_uconstr in _); specialize (H g); subst g.",
            "VernacExtend",
            "e4d56be84f4c76a456afb40e53488c85685e8199"
        ],
        [
            "Ltac begin_defer_core g ids := MkHelperLemmas.mk_begin_defer_helper ids; let H := fresh in intro H; specialize_helper_types H ids; specialize_helper_group H ids; eapply H; clear H; [ MkHelperLemmas.iter_idents ids ltac:(fun x => intro x); intro g |].",
            "VernacExtend",
            "71d56ddeb9d6e8f4599eeb7eb3126e77c240453d"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" := let g := fresh \"g\" in begin_defer_core g tt.",
            "VernacExtend",
            "04bc2a7cc1a47dcdf7054dfe3ee2c9fffc70e4bf"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"in\" ident(g) := begin_defer_core g tt.",
            "VernacExtend",
            "c9f1c4689c9be21ae7bb2b92ba240ca88cd67a17"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) := let g := fresh \"g\" in begin_defer_core g (fun a : unit => tt).",
            "VernacExtend",
            "6f739f3ca7744f7bd238ec4f2f0d66d9282f3855"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) \"in\" ident(g) := begin_defer_core g (fun a : unit => tt).",
            "VernacExtend",
            "602f0750bccc6a89227600f66a8c55003e9091c4"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) := let g := fresh \"g\" in begin_defer_core g (fun a b : unit => tt).",
            "VernacExtend",
            "8b9f1410682f24551d8fa184a7086b05e48e2922"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) \"in\" ident(g) := begin_defer_core g (fun a b : unit => tt).",
            "VernacExtend",
            "031027ae604bf2d8b4e035176795e6b6ae39badd"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) ident(c) := let g := fresh \"g\" in begin_defer_core g (fun a b c : unit => tt).",
            "VernacExtend",
            "b25736cbbb3703004cde0f5dd82d5f05dfc2cba3"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) ident(c) \"in\" ident(g) := begin_defer_core g (fun a b c : unit => tt).",
            "VernacExtend",
            "50db987aaf9eea22d857f1125973b31b340d6935"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) ident(c) ident(d) := let g := fresh \"g\" in begin_defer_core g (fun a b c d : unit => tt).",
            "VernacExtend",
            "ee55c4c7e74c0ef07131be0e15ef2abcff55aea3"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) ident(c) ident(d) \"in\" ident(g) := begin_defer_core g (fun a b c d : unit => tt).",
            "VernacExtend",
            "c80731e3ab7d63044c14018f9cd70ca5c5c98396"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) ident(c) ident(d) ident(e) := let g := fresh \"g\" in begin_defer_core g (fun a b c d e : unit => tt).",
            "VernacExtend",
            "1045b313354017537f92269be5eba99d650befbc"
        ],
        [
            "Tactic Notation \"begin\" \"defer\" \"assuming\" ident(a) ident(b) ident(c) ident(d) ident(e) \"in\" ident(g) := begin_defer_core g (fun a b c d e : unit => tt).",
            "VernacExtend",
            "c793d4a26e82df34111855bafd644d92d40b67cc"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer assuming a b in foo.",
            "VernacExtend",
            "a91d82a01891d358bc5a6806ad5953c8141d9c89"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal nat.",
            "VernacDefinition",
            "a8db164c1059e8d4b06471138a9befc607a4915a"
        ],
        [
            "begin defer assuming a b in foo.",
            "VernacExtend",
            "a91d82a01891d358bc5a6806ad5953c8141d9c89"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Ltac defer_aux tm ty := let ty' := (eval hnf in ty) in lazymatch ty' with | and ?x ?y => defer_aux (@proj2 x y tm) y | _ => eapply (proj1 tm) end.",
            "VernacExtend",
            "ae1de63253794aa8eda27dafa7f66288babd55a0"
        ],
        [
            "Ltac defer_core group := let ty := type of group in match ty with | Marker.group ?G => defer_aux group G end.",
            "VernacExtend",
            "aceccb29078c143acae2e0c72f3d8107e1554045"
        ],
        [
            "Tactic Notation \"defer\" \"in\" ident(g) := defer_core g.",
            "VernacExtend",
            "aab027b3eab84341a81f31d3957ba94676344294"
        ],
        [
            "Tactic Notation \"defer\" := let g := Marker.find_group in defer in g.",
            "VernacExtend",
            "bd777ef3e1bb6f0c70315574ad15f70323ebd581"
        ],
        [
            "Tactic Notation \"defer\" simple_intropattern(H) \":\" uconstr(E) \"in\" ident(g) := assert E as H by defer_core g.",
            "VernacExtend",
            "c805b3442dc0ab39d4f18fab3a5c46174da23d65"
        ],
        [
            "Tactic Notation \"defer\" \":\" uconstr(E) \"in\" ident(g) := let H := fresh in defer H : E in g; revert H.",
            "VernacExtend",
            "82c5cdee2c2ea0e326105a42427c470253713895"
        ],
        [
            "Tactic Notation \"defer\" simple_intropattern(H) \":\" uconstr(E) := let g := Marker.find_group in defer H : E in g.",
            "VernacExtend",
            "d3b943d54ac646f4c5736c79d898fd651331afff"
        ],
        [
            "Tactic Notation \"defer\" \":\" uconstr(E) := let g := Marker.find_group in defer: E in g.",
            "VernacExtend",
            "d1bd2a4aff7c5e100179dcaaf9afb0b3b5023107"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer in foo.",
            "VernacExtend",
            "31da48297e60cb889e37b37b9f44d835fea0591f"
        ],
        [
            "begin defer in bar.",
            "VernacExtend",
            "17e113d68581b93df03190a28337cd9ee255d8e9"
        ],
        [
            "assert (1 = 1) by defer.",
            "VernacExtend",
            "1f25de88869d40ffe53651945cb17d91163aa5a7"
        ],
        [
            "defer HH: (2 = 2).",
            "VernacExtend",
            "ead1181e4379b51dfd3878e938777d28373d6522"
        ],
        [
            "defer: (3 = 3).",
            "VernacExtend",
            "f54852af5ad9b4de8968f4db3b0466e3ed4ecad3"
        ],
        [
            "intros ?.",
            "VernacExtend",
            "5788280a665e6aa2c91e15fef1a838ff418c63fe"
        ],
        [
            "defer _: (4 = 4) in foo.",
            "VernacExtend",
            "37ddfc2a5757330ad953ee093b319a6212b60d95"
        ],
        [
            "defer [E1 E2]: (5 = 5 /\\ 6 = 6) in foo.",
            "VernacExtend",
            "e5b82ba93e58f0a4c63bd7a2b692250a0af3f572"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Ltac deferred_exploit_aux tm ty tac := lazymatch ty with | and ?x ?y => try tac (@proj1 x y tm); tryif is_evar y then idtac else deferred_exploit_aux (@proj2 x y tm) y tac end.",
            "VernacExtend",
            "8344083e5f7d6e7dffba27a6d364b1ee73e2bc87"
        ],
        [
            "Ltac deferred_exploit_core g tac := let ty := type of g in match ty with | Marker.group ?G => progress (deferred_exploit_aux g G tac) end.",
            "VernacExtend",
            "cfc4d6fed4825b17be58d59ee9029594b4784a1c"
        ],
        [
            "Tactic Notation \"deferred\" \"exploit\" tactic(tac) \"in\" ident(g) := deferred_exploit_core g tac.",
            "VernacExtend",
            "09063004d8f49f28970194f6fe327b8e31a018fd"
        ],
        [
            "Tactic Notation \"deferred\" \"exploit\" tactic(tac) := let g := Marker.find_group in deferred exploit tac in g.",
            "VernacExtend",
            "0da90132090efe3a408628d58ace05eadf06d463"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer in foo.",
            "VernacExtend",
            "31da48297e60cb889e37b37b9f44d835fea0591f"
        ],
        [
            "defer ?: (1 + 1 = 2).",
            "VernacExtend",
            "e56aa9f19b3a69146d7bc50db7635668af64c2a8"
        ],
        [
            "defer L: (forall n, n + 0 = n).",
            "VernacExtend",
            "c11d0ca658e9f82690f7838275ce07bd50adf600"
        ],
        [
            "clear L.",
            "VernacExtend",
            "1f8ab355ea830152780958b4ee8fb6ebca5adb87"
        ],
        [
            "assert (3 + 0 = 3).",
            "VernacExtend",
            "2f12103c11a04643626f20d922c350de092972a7"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "deferred exploit (fun H => rewrite H).",
            "VernacExtend",
            "2ae3beb95dce0987b0c1af21a0953ca9522a3ac3"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Ltac deferred_core g := deferred exploit (fun H => generalize H) in g.",
            "VernacExtend",
            "923935bb6800a8373c67f6609d96ac10c0c9b98f"
        ],
        [
            "Tactic Notation \"deferred\" \"in\" ident(g) := deferred_core g.",
            "VernacExtend",
            "3d4ef39f2d5329cb78f75414f9f5ad8471713ca6"
        ],
        [
            "Tactic Notation \"deferred\" := let g := Marker.find_group in deferred in g.",
            "VernacExtend",
            "ebecb8f71d6c677d6574b079214bcc53f155d55a"
        ],
        [
            "Tactic Notation \"deferred\" simple_intropattern(H) \":\" uconstr(E) \"in\" ident(g) := assert E as H; [ deferred in g; try now auto |].",
            "VernacExtend",
            "1cd594dc30a159c1a1bd7a44892cf0df51354d01"
        ],
        [
            "Tactic Notation \"deferred\" \":\" uconstr(E) \"in\" ident(g) := let H := fresh in assert E as H; [ deferred in g; try now auto | revert H ].",
            "VernacExtend",
            "244af3273e2025868e0ca6b12e49aa139565bfcc"
        ],
        [
            "Tactic Notation \"deferred\" simple_intropattern(H) \":\" uconstr(E) := let g := Marker.find_group in deferred H : E in g.",
            "VernacExtend",
            "bd961d059ed19797d7147e916e3d600d0a7b53a8"
        ],
        [
            "Tactic Notation \"deferred\" \":\" uconstr(E) := let g := Marker.find_group in deferred : E in g.",
            "VernacExtend",
            "aac7de93b4aa61a5314e620f8e8c2d74b82d0113"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer.",
            "VernacExtend",
            "aa3c57a4ac613fa224b8e3906d3a7d8a7c34d938"
        ],
        [
            "defer _: (1 + 1 = 2).",
            "VernacExtend",
            "f3f267170b7712a70abc1ae9f8928cbb240df7a5"
        ],
        [
            "defer _: (1 + 2 = 3).",
            "VernacExtend",
            "154c93c0aa94a1a34037347e7440d5dd49096670"
        ],
        [
            "deferred.",
            "VernacExtend",
            "ea347aa7a602b22cc3a18cebe796465e4abf0193"
        ],
        [
            "intros _ _.",
            "VernacExtend",
            "95d87eaa905098932d683036fadece3b7ae69933"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer assuming n.",
            "VernacExtend",
            "d2368c830b8484056f12eec169dcedc374b6c5a2"
        ],
        [
            "defer _: (1+2=3).",
            "VernacExtend",
            "154c93c0aa94a1a34037347e7440d5dd49096670"
        ],
        [
            "defer _: (n + 1 = n).",
            "VernacExtend",
            "57890a88c6df1c62b5964e966b32e1fe4ad55f8b"
        ],
        [
            "deferred ?: (n = n + 1); [].",
            "VernacExtend",
            "8b54dd4a4ce379a35a55474e0532def91afa2997"
        ],
        [
            "deferred: (n + 2 = n).",
            "VernacExtend",
            "b901525244ab276fffca138b9387d1170729cd76"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "admit.",
            "VernacExtend",
            "6f3b875177c67c86e200aa57e88acfa851c78387"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "intros ?.",
            "VernacExtend",
            "5788280a665e6aa2c91e15fef1a838ff418c63fe"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Ltac introv_rec := lazymatch goal with | |- (?P -> ?Q) => idtac | |- (forall _, _) => intro; introv_rec | |- _ => idtac end.",
            "VernacExtend",
            "bd03782070ef289dee0b5fc3b081d3c8dfc75431"
        ],
        [
            "Ltac cleanup_conj_goal_aux tm ty := lazymatch ty with | and ?x ?y => tryif is_evar y then (split; [refine tm | exact I]) else (split; [refine (@proj1 x _ tm) | cleanup_conj_goal_aux uconstr:(@proj2 x _ tm) y]) end.",
            "VernacExtend",
            "96b8c65b0940445a0addfb2994592e029dcdcdaa"
        ],
        [
            "Ltac cleanup_conj_goal_core := let H_P_clean := fresh \"H_P_clean\" in intro H_P_clean; match goal with | |- ?P => cleanup_conj_goal_aux H_P_clean P end.",
            "VernacExtend",
            "de140aab66a884c6e468a70a12ee0ba8a168e97b"
        ],
        [
            "Ltac collect_exists_ids_loop G ids := lazymatch G with | (fun g => exists x, @?body g x) => collect_exists_ids_aux ids x body | (fun g => { x & @?body g x }) => collect_exists_ids_aux ids x body | (fun g => { x | @?body g x }) => collect_exists_ids_aux ids x body | _ => constr:(ids) end with collect_exists_ids_aux ids x body := let G' := constr:(fun (z : _ * _) => body (fst z) (snd z)) in let G' := eval cbn beta in G' in let ids' := collect_exists_ids_loop G' ids in constr:(fun (x : unit) => ids').",
            "VernacExtend",
            "38fe0eced3206c1e4139cf1eb4010e70fddece04"
        ],
        [
            "Ltac collect_exists_ids g := collect_exists_ids_loop (fun (_:unit) => g) tt.",
            "VernacExtend",
            "4a0d58f90d61e32583785191be0cc38f29aa10a1"
        ],
        [
            "Goal Marker.end_defer (exists a b c, a + b = c).",
            "VernacDefinition",
            "1dd2f6ab5e1c1470cd823678c4cb2a238a5fe6e5"
        ],
        [
            "match goal with |- Marker.end_defer ?g => let ids := collect_exists_ids g in idtac end.",
            "VernacExtend",
            "0c6854a880e2c3a50afe73b9f77a66353993cf72"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal Marker.end_defer { a & { b & { c | a + b = c } } }.",
            "VernacDefinition",
            "f015413295b62ae1550136bfa7b2f3d627b9a5a0"
        ],
        [
            "match goal with |- Marker.end_defer ?g => let ids := collect_exists_ids g in idtac end.",
            "VernacExtend",
            "0c6854a880e2c3a50afe73b9f77a66353993cf72"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Ltac end_defer_core := match goal with |- Marker.end_defer ?g => let ids := collect_exists_ids g in MkHelperLemmas.mk_end_defer_helper ids; let H := fresh in intro H; eapply H; clear H; [ introv_rec; cleanup_conj_goal_core | hnf ] end.",
            "VernacExtend",
            "0b048efd5494a8a95b802e86dd55bf20667dbae8"
        ],
        [
            "Tactic Notation \"end\" \"defer\" := end_defer_core.",
            "VernacExtend",
            "b7941cfeec32adcbd5256b33226aab6eb7b24e8d"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer in g.",
            "VernacExtend",
            "ef598c3ecb4dda46d68315cfe1fd4cbd0c7040f8"
        ],
        [
            "defer H1: (1 + 1 = 2).",
            "VernacExtend",
            "b1c66a4e5d7ae4c73b584fff81d10b41542c7269"
        ],
        [
            "defer H2: (1 + 2 = 3).",
            "VernacExtend",
            "8c6f149d34dc30951fd1035af88e482449f9bf8a"
        ],
        [
            "defer H3: (1 + 3 = 4) in g.",
            "VernacExtend",
            "803545d9c74f2d8c2c1313e711df27a5536e6616"
        ],
        [
            "tauto.",
            "VernacExtend",
            "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
        ],
        [
            "end defer.",
            "VernacExtend",
            "8c50de2defa520a24b671cbdebe670e21da440bf"
        ],
        [
            "do 3 split.",
            "VernacExtend",
            "14ed1b9b4bedaccf911e3814cb4dd88ecf947734"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Goal True.",
            "VernacDefinition",
            "00b78715f0a21d5c05d8f28b6770aa926fac466a"
        ],
        [
            "begin defer assuming a b c.",
            "VernacExtend",
            "b576128187b2eeda573f595b2780213871bb73d5"
        ],
        [
            "assert (a + b = c).",
            "VernacExtend",
            "1f72d6fbd3fb83f7f22defb3f87e83eb5481f676"
        ],
        [
            "defer.",
            "VernacExtend",
            "7907c35d9ea839575993bef9b488b4a3ccfc2395"
        ],
        [
            "exact I.",
            "VernacExtend",
            "2cf10cb6670c94bac111ace6912ec2b66fc73c6f"
        ],
        [
            "end defer.",
            "VernacExtend",
            "8c50de2defa520a24b671cbdebe670e21da440bf"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal nat.",
            "VernacDefinition",
            "a8db164c1059e8d4b06471138a9befc607a4915a"
        ],
        [
            "begin defer assuming a b c.",
            "VernacExtend",
            "b576128187b2eeda573f595b2780213871bb73d5"
        ],
        [
            "assert (a + b = c).",
            "VernacExtend",
            "1f72d6fbd3fb83f7f22defb3f87e83eb5481f676"
        ],
        [
            "defer.",
            "VernacExtend",
            "7907c35d9ea839575993bef9b488b4a3ccfc2395"
        ],
        [
            "exact 0.",
            "VernacExtend",
            "ab9e9776a5bdafc743eca95f05b0af8a902d385d"
        ],
        [
            "end defer.",
            "VernacExtend",
            "8c50de2defa520a24b671cbdebe670e21da440bf"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Goal 1= 2 /\\ 2=3.",
            "VernacDefinition",
            "f8e3dafc9703e22b44bc0098ffbee4b0d12249cf"
        ],
        [
            "begin defer.",
            "VernacExtend",
            "aa3c57a4ac613fa224b8e3906d3a7d8a7c34d938"
        ],
        [
            "defer.",
            "VernacExtend",
            "7907c35d9ea839575993bef9b488b4a3ccfc2395"
        ],
        [
            "end defer.",
            "VernacExtend",
            "8c50de2defa520a24b671cbdebe670e21da440bf"
        ],
        [
            "Abort.",
            "VernacAbort",
            "c7c176802253f03c8ef9f27e1c3c9d26e4650d85"
        ],
        [
            "Notation \"'end' 'defer'\" := (Marker.end_defer _) (at level 0).",
            "VernacNotation",
            "c3c24a11234f2adb3a02a902c542b75754f12ddc"
        ],
        [
            "Notation \"'Group' P\" := (Marker.group P) (at level 0).",
            "VernacNotation",
            "9cece9762ad029e6f6c32f815f59a40ff7e63d7f"
        ]
    ],
    "proofs": [
        {
            "name": "group_fold",
            "line_nb": 3,
            "steps": [
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm",
            "line_nb": 24,
            "steps": [
                {
                    "command": [
                        "prove_begin_defer_helper.",
                        "VernacExtend",
                        "477375f22c4aebea0b8549a6ec277851bb843c88"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm0",
            "line_nb": 27,
            "steps": [
                {
                    "command": [
                        "prove_begin_defer_helper.",
                        "VernacExtend",
                        "477375f22c4aebea0b8549a6ec277851bb843c88"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm1",
            "line_nb": 30,
            "steps": [
                {
                    "command": [
                        "prove_begin_defer_helper.",
                        "VernacExtend",
                        "477375f22c4aebea0b8549a6ec277851bb843c88"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm2",
            "line_nb": 33,
            "steps": [
                {
                    "command": [
                        "prove_begin_defer_helper.",
                        "VernacExtend",
                        "477375f22c4aebea0b8549a6ec277851bb843c88"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm3",
            "line_nb": 53,
            "steps": [
                {
                    "command": [
                        "prove_end_defer_helper.",
                        "VernacExtend",
                        "5d13a09324a5d0382563a211707798f49d28f810"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm4",
            "line_nb": 56,
            "steps": [
                {
                    "command": [
                        "prove_end_defer_helper.",
                        "VernacExtend",
                        "5d13a09324a5d0382563a211707798f49d28f810"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Unnamed_thm5",
            "line_nb": 59,
            "steps": [
                {
                    "command": [
                        "prove_end_defer_helper.",
                        "VernacExtend",
                        "5d13a09324a5d0382563a211707798f49d28f810"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}