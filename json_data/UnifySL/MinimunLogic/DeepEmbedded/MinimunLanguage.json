{
    "filename": "MinimunLogic/DeepEmbedded/MinimunLanguage.v",
    "coq_project": "UnifySL",
    "vernac_cmds": [
        [
            "Require Import Coq.Logic.ProofIrrelevance.",
            "VernacRequire",
            "830bd67b83ecfa87e763e0503e058c6181d73cd1"
        ],
        [
            "Require Import Coq.omega.Omega.",
            "VernacRequire",
            "c22118512de22ca1f471830b29716d6337180b58"
        ],
        [
            "Require Import Logic.lib.Bijection.",
            "VernacRequire",
            "7bb59803be65e1b0331aebf5a5e54fdb046de426"
        ],
        [
            "Require Import Logic.lib.Countable.",
            "VernacRequire",
            "0e6db58557f71a0dcd04cbe972aeb1392ac877d1"
        ],
        [
            "Require Import Logic.GeneralLogic.Base.",
            "VernacRequire",
            "070e14a34b6bbb533eb71ad7d5a289e752dd93e4"
        ],
        [
            "Require Import Logic.MinimunLogic.Syntax.",
            "VernacRequire",
            "1fe3f501db6a35e0c279335c26da5e64e6b0b57b"
        ],
        [
            "Local Open Scope logic_base.",
            "VernacOpenCloseScope",
            "5c8594c0dfdcdf011d6f504e216bb05a6ae4277a"
        ],
        [
            "Local Open Scope syntax.",
            "VernacOpenCloseScope",
            "b783c96de8f41f381acfa7d6f61aaee81388d5d7"
        ],
        [
            "Inductive expr {Var: Type}: Type := | impp : expr -> expr -> expr | varp : Var -> expr.",
            "VernacInductive",
            "192e3def23afa498a5c163ed946bd6ee9ed3020b"
        ],
        [
            "Arguments expr Var: clear implicits.",
            "VernacArguments",
            "dc840d4abeff12dbabac873f8c224050bda78c7e"
        ],
        [
            "Instance L (Var: Type): Language := Build_Language (expr Var).",
            "VernacInstance",
            "da25535b2e0428003b1aca8bd77a3e886ad882d1"
        ],
        [
            "Instance minL (Var: Type): MinimunLanguage (L Var) := Build_MinimunLanguage (L Var) impp.",
            "VernacInstance",
            "4e8d12fc4c74b940423063474aadb48ca9ff4f5e"
        ],
        [
            "Definition rank {Var: Type}: expr Var -> nat := fix rank (x: expr Var): nat := match x with | impp y z => 1 + rank y + rank z | varp p => 0 end.",
            "VernacDefinition",
            "e82c59e708a078d119b3f99336ccc8372e17a647"
        ],
        [
            "Definition formula_countable: forall Var, Countable Var -> Countable (expr Var).",
            "VernacDefinition",
            "e17d0e3847c547d457d1028f7345a1a98fc25af6"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "assert (forall n, Countable (sig (fun x: expr Var => rank x <= n))).",
            "VernacExtend",
            "1ca4205a2e81a5d09e04e67e2ebd437e3242d3c9"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "induction n.",
            "VernacExtend",
            "7f3faa2a3277e3553406d09101130efcb1764494"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "apply (@bijection_Countable _ Var); [| solve_Countable].",
            "VernacExtend",
            "3b0d748be7bd15b8d2de92f7183f5eca0e30b833"
        ],
        [
            "apply bijection_sym.",
            "VernacExtend",
            "271e6010b1376f0171b44a40450c33fef8d362d8"
        ],
        [
            "apply (FBuild_bijection _ _ (fun p => exist (fun x: expr Var => rank x <= 0) (varp p) (le_n 0))).",
            "VernacExtend",
            "941020aee3645a06489e5d246633cd2f20268d50"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "hnf; intros.",
            "VernacExtend",
            "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
        ],
        [
            "inversion H; auto.",
            "VernacExtend",
            "ca70ce9532e796fd752cb12d4d270e557a16bc8a"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "hnf; intros.",
            "VernacExtend",
            "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
        ],
        [
            "destruct b as [[] HH]; try solve [inversion HH].",
            "VernacExtend",
            "55c1c86b53408fff2c33f5ee46f30315594f8541"
        ],
        [
            "exists v.",
            "VernacExtend",
            "07e9a3324bfa0e7b5dc708d0101cf063e8084497"
        ],
        [
            "eauto; f_equal; apply proof_irrelevance.",
            "VernacExtend",
            "ec76da4d6f18ff1a8132ed1928036b5cebc895d6"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "set (s := sig (fun x: expr Var => rank x <= n)).",
            "VernacExtend",
            "945b5eaf7cb9d048aa29eabeeab3dac00d2f53ca"
        ],
        [
            "apply (@injection_Countable _ (s * s + Var)%type); [| solve_Countable].",
            "VernacExtend",
            "f801cd69fc38fda9e21b54aaaa13f6c1d8945802"
        ],
        [
            "apply (Build_injection _ _ (fun x y => match y with | inl (exist _ y _, exist _ z _) => proj1_sig x = impp y z | inr p => proj1_sig x = varp p end)).",
            "VernacExtend",
            "1ab8d4c010937cb81557a8ae0eff322d773260af"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "hnf; intros.",
            "VernacExtend",
            "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
        ],
        [
            "destruct a as [[y z | p] ?H].",
            "VernacExtend",
            "4b9929573788bb8c6037aab6d940bfb0eaa8cfb9"
        ],
        [
            "simpl in H.",
            "VernacExtend",
            "78dad51b2bb1130f71851d1e55489020824f59f6"
        ],
        [
            "assert (rank y <= n) by omega.",
            "VernacExtend",
            "6827e2c6f1c6a7d1918bc79ade17859944898c17"
        ],
        [
            "assert (rank z <= n) by omega.",
            "VernacExtend",
            "df2e334dd6be89a893a32ec9eb1626b6ea9ab3ad"
        ],
        [
            "exists (inl (exist _ y H0, exist _ z H1)); auto.",
            "VernacExtend",
            "0e66a873c80f263d47e37f86fd2123759a33dcab"
        ],
        [
            "exists (inr p); auto.",
            "VernacExtend",
            "4b06ef24d7a6e2711cbd75675243aca6e8720e07"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "hnf; intros.",
            "VernacExtend",
            "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
        ],
        [
            "destruct a as [[y z | p] ?H]; destruct b1 as [[[y1 ?H] [z1 ?H]] | p1]; try solve [inversion H]; destruct b2 as [[[y2 ?H] [z2 ?H]] | p2]; try solve [inversion H0].",
            "VernacExtend",
            "ba32ca3e5e7d91b9f22e2e100bba9a10c0c16376"
        ],
        [
            "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
            "VernacExtend",
            "80ffffd82f902a7b329c7fade798d523651de3f8"
        ],
        [
            "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
            "VernacExtend",
            "80ffffd82f902a7b329c7fade798d523651de3f8"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "hnf; intros.",
            "VernacExtend",
            "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
        ],
        [
            "destruct b as [[[y ?H] [z ?H]] | p]; destruct a1 as [[y1 z1 | p1] ?H]; try solve [inversion H]; destruct a2 as [[y2 z2 | p2] ?H]; try solve [inversion H0].",
            "VernacExtend",
            "1867da9d4cca24a1e9b40c0e822ab7bcd8ed5889"
        ],
        [
            "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
            "VernacExtend",
            "80ffffd82f902a7b329c7fade798d523651de3f8"
        ],
        [
            "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
            "VernacExtend",
            "80ffffd82f902a7b329c7fade798d523651de3f8"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "apply (@injection_Countable _ (sigT (fun n => sig (fun x: expr Var => rank x <= n)))); [| solve_Countable; auto].",
            "VernacExtend",
            "13f798cee542f4b15a2ec8e47b845c2673847fa6"
        ],
        [
            "apply (FBuild_injection _ _ (fun x0 => existT (fun n => sig (fun x => rank x <= n)) (rank x0) (exist (fun x => rank x <= rank x0) x0 (le_n (rank x0))))).",
            "VernacExtend",
            "d6de867f1eac0666ab9e9756b99400a83dd831c2"
        ],
        [
            "hnf; intros.",
            "VernacExtend",
            "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
        ],
        [
            "simpl in H.",
            "VernacExtend",
            "78dad51b2bb1130f71851d1e55489020824f59f6"
        ],
        [
            "inversion H; auto.",
            "VernacExtend",
            "ca70ce9532e796fd752cb12d4d270e557a16bc8a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ]
    ],
    "proofs": [
        {
            "name": "formula_countable",
            "line_nb": 13,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "assert (forall n, Countable (sig (fun x: expr Var => rank x <= n))).",
                        "VernacExtend",
                        "1ca4205a2e81a5d09e04e67e2ebd437e3242d3c9"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "induction n.",
                        "VernacExtend",
                        "7f3faa2a3277e3553406d09101130efcb1764494"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "apply (@bijection_Countable _ Var); [| solve_Countable].",
                        "VernacExtend",
                        "3b0d748be7bd15b8d2de92f7183f5eca0e30b833"
                    ]
                },
                {
                    "command": [
                        "apply bijection_sym.",
                        "VernacExtend",
                        "271e6010b1376f0171b44a40450c33fef8d362d8"
                    ]
                },
                {
                    "command": [
                        "apply (FBuild_bijection _ _ (fun p => exist (fun x: expr Var => rank x <= 0) (varp p) (le_n 0))).",
                        "VernacExtend",
                        "941020aee3645a06489e5d246633cd2f20268d50"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "hnf; intros.",
                        "VernacExtend",
                        "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
                    ]
                },
                {
                    "command": [
                        "inversion H; auto.",
                        "VernacExtend",
                        "ca70ce9532e796fd752cb12d4d270e557a16bc8a"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "hnf; intros.",
                        "VernacExtend",
                        "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
                    ]
                },
                {
                    "command": [
                        "destruct b as [[] HH]; try solve [inversion HH].",
                        "VernacExtend",
                        "55c1c86b53408fff2c33f5ee46f30315594f8541"
                    ]
                },
                {
                    "command": [
                        "exists v.",
                        "VernacExtend",
                        "07e9a3324bfa0e7b5dc708d0101cf063e8084497"
                    ]
                },
                {
                    "command": [
                        "eauto; f_equal; apply proof_irrelevance.",
                        "VernacExtend",
                        "ec76da4d6f18ff1a8132ed1928036b5cebc895d6"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "set (s := sig (fun x: expr Var => rank x <= n)).",
                        "VernacExtend",
                        "945b5eaf7cb9d048aa29eabeeab3dac00d2f53ca"
                    ]
                },
                {
                    "command": [
                        "apply (@injection_Countable _ (s * s + Var)%type); [| solve_Countable].",
                        "VernacExtend",
                        "f801cd69fc38fda9e21b54aaaa13f6c1d8945802"
                    ]
                },
                {
                    "command": [
                        "apply (Build_injection _ _ (fun x y => match y with | inl (exist _ y _, exist _ z _) => proj1_sig x = impp y z | inr p => proj1_sig x = varp p end)).",
                        "VernacExtend",
                        "1ab8d4c010937cb81557a8ae0eff322d773260af"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "hnf; intros.",
                        "VernacExtend",
                        "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
                    ]
                },
                {
                    "command": [
                        "destruct a as [[y z | p] ?H].",
                        "VernacExtend",
                        "4b9929573788bb8c6037aab6d940bfb0eaa8cfb9"
                    ]
                },
                {
                    "command": [
                        "simpl in H.",
                        "VernacExtend",
                        "78dad51b2bb1130f71851d1e55489020824f59f6"
                    ]
                },
                {
                    "command": [
                        "assert (rank y <= n) by omega.",
                        "VernacExtend",
                        "6827e2c6f1c6a7d1918bc79ade17859944898c17"
                    ]
                },
                {
                    "command": [
                        "assert (rank z <= n) by omega.",
                        "VernacExtend",
                        "df2e334dd6be89a893a32ec9eb1626b6ea9ab3ad"
                    ]
                },
                {
                    "command": [
                        "exists (inl (exist _ y H0, exist _ z H1)); auto.",
                        "VernacExtend",
                        "0e66a873c80f263d47e37f86fd2123759a33dcab"
                    ]
                },
                {
                    "command": [
                        "exists (inr p); auto.",
                        "VernacExtend",
                        "4b06ef24d7a6e2711cbd75675243aca6e8720e07"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "hnf; intros.",
                        "VernacExtend",
                        "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
                    ]
                },
                {
                    "command": [
                        "destruct a as [[y z | p] ?H]; destruct b1 as [[[y1 ?H] [z1 ?H]] | p1]; try solve [inversion H]; destruct b2 as [[[y2 ?H] [z2 ?H]] | p2]; try solve [inversion H0].",
                        "VernacExtend",
                        "ba32ca3e5e7d91b9f22e2e100bba9a10c0c16376"
                    ]
                },
                {
                    "command": [
                        "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
                        "VernacExtend",
                        "80ffffd82f902a7b329c7fade798d523651de3f8"
                    ]
                },
                {
                    "command": [
                        "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
                        "VernacExtend",
                        "80ffffd82f902a7b329c7fade798d523651de3f8"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "hnf; intros.",
                        "VernacExtend",
                        "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
                    ]
                },
                {
                    "command": [
                        "destruct b as [[[y ?H] [z ?H]] | p]; destruct a1 as [[y1 z1 | p1] ?H]; try solve [inversion H]; destruct a2 as [[y2 z2 | p2] ?H]; try solve [inversion H0].",
                        "VernacExtend",
                        "1867da9d4cca24a1e9b40c0e822ab7bcd8ed5889"
                    ]
                },
                {
                    "command": [
                        "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
                        "VernacExtend",
                        "80ffffd82f902a7b329c7fade798d523651de3f8"
                    ]
                },
                {
                    "command": [
                        "inversion H; inversion H0; subst; subst; repeat f_equal; apply proof_irrelevance.",
                        "VernacExtend",
                        "80ffffd82f902a7b329c7fade798d523651de3f8"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "apply (@injection_Countable _ (sigT (fun n => sig (fun x: expr Var => rank x <= n)))); [| solve_Countable; auto].",
                        "VernacExtend",
                        "13f798cee542f4b15a2ec8e47b845c2673847fa6"
                    ]
                },
                {
                    "command": [
                        "apply (FBuild_injection _ _ (fun x0 => existT (fun n => sig (fun x => rank x <= n)) (rank x0) (exist (fun x => rank x <= rank x0) x0 (le_n (rank x0))))).",
                        "VernacExtend",
                        "d6de867f1eac0666ab9e9756b99400a83dd831c2"
                    ]
                },
                {
                    "command": [
                        "hnf; intros.",
                        "VernacExtend",
                        "56afb10662f39d6d1fe2d1fcd1dc59f4012137ee"
                    ]
                },
                {
                    "command": [
                        "simpl in H.",
                        "VernacExtend",
                        "78dad51b2bb1130f71851d1e55489020824f59f6"
                    ]
                },
                {
                    "command": [
                        "inversion H; auto.",
                        "VernacExtend",
                        "ca70ce9532e796fd752cb12d4d270e557a16bc8a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}