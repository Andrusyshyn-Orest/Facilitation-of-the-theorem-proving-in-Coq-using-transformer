{
    "filename": "ZSignTac.v",
    "coq_project": "PolTac",
    "vernac_cmds": [
        [
            "Require Import Reals.",
            "VernacRequire",
            "45681fd6487015ca7aa8c8e9b408e40e3103ca14"
        ],
        [
            "Require Import RPolS.",
            "VernacRequire",
            "4cf6096b490ea846fdeeeae2e604cb6e1418dfbb"
        ],
        [
            "Require Import PolAux.",
            "VernacRequire",
            "9b9e2fa92deba4432d2265611dee64240404bc3a"
        ],
        [
            "Require Import List.",
            "VernacRequire",
            "d9bcce4a390afeb160107bf87c6f7abe3d82c6d6"
        ],
        [
            "Definition Zsign_type := fun (x y:list Z) => Prop.",
            "VernacDefinition",
            "adfc23882922f82fef06eee6b9c439eb36875ca6"
        ],
        [
            "Definition Zsign_cons : forall x y, (Zsign_type x y) := fun x y => True.",
            "VernacDefinition",
            "7c8d0ebadeba140320a82ee04374937e4c448945"
        ],
        [
            "Ltac Zsign_push term1 term2 := generalize (Zsign_cons term1 term2); intro.",
            "VernacExtend",
            "f73c6863b0dc1d63c4bb51e3e7584d9d08f85aa4"
        ],
        [
            "Ltac Zsign_le term := match term with (?X1 * ?X2)%Z => Zsign_le X1; match goal with H1: (Zsign_type ?s1 ?s2) |- _ => Zsign_le X2; match goal with H2: (Zsign_type ?s3 ?s4) |- _ => clear H1 H2; let s5 := eval unfold List.app in (s1++s3) in let s6 := eval unfold List.app in (s2++s4) in Zsign_push s5 s6 end end | _ => let H1 := fresh \"H\" in (((assert (H1: (0 <= term)%Z); [auto with zarith; fail | idtac]) || (assert (H1: (term <= 0)%Z); [auto with zarith; fail | idtac])); clear H1; Zsign_push (term::nil) (@nil Z)) || Zsign_push (@nil Z) (term::nil) end.",
            "VernacExtend",
            "34958153ddbb78fde221a344dc42d1b1c68396f4"
        ],
        [
            "Ltac Zsign_lt term := match term with (?X1 * ?X2)%Z => Zsign_lt X1; match goal with H1: (Zsign_type ?s1 ?s2) |- _ => Zsign_lt X2; match goal with H2: (Zsign_type ?s3 ?s4) |- _ => clear H1 H2; let s5 := eval unfold List.app in (s1++s3) in let s6 := eval unfold List.app in (s2++s4) in Zsign_push s5 s6 end end | _ => let H1 := fresh \"H\" in (((assert (H1: (0 < term)%Z); [auto with zarith; fail | idtac]) || (assert (H1: (term < 0)%Z); [auto with zarith; fail | idtac])); clear H1; Zsign_push (term::nil) (@nil Z)) || Zsign_push (@nil Z) (term::nil) end.",
            "VernacExtend",
            "72bf7cdaca0fc9f6377efdde6eb8c50dd2b0f636"
        ],
        [
            "Ltac Zsign_top0 := match goal with |- (0 <= ?X1)%Z => Zsign_le X1 | |- (?X1 <= 0)%Z => Zsign_le X1 | |- (0 < ?X1)%Z => Zsign_lt X1 | |- (?X1 < 0)%Z => Zsign_le X1 | |- (0 >= ?X1)%Z => Zsign_le X1 | |- (?X1 >= 0)%Z => Zsign_le X1 | |- (0 > ?X1 )%Z => Zsign_lt X1 | |- (?X1 > 0)%Z => Zsign_le X1 end.",
            "VernacExtend",
            "8f6f6cbbb8627b372dc3a4da1fa0e0ffca3636bf"
        ],
        [
            "Ltac Zsign_top := match goal with | |- (?X1 * _ <= ?X1 * _)%Z => Zsign_le X1 | |- (?X1 * _ < ?X1 * _)%Z => Zsign_le X1 | |- (?X1 * _ >= ?X1 * _)%Z => Zsign_le X1 | |- (?X1 * _ > ?X1 * _)%Z => Zsign_le X1 end.",
            "VernacExtend",
            "324d584c40438c404878f7820e0fcb04e365d968"
        ],
        [
            "Ltac Zhyp_sign_top0 H:= match type of H with (0 <= ?X1)%Z => Zsign_lt X1 | (?X1 <= 0)%Z => Zsign_lt X1 | (0 < ?X1)%Z => Zsign_lt X1 | (?X1 < 0)%Z => Zsign_lt X1 | (0 >= ?X1)%Z => Zsign_lt X1 | (?X1 >= 0)%Z => Zsign_lt X1 | (0 > ?X1 )%Z => Zsign_lt X1 | (?X1 > 0)%Z => Zsign_lt X1 end.",
            "VernacExtend",
            "dc456c71e70ff3e99edbaf265363279feb8078e1"
        ],
        [
            "Ltac Zhyp_sign_top H := match type of H with | (?X1 * _ <= ?X1 * _)%Z => Zsign_lt X1 | (?X1 * _ < ?X1 * _)%Z => Zsign_lt X1 | (?X1 * _ >= ?X1 * _)%Z => Zsign_lt X1 | (?X1 * _ > ?X1 * _)%Z => Zsign_lt X1 | ?X1 => generalize H end.",
            "VernacExtend",
            "4d914787fc094ef7b06dfed5d019cfe0e9c9faf2"
        ],
        [
            "Ltac Zsign_get_term g := match g with (0 <= ?X1)%Z => X1 | (?X1 <= 0)%Z => X1 | (?X1 * _ <= ?X1 * _)%Z => X1 | (0 < ?X1)%Z => X1 | (?X1 < 0)%Z => X1 | (?X1 * _ < ?X1 * _)%Z => X1 | (0 >= ?X1)%Z => X1 | (?X1 >= 0)%Z => X1 | (?X1 * _ >= ?X1 * _)%Z => X1 | (?X1 * _ >= _)%Z => X1 | (0 > ?X1)%Z => X1 | (?X1 > 0)%Z => X1 | (?X1 * _ > ?X1 * _)%Z => X1 end.",
            "VernacExtend",
            "3a8f0849a99b3bf70db08c422cf555550d1002ec"
        ],
        [
            "Ltac Zsign_get_left g := match g with | (_ * ?X1 <= _)%Z => X1 | (_ * ?X1 < _)%Z => X1 | (_ * ?X1 >= _)%Z => X1 | (_ * ?X1 > _)%Z => X1 end.",
            "VernacExtend",
            "f5d7eff5715bf09b98806af4accc2cbca216c84b"
        ],
        [
            "Ltac Zsign_get_right g := match g with | (_ <= _ * ?X1)%Z => X1 | (_ < _ * ?X1)%Z => X1 | (_ >= _ * ?X1)%Z => X1 | (_ > _ * ?X1)%Z => X1 end.",
            "VernacExtend",
            "41dce0581f957de58c82c42efae61dabed7e7ff7"
        ],
        [
            "Fixpoint mkZprodt (l: list Z)(t:Z) {struct l}: Z := match l with nil => t | e::l1 => (e * mkZprodt l1 t)%Z end.",
            "VernacFixpoint",
            "a207a01628f313045664fb1346441418f67b71fe"
        ],
        [
            "Fixpoint mkZprod (l: list Z) : Z := match l with nil => 1%Z | e::nil => e | e::l1 => (e * mkZprod l1)%Z end.",
            "VernacFixpoint",
            "ac7ef0850460546f9b58d31b9644572ef0931de6"
        ],
        [
            "Ltac zsign_tac_aux0 := match goal with |- (0 <= ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zle_sign_pos_pos) || (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zle_sign_neg_neg); try zsign_tac_aux0; clear H1) | |- (?X1 * ?X2 <= 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zle_sign_pos_neg) || (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zle_sign_neg_pos); try zsign_tac_aux0; clear H1) | |- (0 < ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; apply Zlt_sign_pos_pos) || (assert (H1: (X1 < 0)%Z); auto with zarith; apply Zlt_sign_neg_neg); try zsign_tac_aux0; clear H1) | |- (?X1 * ?X2 < 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; apply Zlt_sign_pos_neg) || (assert (H1: (X1 < 0)%Z); auto with zarith; apply Zlt_sign_neg_pos); try zsign_tac_aux0; clear H1) | |- (?X1 * ?X2 >= 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 >= X1)%Z); auto with zarith; apply Zge_sign_neg_neg) || (assert (H1: (X1 >= 0)%Z); auto with zarith; apply Zge_sign_pos_pos); try zsign_tac_aux0; clear H1) | |- (0 >= ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (X1 >= 0)%Z); auto with zarith; apply Zge_sign_pos_neg) || (assert (H1: (0 >= X1)%Z); auto with zarith; apply Zge_sign_neg_pos); try zsign_tac_aux0; clear H1) | |- (0 > ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 > X1)%Z); auto with zarith; apply Zgt_sign_neg_pos) || (assert (H1: (X1 > 0)%Z); auto with zarith; apply Zgt_sign_pos_neg); try zsign_tac_aux0; clear H1) | |- (?X1 * ?X2 > 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 > X1)%Z); auto with zarith; apply Zgt_sign_neg_neg) || (assert (H1: (X1 > 0)%Z); auto with zarith; apply Zgt_sign_pos_pos); try zsign_tac_aux0; clear H1) | _ => auto with zarith; fail 1 \"zsign_tac_aux\" end.",
            "VernacExtend",
            "3b032d8608f952120a296e15d58fa3a5890ed9fe"
        ],
        [
            "Ltac zsign_tac0 := Zsign_top0; match goal with H1: (Zsign_type ?s1 ?s2) |- ?g => clear H1; let s := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (mkZprod s2)) in let t := Zsign_get_term g in replace t with s; [try zsign_tac_aux0 | try ring]; auto with zarith end.",
            "VernacExtend",
            "e6931cd8d4caa7b6966bf42ae137562e30ad1762"
        ],
        [
            "Ltac hyp_zsign_tac_aux0 H := match type of H with (0 <= ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zle_sign_pos_pos_rev _ _ H1 H) || (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zle_sign_neg_neg_rev _ _ H1 H))); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (?X1 * ?X2 <= 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zle_sign_pos_neg_rev _ _ H1 H)) || (assert (H1: (X1 <= 0)%Z); auto with zarith; generalize (Zle_sign_neg_pos_rev _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (0 < ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zlt_sign_pos_pos_rev _ _ H1 H)) || (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zlt_sign_neg_neg_rev _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (?X1 * ?X2 < 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zlt_sign_pos_neg_rev _ _ H1 H)) || (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zlt_sign_neg_pos_rev _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (?X1 * ?X2 >= 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 >X1)%Z); auto with zarith; generalize (Zge_sign_neg_neg_rev _ _ H1 H)) || (assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zge_sign_pos_pos _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (0 >= ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zge_sign_pos_neg _ _ H1 H)) || (assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zge_sign_neg_pos _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (0 > ?X1 * ?X2)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zgt_sign_neg_pos _ _ H1 H)) || (assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zgt_sign_pos_neg _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | (?X1 * ?X2 > 0)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zgt_sign_neg_neg _ _ H1 H)) || (assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zgt_sign_pos_pos _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux0 H; clear H1) | _ => auto with zarith; fail 1 \"hyp_zsign_tac_aux0\" end.",
            "VernacExtend",
            "2a225bfa5887b0434fdbd66c1d3d17cbbff50984"
        ],
        [
            "Ltac hyp_zsign_tac0 H := Zhyp_sign_top0 H; match goal with H1: (Zsign_type ?s1 ?s2) |- ?g => clear H1; let s := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (mkZprod s2)) in let t := Zsign_get_term g in replace t with s in H; [try hyp_zsign_tac_aux0 H | try ring]; auto with zarith end.",
            "VernacExtend",
            "80a548a953c7621798e4ab7db1fb6f9df9e72cf8"
        ],
        [
            "Ltac zsign_tac_aux := match goal with | |- (?X1 * ?X2 <= ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zmult_le_compat_l) || (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zmult_le_neg_compat_l); try zsign_tac_aux; clear H1) | |- (?X1 * ?X2 < ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zmult_lt_compat_l) || (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zmult_lt_neg_compat_l); try zsign_tac_aux; clear H1) | |- (?X1 * ?X2 >= ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (X1 >= 0)%Z); auto with zarith; apply Zmult_ge_compat_l) || (assert (H1: (0 >= X1)%Z); auto with zarith; apply Zmult_ge_neg_compat_l); try zsign_tac_aux; clear H1) | |- (?X1 * ?X2 > ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 <= X1)%Z); auto with zarith; apply Zmult_lt_compat_l) || (assert (H1: (X1 <= 0)%Z); auto with zarith; apply Zmult_lt_neg_compat_l); try zsign_tac_aux; clear H1) | _ => auto with zarith; fail 1 \"Zsign_tac_aux\" end.",
            "VernacExtend",
            "34a39bab6270f5797ffbd184a348cb9d4cf0dab1"
        ],
        [
            "Ltac zsign_tac := zsign_tac0 || (Zsign_top; match goal with H1: (Zsign_type ?s1 ?s2) |- ?g => clear H1; let s := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (mkZprod s2)) in let t := Zsign_get_term g in let l := Zsign_get_left g in let r := Zsign_get_right g in let sl := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (Zmult (mkZprod s2) l)) in let sr := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (Zmult (mkZprod s2) r)) in replace2_tac (Zmult t l) (Zmult t r) sl sr; [zsign_tac_aux | ring | ring] end).",
            "VernacExtend",
            "729c483846c48e078d128bdf1c7cdde598e3ae80"
        ],
        [
            "Ltac hyp_zsign_tac_aux H := match type of H with | (?X1 * ?X2 <= ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zmult_le_compat_l_rev _ _ _ H1 H)) || (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zmult_le_neg_compat_l_rev _ _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux H; clear H1) | (?X1 * ?X2 < ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zmult_lt_compat_l_rev _ _ _ H1 H)) || (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zmult_lt_neg_compat_l_rev _ _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux H; clear H1) | (?X1 * ?X2 >= ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (X1 > 0)%Z); auto with zarith; generalize (Zmult_ge_compat_l_rev _ _ _ H1 H)) || (assert (H1: (0 > X1)%Z); auto with zarith; generalize (Zmult_ge_neg_compat_l_rev _ _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux H; clear H1) | (?X1 * ?X2 > ?X1 * ?X3)%Z => let H1 := fresh \"H\" in ((assert (H1: (0 < X1)%Z); auto with zarith; generalize (Zmult_gt_compat_l_rev _ _ _ H1 H)) || (assert (H1: (X1 < 0)%Z); auto with zarith; generalize (Zmult_gt_neg_compat_l_rev _ _ _ H1 H)); clear H; intros H; try hyp_zsign_tac_aux H; clear H1) | _ => auto with zarith; fail 0 \"Zhyp_sign_tac_aux\" end.",
            "VernacExtend",
            "b73c745e99efd388109a70bf09c753d1eecada47"
        ],
        [
            "Ltac hyp_zsign_tac H := hyp_zsign_tac0 H||( Zhyp_sign_top H; match goal with H1: (Zsign_type ?s1 ?s2) |- _ => clear H1; let s := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (mkZprod s2)) in let g := type of H in let t := Zsign_get_term g in let l := Zsign_get_left g in let r := Zsign_get_right g in let sl := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (Zmult (mkZprod s2) l)) in let sr := eval unfold mkZprod, mkZprodt in (mkZprodt s1 (Zmult (mkZprod s2) r)) in (generalize H; replace2_tac (Zmult t l) (Zmult t r) sl sr; [clear H; intros H; try hyp_zsign_tac_aux H| ring | ring]) end).",
            "VernacExtend",
            "c56b9e4f8a8770d2da739a48da4850df7add649f"
        ],
        [
            "Section Test.",
            "VernacBeginSection",
            "7312dc3febac5f4f4f34b969a6193df7ca6d72da"
        ],
        [
            "Let test : forall a b c, (0 < a -> a * b < a * c -> b < c)%Z.",
            "VernacDefinition",
            "4e6c59f92da740735d2547cc7b5e7d8bc164abbc"
        ],
        [
            "intros a b c H H1.",
            "VernacExtend",
            "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
        ],
        [
            "hyp_zsign_tac H1.",
            "VernacExtend",
            "464ad345d9955da3023458dd3164f0ad73ca9791"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Let test1 : forall a b c, (a < 0 -> a * b < a * c -> c < b)%Z.",
            "VernacDefinition",
            "7639842e3fcfcd4c66def3996d286640152d389d"
        ],
        [
            "intros a b c H H1.",
            "VernacExtend",
            "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
        ],
        [
            "hyp_zsign_tac H1.",
            "VernacExtend",
            "464ad345d9955da3023458dd3164f0ad73ca9791"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Let test2 : forall a b c, (0 < a -> a * b <= a * c -> b <= c)%Z.",
            "VernacDefinition",
            "b67ef39972a99160155e6c023b31dd62bb79070c"
        ],
        [
            "intros a b c H H1.",
            "VernacExtend",
            "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
        ],
        [
            "hyp_zsign_tac H1.",
            "VernacExtend",
            "464ad345d9955da3023458dd3164f0ad73ca9791"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Let test3 : forall a b c, (a < - 0 -> a * b >= a * c -> c >= b)%Z.",
            "VernacDefinition",
            "eaefe6a7b8978c7fbebf936f52a882cbd02b2145"
        ],
        [
            "intros a b c H H1.",
            "VernacExtend",
            "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
        ],
        [
            "hyp_zsign_tac H1.",
            "VernacExtend",
            "464ad345d9955da3023458dd3164f0ad73ca9791"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Test.",
            "VernacEndSegment",
            "5ef36602e05b1405a9de93a2ffeb72f5cdc86267"
        ]
    ],
    "proofs": [
        {
            "name": "test",
            "line_nb": 27,
            "steps": [
                {
                    "command": [
                        "intros a b c H H1.",
                        "VernacExtend",
                        "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
                    ]
                },
                {
                    "command": [
                        "hyp_zsign_tac H1.",
                        "VernacExtend",
                        "464ad345d9955da3023458dd3164f0ad73ca9791"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test1",
            "line_nb": 31,
            "steps": [
                {
                    "command": [
                        "intros a b c H H1.",
                        "VernacExtend",
                        "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
                    ]
                },
                {
                    "command": [
                        "hyp_zsign_tac H1.",
                        "VernacExtend",
                        "464ad345d9955da3023458dd3164f0ad73ca9791"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test2",
            "line_nb": 35,
            "steps": [
                {
                    "command": [
                        "intros a b c H H1.",
                        "VernacExtend",
                        "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
                    ]
                },
                {
                    "command": [
                        "hyp_zsign_tac H1.",
                        "VernacExtend",
                        "464ad345d9955da3023458dd3164f0ad73ca9791"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test3",
            "line_nb": 39,
            "steps": [
                {
                    "command": [
                        "intros a b c H H1.",
                        "VernacExtend",
                        "74446c317a6c7b3e338ec92275b2fcf0ba8e4f71"
                    ]
                },
                {
                    "command": [
                        "hyp_zsign_tac H1.",
                        "VernacExtend",
                        "464ad345d9955da3023458dd3164f0ad73ca9791"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}