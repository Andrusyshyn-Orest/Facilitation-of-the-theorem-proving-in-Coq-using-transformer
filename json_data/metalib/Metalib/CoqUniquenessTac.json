{
    "filename": "Metalib/CoqUniquenessTac.v",
    "coq_project": "metalib",
    "vernac_cmds": [
        [
            "Require Import Coq.Lists.List.",
            "VernacRequire",
            "3f8620a911f16f9e8918ea7512dbb594c917da38"
        ],
        [
            "Require Import Coq.Logic.Eqdep_dec.",
            "VernacRequire",
            "bffc94770dbd58f1391b925eb322f533f236b761"
        ],
        [
            "Require Import Coq.omega.Omega.",
            "VernacRequire",
            "c22118512de22ca1f471830b29716d6337180b58"
        ],
        [
            "Fixpoint arrow (xs : list Type) (res : Type) : Type := match xs with | nil => res | cons y ys => y -> arrow ys res end.",
            "VernacFixpoint",
            "06b539941c59392b0d8b8065693a4d9712e4ed2f"
        ],
        [
            "Fixpoint tuple (xs : list Type) : Type := match xs with | nil => unit | cons y ys => (y * tuple ys)%type end.",
            "VernacFixpoint",
            "ba34b4086b217485352e2abfd50ba9cef075161e"
        ],
        [
            "Definition apply_tuple (xs : list Type) (res : Type) (f : arrow xs res) (arg : tuple xs) : res.",
            "VernacDefinition",
            "b132ca7b552af0ab164526bbdf1534449064cd54"
        ],
        [
            "induction xs as [ | ? ? IH ]; simpl.",
            "VernacExtend",
            "d9a2e488adebe1e033c1ac019c7ce313ded4401d"
        ],
        [
            "exact f.",
            "VernacExtend",
            "98a753342743704f2b7fafdf74e55f2f2ae53883"
        ],
        [
            "exact (IH (f (fst arg)) (snd arg)).",
            "VernacExtend",
            "5a2ca06e7172b295a4bdef6755c44792656369ca"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Fixpoint tr_list_rev (A : Type) (xs : list A) (acc : list A) : list A := match xs with | nil => acc | cons y ys => tr_list_rev A ys (cons y acc) end.",
            "VernacFixpoint",
            "eacb2001d65e48a1a96a2da9b2869a4c432968ea"
        ],
        [
            "Arguments tr_list_rev [ A ].",
            "VernacArguments",
            "946b88279043b1629f830edafe9a360ddf630c79"
        ],
        [
            "Definition list_rev (A : Type) (xs : list A) : list A := tr_list_rev xs nil.",
            "VernacDefinition",
            "6445dd916ad066826bc1b13da45e2c4d3f9f2927"
        ],
        [
            "Arguments list_rev [ A ].",
            "VernacArguments",
            "a922c2da00788db48ca4ddcbffd92e620ad7b25b"
        ],
        [
            "Definition tr_tuple_rev (xs : list Type) (ab : tuple xs) (acc : list Type) (acc' : tuple acc) : tuple (tr_list_rev xs acc).",
            "VernacDefinition",
            "d11cfeb505b0018e444900dc495c646933d6340d"
        ],
        [
            "generalize dependent acc.",
            "VernacExtend",
            "7e2a4ce9a7dbc7a7450a4f506680e3f800d7fabd"
        ],
        [
            "induction xs as [ | ? ? IH ]; simpl; intros acc acc'.",
            "VernacExtend",
            "531ed765c21fbd558e50511c1bca9a4fc1868734"
        ],
        [
            "exact acc'.",
            "VernacExtend",
            "7ef8cc2a6545e676b3bc554ef7d6f05dae52c7e0"
        ],
        [
            "exact (IH (snd ab) (a :: acc) (fst ab, acc')).",
            "VernacExtend",
            "383fa4a56144e94e97c9ba6e6c73330719711c95"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition tuple_rev (xs : list Type) (ab : tuple xs) : tuple (list_rev xs) := tr_tuple_rev xs ab nil tt.",
            "VernacDefinition",
            "42ee52f3c1e82fd360af3fdcd403866de63efb29"
        ],
        [
            "Lemma eq_unit_dec : forall (x y : unit), {x = y} + {x <> y}.",
            "VernacStartTheoremProof",
            "53796bae484d02a09650fdbbedc58f0a49f8ed1d"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_pair_dec : forall (A B : Type), (forall x y : A, {x = y} + {x <> y}) -> (forall x y : B, {x = y} + {x <> y}) -> (forall x y : A * B, {x = y} + {x <> y}).",
            "VernacStartTheoremProof",
            "6ad152786cb3f2bda476293920c011825ca5a807"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Resolve eq_unit_dec eq_pair_dec : eq_dec.",
            "VernacHints",
            "e46d54890709a2c27f112a074fb058e346eec6df"
        ],
        [
            "Ltac uniqueness icount := intros; try (match goal with |- _ = ?f _ => symmetry end); let lhs := match goal with |- ?lhs = _ => constr:(lhs) end in let rhs := match goal with |- _ = ?rhs => constr:(rhs) end in let sort := match type of rhs with | ?pred => match type of pred with ?sort => sort end end in let rec get_pred_type i pred := match i with | O => pred | S ?n => match pred with ?f ?x => get_pred_type n f end end in let pred := get_pred_type icount ltac:(type of rhs) in let rec get_ind_types i pred acc := match i with | O => acc | S ?n => match pred with | ?f ?x => let ind := type of x in get_ind_types n f (@cons Type ind acc) end end in let ind_types := get_ind_types icount ltac:(type of rhs) (@nil Type) in let rec get_inds i pred acc := match i with | O => acc | S ?n => match pred with ?f ?x => get_inds n f (x, acc) end end in let inds := get_inds icount ltac:(type of rhs) tt in let rind_types := constr:(list_rev ind_types) in let rinds := constr:(tuple_rev ind_types inds) in let core := constr:(fun (ainds : tuple rind_types) (rhs : apply_tuple (list_rev rind_types) sort pred (tuple_rev rind_types ainds)) => forall eqpf : rinds = ainds, @eq (apply_tuple (list_rev rind_types) sort pred (tuple_rev rind_types ainds)) (@eq_rect (tuple rind_types) rinds (fun rinds2 => apply_tuple (list_rev rind_types) sort pred (tuple_rev rind_types rinds2)) lhs ainds eqpf) rhs) in let core := eval simpl in core in let rec curry f := match type of f with | forall _ : (unit), _ => constr:(f tt) | forall _ : (_ * unit), _ => constr:(fun a => f (a, tt)) | forall _ : (_ * _), _ => let f' := constr:(fun b a => f (a, b)) in curry f' end in let core := curry core in let core := eval simpl in core in let rec apply_core f args := match args with | tt => constr:(f) | (?x, ?xs) => apply_core (f x) xs end in let core := apply_core core inds in let core := constr:(core rhs) in change lhs with (@eq_rect (tuple rind_types) rinds (fun rinds2 => apply_tuple (list_rev rind_types) sort pred (tuple_rev rind_types rinds2)) lhs rinds (refl_equal rinds)); generalize (refl_equal rinds); change core; case rhs; unfold list_rev, tuple_rev in *; simpl tr_list_rev in *; simpl tr_tuple_rev in *; repeat (match goal with | |- (_, _) = (_, _) -> _ => let H := fresh in intros H; try discriminate; injection H | _ => progress intro end); subst; try (rewrite <- eq_rect_eq_dec; [ f_equal; auto | auto with eq_dec ]).",
            "VernacExtend",
            "834b305e9629dc901ae87286b7d73233b04621e6"
        ]
    ],
    "proofs": [
        {
            "name": "apply_tuple",
            "line_nb": 5,
            "steps": [
                {
                    "command": [
                        "induction xs as [ | ? ? IH ]; simpl.",
                        "VernacExtend",
                        "d9a2e488adebe1e033c1ac019c7ce313ded4401d"
                    ]
                },
                {
                    "command": [
                        "exact f.",
                        "VernacExtend",
                        "98a753342743704f2b7fafdf74e55f2f2ae53883"
                    ]
                },
                {
                    "command": [
                        "exact (IH (f (fst arg)) (snd arg)).",
                        "VernacExtend",
                        "5a2ca06e7172b295a4bdef6755c44792656369ca"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "tr_tuple_rev",
            "line_nb": 14,
            "steps": [
                {
                    "command": [
                        "generalize dependent acc.",
                        "VernacExtend",
                        "7e2a4ce9a7dbc7a7450a4f506680e3f800d7fabd"
                    ]
                },
                {
                    "command": [
                        "induction xs as [ | ? ? IH ]; simpl; intros acc acc'.",
                        "VernacExtend",
                        "531ed765c21fbd558e50511c1bca9a4fc1868734"
                    ]
                },
                {
                    "command": [
                        "exact acc'.",
                        "VernacExtend",
                        "7ef8cc2a6545e676b3bc554ef7d6f05dae52c7e0"
                    ]
                },
                {
                    "command": [
                        "exact (IH (snd ab) (a :: acc) (fst ab, acc')).",
                        "VernacExtend",
                        "383fa4a56144e94e97c9ba6e6c73330719711c95"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "eq_unit_dec",
            "line_nb": 21,
            "steps": [
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_pair_dec",
            "line_nb": 24,
            "steps": [
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}