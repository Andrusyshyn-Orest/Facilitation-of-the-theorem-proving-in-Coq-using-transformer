{
    "filename": "Core/HoareTriples.v",
    "coq_project": "disel",
    "vernac_cmds": [
        [
            "From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat eqtype ssrfun seq.",
            "VernacRequire",
            "037d2ffdc90053d89d1b918c36daaeab721d2d83"
        ],
        [
            "From mathcomp Require Import path.",
            "VernacRequire",
            "7c70f445c754a2a74114416d587d02e512c693e2"
        ],
        [
            "Require Import Eqdep.",
            "VernacRequire",
            "a499933d0898d4c0e235af789d9252f633426d20"
        ],
        [
            "Require Import Relation_Operators.",
            "VernacRequire",
            "5c09f52be79db9d019c350cc3153659920102fbb"
        ],
        [
            "From fcsl Require Import axioms pred prelude ordtype finmap pcm unionmap heap.",
            "VernacRequire",
            "576c96e5dbde92d8f1878b78d95e36aa980a0403"
        ],
        [
            "From DiSeL Require Import Domain Freshness State EqTypeX DepMaps Protocols Worlds NetworkSem Rely.",
            "VernacRequire",
            "92146348786ae8d4e6b443a6287cdc4dd9200516"
        ],
        [
            "From DiSeL Require Import Actions Injection Process Always.",
            "VernacRequire",
            "417e97fe786b283de7f2420918614880dffe1106"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Unset Strict Implicit.",
            "VernacUnsetOption",
            "2842adaf6959318f2042805935c46f513bdc0348"
        ],
        [
            "Unset Printing Implicit Defensive.",
            "VernacUnsetOption",
            "444e5f0be4b25d9b1fd556943a447ec10046d151"
        ],
        [
            "Structure prog (W : world) A (this : nid) := Prog { set_of : proc this W A -> Prop; _ : set_of Unfinished }.",
            "VernacInductive",
            "32cbfe8bdc3af836a02f6352e852ef5a7fc4d90c"
        ],
        [
            "Section Programs.",
            "VernacBeginSection",
            "9a96a0edc3db195bda6b3612d0988ca8fe3fc321"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variable A : Type.",
            "VernacAssumption",
            "8c1a433b6dc10de37f30039d70ed7113b3dab0e0"
        ],
        [
            "Notation coherent := (Coh W).",
            "VernacSyntacticDefinition",
            "1c23df7657813c12a5e38bb2a11852e83aab537e"
        ],
        [
            "Arguments Prog [W A].",
            "VernacArguments",
            "362f7a3131038ebca9e82d6f24577a8812f9c718"
        ],
        [
            "Arguments Prog [W A this].",
            "VernacArguments",
            "21311bd414c572d9294842f963fa87bd0f396573"
        ],
        [
            "Coercion set_of : prog >-> Funclass.",
            "VernacCoercion",
            "3b1c2073b4d3ebe3708dda7862fcc3a0db16f46b"
        ],
        [
            "Canonical prog_PredType W A := mkPredType (fun p => @set_of W A this p).",
            "VernacDefinition",
            "1d3d93115cedc9138c02afb5e7fb6c50c35a8823"
        ],
        [
            "Lemma progE (T1 T2 : prog W A this) : T1 = T2 <-> set_of T1 = set_of T2.",
            "VernacStartTheoremProof",
            "f7f6e88d451d17d7e709ff99895e4c7fc35a6934"
        ],
        [
            "split=>[->//|]; case: T1 T2=>m1 H1 [m2 H2] /= E.",
            "VernacExtend",
            "4a95f82aca0fc9a50f43053eca44fc9141212abe"
        ],
        [
            "by move: H2; rewrite -E => H2; rewrite (pf_irr H1 H2).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition pre := state -> Prop.",
            "VernacDefinition",
            "6e42e669e2114497d6bf15429b7437d8bfbdabfd"
        ],
        [
            "Definition post A := state -> A -> state -> Prop.",
            "VernacDefinition",
            "61a701ffea2021a0067b469e80e67a53d2037d66"
        ],
        [
            "Definition cont A := A -> state -> Prop.",
            "VernacDefinition",
            "402c9176743288e578c513d7475c2c0fcfc7aca8"
        ],
        [
            "Definition spec A := prod pre (post A).",
            "VernacDefinition",
            "9fcf33a4d21280d430c6fef6e6518ef771e4fabd"
        ],
        [
            "Definition has_spec (s : spec A) := [Pred T : prog W A this | forall i t, s.1 i -> i \\In Coh W -> t \\In T -> after i t (s.2 i)].",
            "VernacDefinition",
            "ac737561a2d94324f1fa49a0372b10665729b1d3"
        ],
        [
            "End Programs.",
            "VernacEndSegment",
            "ad673a3aab874f629ed1e249d76fde2b8df98014"
        ],
        [
            "Module DTbin.",
            "VernacDefineModule",
            "934f11f3ad39357baabc397f8505f945275d7cf8"
        ],
        [
            "Section DTbin.",
            "VernacBeginSection",
            "7f2ec21ce205b98fc2f88cdd04730c517f6d29c7"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Structure DTbin (W : world) A (s : spec A) := DTbin_make { prog_of : prog W A this; _ : prog_of \\In has_spec this W s}.",
            "VernacInductive",
            "55e3c092f3cfb5943ad34c9e41f62f33e39d3610"
        ],
        [
            "End DTbin.",
            "VernacEndSegment",
            "1032056f260fb22d1bf2861f5d7d735852d53a7d"
        ],
        [
            "End DTbin.",
            "VernacEndSegment",
            "1032056f260fb22d1bf2861f5d7d735852d53a7d"
        ],
        [
            "Notation DTbin := DTbin.DTbin.",
            "VernacSyntacticDefinition",
            "5efa6b977cfc0da6c17a67e104162ba25b6eb362"
        ],
        [
            "Notation DTbin_make := DTbin.DTbin_make.",
            "VernacSyntacticDefinition",
            "77c9e0be5672c8a36cf335f0d6c98ab64634a49f"
        ],
        [
            "Coercion DTbin.prog_of : DTbin >-> prog.",
            "VernacCoercion",
            "7078697503e802f69a1205ed904249258ecd1ecf"
        ],
        [
            "Section Specs.",
            "VernacBeginSection",
            "3199301d6770bd7ed5c7ce4534ed3eb3b871eed0"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Lemma stsepE (W : world) A (s : spec A) (e1 e2 : DTbin this W s) : e1 = e2 <-> e1 = e2 :> prog W A this.",
            "VernacStartTheoremProof",
            "da94a9036c42b36c741026a83fc65c95fe4baab4"
        ],
        [
            "split=>[->//|]; case: e1 e2=>T1 H1 [T2 H2] /= E.",
            "VernacExtend",
            "4a95f82aca0fc9a50f43053eca44fc9141212abe"
        ],
        [
            "by rewrite -{T2}E in H2 *; rewrite (pf_irr H1 H2).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma prog_unfin (W : world) A (s : spec A) (e : DTbin this W s) : Unfinished \\In DTbin.prog_of e.",
            "VernacStartTheoremProof",
            "41d82297a96eff0a256db986de629d148a7b3438"
        ],
        [
            "by case: e; case.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Inductive DT (W: world) A := with_spec (s : spec A) of DTbin this W s.",
            "VernacInductive",
            "5d046853aff031e84a45905debbaf9bb18929a8d"
        ],
        [
            "Definition spec_of W A (e : DT W A) := let: with_spec s _ := e in s.",
            "VernacDefinition",
            "da96818379eb93905f43da2ad3a9dd5e30fc9019"
        ],
        [
            "Definition pre_of W A := fun e : DT W A => (spec_of e).1.",
            "VernacDefinition",
            "c8272bdc97a730ed77c94411f02fa4a91a9d00ca"
        ],
        [
            "Definition post_of W A := fun e : DT W A => (spec_of e).2.",
            "VernacDefinition",
            "0ca4517f64263e098eff5b872bd13ba8deb32806"
        ],
        [
            "Definition code_of (W : world) A (e : DT W A) := let: with_spec _ c := e return DTbin this W (spec_of e) in c.",
            "VernacDefinition",
            "06d1d8d7385ec3528a80c86f27a33ddb51e74b13"
        ],
        [
            "Arguments pre_of [W A].",
            "VernacArguments",
            "2c3d55de885a7df9fcdd413dd09c5b4f5c39ce22"
        ],
        [
            "Arguments post_of [W A].",
            "VernacArguments",
            "aa9ea362b47a1dc95435c99284292db7b3344ccd"
        ],
        [
            "Arguments with_spec [W A].",
            "VernacArguments",
            "b22773b24c2791f8b8048bf17cc9b592600e4955"
        ],
        [
            "Prenex Implicits pre_of post_of.",
            "VernacExtend",
            "92c84970c8768a8aae157b22767c1193ab231db8"
        ],
        [
            "Coercion with_spec : DTbin >-> DT.",
            "VernacCoercion",
            "ea8dd364005dbe8e0e712b99d5c1a1e3749c7a5a"
        ],
        [
            "Definition verify (W : world) A (i : state) (e : DT W A) r := i \\In Coh W -> forall p, p \\In DTbin.prog_of (code_of e) -> after i p r.",
            "VernacDefinition",
            "ce9b3c2cb985f11c8b51fa49cf8e08f2664b4ade"
        ],
        [
            "End Specs.",
            "VernacEndSegment",
            "cd208cf6549faa997d087fa0ced605d679ec61de"
        ],
        [
            "Module DTLattice.",
            "VernacDefineModule",
            "66edc7eb6f2fbb3190e391b66a1649bba860d3a7"
        ],
        [
            "Section DTLattice.",
            "VernacBeginSection",
            "2cb0b6255591bcc515f5da35ba822a7987bae800"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variables (A : Type) (s : spec A).",
            "VernacAssumption",
            "27847365a3e8a8931b3d4c49d38a42f173a509ec"
        ],
        [
            "Notation prog A := (@prog W A this).",
            "VernacSyntacticDefinition",
            "41f77a2e768191071f485988b03dca399d916eac"
        ],
        [
            "Notation DTbin s := (@DTbin this W A s).",
            "VernacSyntacticDefinition",
            "a43154bdbcc75220aa980e77d2d344489aa03179"
        ],
        [
            "Definition leq (e1 e2 : DTbin s) := set_of (DTbin.prog_of e1) <== set_of (DTbin.prog_of e2).",
            "VernacDefinition",
            "1b22a3293a3d03e9360d09fbc259151cad389a88"
        ],
        [
            "Lemma leq_refl e : leq e e.",
            "VernacStartTheoremProof",
            "c0d64354324762c7781b9cf36b19cec4c653f8b7"
        ],
        [
            "by [].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma leq_trans e1 e2 e3 : leq e1 e2 -> leq e2 e3 -> leq e1 e3.",
            "VernacStartTheoremProof",
            "41f8a63a0ab8c66cefccf7c63a91694bc2d9871e"
        ],
        [
            "by move=>H1 H2 p x; apply: H2; apply: H1.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma leq_asym e1 e2 : leq e1 e2 -> leq e2 e1 -> e1 = e2.",
            "VernacStartTheoremProof",
            "4ceaa743ae68704ed7f8d02ddadc8987adcc38f3"
        ],
        [
            "move: e1 e2=>[m1 N1][m2 N2]; rewrite /leq /= => H1 H2.",
            "VernacExtend",
            "8261237f0cda1915a4077c28869831c5329103ce"
        ],
        [
            "by apply/stsepE/progE; apply: poset_asym H1 H2.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition bot_set t := t = @Unfinished this W A.",
            "VernacDefinition",
            "e44cf6578c70656dbd477190197887a518bb7252"
        ],
        [
            "Definition bot_prg := @Prog _ _ _ bot_set (erefl _).",
            "VernacDefinition",
            "2616a17bc556a8eba8cc0c53eb3d9e6eaefae9cc"
        ],
        [
            "Lemma bot_spec : bot_prg \\In has_spec this W s.",
            "VernacStartTheoremProof",
            "b77e82b1adaae13f6cb117b1bc1f3c98d22090fd"
        ],
        [
            "by move=>i H C t ->; apply: alw_unfin.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition bot := DTbin_make bot_spec.",
            "VernacDefinition",
            "4eb513c98ff9d0dedddc8b5305d9c425cf21904c"
        ],
        [
            "Lemma bot_bot e : leq bot e.",
            "VernacStartTheoremProof",
            "c609530da26d3d7e177cbf3e8f08b33afb4f43a6"
        ],
        [
            "by case: e=>[[p U] H] t ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition sup_set (es : Pred (DTbin s)) t := t = Unfinished \\/ exists e : DTbin s, t \\In DTbin.prog_of e /\\ e \\In es.",
            "VernacDefinition",
            "0bc21bb7e3c4c319f835ab8fc9f30e4b75279a05"
        ],
        [
            "Definition sup_prog es := @Prog _ _ _ (sup_set es) (or_introl (erefl _)).",
            "VernacDefinition",
            "001ed9e1e79f49ff2d1018e33edd42c8d7481770"
        ],
        [
            "Lemma sup_spec es : sup_prog es \\In has_spec this W s.",
            "VernacStartTheoremProof",
            "28bb63984eb38892ce0dcba6371b3f45e0a2c437"
        ],
        [
            "move=>i H C t [->|[e [H1 H2]]]; first by apply: alw_unfin.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by case: e H1 H2=>p H3 /= H4 _; apply: H3 H C _ H4.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition sup es := DTbin_make (@sup_spec es).",
            "VernacDefinition",
            "1a3a8b171b83e4805704161f5ca7b8f01c953da3"
        ],
        [
            "Lemma sup_supB es e : e \\In es -> leq e (sup es).",
            "VernacStartTheoremProof",
            "509dcf93adafa6ff7baa1163e821b8accab4967a"
        ],
        [
            "by move=>H1 x H2; right; exists e.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sup_supL es e : (forall c, c \\In es -> leq c e) -> leq (sup es) e.",
            "VernacStartTheoremProof",
            "eb3b2883097a3b740209705afbc2435483348b7d"
        ],
        [
            "by case: e; case=>m N H /= H1 t [->//|][T][H2]; move/H1; apply.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End DTLattice.",
            "VernacEndSegment",
            "a474dfb6ff9706dd31829061615fdc0d6bc1e068"
        ],
        [
            "Module Exports.",
            "VernacDefineModule",
            "d4a1114ec53f746523a7dec57823f7f03e51fa24"
        ],
        [
            "Section Exports.",
            "VernacBeginSection",
            "3d3d73b16827535e7d0c9fdb92a2f163a05b14f4"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variables (A : Type) (s : spec A).",
            "VernacAssumption",
            "27847365a3e8a8931b3d4c49d38a42f173a509ec"
        ],
        [
            "Definition stPosetMixin := PosetMixin (@leq_refl this W A s) (@leq_asym this W A s) (@leq_trans this W A s).",
            "VernacDefinition",
            "0885f596f5018fe8314bb0a1424bf94fd8a83f84"
        ],
        [
            "Canonical stPoset := Eval hnf in Poset (@DTbin this W A s) stPosetMixin.",
            "VernacDefinition",
            "6d93b13987722edebc12ad1232b2be05ff94978a"
        ],
        [
            "Definition stLatticeMixin := LatticeMixin (@sup_supB this W A s) (@sup_supL this W A s).",
            "VernacDefinition",
            "ace88d3700c0f9dce86da08f1b755c8ec0b1d469"
        ],
        [
            "Canonical stLattice := Eval hnf in Lattice (@DTbin this W A s) stLatticeMixin.",
            "VernacDefinition",
            "2788e61f945900ae1e222bdaa82399ce868d4f26"
        ],
        [
            "End Exports.",
            "VernacEndSegment",
            "71efedae7ccffd696e1ffe5d8ae6baa8a4484918"
        ],
        [
            "End Exports.",
            "VernacEndSegment",
            "71efedae7ccffd696e1ffe5d8ae6baa8a4484918"
        ],
        [
            "End DTLattice.",
            "VernacEndSegment",
            "a474dfb6ff9706dd31829061615fdc0d6bc1e068"
        ],
        [
            "Export DTLattice.Exports.",
            "VernacImport",
            "bbbbde91ef2a727930acc82e28ae3171cba542a8"
        ],
        [
            "Section Fix.",
            "VernacBeginSection",
            "d77361e378a4eccfb0de92f8aca9fd3df236f5e0"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variables (A : Type) (B : A -> Type) (s : forall x, spec (B x)).",
            "VernacAssumption",
            "0fe971cea4266f94bcc682279561a52b90a107dd"
        ],
        [
            "Notation tp := (forall x, DTbin this W (s x)).",
            "VernacSyntacticDefinition",
            "eaa3eb74cb442d8e91f25191b4085002719a94f8"
        ],
        [
            "Notation lat := (dfunLattice (fun x => [lattice of DTbin this W (s x)])).",
            "VernacSyntacticDefinition",
            "d67d9e899f06f279691919a4ba5c090b374ddc08"
        ],
        [
            "Variable (f : tp -> tp).",
            "VernacAssumption",
            "1cca6a84400a2de4b5082100d6e2a5d7b9c63e06"
        ],
        [
            "Definition f' (e : lat) := sup [Pred t : lat | exists e', e' <== e /\\ t = f e'].",
            "VernacDefinition",
            "879adf44578df4e1028fcd81fb3e564148e66370"
        ],
        [
            "Definition ffix : tp := tarski_lfp f'.",
            "VernacDefinition",
            "1e12506879c4524b86db24a248525b83dca53678"
        ],
        [
            "End Fix.",
            "VernacEndSegment",
            "d8c526866dd535372644db6e39d22267c2d9cc5f"
        ],
        [
            "Section Return.",
            "VernacBeginSection",
            "20f8c8c8ca4dd7cb548756711145fe99af6ddfb5"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variables (A : Type) (x : A).",
            "VernacAssumption",
            "2d671b91ecba2737d46e27c73ef5f518d63f6895"
        ],
        [
            "Definition ret_set t := t = Unfinished \\/ t = @Ret this W A x.",
            "VernacDefinition",
            "21aab2dc8e41c1429a61aa099b3709307c8a5b7e"
        ],
        [
            "Definition ret_prog := @Prog _ _ _ ret_set (or_introl (erefl _)).",
            "VernacDefinition",
            "7d5fe1b70ac4cba66fcb6db4831d5fb3dc9a8b98"
        ],
        [
            "Definition ret_s : spec A := (fun i => True, fun i y m => network_rely W this i m /\\ y = x).",
            "VernacDefinition",
            "752ffca5f011749d241bca20f1dd491d23827da2"
        ],
        [
            "Lemma ret_has_spec : ret_prog \\In has_spec this W ret_s.",
            "VernacStartTheoremProof",
            "ed8a6d8c10ba03ed2365bce017cd498aa8d7feda"
        ],
        [
            "move=>i _ C t [->|->]; first by apply: alw_unfin.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by apply: alw_ret=>//= m E y [<-].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition ret := with_spec (DTbin_make ret_has_spec).",
            "VernacDefinition",
            "9a72a9a45d3d2aa1ce069c048bb5cb82d9554615"
        ],
        [
            "End Return.",
            "VernacEndSegment",
            "7881314b4a4115e5715d241a1fec160a84a3c7e0"
        ],
        [
            "Section Act.",
            "VernacBeginSection",
            "54d6eb82af38d2f78a976d5ff1e8bfd858282601"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variables (A : Type) (x : A).",
            "VernacAssumption",
            "2d671b91ecba2737d46e27c73ef5f518d63f6895"
        ],
        [
            "Variable a : action W A this.",
            "VernacAssumption",
            "3818d5511ab283dc7831fec2245e16ed808ff699"
        ],
        [
            "Definition act_set t := t = Unfinished \\/ t = @Act this W A a.",
            "VernacDefinition",
            "774b8653ddaf26f6107ab20e39cba448c8ae140d"
        ],
        [
            "Definition act_prog := @Prog _ _ _ act_set (or_introl (erefl _)).",
            "VernacDefinition",
            "0f719704f7eb0e4c026f709d6d5f03225bfff333"
        ],
        [
            "Definition act_s : spec A := (fun i => forall j, network_rely W this i j -> a_safe a j, fun i y m => exists j k, [/\\ network_rely W this i j, exists (S: a_safe a j), a_step S k y & network_rely W this k m]).",
            "VernacDefinition",
            "44727e406535e27803c4021212a801ebd5b991b2"
        ],
        [
            "Lemma act_has_spec : act_prog \\In has_spec this W act_s.",
            "VernacStartTheoremProof",
            "90a2255c446e7904757cdeac662c7c4cbc4819a5"
        ],
        [
            "move=>i t S C [] -> /=; first by apply: alw_unfin.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "apply: alw_act C _; move=>j E1; move/S: (E1)=>pf; exists pf.",
            "VernacExtend",
            "3aa2c37caa1ec61ee662299c66b0e60249700d96"
        ],
        [
            "split=>// k y m St E2 v [<-]; exists j, k.",
            "VernacExtend",
            "a105052755410da2f211c2b4c63b728837d3287a"
        ],
        [
            "by split=>//; exists pf.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition act := with_spec (DTbin_make act_has_spec).",
            "VernacDefinition",
            "fbed9e35fa5a7bf70e5c1d246a02a7e806cd88a5"
        ],
        [
            "End Act.",
            "VernacEndSegment",
            "ae31266fb818469ef51954b2ccf20b8e51e708a0"
        ],
        [
            "Section Bind.",
            "VernacBeginSection",
            "5993903483cf8b30dda4901ecd8fd710324c1304"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variable W : world.",
            "VernacAssumption",
            "92d3732f8ee464718a9d77a50e1d3ac970c2e983"
        ],
        [
            "Variables (A B : Type).",
            "VernacAssumption",
            "b4e42fd426c23cd1c77c79fc26c25f95338235a5"
        ],
        [
            "Section Prog.",
            "VernacBeginSection",
            "9357660d28719ba1b50cda38a5d1853308d09a7b"
        ],
        [
            "Variables (T : prog W A this) (K : A -> prog W B this).",
            "VernacAssumption",
            "7db4d9a3cfd56a33d19265db66873dd4ec7815bd"
        ],
        [
            "Definition bnd_set t := t = Unfinished \\/ exists t', t \\In pcat t' K /\\ t' \\In T.",
            "VernacDefinition",
            "0ca97bbab03a53036f6eb6bf544b279dcf8a6553"
        ],
        [
            "Definition bnd_prog := @Prog _ _ _ bnd_set (or_introl (erefl _)).",
            "VernacDefinition",
            "ea5f85673a5a62304ba63ec3c7d05400d74a5a47"
        ],
        [
            "End Prog.",
            "VernacEndSegment",
            "4bf2c9df33797bac7d3ac73f633ad63f327f1462"
        ],
        [
            "Variables (e1 : DT this W A) (e2 : A -> DT this W B).",
            "VernacAssumption",
            "1a6017304a15d78873d9b1320f0c9ff105fc2752"
        ],
        [
            "Notation s1 := (spec_of e1).",
            "VernacSyntacticDefinition",
            "ea9ecb66b7abd666328bd9b1d6230f8802fed328"
        ],
        [
            "Notation s2 := (fun x => spec_of (e2 x)).",
            "VernacSyntacticDefinition",
            "c2b7ddfe5425d8f1cde8ababb0f1482dc270c863"
        ],
        [
            "Definition bind_s : spec B := (fun i => s1.1 i /\\ forall x s, s1.2 i x s -> (s2 x).1 s, fun i y m => exists x s, s1.2 i x s /\\ (s2 x).2 s y m).",
            "VernacDefinition",
            "a139442d2a62c481a47e5191570dd0ddb6bc6c81"
        ],
        [
            "Lemma bind_has_spec : bnd_prog (code_of e1) (fun x => let y := e2 x in code_of y) \\In has_spec this W bind_s.",
            "VernacStartTheoremProof",
            "fd04a4a0b7b3eab239e164de8385960b37812107"
        ],
        [
            "move=>i t [S1 S2] Ci [->|[t1 [Pc P1]]] /=; first by apply: alw_unfin.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "apply: aft_bnd Pc _; case: (code_of e1) P1=>T1 H /= P1.",
            "VernacExtend",
            "20ec428e50c31e1399aee62c5a532bc8417a4b29"
        ],
        [
            "apply: {H P1 Ci S1 T1 t t1} aft_imp (H _ _ S1 Ci P1).",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "move=>x s Cs S3 t; case: (code_of (e2 x))=>T /= H P.",
            "VernacExtend",
            "a01b3d93f426ff68d360351709a5fa5af822af32"
        ],
        [
            "by apply: aft_imp (H _ _ (S2 _ _ S3) Cs P)=>m y Cm; exists x, s.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition bind := with_spec (DTbin_make bind_has_spec).",
            "VernacDefinition",
            "9e620f399a668dc934a262647a5394197f14282a"
        ],
        [
            "End Bind.",
            "VernacEndSegment",
            "25a72c4b68ee0e3e47c8c9a42a2cc4437b0aa290"
        ],
        [
            "Section Inject.",
            "VernacBeginSection",
            "288eb7d180d6a906b6b12f80492c95b26b1184ff"
        ],
        [
            "Variables (this : nid) (V W : world) (K : hooks) (A : Type) (w : injects V W K).",
            "VernacAssumption",
            "8d6278c6d557393f341fad5f7e42f89839b00268"
        ],
        [
            "Variable (e : DT this V A).",
            "VernacAssumption",
            "84ae548b43d6c49f0b5d00064c0fbdf266bef597"
        ],
        [
            "Notation W2 := (inj_ext w).",
            "VernacSyntacticDefinition",
            "c7a8c3ce43aa605c3f289f38ff7c82776c55ae74"
        ],
        [
            "Notation s := (spec_of e).",
            "VernacSyntacticDefinition",
            "b7d0282fea530ad85eec21a7aece5fff83116b1a"
        ],
        [
            "Section Prog.",
            "VernacBeginSection",
            "9357660d28719ba1b50cda38a5d1853308d09a7b"
        ],
        [
            "Variable T : prog V A this.",
            "VernacAssumption",
            "73038a98c906473f2437b635a72b557292869c6c"
        ],
        [
            "Definition inject_set t := t = Unfinished \\/ exists t', t' \\In T /\\ t = Inject w t'.",
            "VernacDefinition",
            "5a92d08341375a8a9016ef1ddda0e1cbd48f0d6e"
        ],
        [
            "Definition inject_prog := @Prog _ _ _ inject_set (or_introl (erefl _)).",
            "VernacDefinition",
            "0edc2cfa14237d4e4919fbe7838e9e94464ae8d4"
        ],
        [
            "End Prog.",
            "VernacEndSegment",
            "4bf2c9df33797bac7d3ac73f633ad63f327f1462"
        ],
        [
            "Definition inject_s : spec A := (fun i => exists i1 i2, i = i1 \\+ i2 /\\ i1 \\In Coh V /\\ s.1 i1, fun i y m => forall i1 i2, i = i1 \\+ i2 -> i1 \\In Coh V -> exists m1 m2, [/\\ m = m1 \\+ m2, s.2 i1 y m1 & network_rely W2 this i2 m2]).",
            "VernacDefinition",
            "6716843bf00306d5cf7e255f58143a7c96d686c6"
        ],
        [
            "Lemma inject_has_spec : inject_prog (code_of e) \\In has_spec this W inject_s.",
            "VernacStartTheoremProof",
            "a916202d589727d82a38b76abde8efa92dccd21d"
        ],
        [
            "move=>i /= t [i1][j1][->{i}][Ci1 H1] C.",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "case=>[|[t' [H2 ->{t}]]]; first by move=>->; apply: alw_unfin.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "have : after i1 t' (s.2 i1) by case: (code_of e) H2=>p /= /(_ _ _ H1); apply.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "move/(aft_inject w C); apply: aft_imp=>{H1 t' H2} v m _.",
            "VernacExtend",
            "d6ebf3361f380a12d5c2c9bbb7ea363132c48b36"
        ],
        [
            "case=>i2 [j2][->{m} Ci2 S2 H2] i3 j3 E Ci3.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "suff [E1 E2]: i3 = i1 /\\ j3 = j1.",
            "VernacExtend",
            "d07fc8b2103f140554938023774bf3f75d04ba99"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "by rewrite {i3 E Ci3}E1 {j3}E2; exists i2, j2.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "move: (coh_prec (cohS C) Ci1 Ci3 E) (E)=>{Ci3 E} <-.",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "by move/(joinxK (cohS C)).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition inject := with_spec (DTbin_make inject_has_spec).",
            "VernacDefinition",
            "bde3d8e8ca722fc004bec5a889c27ea7e77227e0"
        ],
        [
            "End Inject.",
            "VernacEndSegment",
            "2e7da3c1b9d80988bad2f3bac89c7d92f385ce6e"
        ],
        [
            "From DiSeL Require Import InductiveInv.",
            "VernacRequire",
            "ef051c51817d176eaa3a07f7085dac509508cfbb"
        ],
        [
            "Section InductiveInv.",
            "VernacBeginSection",
            "c1d668158700c8e42aa6b43d21b4a6fb0a02829f"
        ],
        [
            "Variable pr : protocol.",
            "VernacAssumption",
            "d6790772eb3e4aa6e3d921860f3249ca87b4f0f4"
        ],
        [
            "Notation l := (plab pr).",
            "VernacSyntacticDefinition",
            "70cefb7a5b2500da653faa3042413b33e5c3a49e"
        ],
        [
            "Notation coh := (coh pr).",
            "VernacSyntacticDefinition",
            "eca1a74842a12fe116afffaf48c14e07fbfbba87"
        ],
        [
            "Variable I : dstatelet -> pred nid -> Prop.",
            "VernacAssumption",
            "d24dd684b16718059d65754269e40f62bc07f5e4"
        ],
        [
            "Variable ii : InductiveInv pr I.",
            "VernacAssumption",
            "9e0a00beb44958f6d361567e90d4971ed69b712d"
        ],
        [
            "Variables (A : Type) (this: nid).",
            "VernacAssumption",
            "bfb9a170673c785934c00855e41e8f7ae638fe42"
        ],
        [
            "Notation V := (mkWorld pr).",
            "VernacSyntacticDefinition",
            "7ad8b8c12324745ceecc43fd86d0a3078dcdb3b5"
        ],
        [
            "Notation W := (mkWorld (ProtocolWithIndInv ii)).",
            "VernacSyntacticDefinition",
            "423010b81a46b9c209c8faa3c7ee9cc2646ccfd4"
        ],
        [
            "Variable (e : DT this V A).",
            "VernacAssumption",
            "84ae548b43d6c49f0b5d00064c0fbdf266bef597"
        ],
        [
            "Notation s := (spec_of e).",
            "VernacSyntacticDefinition",
            "b7d0282fea530ad85eec21a7aece5fff83116b1a"
        ],
        [
            "Section Prog.",
            "VernacBeginSection",
            "9357660d28719ba1b50cda38a5d1853308d09a7b"
        ],
        [
            "Variable T : prog V A this.",
            "VernacAssumption",
            "73038a98c906473f2437b635a72b557292869c6c"
        ],
        [
            "Definition with_inv_set t := t = Unfinished \\/ exists t', t' \\In T /\\ t = WithInv pr I ii (erefl _) t'.",
            "VernacDefinition",
            "5920ed9f8fb262251fd2fd309d7d13a01b866220"
        ],
        [
            "Definition with_inv_prog := @Prog _ _ _ with_inv_set (or_introl (erefl _)).",
            "VernacDefinition",
            "1b28fcc66f4c0c1430335b28bf9cd994fb36f5ee"
        ],
        [
            "End Prog.",
            "VernacEndSegment",
            "4bf2c9df33797bac7d3ac73f633ad63f327f1462"
        ],
        [
            "Notation getS i := (getStatelet i l).",
            "VernacSyntacticDefinition",
            "b469b3fcd4fe91d452f8f4fe2aa5f5a738e78646"
        ],
        [
            "Definition with_inv_s : spec A := (fun i => s.1 i, fun i y m => m \\In Coh W /\\ s.2 i y m).",
            "VernacDefinition",
            "0ed7dae79b35dd83fecdda212028cea13d8455af"
        ],
        [
            "Lemma with_inv_has_spec : with_inv_prog (code_of e) \\In has_spec this W with_inv_s.",
            "VernacStartTheoremProof",
            "4f4ce616ebda15e9cf49a48f7837951370e7c4f6"
        ],
        [
            "move=>i/=t H1 C1.",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "case=>[|[t'[H2]->{t}]]; first by move=>->; apply: alw_unfin.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "apply: (aft_ind_inv C1).",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "by case: (code_of e) H2=>p /=/(_ _ _ H1 (with_inv_coh C1)); apply; move/with_inv_coh: C1.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition with_inv := with_spec (DTbin_make with_inv_has_spec).",
            "VernacDefinition",
            "e8b08a0b0ab5d0070bd58dc919879bb67fcceb0a"
        ],
        [
            "End InductiveInv.",
            "VernacEndSegment",
            "7208c6aca529d5639e607a6dcba952a0f50789cd"
        ],
        [
            "Definition conseq (W : world) A this (e : DT this W A) (s : spec A) := forall i, s.1 i -> verify i e (s.2 i).",
            "VernacDefinition",
            "5c7bb3a67ed0076ce8d2196389c820961603a8b1"
        ],
        [
            "Lemma conseq_refl (W : world) A this (e : DT this W A) : conseq e (spec_of e).",
            "VernacStartTheoremProof",
            "a8ed124a8fa35a1c2bf75a5747f0d7a8efdbd3b0"
        ],
        [
            "by case: e; case=>p q [T H i] /= Hp C t; apply: H.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Resolve conseq_refl.",
            "VernacHints",
            "9f9537e7b753566399d09916397ecf63ff88dbb6"
        ],
        [
            "Section Do.",
            "VernacBeginSection",
            "74befe2c61892b6ba087232f441b69c384feb881"
        ],
        [
            "Variable this : nid.",
            "VernacAssumption",
            "242c7869c0bef3fe166243583278f6bbaa63bbf4"
        ],
        [
            "Variables (W : world) (A : Type) (s2 : spec A).",
            "VernacAssumption",
            "d5f0e3546ed145e042e7328976a97975a0707edc"
        ],
        [
            "Variables (e : DT this W A) (pf : conseq e s2).",
            "VernacAssumption",
            "7269c462e713eaeab712d28119bf43b6b47e3317"
        ],
        [
            "Definition do_prog := DTbin.prog_of (code_of e).",
            "VernacDefinition",
            "b30f544309f9a0ca041f2186da8fd521db262d19"
        ],
        [
            "Lemma do_has_spec : do_prog \\In has_spec this W s2.",
            "VernacStartTheoremProof",
            "75a4cd2c515502b8dc96ff27341605ddbd8497ae"
        ],
        [
            "rewrite /do_prog; case: e pf=>T Ht /=; case: s2=>p q.",
            "VernacExtend",
            "1418099f654a9d12bdfd561bac86adb846b83bfd"
        ],
        [
            "by move=>H1 i t /= Hp C H; apply: H1.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition do' := DTbin_make do_has_spec.",
            "VernacDefinition",
            "833dbe64d7a4cd8e3da01adfe3489db140182c42"
        ],
        [
            "End Do.",
            "VernacEndSegment",
            "3cb40fbc0d1ec706bc6cad80ac0c787577edf1f5"
        ],
        [
            "Notation iinject x := (@inject _ _ _ _ _ _ x).",
            "VernacSyntacticDefinition",
            "5984ba7a03e58bdd93cc34a3f439efe22240da7d"
        ],
        [
            "Notation uinject x := (@inject _ _ _ Unit _ _ x).",
            "VernacSyntacticDefinition",
            "bb97a3e7f0a589613002dce75c0aaf6ac9f3ba68"
        ],
        [
            "Notation \"'Do' e\" := (@do' _ _ _ _ e _) (at level 80).",
            "VernacNotation",
            "cb4b31caa464fac04b05b0c668e5ee1be4feb6a3"
        ],
        [
            "Notation \"x '<--' c1 ';' c2\" := (bind c1 (fun x => c2)) (at level 81, right associativity).",
            "VernacNotation",
            "8e0b840f65db945fb9b2a5628f100f69466f65a7"
        ],
        [
            "Notation \"c1 ';;' c2\" := (bind c1 (fun _ => c2)) (at level 81, right associativity).",
            "VernacNotation",
            "beb8acae8f421b6a3d53ab954a7c76e3b5a82352"
        ]
    ],
    "proofs": [
        {
            "name": "progE",
            "line_nb": 20,
            "steps": [
                {
                    "command": [
                        "split=>[->//|]; case: T1 T2=>m1 H1 [m2 H2] /= E.",
                        "VernacExtend",
                        "4a95f82aca0fc9a50f43053eca44fc9141212abe"
                    ]
                },
                {
                    "command": [
                        "by move: H2; rewrite -E => H2; rewrite (pf_irr H1 H2).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "stsepE",
            "line_nb": 41,
            "steps": [
                {
                    "command": [
                        "split=>[->//|]; case: e1 e2=>T1 H1 [T2 H2] /= E.",
                        "VernacExtend",
                        "4a95f82aca0fc9a50f43053eca44fc9141212abe"
                    ]
                },
                {
                    "command": [
                        "by rewrite -{T2}E in H2 *; rewrite (pf_irr H1 H2).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prog_unfin",
            "line_nb": 45,
            "steps": [
                {
                    "command": [
                        "by case: e; case.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "leq_refl",
            "line_nb": 68,
            "steps": [
                {
                    "command": [
                        "by [].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "leq_trans",
            "line_nb": 71,
            "steps": [
                {
                    "command": [
                        "by move=>H1 H2 p x; apply: H2; apply: H1.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "leq_asym",
            "line_nb": 74,
            "steps": [
                {
                    "command": [
                        "move: e1 e2=>[m1 N1][m2 N2]; rewrite /leq /= => H1 H2.",
                        "VernacExtend",
                        "8261237f0cda1915a4077c28869831c5329103ce"
                    ]
                },
                {
                    "command": [
                        "by apply/stsepE/progE; apply: poset_asym H1 H2.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bot_spec",
            "line_nb": 80,
            "steps": [
                {
                    "command": [
                        "by move=>i H C t ->; apply: alw_unfin.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bot_bot",
            "line_nb": 84,
            "steps": [
                {
                    "command": [
                        "by case: e=>[[p U] H] t ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sup_spec",
            "line_nb": 89,
            "steps": [
                {
                    "command": [
                        "move=>i H C t [->|[e [H1 H2]]]; first by apply: alw_unfin.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by case: e H1 H2=>p H3 /= H4 _; apply: H3 H C _ H4.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sup_supB",
            "line_nb": 94,
            "steps": [
                {
                    "command": [
                        "by move=>H1 x H2; right; exists e.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sup_supL",
            "line_nb": 97,
            "steps": [
                {
                    "command": [
                        "by case: e; case=>m N H /= H1 t [->//|][T][H2]; move/H1; apply.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ret_has_spec",
            "line_nb": 131,
            "steps": [
                {
                    "command": [
                        "move=>i _ C t [->|->]; first by apply: alw_unfin.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by apply: alw_ret=>//= m E y [<-].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "act_has_spec",
            "line_nb": 145,
            "steps": [
                {
                    "command": [
                        "move=>i t S C [] -> /=; first by apply: alw_unfin.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "apply: alw_act C _; move=>j E1; move/S: (E1)=>pf; exists pf.",
                        "VernacExtend",
                        "3aa2c37caa1ec61ee662299c66b0e60249700d96"
                    ]
                },
                {
                    "command": [
                        "split=>// k y m St E2 v [<-]; exists j, k.",
                        "VernacExtend",
                        "a105052755410da2f211c2b4c63b728837d3287a"
                    ]
                },
                {
                    "command": [
                        "by split=>//; exists pf.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bind_has_spec",
            "line_nb": 166,
            "steps": [
                {
                    "command": [
                        "move=>i t [S1 S2] Ci [->|[t1 [Pc P1]]] /=; first by apply: alw_unfin.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "apply: aft_bnd Pc _; case: (code_of e1) P1=>T1 H /= P1.",
                        "VernacExtend",
                        "20ec428e50c31e1399aee62c5a532bc8417a4b29"
                    ]
                },
                {
                    "command": [
                        "apply: {H P1 Ci S1 T1 t t1} aft_imp (H _ _ S1 Ci P1).",
                        "VernacExtend",
                        "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
                    ]
                },
                {
                    "command": [
                        "move=>x s Cs S3 t; case: (code_of (e2 x))=>T /= H P.",
                        "VernacExtend",
                        "a01b3d93f426ff68d360351709a5fa5af822af32"
                    ]
                },
                {
                    "command": [
                        "by apply: aft_imp (H _ _ (S2 _ _ S3) Cs P)=>m y Cm; exists x, s.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "inject_has_spec",
            "line_nb": 186,
            "steps": [
                {
                    "command": [
                        "move=>i /= t [i1][j1][->{i}][Ci1 H1] C.",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "case=>[|[t' [H2 ->{t}]]]; first by move=>->; apply: alw_unfin.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "have : after i1 t' (s.2 i1) by case: (code_of e) H2=>p /= /(_ _ _ H1); apply.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "move/(aft_inject w C); apply: aft_imp=>{H1 t' H2} v m _.",
                        "VernacExtend",
                        "d6ebf3361f380a12d5c2c9bbb7ea363132c48b36"
                    ]
                },
                {
                    "command": [
                        "case=>i2 [j2][->{m} Ci2 S2 H2] i3 j3 E Ci3.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "suff [E1 E2]: i3 = i1 /\\ j3 = j1.",
                        "VernacExtend",
                        "d07fc8b2103f140554938023774bf3f75d04ba99"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "by rewrite {i3 E Ci3}E1 {j3}E2; exists i2, j2.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "move: (coh_prec (cohS C) Ci1 Ci3 E) (E)=>{Ci3 E} <-.",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "by move/(joinxK (cohS C)).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "conseq_refl",
            "line_nb": 228,
            "steps": [
                {
                    "command": [
                        "by case: e; case=>p q [T H i] /= Hp C t; apply: H.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "do_has_spec",
            "line_nb": 237,
            "steps": [
                {
                    "command": [
                        "rewrite /do_prog; case: e pf=>T Ht /=; case: s2=>p q.",
                        "VernacExtend",
                        "1418099f654a9d12bdfd561bac86adb846b83bfd"
                    ]
                },
                {
                    "command": [
                        "by move=>H1 i t /= Hp C H; apply: H1.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}