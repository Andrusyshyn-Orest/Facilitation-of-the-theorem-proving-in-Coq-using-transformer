{
    "filename": "mathcomp/ssreflect/path.v",
    "coq_project": "math-comp",
    "vernac_cmds": [
        [
            "Require Import mathcomp.ssreflect.ssreflect.",
            "VernacRequire",
            "85e251063dc2b5a9653f7bb76dcd176ed36b42a9"
        ],
        [
            "From mathcomp Require Import ssrfun ssrbool eqtype ssrnat seq.",
            "VernacRequire",
            "8545ccf335ab63fd28b87a2c32b12f2259513a2c"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Unset Strict Implicit.",
            "VernacUnsetOption",
            "2842adaf6959318f2042805935c46f513bdc0348"
        ],
        [
            "Unset Printing Implicit Defensive.",
            "VernacUnsetOption",
            "444e5f0be4b25d9b1fd556943a447ec10046d151"
        ],
        [
            "Section Paths.",
            "VernacBeginSection",
            "3110013cac08158d19802d0d34d7659eadae71d6"
        ],
        [
            "Variables (n0 : nat) (T : Type).",
            "VernacAssumption",
            "29998335e6c855dadd5f2bc72b16be4a0241b308"
        ],
        [
            "Section Path.",
            "VernacBeginSection",
            "dc04f1cea6cf3425cea4d603ebadf37bf3cce251"
        ],
        [
            "Variables (x0_cycle : T) (e : rel T).",
            "VernacAssumption",
            "12c36e88b8eaf9be35ddef1db20cfe945774d06f"
        ],
        [
            "Fixpoint path x (p : seq T) := if p is y :: p' then e x y && path y p' else true.",
            "VernacFixpoint",
            "6cd9e5b709c3968e0cead7fc0a12b51618935548"
        ],
        [
            "Lemma cat_path x p1 p2 : path x (p1 ++ p2) = path x p1 && path (last x p1) p2.",
            "VernacStartTheoremProof",
            "e3dcce0ba6b10091391a2602212a959149f70436"
        ],
        [
            "by elim: p1 x => [|y p1 Hrec] x //=; rewrite Hrec -!andbA.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma rcons_path x p y : path x (rcons p y) = path x p && e (last x p) y.",
            "VernacStartTheoremProof",
            "03d27846a20b57cf32ad186deb4f31a71f2bd5ec"
        ],
        [
            "by rewrite -cats1 cat_path /= andbT.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pathP x p x0 : reflect (forall i, i < size p -> e (nth x0 (x :: p) i) (nth x0 p i)) (path x p).",
            "VernacStartTheoremProof",
            "e958025e48731d058e9755aedb27ffcd24a53fd4"
        ],
        [
            "elim: p x => [|y p IHp] x /=; first by left.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "apply: (iffP andP) => [[e_xy /IHp e_p [] //] | e_p].",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "by split; [apply: (e_p 0) | apply/(IHp y) => i; apply: e_p i.+1].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition cycle p := if p is x :: p' then path x (rcons p' x) else true.",
            "VernacDefinition",
            "5a551d88cce37cc408bdee11eb9e0da0dcfc5eec"
        ],
        [
            "Lemma cycle_path p : cycle p = path (last x0_cycle p) p.",
            "VernacStartTheoremProof",
            "f7b5a1607e2d99649c0d1ac9850d2b77f03d87ee"
        ],
        [
            "by case: p => //= x p; rewrite rcons_path andbC.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma rot_cycle p : cycle (rot n0 p) = cycle p.",
            "VernacStartTheoremProof",
            "a750b3546cfbf1f39f5e72c336768ff03dee77ad"
        ],
        [
            "case: n0 p => [|n] [|y0 p] //=; first by rewrite /rot /= cats0.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite /rot /= -{3}(cat_take_drop n p) -cats1 -catA cat_path.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "case: (drop n p) => [|z0 q]; rewrite /= -cats1 !cat_path /= !andbT andbC //.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "by rewrite last_cat; repeat bool_congr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma rotr_cycle p : cycle (rotr n0 p) = cycle p.",
            "VernacStartTheoremProof",
            "56174a2ad849518d5c8bc716b7984f4ae4bf3190"
        ],
        [
            "by rewrite -rot_cycle rotrK.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Path.",
            "VernacEndSegment",
            "23a9d60f698de764e0a0c34039e40a5c183a28f9"
        ],
        [
            "Lemma eq_path e e' : e =2 e' -> path e =2 path e'.",
            "VernacStartTheoremProof",
            "803711235ce57a2cd0e2c096b81f7a040a6de2c1"
        ],
        [
            "by move=> ee' x p; elim: p x => //= y p IHp x; rewrite ee' IHp.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_cycle e e' : e =2 e' -> cycle e =1 cycle e'.",
            "VernacStartTheoremProof",
            "8729345f9dfd0018bcb3b9a8af51150bc9c7044d"
        ],
        [
            "by move=> ee' [|x p] //=; apply: eq_path.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sub_path e e' : subrel e e' -> forall x p, path e x p -> path e' x p.",
            "VernacStartTheoremProof",
            "e04237d2c59a2e0ce8c49de5dd82d637d887080c"
        ],
        [
            "by move=> ee' x p; elim: p x => //= y p IHp x /andP[/ee'-> /IHp].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma rev_path e x p : path e (last x p) (rev (belast x p)) = path (fun z => e^~ z) x p.",
            "VernacStartTheoremProof",
            "8f696654a867ccd5a9ea79e9cf5a0c788387565b"
        ],
        [
            "elim: p x => //= y p IHp x; rewrite rev_cons rcons_path -{}IHp andbC.",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "by rewrite -(last_cons x) -rev_rcons -lastI rev_cons last_rcons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Paths.",
            "VernacEndSegment",
            "0823da709099f7b60c7938b6caaadabfe986b3c2"
        ],
        [
            "Arguments pathP {T e x p}.",
            "VernacArguments",
            "5a99f4f5e7e85bcd23ac1232e51a204938c615dd"
        ],
        [
            "Section EqPath.",
            "VernacBeginSection",
            "141961a1aee6ea0ff68480ce1a39f41aeb87d913"
        ],
        [
            "Variables (n0 : nat) (T : eqType) (x0_cycle : T) (e : rel T).",
            "VernacAssumption",
            "a2e199a1e1b9405b4a9863154b46e2ac15d7f381"
        ],
        [
            "Implicit Type p : seq T.",
            "VernacReserve",
            "0479d26ea48838e28e3b38a49a5ff1d1a8be73c4"
        ],
        [
            "Variant split x : seq T -> seq T -> seq T -> Type := Split p1 p2 : split x (rcons p1 x ++ p2) p1 p2.",
            "VernacInductive",
            "e47d9e0d3d1a26ce6bd3cf9f76e469c1026f18e9"
        ],
        [
            "Lemma splitP p x (i := index x p) : x \\in p -> split x p (take i p) (drop i.+1 p).",
            "VernacStartTheoremProof",
            "61c18ef664d912384f6867de9fe8f393fa60f9dd"
        ],
        [
            "move=> p_x; have lt_ip: i < size p by rewrite index_mem.",
            "VernacExtend",
            "ccd83c252dcbae3d56f3d057fcb8217878b51901"
        ],
        [
            "by rewrite -{1}(cat_take_drop i p) (drop_nth x lt_ip) -cat_rcons nth_index.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Variant splitl x1 x : seq T -> Type := Splitl p1 p2 of last x1 p1 = x : splitl x1 x (p1 ++ p2).",
            "VernacInductive",
            "928dc09adf3d141eb67f6fafa1639c2494033bf3"
        ],
        [
            "Lemma splitPl x1 p x : x \\in x1 :: p -> splitl x1 x p.",
            "VernacStartTheoremProof",
            "0ff2af4dee4d003d90bad83afb8ca14daf62fa89"
        ],
        [
            "rewrite inE; case: eqP => [->| _ /splitP[]]; first by rewrite -(cat0s p).",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by split; apply: last_rcons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Variant splitr x : seq T -> Type := Splitr p1 p2 : splitr x (p1 ++ x :: p2).",
            "VernacInductive",
            "65c33f2c2b3f9d11328addd25972d3139bab6f62"
        ],
        [
            "Lemma splitPr p x : x \\in p -> splitr x p.",
            "VernacStartTheoremProof",
            "49c588fb96f25b317f75253d9ff4eebe86bd4a23"
        ],
        [
            "by case/splitP=> p1 p2; rewrite cat_rcons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint next_at x y0 y p := match p with | [::] => if x == y then y0 else x | y' :: p' => if x == y then y' else next_at x y0 y' p' end.",
            "VernacFixpoint",
            "20599dd0649a03795d503b29df4711a43f6ea9fc"
        ],
        [
            "Definition next p x := if p is y :: p' then next_at x y y p' else x.",
            "VernacDefinition",
            "99293e747d813769e1ce377ee8cfd1478a75bb36"
        ],
        [
            "Fixpoint prev_at x y0 y p := match p with | [::] => if x == y0 then y else x | y' :: p' => if x == y' then y else prev_at x y0 y' p' end.",
            "VernacFixpoint",
            "c06a825e6f0c38157ad91898293644a433879de6"
        ],
        [
            "Definition prev p x := if p is y :: p' then prev_at x y y p' else x.",
            "VernacDefinition",
            "2d12baf593a820df2a9ae84958548f1027aa2e55"
        ],
        [
            "Lemma next_nth p x : next p x = if x \\in p then if p is y :: p' then nth y p' (index x p) else x else x.",
            "VernacStartTheoremProof",
            "004d2cb5b87248c1e8b75e18099d069cfe55f26a"
        ],
        [
            "case: p => //= y0 p.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "elim: p {2 3 5}y0 => [|y' p IHp] y /=; rewrite (eq_sym y) inE; by case: ifP => // _; apply: IHp.",
            "VernacExtend",
            "244a9a5eebe0941cff21b86f46627271de195205"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma prev_nth p x : prev p x = if x \\in p then if p is y :: p' then nth y p (index x p') else x else x.",
            "VernacStartTheoremProof",
            "7515218e39dd3afc3f5020fda6f4faf225d10f73"
        ],
        [
            "case: p => //= y0 p; rewrite inE orbC.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "elim: p {2 5}y0 => [|y' p IHp] y; rewrite /= ?inE // (eq_sym y').",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "by case: ifP => // _; apply: IHp.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem_next p x : (next p x \\in p) = (x \\in p).",
            "VernacStartTheoremProof",
            "00e2df72efe3be5ec869cd163821c00a4525e93f"
        ],
        [
            "rewrite next_nth; case p_x: (x \\in p) => //.",
            "VernacExtend",
            "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
        ],
        [
            "case: p (index x p) p_x => [|y0 p'] //= i _; rewrite inE.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "have [lt_ip | ge_ip] := ltnP i (size p'); first by rewrite orbC mem_nth.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite nth_default ?eqxx.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem_prev p x : (prev p x \\in p) = (x \\in p).",
            "VernacStartTheoremProof",
            "787cefc2fc8c57abe0c8738332261489634a0c5a"
        ],
        [
            "rewrite prev_nth; case p_x: (x \\in p) => //; case: p => [|y0 p] // in p_x *.",
            "VernacExtend",
            "1418099f654a9d12bdfd561bac86adb846b83bfd"
        ],
        [
            "by apply mem_nth; rewrite /= ltnS index_size.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition ucycleb p := cycle e p && uniq p.",
            "VernacDefinition",
            "a2d30b8be9c969eb2819cafe774f508f4804f30a"
        ],
        [
            "Definition ucycle p : Prop := cycle e p && uniq p.",
            "VernacDefinition",
            "dbeca322128584783340e5f7052748d62a2ebbdc"
        ],
        [
            "Lemma ucycle_cycle p : ucycle p -> cycle e p.",
            "VernacStartTheoremProof",
            "6d439f178827fba03db41ed8b8b4305b2cb53760"
        ],
        [
            "by case/andP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ucycle_uniq p : ucycle p -> uniq p.",
            "VernacStartTheoremProof",
            "9c324d55199f958020018eb7ef20c96bc2b5899b"
        ],
        [
            "by case/andP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma next_cycle p x : cycle e p -> x \\in p -> e x (next p x).",
            "VernacStartTheoremProof",
            "e8a02454f2829f82fc7202630dbbb33ef697f0cc"
        ],
        [
            "case: p => //= y0 p; elim: p {1 3 5}y0 => [|z p IHp] y /=; rewrite inE.",
            "VernacExtend",
            "810b24f801b6f73dbb85b7524f481afcf2d89973"
        ],
        [
            "by rewrite andbT; case: (x =P y) => // ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by case/andP=> eyz /IHp; case: (x =P y) => // ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma prev_cycle p x : cycle e p -> x \\in p -> e (prev p x) x.",
            "VernacStartTheoremProof",
            "0fb4605c780e665eaf160a5286e755c4e47cb366"
        ],
        [
            "case: p => //= y0 p; rewrite inE orbC.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "elim: p {1 5}y0 => [|z p IHp] y /=; rewrite ?inE.",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "by rewrite andbT; case: (x =P y0) => // ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by case/andP=> eyz /IHp; case: (x =P z) => // ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma rot_ucycle p : ucycle (rot n0 p) = ucycle p.",
            "VernacStartTheoremProof",
            "bee1e24528e7fbf1921a36d5886ac07393d4f869"
        ],
        [
            "by rewrite /ucycle rot_uniq rot_cycle.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma rotr_ucycle p : ucycle (rotr n0 p) = ucycle p.",
            "VernacStartTheoremProof",
            "c4f9eb4c92d2dc915c5b1abf01a167484346f41b"
        ],
        [
            "by rewrite /ucycle rotr_uniq rotr_cycle.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition mem2 p x y := y \\in drop (index x p) p.",
            "VernacDefinition",
            "0ba69052102639f180979eceb22560342829297a"
        ],
        [
            "Lemma mem2l p x y : mem2 p x y -> x \\in p.",
            "VernacStartTheoremProof",
            "c6904f6c70f999977db233fb566d064a16df110a"
        ],
        [
            "by rewrite /mem2 -!index_mem size_drop ltn_subRL; apply/leq_ltn_trans/leq_addr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2lf {p x y} : x \\notin p -> mem2 p x y = false.",
            "VernacStartTheoremProof",
            "6779168757f5f480614361b9ef8336c98536a53b"
        ],
        [
            "exact/contraNF/mem2l.",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2r p x y : mem2 p x y -> y \\in p.",
            "VernacStartTheoremProof",
            "68993c0626c5a6119b97b20478859403891cd9e4"
        ],
        [
            "by rewrite -[in y \\in p](cat_take_drop (index x p) p) mem_cat orbC /mem2 => ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2rf {p x y} : y \\notin p -> mem2 p x y = false.",
            "VernacStartTheoremProof",
            "a6693577bf2cbfaa7b25efb6b4598f653116a9e6"
        ],
        [
            "exact/contraNF/mem2r.",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2_cat p1 p2 x y : mem2 (p1 ++ p2) x y = mem2 p1 x y || mem2 p2 x y || (x \\in p1) && (y \\in p2).",
            "VernacStartTheoremProof",
            "0f4ef49d2023e400fd5ea690ffd080934295ace6"
        ],
        [
            "rewrite [LHS]/mem2 index_cat fun_if if_arg !drop_cat addKn.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "case: ifPn => [p1x | /mem2lf->]; last by rewrite ltnNge leq_addr orbF.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite index_mem p1x mem_cat -orbA (orb_idl (@mem2r _ _ _)).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2_splice p1 p3 x y p2 : mem2 (p1 ++ p3) x y -> mem2 (p1 ++ p2 ++ p3) x y.",
            "VernacStartTheoremProof",
            "b334e3fe2fc7a4dd61f97e274227e64dc4933b0a"
        ],
        [
            "by rewrite !mem2_cat mem_cat andb_orr orbC => /or3P[]->; rewrite ?orbT.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2_splice1 p1 p3 x y z : mem2 (p1 ++ p3) x y -> mem2 (p1 ++ z :: p3) x y.",
            "VernacStartTheoremProof",
            "5b226bc296386d0b7ca372e6a0430a7feaf8dcb0"
        ],
        [
            "exact: mem2_splice [::z].",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2_cons x p y z : mem2 (x :: p) y z = (if x == y then z \\in x :: p else mem2 p y z).",
            "VernacStartTheoremProof",
            "5e9759061ef527e5057ea2e3aa15f171e6e23831"
        ],
        [
            "by rewrite [LHS]/mem2 /=; case: ifP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2_seq1 x y z : mem2 [:: x] y z = (y == x) && (z == x).",
            "VernacStartTheoremProof",
            "5e6c30a1e0efa59ea3aa9e8500b2181de40c49d4"
        ],
        [
            "by rewrite mem2_cons eq_sym inE.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2_last y0 p x : mem2 p x (last y0 p) = (x \\in p).",
            "VernacStartTheoremProof",
            "46d35ff4dc5ce64206a0830d252674bd1526c1a1"
        ],
        [
            "apply/idP/idP; first exact: mem2l; rewrite -index_mem /mem2 => p_x.",
            "VernacExtend",
            "58dba442af7e38d8e79d91f6dc3f45e6bb3c040b"
        ],
        [
            "by rewrite -nth_last -(subnKC p_x) -nth_drop mem_nth // size_drop subnSK.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2l_cat {p1 p2 x} : x \\notin p1 -> mem2 (p1 ++ p2) x =1 mem2 p2 x.",
            "VernacStartTheoremProof",
            "752811b4d8f5b95381ac984708071a0ed3bfdd21"
        ],
        [
            "by move=> p1'x y; rewrite mem2_cat (negPf p1'x) mem2lf ?orbF.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2r_cat {p1 p2 x y} : y \\notin p2 -> mem2 (p1 ++ p2) x y = mem2 p1 x y.",
            "VernacStartTheoremProof",
            "1c26d0165d3ffd8f2da226aed0e214281eff85ac"
        ],
        [
            "by move=> p2'y; rewrite mem2_cat (negPf p2'y) -orbA orbC andbF mem2rf.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem2lr_splice {p1 p2 p3 x y} : x \\notin p2 -> y \\notin p2 -> mem2 (p1 ++ p2 ++ p3) x y = mem2 (p1 ++ p3) x y.",
            "VernacStartTheoremProof",
            "65b148130b72730fa0e39b8e6be3d3b6757ff13d"
        ],
        [
            "move=> p2'x p2'y; rewrite catA !mem2_cat !mem_cat.",
            "VernacExtend",
            "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
        ],
        [
            "by rewrite (negPf p2'x) (negPf p2'y) (mem2lf p2'x) andbF !orbF.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Variant split2r x y : seq T -> Type := Split2r p1 p2 of y \\in x :: p2 : split2r x y (p1 ++ x :: p2).",
            "VernacInductive",
            "591ec7741833d06ee310533472383de4146f4b32"
        ],
        [
            "Lemma splitP2r p x y : mem2 p x y -> split2r x y p.",
            "VernacStartTheoremProof",
            "70ce3cfa0c148e85f0ee7ad1b9528dfb6c623616"
        ],
        [
            "move=> pxy; have px := mem2l pxy.",
            "VernacExtend",
            "ccd83c252dcbae3d56f3d057fcb8217878b51901"
        ],
        [
            "have:= pxy; rewrite /mem2 (drop_nth x) ?index_mem ?nth_index //.",
            "VernacExtend",
            "aa9d5fbc682ed874cd64b2543ca6c859b978e924"
        ],
        [
            "by case/splitP: px => p1 p2; rewrite cat_rcons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint shorten x p := if p is y :: p' then if x \\in p then shorten x p' else y :: shorten y p' else [::].",
            "VernacFixpoint",
            "f78ddd105a981cd5851d038858b2d27c08c9c0ae"
        ],
        [
            "Variant shorten_spec x p : T -> seq T -> Type := ShortenSpec p' of path e x p' & uniq (x :: p') & subpred (mem p') (mem p) : shorten_spec x p (last x p') p'.",
            "VernacInductive",
            "847bd803e0794333a8cef6cd464246e25cb560c3"
        ],
        [
            "Lemma shortenP x p : path e x p -> shorten_spec x p (last x p) (shorten x p).",
            "VernacStartTheoremProof",
            "451ab09c9a29bfda6c279120f03f23c9f8b8d54c"
        ],
        [
            "move=> e_p; have: x \\in x :: p by apply: mem_head.",
            "VernacExtend",
            "ccd83c252dcbae3d56f3d057fcb8217878b51901"
        ],
        [
            "elim: p x {1 3 5}x e_p => [|y2 p IHp] x y1.",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "by rewrite mem_seq1 => _ /eqP->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "rewrite inE orbC /= => /andP[ey12 /IHp {IHp}IHp].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "case: ifPn => [y2p_x _ | not_y2p_x /eqP def_x].",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "have [p' e_p' Up' p'p] := IHp _ y2p_x.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "by split=> // y /p'p; apply: predU1r.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "have [p' e_p' Up' p'p] := IHp y2 (mem_head y2 p).",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "have{p'p} p'p z: z \\in y2 :: p' -> z \\in y2 :: p.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "by rewrite !inE; case: (z == y2) => // /p'p.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "rewrite -(last_cons y1) def_x; split=> //=; first by rewrite ey12.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite (contra (p'p y1)) -?def_x.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End EqPath.",
            "VernacEndSegment",
            "af1a7744dce10fb33758b420e37929e5a2b40e2e"
        ],
        [
            "Section SortSeq.",
            "VernacBeginSection",
            "680d784794e4e54cb99e452b56aa25d66a654336"
        ],
        [
            "Variable T : eqType.",
            "VernacAssumption",
            "2ceeb4536776ca324e5be084d2deb4d476694ef1"
        ],
        [
            "Variable leT : rel T.",
            "VernacAssumption",
            "177ffd109c1402735d694a1fd5f5d2dbff3c0b2a"
        ],
        [
            "Definition sorted s := if s is x :: s' then path leT x s' else true.",
            "VernacDefinition",
            "82287b09e70c02d26172d2141f89f15b0b1df3fd"
        ],
        [
            "Lemma path_sorted x s : path leT x s -> sorted s.",
            "VernacStartTheoremProof",
            "0f0729e80aa07b317ebac18c369459a5e1377708"
        ],
        [
            "by case: s => //= y s /andP[].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma path_min_sorted x s : {in s, forall y, leT x y} -> path leT x s = sorted s.",
            "VernacStartTheoremProof",
            "c570ddce7ac78c010178da9575087d539ed77ee7"
        ],
        [
            "by case: s => //= y s -> //; apply: mem_head.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Section Transitive.",
            "VernacBeginSection",
            "dee2646dc4aefa61baf899403e528c1318bbbadc"
        ],
        [
            "Hypothesis leT_tr : transitive leT.",
            "VernacAssumption",
            "4855ff33a4adac6bd6c86b233d0e852d000141d0"
        ],
        [
            "Lemma subseq_order_path x s1 s2 : subseq s1 s2 -> path leT x s2 -> path leT x s1.",
            "VernacStartTheoremProof",
            "21998d616984d9ec3608ee0faeafd69f8331dd7f"
        ],
        [
            "elim: s2 x s1 => [|y s2 IHs] x [|z s1] //= {IHs}/(IHs y).",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "case: eqP => [-> | _] IHs /andP[] => [-> // | leTxy /IHs /=].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "by case/andP=> /(leT_tr leTxy)->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma order_path_min x s : path leT x s -> all (leT x) s.",
            "VernacStartTheoremProof",
            "219d2341c6fbac3092833d020b1a8b433f9939af"
        ],
        [
            "move/subseq_order_path=> le_x_s; apply/allP=> y.",
            "VernacExtend",
            "d6ebf3361f380a12d5c2c9bbb7ea363132c48b36"
        ],
        [
            "by rewrite -sub1seq => /le_x_s/andP[].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma subseq_sorted s1 s2 : subseq s1 s2 -> sorted s2 -> sorted s1.",
            "VernacStartTheoremProof",
            "fa40322f7a541f6d91c0085a7c350e9746216f8d"
        ],
        [
            "case: s1 s2 => [|x1 s1] [|x2 s2] //= sub_s12 /(subseq_order_path sub_s12).",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "by case: eqP => [-> | _ /andP[]].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sorted_filter a s : sorted s -> sorted (filter a s).",
            "VernacStartTheoremProof",
            "5445a169735246e895170099a643044061641fd5"
        ],
        [
            "exact: subseq_sorted (filter_subseq a s).",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sorted_uniq : irreflexive leT -> forall s, sorted s -> uniq s.",
            "VernacStartTheoremProof",
            "46ea8a13e329dd168b13773bfb0b9874357326f6"
        ],
        [
            "move=> leT_irr; elim=> //= x s IHs s_ord.",
            "VernacExtend",
            "06880003f1108b2eb418688c7bc6bf1013cf0e4c"
        ],
        [
            "rewrite (IHs (path_sorted s_ord)) andbT; apply/negP=> s_x.",
            "VernacExtend",
            "634a7639ed2fb7caf62757f84400927f5829b7d5"
        ],
        [
            "by case/allPn: (order_path_min s_ord); exists x; rewrite // leT_irr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_sorted : antisymmetric leT -> forall s1 s2, sorted s1 -> sorted s2 -> perm_eq s1 s2 -> s1 = s2.",
            "VernacStartTheoremProof",
            "37468b3b87901d0d533df5f00a6ffa079f1fc366"
        ],
        [
            "move=> leT_asym; elim=> [|x1 s1 IHs1] s2 //= ord_s1 ord_s2 eq_s12.",
            "VernacExtend",
            "06880003f1108b2eb418688c7bc6bf1013cf0e4c"
        ],
        [
            "by case: {+}s2 (perm_eq_size eq_s12).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "have s2_x1: x1 \\in s2 by rewrite -(perm_eq_mem eq_s12) mem_head.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "case: s2 s2_x1 eq_s12 ord_s2 => //= x2 s2; rewrite in_cons.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "case: eqP => [<- _| ne_x12 /= s2_x1] eq_s12 ord_s2.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "by rewrite {IHs1}(IHs1 s2) ?(@path_sorted x1) // -(perm_cons x1).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "case: (ne_x12); apply: leT_asym; rewrite (allP (order_path_min ord_s2)) //.",
            "VernacExtend",
            "db5c0dcae9fc8f6605ec5d5bf559f9684231fcd6"
        ],
        [
            "have: x2 \\in x1 :: s1 by rewrite (perm_eq_mem eq_s12) mem_head.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "case/predU1P=> [eq_x12 | s1_x2]; first by case ne_x12.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite (allP (order_path_min ord_s1)).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_sorted_irr : irreflexive leT -> forall s1 s2, sorted s1 -> sorted s2 -> s1 =i s2 -> s1 = s2.",
            "VernacStartTheoremProof",
            "8bf41fe7329658941283daa0c6632ecd75abd0da"
        ],
        [
            "move=> leT_irr s1 s2 s1_sort s2_sort eq_s12.",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "have: antisymmetric leT.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "by move=> m n /andP[? ltnm]; case/idP: (leT_irr m); apply: leT_tr ltnm.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by move/eq_sorted; apply=> //; apply: uniq_perm_eq => //; apply: sorted_uniq.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Transitive.",
            "VernacEndSegment",
            "6a3dc6bd3231ad3af04e195eb421db64307bc060"
        ],
        [
            "Hypothesis leT_total : total leT.",
            "VernacAssumption",
            "1960e4ab016480c5519dae3202fe0a6e502a5ef7"
        ],
        [
            "Fixpoint merge s1 := if s1 is x1 :: s1' then let fix merge_s1 s2 := if s2 is x2 :: s2' then if leT x2 x1 then x2 :: merge_s1 s2' else x1 :: merge s1' s2 else s1 in merge_s1 else id.",
            "VernacFixpoint",
            "0e55a8d85aaedc450c2c814d75987bfcf77422d3"
        ],
        [
            "Lemma merge_path x s1 s2 : path leT x s1 -> path leT x s2 -> path leT x (merge s1 s2).",
            "VernacStartTheoremProof",
            "424b2d7e1710ae3c5b369cf51af5e8e717cd5aa2"
        ],
        [
            "elim: s1 s2 x => //= x1 s1 IHs1.",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "elim=> //= x2 s2 IHs2 x /andP[le_x_x1 ord_s1] /andP[le_x_x2 ord_s2].",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "case: ifP => le_x21 /=; first by rewrite le_x_x2 {}IHs2 // le_x21.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite le_x_x1 IHs1 //=; have:= leT_total x2 x1; rewrite le_x21 /= => ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma merge_sorted s1 s2 : sorted s1 -> sorted s2 -> sorted (merge s1 s2).",
            "VernacStartTheoremProof",
            "0b3a7bc4f7984d4edcf5752804ec844f53ac79f4"
        ],
        [
            "case: s1 s2 => [|x1 s1] [|x2 s2] //= ord_s1 ord_s2.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "case: ifP => le_x21 /=.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "by apply: (@merge_path x2 (x1 :: s1)) => //=; rewrite le_x21.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by apply: merge_path => //=; have:= leT_total x2 x1; rewrite le_x21 /= => ->.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma perm_merge s1 s2 : perm_eql (merge s1 s2) (s1 ++ s2).",
            "VernacStartTheoremProof",
            "99421ec029c9b7ccb22e7afc4540631e76a9b97e"
        ],
        [
            "apply/perm_eqlP; rewrite perm_eq_sym; elim: s1 s2 => //= x1 s1 IHs1.",
            "VernacExtend",
            "50460284180dcd83c121bd2e598800c155f096bd"
        ],
        [
            "elim=> [|x2 s2 IHs2]; rewrite /= ?cats0 //.",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "case: ifP => _ /=; last by rewrite perm_cons.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite (perm_catCA (_ :: _) [::x2]) perm_cons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem_merge s1 s2 : merge s1 s2 =i s1 ++ s2.",
            "VernacStartTheoremProof",
            "e0722535c4e2a5e335f4bb480b04134241dac348"
        ],
        [
            "by apply: perm_eq_mem; rewrite perm_merge.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma size_merge s1 s2 : size (merge s1 s2) = size (s1 ++ s2).",
            "VernacStartTheoremProof",
            "07c22519ff6fd26fafc47d86f7be0b1b101d1a83"
        ],
        [
            "by apply: perm_eq_size; rewrite perm_merge.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma merge_uniq s1 s2 : uniq (merge s1 s2) = uniq (s1 ++ s2).",
            "VernacStartTheoremProof",
            "83fa9818fafc5466e1ac7280e43d60ad4b26a329"
        ],
        [
            "by apply: perm_eq_uniq; rewrite perm_merge.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint merge_sort_push s1 ss := match ss with | [::] :: ss' | [::] as ss' => s1 :: ss' | s2 :: ss' => [::] :: merge_sort_push (merge s1 s2) ss' end.",
            "VernacFixpoint",
            "af37d1c97e669b9bd87455266a571dea1fc9264f"
        ],
        [
            "Fixpoint merge_sort_pop s1 ss := if ss is s2 :: ss' then merge_sort_pop (merge s1 s2) ss' else s1.",
            "VernacFixpoint",
            "1860c756d61523d4fba9c7b16b9a27d079bfdd2f"
        ],
        [
            "Fixpoint merge_sort_rec ss s := if s is [:: x1, x2 & s'] then let s1 := if leT x1 x2 then [:: x1; x2] else [:: x2; x1] in merge_sort_rec (merge_sort_push s1 ss) s' else merge_sort_pop s ss.",
            "VernacFixpoint",
            "9ea68e90753bb118a102c016ea4636fc32e0ce3c"
        ],
        [
            "Definition sort := merge_sort_rec [::].",
            "VernacDefinition",
            "45d27781c5478de696f4f1dd9e0c0c7c2c9ad10c"
        ],
        [
            "Lemma sort_sorted s : sorted (sort s).",
            "VernacStartTheoremProof",
            "02d1178c6e948acdc11044d10ba1b350c07c32c2"
        ],
        [
            "rewrite /sort; have allss: all sorted [::] by [].",
            "VernacExtend",
            "7be6e3cf9ccbce33486c4b5c6fefdf7a9ad6e52b"
        ],
        [
            "elim: {s}_.+1 {-2}s [::] allss (ltnSn (size s)) => // n IHn s ss allss.",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "have: sorted s -> sorted (merge_sort_pop s ss).",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "elim: ss allss s => //= s2 ss IHss /andP[ord_s2 ord_ss] s ord_s.",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "exact: IHss ord_ss _ (merge_sorted ord_s ord_s2).",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "case: s => [|x1 [|x2 s _]]; try by auto.",
            "VernacExtend",
            "700e4ba7c43aef376de752aa78d70ea0bf66a54e"
        ],
        [
            "move/ltnW/IHn; apply=> {n IHn s}; set s1 := if _ then _ else _.",
            "VernacExtend",
            "087c3b66226a45d8597d03f3e4b691c28cc161ee"
        ],
        [
            "have: sorted s1 by apply: (@merge_sorted [::x2] [::x1]).",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "elim: ss {x1 x2}s1 allss => /= [|s2 ss IHss] s1; first by rewrite andbT.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "case/andP=> ord_s2 ord_ss ord_s1.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "by case: {1}s2=> /= [|_ _]; [rewrite ord_s1 | apply: IHss (merge_sorted _ _)].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma perm_sort s : perm_eql (sort s) s.",
            "VernacStartTheoremProof",
            "e4e6ec8fb1011d86a0c039ab6cdc53d82828cfa8"
        ],
        [
            "rewrite /sort; apply/perm_eqlP; pose catss := foldr (@cat T) [::].",
            "VernacExtend",
            "8dca88d8134ba32975a9e41c7aca850566c32729"
        ],
        [
            "rewrite perm_eq_sym -{1}[s]/(catss [::] ++ s).",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "elim: {s}_.+1 {-2}s [::] (ltnSn (size s)) => // n IHn s ss.",
            "VernacExtend",
            "e686a1895f1799b840b76242f931100819a9ad6c"
        ],
        [
            "have: perm_eq (catss ss ++ s) (merge_sort_pop s ss).",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "elim: ss s => //= s2 ss IHss s1; rewrite -{IHss}(perm_eqrP (IHss _)).",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "by rewrite perm_catC catA perm_catC perm_cat2l -perm_merge.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "case: s => // x1 [//|x2 s _]; move/ltnW; move/IHn=> {n IHn}IHs.",
            "VernacExtend",
            "ad9703cddf270cbbe68f7e9fd9d34355dc053bfe"
        ],
        [
            "rewrite -{IHs}(perm_eqrP (IHs _)) ifE; set s1 := if_expr _ _ _.",
            "VernacExtend",
            "c1f58f36c5711f022b4a54717f37c2782f34a159"
        ],
        [
            "rewrite (catA _ [:: _; _] s) {s}perm_cat2r.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "apply: (@perm_eq_trans _ (catss ss ++ s1)).",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "by rewrite perm_cat2l /s1 -ifE; case: ifP; rewrite // (perm_catC [:: _]).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "elim: ss {x1 x2}s1 => /= [|s2 ss IHss] s1; first by rewrite cats0.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite perm_catC; case def_s2: {2}s2=> /= [|y s2']; first by rewrite def_s2.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite catA -{IHss}(perm_eqrP (IHss _)) perm_catC perm_cat2l -perm_merge.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma mem_sort s : sort s =i s.",
            "VernacStartTheoremProof",
            "708d96199a6f00002b3c524871a0988d0c125cf4"
        ],
        [
            "by apply: perm_eq_mem; rewrite perm_sort.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma size_sort s : size (sort s) = size s.",
            "VernacStartTheoremProof",
            "fc62d1b3f9b966ba916c73100d104860998a97b3"
        ],
        [
            "by apply: perm_eq_size; rewrite perm_sort.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sort_uniq s : uniq (sort s) = uniq s.",
            "VernacStartTheoremProof",
            "cc7e404c75454de45798bc9a5bb3d9043c8acb93"
        ],
        [
            "by apply: perm_eq_uniq; rewrite perm_sort.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma perm_sortP : transitive leT -> antisymmetric leT -> forall s1 s2, reflect (sort s1 = sort s2) (perm_eq s1 s2).",
            "VernacStartTheoremProof",
            "3df4f719628d2b9825daaea19fc6182157674a45"
        ],
        [
            "move=> leT_tr leT_asym s1 s2.",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "apply: (iffP idP) => eq12; last by rewrite -perm_sort eq12 perm_sort.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "apply: eq_sorted; rewrite ?sort_sorted //.",
            "VernacExtend",
            "56c014161b39aecfb3c54301c2409dba4e8e1857"
        ],
        [
            "by rewrite perm_sort (perm_eqlP eq12) -perm_sort.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End SortSeq.",
            "VernacEndSegment",
            "17b9db9b1bae60dde0566e79ea8b8229965879e7"
        ],
        [
            "Lemma rev_sorted (T : eqType) (leT : rel T) s : sorted leT (rev s) = sorted (fun y x => leT x y) s.",
            "VernacStartTheoremProof",
            "adc5e59a7ebd6eb87093a5486c61702e56547f62"
        ],
        [
            "by case: s => //= x p; rewrite -rev_path lastI rev_rcons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ltn_sorted_uniq_leq s : sorted ltn s = uniq s && sorted leq s.",
            "VernacStartTheoremProof",
            "f184a721253f1d0764de408dc339dee76d0478a8"
        ],
        [
            "case: s => //= n s; elim: s n => //= m s IHs n.",
            "VernacExtend",
            "1821533cafd21deefc2f797d67a58b45e0a54e79"
        ],
        [
            "rewrite inE ltn_neqAle negb_or IHs -!andbA.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "case sn: (n \\in s); last do !bool_congr.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite andbF; apply/and5P=> [[ne_nm lenm _ _ le_ms]]; case/negP: ne_nm.",
            "VernacExtend",
            "e653a755ab5d693b79348e5a2832d3e386fea3c7"
        ],
        [
            "by rewrite eqn_leq lenm; apply: (allP (order_path_min leq_trans le_ms)).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma iota_sorted i n : sorted leq (iota i n).",
            "VernacStartTheoremProof",
            "f75866a94605f2744d93515b9c5a353a7a6e407a"
        ],
        [
            "by elim: n i => // [[|n] //= IHn] i; rewrite IHn leqW.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma iota_ltn_sorted i n : sorted ltn (iota i n).",
            "VernacStartTheoremProof",
            "268a2d2c9cf2457e5b0ac41d6ebf88f5ecd63913"
        ],
        [
            "by rewrite ltn_sorted_uniq_leq iota_sorted iota_uniq.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Notation fpath f := (path (coerced_frel f)).",
            "VernacSyntacticDefinition",
            "e3733dc010dc4875f96f49e4f61728b87a584610"
        ],
        [
            "Notation fcycle f := (cycle (coerced_frel f)).",
            "VernacSyntacticDefinition",
            "fe5bfab8854570b3b2c679b44403669b80eb42dd"
        ],
        [
            "Notation ufcycle f := (ucycle (coerced_frel f)).",
            "VernacSyntacticDefinition",
            "8f228553b09312d2e0f53f3d94e0c59b3e76744c"
        ],
        [
            "Prenex Implicits path next prev cycle ucycle mem2.",
            "VernacExtend",
            "6603ef03b5423a775b6c1cd8d40fed8734faccc7"
        ],
        [
            "Section Trajectory.",
            "VernacBeginSection",
            "6c5854cf3ebc036e5337eff8b43fc6b511118920"
        ],
        [
            "Variables (T : Type) (f : T -> T).",
            "VernacAssumption",
            "db1a8b51c49b69508412be78d68431023f5600a5"
        ],
        [
            "Fixpoint traject x n := if n is n'.+1 then x :: traject (f x) n' else [::].",
            "VernacFixpoint",
            "baadff8f25c84f38a822960478e7f721b717425e"
        ],
        [
            "Lemma trajectS x n : traject x n.+1 = x :: traject (f x) n.",
            "VernacStartTheoremProof",
            "029fb78558b2dc911f7038c28b722500f82f0bd1"
        ],
        [
            "by [].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma trajectSr x n : traject x n.+1 = rcons (traject x n) (iter n f x).",
            "VernacStartTheoremProof",
            "87dd2b6f1ec2fbdaf280a6ed33b0904b245c8a0a"
        ],
        [
            "by elim: n x => //= n IHn x; rewrite IHn -iterSr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma last_traject x n : last x (traject (f x) n) = iter n f x.",
            "VernacStartTheoremProof",
            "2bca138dfba92bc0da97e8340626681449701910"
        ],
        [
            "by case: n => // n; rewrite iterSr trajectSr last_rcons.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma traject_iteri x n : traject x n = iteri n (fun i => rcons^~ (iter i f x)) [::].",
            "VernacStartTheoremProof",
            "e5b3b901c76c6b622095ceaa2e5920b446f1a190"
        ],
        [
            "by elim: n => //= n <-; rewrite -trajectSr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma size_traject x n : size (traject x n) = n.",
            "VernacStartTheoremProof",
            "65519eda06a128568e3cc9d24ef4261f4519aa3d"
        ],
        [
            "by elim: n x => //= n IHn x //=; rewrite IHn.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma nth_traject i n : i < n -> forall x, nth x (traject x n) i = iter i f x.",
            "VernacStartTheoremProof",
            "2c7aa01fb3a704da446c8b2d69d1871443bec739"
        ],
        [
            "elim: n => // n IHn; rewrite ltnS leq_eqVlt => le_i_n x.",
            "VernacExtend",
            "5c0d3b68844697b312245da3ed2c1b277720f6af"
        ],
        [
            "rewrite trajectSr nth_rcons size_traject.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "by case: ltngtP le_i_n => [? _||->] //; apply: IHn.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Trajectory.",
            "VernacEndSegment",
            "59e6b05c99a5031e17d503f451b4049f5b8e92d7"
        ],
        [
            "Section EqTrajectory.",
            "VernacBeginSection",
            "d8c0920abf185bb9d22a96b22d83d03a64c7b704"
        ],
        [
            "Variables (T : eqType) (f : T -> T).",
            "VernacAssumption",
            "75a755f85d911b922b991a8c6bd01615c43dfbd4"
        ],
        [
            "Lemma eq_fpath f' : f =1 f' -> fpath f =2 fpath f'.",
            "VernacStartTheoremProof",
            "53929eeef237598a3e9b9a5bfc19dcb75300b6ec"
        ],
        [
            "by move/eq_frel/eq_path.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_fcycle f' : f =1 f' -> fcycle f =1 fcycle f'.",
            "VernacStartTheoremProof",
            "9a086a24c4de7b71dae361e105c3f4bbdb9793e7"
        ],
        [
            "by move/eq_frel/eq_cycle.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma fpathP x p : reflect (exists n, p = traject f (f x) n) (fpath f x p).",
            "VernacStartTheoremProof",
            "012f1196ba8a920afbd0b5a0a328ee1d13a82851"
        ],
        [
            "elim: p x => [|y p IHp] x; first by left; exists 0.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite /= andbC; case: IHp => [fn_p | not_fn_p]; last first.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by right=> [] [[//|n]] [<- fn_p]; case: not_fn_p; exists n.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "apply: (iffP eqP) => [-> | [[] // _ []//]].",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "by have [n ->] := fn_p; exists n.+1.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma fpath_traject x n : fpath f x (traject f (f x) n).",
            "VernacStartTheoremProof",
            "4c9f62fd2e260f93d4229729460df395a95b4e33"
        ],
        [
            "by apply/(fpathP x); exists n.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition looping x n := iter n f x \\in traject f x n.",
            "VernacDefinition",
            "97b300628ca6c2f63f30c7165142646eb0e7814c"
        ],
        [
            "Lemma loopingP x n : reflect (forall m, iter m f x \\in traject f x n) (looping x n).",
            "VernacStartTheoremProof",
            "5a0e490799bd95eb9491b83d0fb53b6a0e62dd82"
        ],
        [
            "apply: (iffP idP) => loop_n; last exact: loop_n.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "case: n => // n in loop_n *; elim=> [|m /= IHm]; first exact: mem_head.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "move: (fpath_traject x n) loop_n; rewrite /looping !iterS -last_traject /=.",
            "VernacExtend",
            "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
        ],
        [
            "move: (iter m f x) IHm => y /splitPl[p1 p2 def_y].",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "rewrite cat_path last_cat def_y; case: p2 => // z p2 /and3P[_ /eqP-> _] _.",
            "VernacExtend",
            "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
        ],
        [
            "by rewrite inE mem_cat mem_head !orbT.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma trajectP x n y : reflect (exists2 i, i < n & y = iter i f x) (y \\in traject f x n).",
            "VernacStartTheoremProof",
            "7ee6dfa8e4208e967dfb241be0d8494dea78d469"
        ],
        [
            "elim: n x => [|n IHn] x /=; first by right; case.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite inE; have [-> | /= neq_xy] := eqP; first by left; exists 0.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "apply: {IHn}(iffP (IHn _)) => [[i] | [[|i]]] // lt_i_n ->.",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "by exists i.+1; rewrite ?iterSr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by exists i; rewrite ?iterSr.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma looping_uniq x n : uniq (traject f x n.+1) = ~~ looping x n.",
            "VernacStartTheoremProof",
            "24ea19cc29893dc1cb0e2995a578a9e26442796e"
        ],
        [
            "rewrite /looping; elim: n x => [|n IHn] x //.",
            "VernacExtend",
            "44a8e3b453c9376c468b4e3e0046f5ac33e11d6d"
        ],
        [
            "rewrite {-3}[n.+1]lock /= -lock {}IHn -iterSr -negb_or inE; congr (~~ _).",
            "VernacExtend",
            "a0279e71fd23ac6bde2b8b4402981a70ea719044"
        ],
        [
            "apply: orb_id2r => /trajectP no_loop.",
            "VernacExtend",
            "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
        ],
        [
            "apply/idP/eqP => [/trajectP[m le_m_n def_x] | {1}<-]; last first.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite iterSr -last_traject mem_last.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "have loop_m: looping x m.+1 by rewrite /looping iterSr -def_x mem_head.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "have/trajectP[[|i] // le_i_m def_fn1x] := loopingP _ _ loop_m n.+1.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "by case: no_loop; exists i; rewrite -?iterSr // -ltnS (leq_trans le_i_m).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End EqTrajectory.",
            "VernacEndSegment",
            "024292f85de8df1e3929e6b6c502a268463ce8bb"
        ],
        [
            "Arguments fpathP {T f x p}.",
            "VernacArguments",
            "30b4582774e3b33e4a8c2d0fe7bee9554e549987"
        ],
        [
            "Arguments loopingP {T f x n}.",
            "VernacArguments",
            "dfa17422f101282cbc5d5f60c2c07b1697c7eb80"
        ],
        [
            "Arguments trajectP {T f x n y}.",
            "VernacArguments",
            "e72c3db9f407b0839f90fb9627f55fd8c4c5e1c5"
        ],
        [
            "Prenex Implicits traject.",
            "VernacExtend",
            "6158aa6663c8558875c8a36c65752e21266c8856"
        ],
        [
            "Section UniqCycle.",
            "VernacBeginSection",
            "0a70dfbde1de1b5d1a8fa4bcd550e80e04fbeadb"
        ],
        [
            "Variables (n0 : nat) (T : eqType) (e : rel T) (p : seq T).",
            "VernacAssumption",
            "2b3efa321ccbe6ec9761bcb333540aa249cbcf42"
        ],
        [
            "Hypothesis Up : uniq p.",
            "VernacAssumption",
            "36f5d1a87760f7c6ae71e1567fea0a4957bd2378"
        ],
        [
            "Lemma prev_next : cancel (next p) (prev p).",
            "VernacStartTheoremProof",
            "01ae0b162aee78e793676cd7bbe730864189d1bb"
        ],
        [
            "move=> x; rewrite prev_nth mem_next next_nth; case p_x: (x \\in p) => //.",
            "VernacExtend",
            "d7214ac8fd48f4d1cd143edd9d16f6d28386a302"
        ],
        [
            "case def_p: p Up p_x => // [y q]; rewrite -{-1}def_p => /= /andP[not_qy Uq] p_x.",
            "VernacExtend",
            "ba44c9d0281a02110ce54645304e6d990debd9c0"
        ],
        [
            "rewrite -{2}(nth_index y p_x); congr (nth y _ _); set i := index x p.",
            "VernacExtend",
            "c32c5ac311e3847dc87621ff9971372f5f613e0c"
        ],
        [
            "have: ~~ (size q < i) by rewrite -index_mem -/i def_p leqNgt in p_x.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "case: ltngtP => // [lt_i_q | ->] _; first by rewrite index_uniq.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by apply/eqP; rewrite nth_default // eqn_leq index_size leqNgt index_mem.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma next_prev : cancel (prev p) (next p).",
            "VernacStartTheoremProof",
            "9f5d376532c9fc0248643b239fa826dcca0a58a0"
        ],
        [
            "move=> x; rewrite next_nth mem_prev prev_nth; case p_x: (x \\in p) => //.",
            "VernacExtend",
            "d7214ac8fd48f4d1cd143edd9d16f6d28386a302"
        ],
        [
            "case def_p: p p_x => // [y q]; rewrite -def_p => p_x.",
            "VernacExtend",
            "ba44c9d0281a02110ce54645304e6d990debd9c0"
        ],
        [
            "rewrite index_uniq //; last by rewrite def_p ltnS index_size.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "case q_x: (x \\in q); first exact: nth_index.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite nth_default; last by rewrite leqNgt index_mem q_x.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by apply/eqP; rewrite def_p inE q_x orbF eq_sym in p_x.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma cycle_next : fcycle (next p) p.",
            "VernacStartTheoremProof",
            "bed1267ba1344550ebb0a057ccc74192840016a9"
        ],
        [
            "case def_p: {-2}p Up => [|x q] Uq //.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "apply/(pathP x)=> i; rewrite size_rcons => le_i_q.",
            "VernacExtend",
            "5fce7e5361004176d6b434b36b4623c7387f70bb"
        ],
        [
            "rewrite -cats1 -cat_cons nth_cat le_i_q /= next_nth {}def_p mem_nth //.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "rewrite index_uniq // nth_cat /= ltn_neqAle andbC -ltnS le_i_q.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "by case: (i =P _) => //= ->; rewrite subnn nth_default.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma cycle_prev : cycle (fun x y => x == prev p y) p.",
            "VernacStartTheoremProof",
            "67273017919c8bd4c6f969d8f469528f668f2692"
        ],
        [
            "apply: etrans cycle_next; symmetry; case def_p: p => [|x q] //.",
            "VernacExtend",
            "f91c4a8f7dbfb8ccfc52f8866c2d83ba6c30e84f"
        ],
        [
            "by apply: eq_path; rewrite -def_p; apply: (can2_eq prev_next next_prev).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma cycle_from_next : (forall x, x \\in p -> e x (next p x)) -> cycle e p.",
            "VernacStartTheoremProof",
            "2de9866aa783f2c87e707601efd58bbd0ec9cde4"
        ],
        [
            "case: p (next p) cycle_next => //= [x q] n; rewrite -(belast_rcons x q x).",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "move: {q}(rcons q x) => q n_q; move/allP.",
            "VernacExtend",
            "8b784377bdc4d565ff66d4cf36a6041e9354c156"
        ],
        [
            "by elim: q x n_q => //= _ q IHq x /andP[/eqP <- n_q] /andP[-> /IHq->].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma cycle_from_prev : (forall x, x \\in p -> e (prev p x) x) -> cycle e p.",
            "VernacStartTheoremProof",
            "ef4c2b313c348bdd0a00e69fc8d9118dbd031485"
        ],
        [
            "move=> e_p; apply: cycle_from_next => x p_x.",
            "VernacExtend",
            "d6ebf3361f380a12d5c2c9bbb7ea363132c48b36"
        ],
        [
            "by rewrite -{1}[x]prev_next e_p ?mem_next.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma next_rot : next (rot n0 p) =1 next p.",
            "VernacStartTheoremProof",
            "499e082e038d9b9bdc83b41d248870432187f63d"
        ],
        [
            "move=> x; have n_p := cycle_next; rewrite -(rot_cycle n0) in n_p.",
            "VernacExtend",
            "7cbc77a1e43ca1454debc28656b2dec3869cf69b"
        ],
        [
            "case p_x: (x \\in p); last by rewrite !next_nth mem_rot p_x.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite (eqP (next_cycle n_p _)) ?mem_rot.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma prev_rot : prev (rot n0 p) =1 prev p.",
            "VernacStartTheoremProof",
            "9c6bf2f08aa7ebee7cc2d6c800fa002061617402"
        ],
        [
            "move=> x; have p_p := cycle_prev; rewrite -(rot_cycle n0) in p_p.",
            "VernacExtend",
            "7cbc77a1e43ca1454debc28656b2dec3869cf69b"
        ],
        [
            "case p_x: (x \\in p); last by rewrite !prev_nth mem_rot p_x.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite (eqP (prev_cycle p_p _)) ?mem_rot.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End UniqCycle.",
            "VernacEndSegment",
            "c46afa972e51774d18e5524ccf82585c8fca11ae"
        ],
        [
            "Section UniqRotrCycle.",
            "VernacBeginSection",
            "ffb9d0d1eada6b6667c5ebf88af5283e3cc84c64"
        ],
        [
            "Variables (n0 : nat) (T : eqType) (p : seq T).",
            "VernacAssumption",
            "7a4bdcaa5a1642eb2d1001d2c3cefed3118cd091"
        ],
        [
            "Hypothesis Up : uniq p.",
            "VernacAssumption",
            "36f5d1a87760f7c6ae71e1567fea0a4957bd2378"
        ],
        [
            "Lemma next_rotr : next (rotr n0 p) =1 next p.",
            "VernacStartTheoremProof",
            "7468f521c13533ab232fdade767156fb45dd25dc"
        ],
        [
            "exact: next_rot.",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma prev_rotr : prev (rotr n0 p) =1 prev p.",
            "VernacStartTheoremProof",
            "18b5561ed869fe9f3b9d6ce454dd81c9a3e9c799"
        ],
        [
            "exact: prev_rot.",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End UniqRotrCycle.",
            "VernacEndSegment",
            "af3e396b0f6c03e0bab56474f1fb501d5becad32"
        ],
        [
            "Section UniqCycleRev.",
            "VernacBeginSection",
            "4f25a709526f8d5dc2c7eee801ae6346fb24dcdd"
        ],
        [
            "Variable T : eqType.",
            "VernacAssumption",
            "2ceeb4536776ca324e5be084d2deb4d476694ef1"
        ],
        [
            "Implicit Type p : seq T.",
            "VernacReserve",
            "0479d26ea48838e28e3b38a49a5ff1d1a8be73c4"
        ],
        [
            "Lemma prev_rev p : uniq p -> prev (rev p) =1 next p.",
            "VernacStartTheoremProof",
            "8ceb61432d012b91b1bac1aff4f7357e91d3405a"
        ],
        [
            "move=> Up x; case p_x: (x \\in p); last first.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite next_nth prev_nth mem_rev p_x.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "case/rot_to: p_x (Up) => [i q def_p] Urp; rewrite -rev_uniq in Urp.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "rewrite -(prev_rotr i Urp); do 2 rewrite -(prev_rotr 1) ?rotr_uniq //.",
            "VernacExtend",
            "176e1e2c61baec50cf97174e7c01163bc47db12d"
        ],
        [
            "rewrite -rev_rot -(next_rot i Up) {i p Up Urp}def_p.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "by case: q => // y q; rewrite !rev_cons !(=^~ rcons_cons, rotr1_rcons) /= eqxx.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma next_rev p : uniq p -> next (rev p) =1 prev p.",
            "VernacStartTheoremProof",
            "db579105aff22c4875ffbdd71a53fcb6371d3199"
        ],
        [
            "by move=> Up x; rewrite -{2}[p]revK prev_rev // rev_uniq.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End UniqCycleRev.",
            "VernacEndSegment",
            "0e0fe66595e2eb1acec7478546f4c5a7b4544e64"
        ],
        [
            "Section MapPath.",
            "VernacBeginSection",
            "b3fe7432dec0639665b89baba84cf66c2eae734c"
        ],
        [
            "Variables (T T' : Type) (h : T' -> T) (e : rel T) (e' : rel T').",
            "VernacAssumption",
            "cdc04129ee6aaf1d00725c07b29618b26bb54d31"
        ],
        [
            "Definition rel_base (b : pred T) := forall x' y', ~~ b (h x') -> e (h x') (h y') = e' x' y'.",
            "VernacDefinition",
            "f9fafbc30137cfb2f9d2c2ce5b726bc71f5eeb1f"
        ],
        [
            "Lemma map_path b x' p' (Bb : rel_base b) : ~~ has (preim h b) (belast x' p') -> path e (h x') (map h p') = path e' x' p'.",
            "VernacStartTheoremProof",
            "727b9255c3b3e9df8e86aa068796e43f271735fe"
        ],
        [
            "by elim: p' x' => [|y' p' IHp'] x' //= /norP[/Bb-> /IHp'->].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End MapPath.",
            "VernacEndSegment",
            "dfa9c5410449d7f3693df0ff8687202ccb3aa68f"
        ],
        [
            "Section MapEqPath.",
            "VernacBeginSection",
            "defb733dafe8310a6b1c956891b32e2bd014d43d"
        ],
        [
            "Variables (T T' : eqType) (h : T' -> T) (e : rel T) (e' : rel T').",
            "VernacAssumption",
            "1bbf543b775883a3762fa1ee1a3a837eab0d7a3f"
        ],
        [
            "Hypothesis Ih : injective h.",
            "VernacAssumption",
            "ad59e3d6921b15625f5993915bd7bb93085d2407"
        ],
        [
            "Lemma mem2_map x' y' p' : mem2 (map h p') (h x') (h y') = mem2 p' x' y'.",
            "VernacStartTheoremProof",
            "65b65228dbcf8e0dc4e722e4479c426960b896f1"
        ],
        [
            "by rewrite {1}/mem2 (index_map Ih) -map_drop mem_map.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma next_map p : uniq p -> forall x, next (map h p) (h x) = h (next p x).",
            "VernacStartTheoremProof",
            "de33ae44977e43fa8fdcadac6b4279a4acd73ce1"
        ],
        [
            "move=> Up x; case p_x: (x \\in p); last by rewrite !next_nth (mem_map Ih) p_x.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "case/rot_to: p_x => i p' def_p.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "rewrite -(next_rot i Up); rewrite -(map_inj_uniq Ih) in Up.",
            "VernacExtend",
            "2194fcb4d6d52cbae24a29f7ff14a3997f1912fd"
        ],
        [
            "rewrite -(next_rot i Up) -map_rot {i p Up}def_p /=.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "by case: p' => [|y p''] //=; rewrite !eqxx.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma prev_map p : uniq p -> forall x, prev (map h p) (h x) = h (prev p x).",
            "VernacStartTheoremProof",
            "f07b148b08052cde20d7aef51c4d95bb54b35e66"
        ],
        [
            "move=> Up x; rewrite -{1}[x](next_prev Up) -(next_map Up).",
            "VernacExtend",
            "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
        ],
        [
            "by rewrite prev_next ?map_inj_uniq.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End MapEqPath.",
            "VernacEndSegment",
            "396980f3cb32e4c683ad8f57dcbd39221d1bc19e"
        ],
        [
            "Definition fun_base (T T' : eqType) (h : T' -> T) f f' := rel_base h (frel f) (frel f').",
            "VernacDefinition",
            "01fe6942e1dfd84db446d65b3c86b1bcae59ee21"
        ],
        [
            "Section CycleArc.",
            "VernacBeginSection",
            "fba6e435fc8b223b48f0159b2921525f1ec2ce51"
        ],
        [
            "Variable T : eqType.",
            "VernacAssumption",
            "2ceeb4536776ca324e5be084d2deb4d476694ef1"
        ],
        [
            "Implicit Type p : seq T.",
            "VernacReserve",
            "0479d26ea48838e28e3b38a49a5ff1d1a8be73c4"
        ],
        [
            "Definition arc p x y := let px := rot (index x p) p in take (index y px) px.",
            "VernacDefinition",
            "1900ed2274ae56983e9ba839477f9496753713b5"
        ],
        [
            "Lemma arc_rot i p : uniq p -> {in p, arc (rot i p) =2 arc p}.",
            "VernacStartTheoremProof",
            "71ddfebeef19619944f509cf2feb7ca34ab30d84"
        ],
        [
            "move=> Up x p_x y; congr (fun q => take (index y q) q); move: Up p_x {y}.",
            "VernacExtend",
            "0b5f3fbcc42721fc7d8ff403b642924252aaa07a"
        ],
        [
            "rewrite -{1 2 5 6}(cat_take_drop i p) /rot cat_uniq => /and3P[_ Up12 _].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "rewrite !drop_cat !take_cat !index_cat mem_cat orbC.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "case p2x: (x \\in drop i p) => /= => [_ | p1x].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "rewrite index_mem p2x [x \\in _](negbTE (hasPn Up12 _ p2x)) /= addKn.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "by rewrite ltnNge leq_addr catA.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by rewrite p1x index_mem p1x addKn ltnNge leq_addr /= catA.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma left_arc x y p1 p2 (p := x :: p1 ++ y :: p2) : uniq p -> arc p x y = x :: p1.",
            "VernacStartTheoremProof",
            "7530737a495bea3dfd777a8ef42704081801c15e"
        ],
        [
            "rewrite /arc /p [index x _]/= eqxx rot0 -cat_cons cat_uniq index_cat.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "move: (x :: p1) => xp1 /and3P[_ /norP[/= /negbTE-> _] _].",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "by rewrite eqxx addn0 take_size_cat.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma right_arc x y p1 p2 (p := x :: p1 ++ y :: p2) : uniq p -> arc p y x = y :: p2.",
            "VernacStartTheoremProof",
            "b503e753a0717be1d50388b3179e47f29113eeff"
        ],
        [
            "rewrite -[p]cat_cons -rot_size_cat rot_uniq => Up.",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "by rewrite arc_rot ?left_arc ?mem_head.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Variant rot_to_arc_spec p x y := RotToArcSpec i p1 p2 of x :: p1 = arc p x y & y :: p2 = arc p y x & rot i p = x :: p1 ++ y :: p2 : rot_to_arc_spec p x y.",
            "VernacInductive",
            "26adfe4b7b37ff3443c70139d470637cde1e1cb3"
        ],
        [
            "Lemma rot_to_arc p x y : uniq p -> x \\in p -> y \\in p -> x != y -> rot_to_arc_spec p x y.",
            "VernacStartTheoremProof",
            "518792f3fa8703a15c7ca5677307ad497a055e7a"
        ],
        [
            "move=> Up p_x p_y ne_xy; case: (rot_to p_x) (p_y) (Up) => [i q def_p] q_y.",
            "VernacExtend",
            "a01b3d93f426ff68d360351709a5fa5af822af32"
        ],
        [
            "rewrite -(mem_rot i) def_p inE eq_sym (negbTE ne_xy) in q_y.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "rewrite -(rot_uniq i) def_p.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "case/splitPr: q / q_y def_p => q1 q2 def_p Uq12; exists i q1 q2 => //.",
            "VernacExtend",
            "ba44c9d0281a02110ce54645304e6d990debd9c0"
        ],
        [
            "by rewrite -(arc_rot i Up p_x) def_p left_arc.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by rewrite -(arc_rot i Up p_y) def_p right_arc.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End CycleArc.",
            "VernacEndSegment",
            "2166ced540b6bb4cf1ff4cbf9b452f08a8a7118e"
        ],
        [
            "Prenex Implicits arc.",
            "VernacExtend",
            "15bb72b7460cd5496c271b736f9e06fcdfc0d037"
        ],
        [
            "Section Monotonicity.",
            "VernacBeginSection",
            "6917b453478371a5625a5a73cea62a26435d5e68"
        ],
        [
            "Variables (T : eqType) (r : rel T).",
            "VernacAssumption",
            "55cc25056cca08457b30a6eddb9871d707fd7cf9"
        ],
        [
            "Hypothesis r_trans : transitive r.",
            "VernacAssumption",
            "3fe66d21c1a5c11c14fdb0df3715fc1f0c1253c5"
        ],
        [
            "Lemma sorted_lt_nth x0 (s : seq T) : sorted r s -> {in [pred n | n < size s] &, {homo nth x0 s : i j / i < j >-> r i j}}.",
            "VernacStartTheoremProof",
            "7f9e589343e9930affa2cf00956021d989ed91c2"
        ],
        [
            "move=> s_sorted i j; rewrite -!topredE /=.",
            "VernacExtend",
            "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
        ],
        [
            "wlog ->: i j s s_sorted / i = 0 => [/(_ 0 (j - i) (drop i s)) hw|] ilt jlt ltij.",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "move: hw; rewrite !size_drop !nth_drop addn0 subnKC ?(ltnW ltij) //.",
            "VernacExtend",
            "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
        ],
        [
            "by rewrite (subseq_sorted _ (drop_subseq _ _)) ?subn_gt0 ?ltn_sub2r//; apply.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "case: s ilt j jlt ltij => [|x s] //= _ [//|j] jlt _ in s_sorted *.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "by have /allP -> //= := order_path_min r_trans s_sorted; rewrite mem_nth.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ltn_index (s : seq T) : sorted r s -> {in s &, forall x y, index x s < index y s -> r x y}.",
            "VernacStartTheoremProof",
            "d08e2f6088c51ac314bfaa4db0b4bdf585814649"
        ],
        [
            "case: s => [//|x0 s'] r_sorted x y xs ys.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "move=> /(@sorted_lt_nth x0 (x0 :: s')).",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "by rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hypothesis r_refl : reflexive r.",
            "VernacAssumption",
            "87edcb51bd11862227e4221b22a4d53006f67e78"
        ],
        [
            "Lemma sorted_le_nth x0 (s : seq T) : sorted r s -> {in [pred n | n < size s] &, {homo nth x0 s : i j / i <= j >-> r i j}}.",
            "VernacStartTheoremProof",
            "517f9e54c671cc7f74fdfc37ba27f2817cf6b55b"
        ],
        [
            "move=> s_sorted x y xs ys.",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "by rewrite leq_eqVlt=> /orP[/eqP->//|/sorted_lt_nth]; apply.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma leq_index (s : seq T) : sorted r s -> {in s &, forall x y, index x s <= index y s -> r x y}.",
            "VernacStartTheoremProof",
            "4e2c161740c69a200b2049d651bb690b2fc5dac3"
        ],
        [
            "case: s => [//|x0 s'] r_sorted x y xs ys.",
            "VernacExtend",
            "e00fff71ff314c991514fc71c41a3556702e444a"
        ],
        [
            "move=> /(@sorted_le_nth x0 (x0 :: s')).",
            "VernacExtend",
            "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
        ],
        [
            "by rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Monotonicity.",
            "VernacEndSegment",
            "423de9cd96973925c004f94a094ccb9d0dd2c63f"
        ]
    ],
    "proofs": [
        {
            "name": "cat_path",
            "line_nb": 10,
            "steps": [
                {
                    "command": [
                        "by elim: p1 x => [|y p1 Hrec] x //=; rewrite Hrec -!andbA.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rcons_path",
            "line_nb": 13,
            "steps": [
                {
                    "command": [
                        "by rewrite -cats1 cat_path /= andbT.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pathP",
            "line_nb": 16,
            "steps": [
                {
                    "command": [
                        "elim: p x => [|y p IHp] x /=; first by left.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "apply: (iffP andP) => [[e_xy /IHp e_p [] //] | e_p].",
                        "VernacExtend",
                        "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
                    ]
                },
                {
                    "command": [
                        "by split; [apply: (e_p 0) | apply/(IHp y) => i; apply: e_p i.+1].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "cycle_path",
            "line_nb": 22,
            "steps": [
                {
                    "command": [
                        "by case: p => //= x p; rewrite rcons_path andbC.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rot_cycle",
            "line_nb": 25,
            "steps": [
                {
                    "command": [
                        "case: n0 p => [|n] [|y0 p] //=; first by rewrite /rot /= cats0.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "rewrite /rot /= -{3}(cat_take_drop n p) -cats1 -catA cat_path.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "case: (drop n p) => [|z0 q]; rewrite /= -cats1 !cat_path /= !andbT andbC //.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "by rewrite last_cat; repeat bool_congr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rotr_cycle",
            "line_nb": 31,
            "steps": [
                {
                    "command": [
                        "by rewrite -rot_cycle rotrK.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_path",
            "line_nb": 35,
            "steps": [
                {
                    "command": [
                        "by move=> ee' x p; elim: p x => //= y p IHp x; rewrite ee' IHp.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_cycle",
            "line_nb": 38,
            "steps": [
                {
                    "command": [
                        "by move=> ee' [|x p] //=; apply: eq_path.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sub_path",
            "line_nb": 41,
            "steps": [
                {
                    "command": [
                        "by move=> ee' x p; elim: p x => //= y p IHp x /andP[/ee'-> /IHp].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rev_path",
            "line_nb": 44,
            "steps": [
                {
                    "command": [
                        "elim: p x => //= y p IHp x; rewrite rev_cons rcons_path -{}IHp andbC.",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "by rewrite -(last_cons x) -rev_rcons -lastI rev_cons last_rcons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "splitP",
            "line_nb": 54,
            "steps": [
                {
                    "command": [
                        "move=> p_x; have lt_ip: i < size p by rewrite index_mem.",
                        "VernacExtend",
                        "ccd83c252dcbae3d56f3d057fcb8217878b51901"
                    ]
                },
                {
                    "command": [
                        "by rewrite -{1}(cat_take_drop i p) (drop_nth x lt_ip) -cat_rcons nth_index.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "splitPl",
            "line_nb": 59,
            "steps": [
                {
                    "command": [
                        "rewrite inE; case: eqP => [->| _ /splitP[]]; first by rewrite -(cat0s p).",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by split; apply: last_rcons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "splitPr",
            "line_nb": 64,
            "steps": [
                {
                    "command": [
                        "by case/splitP=> p1 p2; rewrite cat_rcons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_nth",
            "line_nb": 71,
            "steps": [
                {
                    "command": [
                        "case: p => //= y0 p.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "elim: p {2 3 5}y0 => [|y' p IHp] y /=; rewrite (eq_sym y) inE; by case: ifP => // _; apply: IHp.",
                        "VernacExtend",
                        "244a9a5eebe0941cff21b86f46627271de195205"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_nth",
            "line_nb": 75,
            "steps": [
                {
                    "command": [
                        "case: p => //= y0 p; rewrite inE orbC.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "elim: p {2 5}y0 => [|y' p IHp] y; rewrite /= ?inE // (eq_sym y').",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "by case: ifP => // _; apply: IHp.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem_next",
            "line_nb": 80,
            "steps": [
                {
                    "command": [
                        "rewrite next_nth; case p_x: (x \\in p) => //.",
                        "VernacExtend",
                        "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
                    ]
                },
                {
                    "command": [
                        "case: p (index x p) p_x => [|y0 p'] //= i _; rewrite inE.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "have [lt_ip | ge_ip] := ltnP i (size p'); first by rewrite orbC mem_nth.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite nth_default ?eqxx.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem_prev",
            "line_nb": 86,
            "steps": [
                {
                    "command": [
                        "rewrite prev_nth; case p_x: (x \\in p) => //; case: p => [|y0 p] // in p_x *.",
                        "VernacExtend",
                        "1418099f654a9d12bdfd561bac86adb846b83bfd"
                    ]
                },
                {
                    "command": [
                        "by apply mem_nth; rewrite /= ltnS index_size.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ucycle_cycle",
            "line_nb": 92,
            "steps": [
                {
                    "command": [
                        "by case/andP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ucycle_uniq",
            "line_nb": 95,
            "steps": [
                {
                    "command": [
                        "by case/andP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_cycle",
            "line_nb": 98,
            "steps": [
                {
                    "command": [
                        "case: p => //= y0 p; elim: p {1 3 5}y0 => [|z p IHp] y /=; rewrite inE.",
                        "VernacExtend",
                        "810b24f801b6f73dbb85b7524f481afcf2d89973"
                    ]
                },
                {
                    "command": [
                        "by rewrite andbT; case: (x =P y) => // ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by case/andP=> eyz /IHp; case: (x =P y) => // ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_cycle",
            "line_nb": 103,
            "steps": [
                {
                    "command": [
                        "case: p => //= y0 p; rewrite inE orbC.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "elim: p {1 5}y0 => [|z p IHp] y /=; rewrite ?inE.",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "by rewrite andbT; case: (x =P y0) => // ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by case/andP=> eyz /IHp; case: (x =P z) => // ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rot_ucycle",
            "line_nb": 109,
            "steps": [
                {
                    "command": [
                        "by rewrite /ucycle rot_uniq rot_cycle.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rotr_ucycle",
            "line_nb": 112,
            "steps": [
                {
                    "command": [
                        "by rewrite /ucycle rotr_uniq rotr_cycle.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2l",
            "line_nb": 116,
            "steps": [
                {
                    "command": [
                        "by rewrite /mem2 -!index_mem size_drop ltn_subRL; apply/leq_ltn_trans/leq_addr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2lf",
            "line_nb": 119,
            "steps": [
                {
                    "command": [
                        "exact/contraNF/mem2l.",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2r",
            "line_nb": 122,
            "steps": [
                {
                    "command": [
                        "by rewrite -[in y \\in p](cat_take_drop (index x p) p) mem_cat orbC /mem2 => ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2rf",
            "line_nb": 125,
            "steps": [
                {
                    "command": [
                        "exact/contraNF/mem2r.",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_cat",
            "line_nb": 128,
            "steps": [
                {
                    "command": [
                        "rewrite [LHS]/mem2 index_cat fun_if if_arg !drop_cat addKn.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "case: ifPn => [p1x | /mem2lf->]; last by rewrite ltnNge leq_addr orbF.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite index_mem p1x mem_cat -orbA (orb_idl (@mem2r _ _ _)).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_splice",
            "line_nb": 133,
            "steps": [
                {
                    "command": [
                        "by rewrite !mem2_cat mem_cat andb_orr orbC => /or3P[]->; rewrite ?orbT.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_splice1",
            "line_nb": 136,
            "steps": [
                {
                    "command": [
                        "exact: mem2_splice [::z].",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_cons",
            "line_nb": 139,
            "steps": [
                {
                    "command": [
                        "by rewrite [LHS]/mem2 /=; case: ifP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_seq1",
            "line_nb": 142,
            "steps": [
                {
                    "command": [
                        "by rewrite mem2_cons eq_sym inE.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_last",
            "line_nb": 145,
            "steps": [
                {
                    "command": [
                        "apply/idP/idP; first exact: mem2l; rewrite -index_mem /mem2 => p_x.",
                        "VernacExtend",
                        "58dba442af7e38d8e79d91f6dc3f45e6bb3c040b"
                    ]
                },
                {
                    "command": [
                        "by rewrite -nth_last -(subnKC p_x) -nth_drop mem_nth // size_drop subnSK.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2l_cat",
            "line_nb": 149,
            "steps": [
                {
                    "command": [
                        "by move=> p1'x y; rewrite mem2_cat (negPf p1'x) mem2lf ?orbF.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2r_cat",
            "line_nb": 152,
            "steps": [
                {
                    "command": [
                        "by move=> p2'y; rewrite mem2_cat (negPf p2'y) -orbA orbC andbF mem2rf.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2lr_splice",
            "line_nb": 155,
            "steps": [
                {
                    "command": [
                        "move=> p2'x p2'y; rewrite catA !mem2_cat !mem_cat.",
                        "VernacExtend",
                        "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
                    ]
                },
                {
                    "command": [
                        "by rewrite (negPf p2'x) (negPf p2'y) (mem2lf p2'x) andbF !orbF.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "splitP2r",
            "line_nb": 160,
            "steps": [
                {
                    "command": [
                        "move=> pxy; have px := mem2l pxy.",
                        "VernacExtend",
                        "ccd83c252dcbae3d56f3d057fcb8217878b51901"
                    ]
                },
                {
                    "command": [
                        "have:= pxy; rewrite /mem2 (drop_nth x) ?index_mem ?nth_index //.",
                        "VernacExtend",
                        "aa9d5fbc682ed874cd64b2543ca6c859b978e924"
                    ]
                },
                {
                    "command": [
                        "by case/splitP: px => p1 p2; rewrite cat_rcons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "shortenP",
            "line_nb": 167,
            "steps": [
                {
                    "command": [
                        "move=> e_p; have: x \\in x :: p by apply: mem_head.",
                        "VernacExtend",
                        "ccd83c252dcbae3d56f3d057fcb8217878b51901"
                    ]
                },
                {
                    "command": [
                        "elim: p x {1 3 5}x e_p => [|y2 p IHp] x y1.",
                        "VernacExtend",
                        "e686a1895f1799b840b76242f931100819a9ad6c"
                    ]
                },
                {
                    "command": [
                        "by rewrite mem_seq1 => _ /eqP->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "rewrite inE orbC /= => /andP[ey12 /IHp {IHp}IHp].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "case: ifPn => [y2p_x _ | not_y2p_x /eqP def_x].",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "have [p' e_p' Up' p'p] := IHp _ y2p_x.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "by split=> // y /p'p; apply: predU1r.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "have [p' e_p' Up' p'p] := IHp y2 (mem_head y2 p).",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "have{p'p} p'p z: z \\in y2 :: p' -> z \\in y2 :: p.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "by rewrite !inE; case: (z == y2) => // /p'p.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "rewrite -(last_cons y1) def_x; split=> //=; first by rewrite ey12.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite (contra (p'p y1)) -?def_x.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "path_sorted",
            "line_nb": 186,
            "steps": [
                {
                    "command": [
                        "by case: s => //= y s /andP[].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "path_min_sorted",
            "line_nb": 189,
            "steps": [
                {
                    "command": [
                        "by case: s => //= y s -> //; apply: mem_head.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "subseq_order_path",
            "line_nb": 194,
            "steps": [
                {
                    "command": [
                        "elim: s2 x s1 => [|y s2 IHs] x [|z s1] //= {IHs}/(IHs y).",
                        "VernacExtend",
                        "e686a1895f1799b840b76242f931100819a9ad6c"
                    ]
                },
                {
                    "command": [
                        "case: eqP => [-> | _] IHs /andP[] => [-> // | leTxy /IHs /=].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "by case/andP=> /(leT_tr leTxy)->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "order_path_min",
            "line_nb": 199,
            "steps": [
                {
                    "command": [
                        "move/subseq_order_path=> le_x_s; apply/allP=> y.",
                        "VernacExtend",
                        "d6ebf3361f380a12d5c2c9bbb7ea363132c48b36"
                    ]
                },
                {
                    "command": [
                        "by rewrite -sub1seq => /le_x_s/andP[].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "subseq_sorted",
            "line_nb": 203,
            "steps": [
                {
                    "command": [
                        "case: s1 s2 => [|x1 s1] [|x2 s2] //= sub_s12 /(subseq_order_path sub_s12).",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "by case: eqP => [-> | _ /andP[]].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sorted_filter",
            "line_nb": 207,
            "steps": [
                {
                    "command": [
                        "exact: subseq_sorted (filter_subseq a s).",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sorted_uniq",
            "line_nb": 210,
            "steps": [
                {
                    "command": [
                        "move=> leT_irr; elim=> //= x s IHs s_ord.",
                        "VernacExtend",
                        "06880003f1108b2eb418688c7bc6bf1013cf0e4c"
                    ]
                },
                {
                    "command": [
                        "rewrite (IHs (path_sorted s_ord)) andbT; apply/negP=> s_x.",
                        "VernacExtend",
                        "634a7639ed2fb7caf62757f84400927f5829b7d5"
                    ]
                },
                {
                    "command": [
                        "by case/allPn: (order_path_min s_ord); exists x; rewrite // leT_irr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_sorted",
            "line_nb": 215,
            "steps": [
                {
                    "command": [
                        "move=> leT_asym; elim=> [|x1 s1 IHs1] s2 //= ord_s1 ord_s2 eq_s12.",
                        "VernacExtend",
                        "06880003f1108b2eb418688c7bc6bf1013cf0e4c"
                    ]
                },
                {
                    "command": [
                        "by case: {+}s2 (perm_eq_size eq_s12).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "have s2_x1: x1 \\in s2 by rewrite -(perm_eq_mem eq_s12) mem_head.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "case: s2 s2_x1 eq_s12 ord_s2 => //= x2 s2; rewrite in_cons.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "case: eqP => [<- _| ne_x12 /= s2_x1] eq_s12 ord_s2.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "by rewrite {IHs1}(IHs1 s2) ?(@path_sorted x1) // -(perm_cons x1).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "case: (ne_x12); apply: leT_asym; rewrite (allP (order_path_min ord_s2)) //.",
                        "VernacExtend",
                        "db5c0dcae9fc8f6605ec5d5bf559f9684231fcd6"
                    ]
                },
                {
                    "command": [
                        "have: x2 \\in x1 :: s1 by rewrite (perm_eq_mem eq_s12) mem_head.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "case/predU1P=> [eq_x12 | s1_x2]; first by case ne_x12.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite (allP (order_path_min ord_s1)).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_sorted_irr",
            "line_nb": 227,
            "steps": [
                {
                    "command": [
                        "move=> leT_irr s1 s2 s1_sort s2_sort eq_s12.",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "have: antisymmetric leT.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "by move=> m n /andP[? ltnm]; case/idP: (leT_irr m); apply: leT_tr ltnm.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by move/eq_sorted; apply=> //; apply: uniq_perm_eq => //; apply: sorted_uniq.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "merge_path",
            "line_nb": 236,
            "steps": [
                {
                    "command": [
                        "elim: s1 s2 x => //= x1 s1 IHs1.",
                        "VernacExtend",
                        "e686a1895f1799b840b76242f931100819a9ad6c"
                    ]
                },
                {
                    "command": [
                        "elim=> //= x2 s2 IHs2 x /andP[le_x_x1 ord_s1] /andP[le_x_x2 ord_s2].",
                        "VernacExtend",
                        "e686a1895f1799b840b76242f931100819a9ad6c"
                    ]
                },
                {
                    "command": [
                        "case: ifP => le_x21 /=; first by rewrite le_x_x2 {}IHs2 // le_x21.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite le_x_x1 IHs1 //=; have:= leT_total x2 x1; rewrite le_x21 /= => ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "merge_sorted",
            "line_nb": 242,
            "steps": [
                {
                    "command": [
                        "case: s1 s2 => [|x1 s1] [|x2 s2] //= ord_s1 ord_s2.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "case: ifP => le_x21 /=.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "by apply: (@merge_path x2 (x1 :: s1)) => //=; rewrite le_x21.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by apply: merge_path => //=; have:= leT_total x2 x1; rewrite le_x21 /= => ->.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "perm_merge",
            "line_nb": 248,
            "steps": [
                {
                    "command": [
                        "apply/perm_eqlP; rewrite perm_eq_sym; elim: s1 s2 => //= x1 s1 IHs1.",
                        "VernacExtend",
                        "50460284180dcd83c121bd2e598800c155f096bd"
                    ]
                },
                {
                    "command": [
                        "elim=> [|x2 s2 IHs2]; rewrite /= ?cats0 //.",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "case: ifP => _ /=; last by rewrite perm_cons.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite (perm_catCA (_ :: _) [::x2]) perm_cons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem_merge",
            "line_nb": 254,
            "steps": [
                {
                    "command": [
                        "by apply: perm_eq_mem; rewrite perm_merge.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "size_merge",
            "line_nb": 257,
            "steps": [
                {
                    "command": [
                        "by apply: perm_eq_size; rewrite perm_merge.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "merge_uniq",
            "line_nb": 260,
            "steps": [
                {
                    "command": [
                        "by apply: perm_eq_uniq; rewrite perm_merge.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sort_sorted",
            "line_nb": 267,
            "steps": [
                {
                    "command": [
                        "rewrite /sort; have allss: all sorted [::] by [].",
                        "VernacExtend",
                        "7be6e3cf9ccbce33486c4b5c6fefdf7a9ad6e52b"
                    ]
                },
                {
                    "command": [
                        "elim: {s}_.+1 {-2}s [::] allss (ltnSn (size s)) => // n IHn s ss allss.",
                        "VernacExtend",
                        "e686a1895f1799b840b76242f931100819a9ad6c"
                    ]
                },
                {
                    "command": [
                        "have: sorted s -> sorted (merge_sort_pop s ss).",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "elim: ss allss s => //= s2 ss IHss /andP[ord_s2 ord_ss] s ord_s.",
                        "VernacExtend",
                        "e686a1895f1799b840b76242f931100819a9ad6c"
                    ]
                },
                {
                    "command": [
                        "exact: IHss ord_ss _ (merge_sorted ord_s ord_s2).",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "case: s => [|x1 [|x2 s _]]; try by auto.",
                        "VernacExtend",
                        "700e4ba7c43aef376de752aa78d70ea0bf66a54e"
                    ]
                },
                {
                    "command": [
                        "move/ltnW/IHn; apply=> {n IHn s}; set s1 := if _ then _ else _.",
                        "VernacExtend",
                        "087c3b66226a45d8597d03f3e4b691c28cc161ee"
                    ]
                },
                {
                    "command": [
                        "have: sorted s1 by apply: (@merge_sorted [::x2] [::x1]).",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "elim: ss {x1 x2}s1 allss => /= [|s2 ss IHss] s1; first by rewrite andbT.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "case/andP=> ord_s2 ord_ss ord_s1.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "by case: {1}s2=> /= [|_ _]; [rewrite ord_s1 | apply: IHss (merge_sorted _ _)].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem_sort",
            "line_nb": 296,
            "steps": [
                {
                    "command": [
                        "by apply: perm_eq_mem; rewrite perm_sort.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "size_sort",
            "line_nb": 299,
            "steps": [
                {
                    "command": [
                        "by apply: perm_eq_size; rewrite perm_sort.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sort_uniq",
            "line_nb": 302,
            "steps": [
                {
                    "command": [
                        "by apply: perm_eq_uniq; rewrite perm_sort.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rev_sorted",
            "line_nb": 312,
            "steps": [
                {
                    "command": [
                        "by case: s => //= x p; rewrite -rev_path lastI rev_rcons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ltn_sorted_uniq_leq",
            "line_nb": 315,
            "steps": [
                {
                    "command": [
                        "case: s => //= n s; elim: s n => //= m s IHs n.",
                        "VernacExtend",
                        "1821533cafd21deefc2f797d67a58b45e0a54e79"
                    ]
                },
                {
                    "command": [
                        "rewrite inE ltn_neqAle negb_or IHs -!andbA.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "case sn: (n \\in s); last do !bool_congr.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "rewrite andbF; apply/and5P=> [[ne_nm lenm _ _ le_ms]]; case/negP: ne_nm.",
                        "VernacExtend",
                        "e653a755ab5d693b79348e5a2832d3e386fea3c7"
                    ]
                },
                {
                    "command": [
                        "by rewrite eqn_leq lenm; apply: (allP (order_path_min leq_trans le_ms)).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "iota_sorted",
            "line_nb": 322,
            "steps": [
                {
                    "command": [
                        "by elim: n i => // [[|n] //= IHn] i; rewrite IHn leqW.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "iota_ltn_sorted",
            "line_nb": 325,
            "steps": [
                {
                    "command": [
                        "by rewrite ltn_sorted_uniq_leq iota_sorted iota_uniq.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "trajectS",
            "line_nb": 335,
            "steps": [
                {
                    "command": [
                        "by [].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "trajectSr",
            "line_nb": 338,
            "steps": [
                {
                    "command": [
                        "by elim: n x => //= n IHn x; rewrite IHn -iterSr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "last_traject",
            "line_nb": 341,
            "steps": [
                {
                    "command": [
                        "by case: n => // n; rewrite iterSr trajectSr last_rcons.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "traject_iteri",
            "line_nb": 344,
            "steps": [
                {
                    "command": [
                        "by elim: n => //= n <-; rewrite -trajectSr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "size_traject",
            "line_nb": 347,
            "steps": [
                {
                    "command": [
                        "by elim: n x => //= n IHn x //=; rewrite IHn.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "nth_traject",
            "line_nb": 350,
            "steps": [
                {
                    "command": [
                        "elim: n => // n IHn; rewrite ltnS leq_eqVlt => le_i_n x.",
                        "VernacExtend",
                        "5c0d3b68844697b312245da3ed2c1b277720f6af"
                    ]
                },
                {
                    "command": [
                        "rewrite trajectSr nth_rcons size_traject.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "by case: ltngtP le_i_n => [? _||->] //; apply: IHn.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_fpath",
            "line_nb": 358,
            "steps": [
                {
                    "command": [
                        "by move/eq_frel/eq_path.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_fcycle",
            "line_nb": 361,
            "steps": [
                {
                    "command": [
                        "by move/eq_frel/eq_cycle.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "fpathP",
            "line_nb": 364,
            "steps": [
                {
                    "command": [
                        "elim: p x => [|y p IHp] x; first by left; exists 0.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "rewrite /= andbC; case: IHp => [fn_p | not_fn_p]; last first.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by right=> [] [[//|n]] [<- fn_p]; case: not_fn_p; exists n.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "apply: (iffP eqP) => [-> | [[] // _ []//]].",
                        "VernacExtend",
                        "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
                    ]
                },
                {
                    "command": [
                        "by have [n ->] := fn_p; exists n.+1.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "fpath_traject",
            "line_nb": 371,
            "steps": [
                {
                    "command": [
                        "by apply/(fpathP x); exists n.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "loopingP",
            "line_nb": 375,
            "steps": [
                {
                    "command": [
                        "apply: (iffP idP) => loop_n; last exact: loop_n.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "case: n => // n in loop_n *; elim=> [|m /= IHm]; first exact: mem_head.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "move: (fpath_traject x n) loop_n; rewrite /looping !iterS -last_traject /=.",
                        "VernacExtend",
                        "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
                    ]
                },
                {
                    "command": [
                        "move: (iter m f x) IHm => y /splitPl[p1 p2 def_y].",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "rewrite cat_path last_cat def_y; case: p2 => // z p2 /and3P[_ /eqP-> _] _.",
                        "VernacExtend",
                        "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
                    ]
                },
                {
                    "command": [
                        "by rewrite inE mem_cat mem_head !orbT.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "trajectP",
            "line_nb": 383,
            "steps": [
                {
                    "command": [
                        "elim: n x => [|n IHn] x /=; first by right; case.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "rewrite inE; have [-> | /= neq_xy] := eqP; first by left; exists 0.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "apply: {IHn}(iffP (IHn _)) => [[i] | [[|i]]] // lt_i_n ->.",
                        "VernacExtend",
                        "4bd6fa79b17bcd2bfb7af091fb325367a20385d6"
                    ]
                },
                {
                    "command": [
                        "by exists i.+1; rewrite ?iterSr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by exists i; rewrite ?iterSr.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_next",
            "line_nb": 408,
            "steps": [
                {
                    "command": [
                        "move=> x; rewrite prev_nth mem_next next_nth; case p_x: (x \\in p) => //.",
                        "VernacExtend",
                        "d7214ac8fd48f4d1cd143edd9d16f6d28386a302"
                    ]
                },
                {
                    "command": [
                        "case def_p: p Up p_x => // [y q]; rewrite -{-1}def_p => /= /andP[not_qy Uq] p_x.",
                        "VernacExtend",
                        "ba44c9d0281a02110ce54645304e6d990debd9c0"
                    ]
                },
                {
                    "command": [
                        "rewrite -{2}(nth_index y p_x); congr (nth y _ _); set i := index x p.",
                        "VernacExtend",
                        "c32c5ac311e3847dc87621ff9971372f5f613e0c"
                    ]
                },
                {
                    "command": [
                        "have: ~~ (size q < i) by rewrite -index_mem -/i def_p leqNgt in p_x.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "case: ltngtP => // [lt_i_q | ->] _; first by rewrite index_uniq.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by apply/eqP; rewrite nth_default // eqn_leq index_size leqNgt index_mem.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_prev",
            "line_nb": 416,
            "steps": [
                {
                    "command": [
                        "move=> x; rewrite next_nth mem_prev prev_nth; case p_x: (x \\in p) => //.",
                        "VernacExtend",
                        "d7214ac8fd48f4d1cd143edd9d16f6d28386a302"
                    ]
                },
                {
                    "command": [
                        "case def_p: p p_x => // [y q]; rewrite -def_p => p_x.",
                        "VernacExtend",
                        "ba44c9d0281a02110ce54645304e6d990debd9c0"
                    ]
                },
                {
                    "command": [
                        "rewrite index_uniq //; last by rewrite def_p ltnS index_size.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "case q_x: (x \\in q); first exact: nth_index.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "rewrite nth_default; last by rewrite leqNgt index_mem q_x.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by apply/eqP; rewrite def_p inE q_x orbF eq_sym in p_x.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "cycle_next",
            "line_nb": 424,
            "steps": [
                {
                    "command": [
                        "case def_p: {-2}p Up => [|x q] Uq //.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "apply/(pathP x)=> i; rewrite size_rcons => le_i_q.",
                        "VernacExtend",
                        "5fce7e5361004176d6b434b36b4623c7387f70bb"
                    ]
                },
                {
                    "command": [
                        "rewrite -cats1 -cat_cons nth_cat le_i_q /= next_nth {}def_p mem_nth //.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "rewrite index_uniq // nth_cat /= ltn_neqAle andbC -ltnS le_i_q.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "by case: (i =P _) => //= ->; rewrite subnn nth_default.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "cycle_prev",
            "line_nb": 431,
            "steps": [
                {
                    "command": [
                        "apply: etrans cycle_next; symmetry; case def_p: p => [|x q] //.",
                        "VernacExtend",
                        "f91c4a8f7dbfb8ccfc52f8866c2d83ba6c30e84f"
                    ]
                },
                {
                    "command": [
                        "by apply: eq_path; rewrite -def_p; apply: (can2_eq prev_next next_prev).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "cycle_from_next",
            "line_nb": 435,
            "steps": [
                {
                    "command": [
                        "case: p (next p) cycle_next => //= [x q] n; rewrite -(belast_rcons x q x).",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "move: {q}(rcons q x) => q n_q; move/allP.",
                        "VernacExtend",
                        "8b784377bdc4d565ff66d4cf36a6041e9354c156"
                    ]
                },
                {
                    "command": [
                        "by elim: q x n_q => //= _ q IHq x /andP[/eqP <- n_q] /andP[-> /IHq->].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "cycle_from_prev",
            "line_nb": 440,
            "steps": [
                {
                    "command": [
                        "move=> e_p; apply: cycle_from_next => x p_x.",
                        "VernacExtend",
                        "d6ebf3361f380a12d5c2c9bbb7ea363132c48b36"
                    ]
                },
                {
                    "command": [
                        "by rewrite -{1}[x]prev_next e_p ?mem_next.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_rot",
            "line_nb": 444,
            "steps": [
                {
                    "command": [
                        "move=> x; have n_p := cycle_next; rewrite -(rot_cycle n0) in n_p.",
                        "VernacExtend",
                        "7cbc77a1e43ca1454debc28656b2dec3869cf69b"
                    ]
                },
                {
                    "command": [
                        "case p_x: (x \\in p); last by rewrite !next_nth mem_rot p_x.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite (eqP (next_cycle n_p _)) ?mem_rot.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_rot",
            "line_nb": 449,
            "steps": [
                {
                    "command": [
                        "move=> x; have p_p := cycle_prev; rewrite -(rot_cycle n0) in p_p.",
                        "VernacExtend",
                        "7cbc77a1e43ca1454debc28656b2dec3869cf69b"
                    ]
                },
                {
                    "command": [
                        "case p_x: (x \\in p); last by rewrite !prev_nth mem_rot p_x.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite (eqP (prev_cycle p_p _)) ?mem_rot.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_rotr",
            "line_nb": 458,
            "steps": [
                {
                    "command": [
                        "exact: next_rot.",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_rotr",
            "line_nb": 461,
            "steps": [
                {
                    "command": [
                        "exact: prev_rot.",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_rev",
            "line_nb": 468,
            "steps": [
                {
                    "command": [
                        "move=> Up x; case p_x: (x \\in p); last first.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite next_nth prev_nth mem_rev p_x.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "case/rot_to: p_x (Up) => [i q def_p] Urp; rewrite -rev_uniq in Urp.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "rewrite -(prev_rotr i Urp); do 2 rewrite -(prev_rotr 1) ?rotr_uniq //.",
                        "VernacExtend",
                        "176e1e2c61baec50cf97174e7c01163bc47db12d"
                    ]
                },
                {
                    "command": [
                        "rewrite -rev_rot -(next_rot i Up) {i p Up Urp}def_p.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "by case: q => // y q; rewrite !rev_cons !(=^~ rcons_cons, rotr1_rcons) /= eqxx.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_rev",
            "line_nb": 476,
            "steps": [
                {
                    "command": [
                        "by move=> Up x; rewrite -{2}[p]revK prev_rev // rev_uniq.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "map_path",
            "line_nb": 483,
            "steps": [
                {
                    "command": [
                        "by elim: p' x' => [|y' p' IHp'] x' //= /norP[/Bb-> /IHp'->].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mem2_map",
            "line_nb": 490,
            "steps": [
                {
                    "command": [
                        "by rewrite {1}/mem2 (index_map Ih) -map_drop mem_map.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "next_map",
            "line_nb": 493,
            "steps": [
                {
                    "command": [
                        "move=> Up x; case p_x: (x \\in p); last by rewrite !next_nth (mem_map Ih) p_x.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "case/rot_to: p_x => i p' def_p.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "rewrite -(next_rot i Up); rewrite -(map_inj_uniq Ih) in Up.",
                        "VernacExtend",
                        "2194fcb4d6d52cbae24a29f7ff14a3997f1912fd"
                    ]
                },
                {
                    "command": [
                        "rewrite -(next_rot i Up) -map_rot {i p Up}def_p /=.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "by case: p' => [|y p''] //=; rewrite !eqxx.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "prev_map",
            "line_nb": 500,
            "steps": [
                {
                    "command": [
                        "move=> Up x; rewrite -{1}[x](next_prev Up) -(next_map Up).",
                        "VernacExtend",
                        "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
                    ]
                },
                {
                    "command": [
                        "by rewrite prev_next ?map_inj_uniq.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "arc_rot",
            "line_nb": 510,
            "steps": [
                {
                    "command": [
                        "move=> Up x p_x y; congr (fun q => take (index y q) q); move: Up p_x {y}.",
                        "VernacExtend",
                        "0b5f3fbcc42721fc7d8ff403b642924252aaa07a"
                    ]
                },
                {
                    "command": [
                        "rewrite -{1 2 5 6}(cat_take_drop i p) /rot cat_uniq => /and3P[_ Up12 _].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "rewrite !drop_cat !take_cat !index_cat mem_cat orbC.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "case p2x: (x \\in drop i p) => /= => [_ | p1x].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "rewrite index_mem p2x [x \\in _](negbTE (hasPn Up12 _ p2x)) /= addKn.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "by rewrite ltnNge leq_addr catA.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by rewrite p1x index_mem p1x addKn ltnNge leq_addr /= catA.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "left_arc",
            "line_nb": 519,
            "steps": [
                {
                    "command": [
                        "rewrite /arc /p [index x _]/= eqxx rot0 -cat_cons cat_uniq index_cat.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "move: (x :: p1) => xp1 /and3P[_ /norP[/= /negbTE-> _] _].",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "by rewrite eqxx addn0 take_size_cat.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "right_arc",
            "line_nb": 524,
            "steps": [
                {
                    "command": [
                        "rewrite -[p]cat_cons -rot_size_cat rot_uniq => Up.",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "by rewrite arc_rot ?left_arc ?mem_head.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rot_to_arc",
            "line_nb": 529,
            "steps": [
                {
                    "command": [
                        "move=> Up p_x p_y ne_xy; case: (rot_to p_x) (p_y) (Up) => [i q def_p] q_y.",
                        "VernacExtend",
                        "a01b3d93f426ff68d360351709a5fa5af822af32"
                    ]
                },
                {
                    "command": [
                        "rewrite -(mem_rot i) def_p inE eq_sym (negbTE ne_xy) in q_y.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "rewrite -(rot_uniq i) def_p.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "case/splitPr: q / q_y def_p => q1 q2 def_p Uq12; exists i q1 q2 => //.",
                        "VernacExtend",
                        "ba44c9d0281a02110ce54645304e6d990debd9c0"
                    ]
                },
                {
                    "command": [
                        "by rewrite -(arc_rot i Up p_x) def_p left_arc.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by rewrite -(arc_rot i Up p_y) def_p right_arc.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sorted_lt_nth",
            "line_nb": 542,
            "steps": [
                {
                    "command": [
                        "move=> s_sorted i j; rewrite -!topredE /=.",
                        "VernacExtend",
                        "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
                    ]
                },
                {
                    "command": [
                        "wlog ->: i j s s_sorted / i = 0 => [/(_ 0 (j - i) (drop i s)) hw|] ilt jlt ltij.",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "move: hw; rewrite !size_drop !nth_drop addn0 subnKC ?(ltnW ltij) //.",
                        "VernacExtend",
                        "057edeb0967475c7ea5e8c98c449ddc5613eddc1"
                    ]
                },
                {
                    "command": [
                        "by rewrite (subseq_sorted _ (drop_subseq _ _)) ?subn_gt0 ?ltn_sub2r//; apply.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "case: s ilt j jlt ltij => [|x s] //= _ [//|j] jlt _ in s_sorted *.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "by have /allP -> //= := order_path_min r_trans s_sorted; rewrite mem_nth.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ltn_index",
            "line_nb": 550,
            "steps": [
                {
                    "command": [
                        "case: s => [//|x0 s'] r_sorted x y xs ys.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "move=> /(@sorted_lt_nth x0 (x0 :: s')).",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "by rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sorted_le_nth",
            "line_nb": 556,
            "steps": [
                {
                    "command": [
                        "move=> s_sorted x y xs ys.",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "by rewrite leq_eqVlt=> /orP[/eqP->//|/sorted_lt_nth]; apply.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "leq_index",
            "line_nb": 560,
            "steps": [
                {
                    "command": [
                        "case: s => [//|x0 s'] r_sorted x y xs ys.",
                        "VernacExtend",
                        "e00fff71ff314c991514fc71c41a3556702e444a"
                    ]
                },
                {
                    "command": [
                        "move=> /(@sorted_le_nth x0 (x0 :: s')).",
                        "VernacExtend",
                        "b1b2cb7a3a617cba67460b4eca1f04de3c1cc716"
                    ]
                },
                {
                    "command": [
                        "by rewrite ?nth_index ?[_ \\in gtn _]index_mem //; apply.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}