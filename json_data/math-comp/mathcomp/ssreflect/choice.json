{
    "filename": "mathcomp/ssreflect/choice.v",
    "coq_project": "math-comp",
    "vernac_cmds": [
        [
            "Require Import mathcomp.ssreflect.ssreflect.",
            "VernacRequire",
            "85e251063dc2b5a9653f7bb76dcd176ed36b42a9"
        ],
        [
            "From mathcomp Require Import ssrfun ssrbool eqtype ssrnat seq.",
            "VernacRequire",
            "8545ccf335ab63fd28b87a2c32b12f2259513a2c"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Unset Strict Implicit.",
            "VernacUnsetOption",
            "2842adaf6959318f2042805935c46f513bdc0348"
        ],
        [
            "Unset Printing Implicit Defensive.",
            "VernacUnsetOption",
            "444e5f0be4b25d9b1fd556943a447ec10046d151"
        ],
        [
            "Module CodeSeq.",
            "VernacDefineModule",
            "d28ca71cd3e4111369eeb93f358ba92b8db703ee"
        ],
        [
            "Definition code := foldr (fun n m => 2 ^ n * m.*2.+1) 0.",
            "VernacDefinition",
            "7f88a4b7676296882ec14617006ae27265ce8343"
        ],
        [
            "Fixpoint decode_rec (v q r : nat) {struct q} := match q, r with | 0, _ => [:: v] | q'.+1, 0 => v :: [rec 0, q', q'] | q'.+1, 1 => [rec v.+1, q', q'] | q'.+1, r'.+2 => [rec v, q', r'] end where \"[ 'rec' v , q , r ]\" := (decode_rec v q r).",
            "VernacFixpoint",
            "24b90ad2dbe6d7cb3af2585c3dbd7b3d68767d93"
        ],
        [
            "Definition decode n := if n is 0 then [::] else [rec 0, n.-1, n.-1].",
            "VernacDefinition",
            "54185a26c175eb30c2f5ad9ca71d99a8ed7780ae"
        ],
        [
            "Lemma decodeK : cancel decode code.",
            "VernacStartTheoremProof",
            "047f71c0d5fdd1c359d799be7c5c9f82ce642481"
        ],
        [
            "have m2s: forall n, n.*2 - n = n by move=> n; rewrite -addnn addnK.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "case=> //= n; rewrite -[n.+1]mul1n -(expn0 2) -{3}[n]m2s.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "elim: n {2 4}n {1 3}0 => [|q IHq] [|[|r]] v //=; rewrite {}IHq ?mul1n ?m2s //.",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "by rewrite expnSr -mulnA mul2n.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma codeK : cancel code decode.",
            "VernacStartTheoremProof",
            "dc4bbcc6a4f20806fcca4fedcc21d7be3403d4a3"
        ],
        [
            "elim=> //= v s IHs; rewrite -[_ * _]prednK ?muln_gt0 ?expn_gt0 //=.",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "rewrite -{3}[v]addn0; elim: v {1 4}0 => [|v IHv {IHs}] q.",
            "VernacExtend",
            "44a8e3b453c9376c468b4e3e0046f5ac33e11d6d"
        ],
        [
            "rewrite mul1n /= -{1}addnn -{4}IHs; move: (_ s) {IHs} => n.",
            "VernacExtend",
            "7e529e80bb2879787ee6d9466056f19f0215c721"
        ],
        [
            "by elim: {1 3}n => //=; case: n.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "rewrite expnS -mulnA mul2n -{1}addnn -[_ * _]prednK ?muln_gt0 ?expn_gt0 //.",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "by rewrite doubleS addSn /= addSnnS; elim: {-2}_.-1 => //=.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ltn_code s : all (fun j => j < code s) s.",
            "VernacStartTheoremProof",
            "795972abce4d3b3ce30f54396d472ddcd41912da"
        ],
        [
            "elim: s => //= i s IHs; rewrite -[_.+1]muln1 leq_mul 1?ltn_expl //=.",
            "VernacExtend",
            "de65c8193056a36f6dbb91fe21357bd770b140db"
        ],
        [
            "apply: sub_all IHs => j /leqW lejs; rewrite -[j.+1]mul1n leq_mul ?expn_gt0 //.",
            "VernacExtend",
            "56c014161b39aecfb3c54301c2409dba4e8e1857"
        ],
        [
            "by rewrite ltnS -[j]mul1n -mul2n leq_mul.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma gtn_decode n : all (ltn^~ n) (decode n).",
            "VernacStartTheoremProof",
            "65ea1c91e82b76f4457b1cd7f9bd49e87e1c4f13"
        ],
        [
            "by rewrite -{1}[n]decodeK ltn_code.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End CodeSeq.",
            "VernacEndSegment",
            "080ab946b59ef46d0a0d00a08f2e7c925a32ebe3"
        ],
        [
            "Section OtherEncodings.",
            "VernacBeginSection",
            "496e8be35d199b8cd32199b96911c88667c07052"
        ],
        [
            "Variables T T1 T2 : Type.",
            "VernacAssumption",
            "e86a813b41044311bd40c07d0af9a14f3aac5206"
        ],
        [
            "Definition seq_of_opt := @oapp T _ (nseq 1) [::].",
            "VernacDefinition",
            "2ac066c4ee34b44f092811a320d974c905d15ed3"
        ],
        [
            "Lemma seq_of_optK : cancel seq_of_opt ohead.",
            "VernacStartTheoremProof",
            "37e26e3ba59eec943974a69c0d2ea1945b9145ff"
        ],
        [
            "by case.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition tag_of_pair (p : T1 * T2) := @Tagged T1 p.1 (fun _ => T2) p.2.",
            "VernacDefinition",
            "9ac288490b161408e7bf86c139c91edbd46951d8"
        ],
        [
            "Definition pair_of_tag (u : {i : T1 & T2}) := (tag u, tagged u).",
            "VernacDefinition",
            "9429dc7ec99742569c193c8039d3de4aa8e31628"
        ],
        [
            "Lemma tag_of_pairK : cancel tag_of_pair pair_of_tag.",
            "VernacStartTheoremProof",
            "83872f6ed95e20a1b02e97274aa8606c7e33463a"
        ],
        [
            "by case.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pair_of_tagK : cancel pair_of_tag tag_of_pair.",
            "VernacStartTheoremProof",
            "756f7e90d705abcf36bd5c85b1acccd1340e9525"
        ],
        [
            "by case.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition opair_of_sum (s : T1 + T2) := match s with inl x => (Some x, None) | inr y => (None, Some y) end.",
            "VernacDefinition",
            "45f0cd6f45170d660f556cb7bfd3ea1eed2474e8"
        ],
        [
            "Definition sum_of_opair p := oapp (some \\o @inr T1 T2) (omap (@inl _ T2) p.1) p.2.",
            "VernacDefinition",
            "d82551649f2bfa16e7b7e2311d10fa481e10ec75"
        ],
        [
            "Lemma opair_of_sumK : pcancel opair_of_sum sum_of_opair.",
            "VernacStartTheoremProof",
            "4ce2f01508a36823487afa6a39f67b9d328c2bcf"
        ],
        [
            "by case.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bool_of_unitK : cancel (fun _ => true) (fun _ => tt).",
            "VernacStartTheoremProof",
            "85a0e51be94ecfcaed9eed0310bbef22c3f10344"
        ],
        [
            "by case.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End OtherEncodings.",
            "VernacEndSegment",
            "fe4fcc8865e60a7536c92f134228137f953a7386"
        ],
        [
            "Prenex Implicits seq_of_opt tag_of_pair pair_of_tag opair_of_sum sum_of_opair.",
            "VernacExtend",
            "e233c7a56564a440b6c56278ee6fbaefb0ebc246"
        ],
        [
            "Prenex Implicits seq_of_optK tag_of_pairK pair_of_tagK opair_of_sumK.",
            "VernacExtend",
            "7ee58f063fa73328db18c06faaff0c654c997314"
        ],
        [
            "Module GenTree.",
            "VernacDefineModule",
            "f4fd5588e838476ec141b60cdf52fd1e474ef7c7"
        ],
        [
            "Section Def.",
            "VernacBeginSection",
            "891f679f68bab7ae72311468953cd39d353d2080"
        ],
        [
            "Variable T : Type.",
            "VernacAssumption",
            "a15b17e37c4241158d544882375356c273dc93f2"
        ],
        [
            "Unset Elimination Schemes.",
            "VernacUnsetOption",
            "4d234cd3b6f71aa059ae1f499612aad67477dab3"
        ],
        [
            "Inductive tree := Leaf of T | Node of nat & seq tree.",
            "VernacInductive",
            "c76c0094819e546c75fffe0355ade9611f411d92"
        ],
        [
            "Definition tree_rect K IH_leaf IH_node := fix loop t : K t := match t with | Leaf x => IH_leaf x | Node n f0 => let fix iter_pair f : foldr (fun t => prod (K t)) unit f := if f is t :: f' then (loop t, iter_pair f') else tt in IH_node n f0 (iter_pair f0) end.",
            "VernacDefinition",
            "cd2050234e7335fce751686f56ca119faa4b999e"
        ],
        [
            "Definition tree_rec (K : tree -> Set) := @tree_rect K.",
            "VernacDefinition",
            "8ad7ba81fd700ca091f4fd4fbed8c734822946c6"
        ],
        [
            "Definition tree_ind K IH_leaf IH_node := fix loop t : K t : Prop := match t with | Leaf x => IH_leaf x | Node n f0 => let fix iter_conj f : foldr (fun t => and (K t)) True f := if f is t :: f' then conj (loop t) (iter_conj f') else Logic.I in IH_node n f0 (iter_conj f0) end.",
            "VernacDefinition",
            "5fe9be3489e84da25520c9e83e8cc05d23523d7b"
        ],
        [
            "Fixpoint encode t : seq (nat + T) := match t with | Leaf x => [:: inr _ x] | Node n f => inl _ n.+1 :: rcons (flatten (map encode f)) (inl _ 0) end.",
            "VernacFixpoint",
            "494b629e5be7362ff70ed17831f8d0175229c44a"
        ],
        [
            "Definition decode_step c fs := match c with | inr x => (Leaf x :: fs.1, fs.2) | inl 0 => ([::], fs.1 :: fs.2) | inl n.+1 => (Node n fs.1 :: head [::] fs.2, behead fs.2) end.",
            "VernacDefinition",
            "edd2eeb9fa4bf3f6918043213b3b9204f40410ad"
        ],
        [
            "Definition decode c := ohead (foldr decode_step ([::], [::]) c).1.",
            "VernacDefinition",
            "ed5d3fd899abcb05f7d90cf1007997ae60387207"
        ],
        [
            "Lemma codeK : pcancel encode decode.",
            "VernacStartTheoremProof",
            "0eaf323257f103dbf200356f209562906161b87e"
        ],
        [
            "move=> t; rewrite /decode; set fs := (_, _).",
            "VernacExtend",
            "08b421e4a82ee4b06ce888937579fc5af7d251b4"
        ],
        [
            "suffices ->: foldr decode_step fs (encode t) = (t :: fs.1, fs.2) by [].",
            "VernacExtend",
            "290ed488b5562e885aa2cac56f3a69b4faa0eaa6"
        ],
        [
            "elim: t => //= n f IHt in (fs) *; elim: f IHt => //= t f IHf [].",
            "VernacExtend",
            "8d9610d860d3dda1775694df9b5c84e02421098f"
        ],
        [
            "by rewrite rcons_cat foldr_cat => -> /= /IHf[-> -> ->].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Def.",
            "VernacEndSegment",
            "616ad5692568c74f61a9df3a82ac03d2b7ebac01"
        ],
        [
            "End GenTree.",
            "VernacEndSegment",
            "89bf424b623ed040717737e5c97521668d438f79"
        ],
        [
            "Arguments GenTree.codeK : clear implicits.",
            "VernacArguments",
            "528250ffa0e0db95a4389d7ba03b408578132393"
        ],
        [
            "Definition tree_eqMixin (T : eqType) := PcanEqMixin (GenTree.codeK T).",
            "VernacDefinition",
            "1769fef40fd86df0c1648ef3cd6c90aae04e781e"
        ],
        [
            "Canonical tree_eqType (T : eqType) := EqType (GenTree.tree T) (tree_eqMixin T).",
            "VernacDefinition",
            "5db28ad533399446225cbef3ac294ac328f28c9e"
        ],
        [
            "Module Choice.",
            "VernacDefineModule",
            "ba2fe3a61d93a9161bb187d3d49ca01d7f7c3a12"
        ],
        [
            "Section ClassDef.",
            "VernacBeginSection",
            "a5b792261e6c496f5a1a8d0f7da8c96156ca2fed"
        ],
        [
            "Record mixin_of T := Mixin { find : pred T -> nat -> option T; _ : forall P n x, find P n = Some x -> P x; _ : forall P : pred T, (exists x, P x) -> exists n, find P n; _ : forall P Q : pred T, P =1 Q -> find P =1 find Q }.",
            "VernacInductive",
            "3a9c997d9941ebea02876ecfb479dc5508467da3"
        ],
        [
            "Record class_of T := Class {base : Equality.class_of T; mixin : mixin_of T}.",
            "VernacInductive",
            "14a5b1b88a0d3a0cca6f09900461339a6635b32a"
        ],
        [
            "Local Coercion base : class_of >-> Equality.class_of.",
            "VernacCoercion",
            "24a98867dac3d3769e5a2ca16e45d82fb1a2b418"
        ],
        [
            "Structure type := Pack {sort; _ : class_of sort}.",
            "VernacInductive",
            "42b0161295055637e72e97af35c3d44479cc946b"
        ],
        [
            "Local Coercion sort : type >-> Sortclass.",
            "VernacCoercion",
            "e4478cd37693106f84ed020bd073c4970dc87530"
        ],
        [
            "Variables (T : Type) (cT : type).",
            "VernacAssumption",
            "eb35f5737a32cba56acb24ac87490232dc2dfcb9"
        ],
        [
            "Definition class := let: Pack _ c as cT' := cT return class_of cT' in c.",
            "VernacDefinition",
            "0e4a80652d474f8010316ff26a5322b5207d82a3"
        ],
        [
            "Definition clone c of phant_id class c := @Pack T c.",
            "VernacDefinition",
            "e082321bed0d5d4d78139419fead577313b82668"
        ],
        [
            "Let xT := let: Pack T _ := cT in T.",
            "VernacDefinition",
            "0a87c77e3a5ac8febf0910b95d7b998b7cb9cf6d"
        ],
        [
            "Notation xclass := (class : class_of xT).",
            "VernacSyntacticDefinition",
            "e136614fedd7b331a23b54adad5b0bce11895ed4"
        ],
        [
            "Definition pack m := fun b bT & phant_id (Equality.class bT) b => Pack (@Class T b m).",
            "VernacDefinition",
            "9569594b3b490c927ce2b18b4f56d3ef198b16cf"
        ],
        [
            "Definition eqType := @Equality.Pack cT xclass.",
            "VernacDefinition",
            "6139f412b89e62ff13c9c707c885de4b39151e9d"
        ],
        [
            "End ClassDef.",
            "VernacEndSegment",
            "bce1c8832045d8291c44a3fb67e9767782d2745b"
        ],
        [
            "Module Import Exports.",
            "VernacDefineModule",
            "f5a1035b94691e963f68c6f9e1df4c47bb9f27d8"
        ],
        [
            "Coercion base : class_of >-> Equality.class_of.",
            "VernacCoercion",
            "c210e2f5474b2da1bd12d01bbb05530e5ff0f9d6"
        ],
        [
            "Coercion sort : type >-> Sortclass.",
            "VernacCoercion",
            "9e1cbf06afa0d2731dbb8bfd6b9ae32be22a8ae7"
        ],
        [
            "Coercion eqType : type >-> Equality.type.",
            "VernacCoercion",
            "58308c67b5e73c9e004d57c486a5071598a25e8c"
        ],
        [
            "Canonical eqType.",
            "VernacCanonical",
            "dd1ac877a396f552e2a8f23e59be45903d8b15ad"
        ],
        [
            "Notation choiceType := type.",
            "VernacSyntacticDefinition",
            "f7a215f2d5abe6e28695463c67b58aa4a029ebdd"
        ],
        [
            "Notation choiceMixin := mixin_of.",
            "VernacSyntacticDefinition",
            "03e215043e6829f971cf3747709b339cdddb62b3"
        ],
        [
            "Notation ChoiceType T m := (@pack T m _ _ id).",
            "VernacSyntacticDefinition",
            "7253fa43a818839d4855db58a25e85cb37117c53"
        ],
        [
            "Notation \"[ 'choiceType' 'of' T 'for' cT ]\" := (@clone T cT _ idfun) (at level 0, format \"[ 'choiceType' 'of' T 'for' cT ]\") : form_scope.",
            "VernacNotation",
            "5288e3349f03be52ba6ddf6fba466633a163c98a"
        ],
        [
            "Notation \"[ 'choiceType' 'of' T ]\" := (@clone T _ _ id) (at level 0, format \"[ 'choiceType' 'of' T ]\") : form_scope.",
            "VernacNotation",
            "623957d7802c55d8ab0933c002821e54fdf89391"
        ],
        [
            "End Exports.",
            "VernacEndSegment",
            "71efedae7ccffd696e1ffe5d8ae6baa8a4484918"
        ],
        [
            "Module InternalTheory.",
            "VernacDefineModule",
            "b1b31f12a236afd704272d32312fc407de016987"
        ],
        [
            "Section InternalTheory.",
            "VernacBeginSection",
            "0eb81ab80c2b849f4634dbdfd07a4fa353dfb001"
        ],
        [
            "Definition find T := find (mixin (class T)).",
            "VernacDefinition",
            "c80fe73d4bc7e2388551610004de1cfe019fd63a"
        ],
        [
            "Variable T : choiceType.",
            "VernacAssumption",
            "e5a71f2b7fbe826624aa45de919f05159938a9ea"
        ],
        [
            "Implicit Types P Q : pred T.",
            "VernacReserve",
            "41f7150f9daed8c8a64d887acdcc469a88a12301"
        ],
        [
            "Lemma correct P n x : find P n = Some x -> P x.",
            "VernacStartTheoremProof",
            "e898746674cbeb486b88e3be3b83c5a4ca415de6"
        ],
        [
            "by case: T => _ [_ []] //= in P n x *.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma complete P : (exists x, P x) -> (exists n, find P n).",
            "VernacStartTheoremProof",
            "b3465896b63ad8fe148045037963532f9d6ac38c"
        ],
        [
            "by case: T => _ [_ []] //= in P *.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma extensional P Q : P =1 Q -> find P =1 find Q.",
            "VernacStartTheoremProof",
            "7e15685341746dc7bcefd68bb37b9fa4d5f3d4fe"
        ],
        [
            "by case: T => _ [_ []] //= in P Q *.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fact xchoose_subproof P exP : {x | find P (ex_minn (@complete P exP)) = Some x}.",
            "VernacStartTheoremProof",
            "88c471c6e0a58b32df38911d812c105c9687ce46"
        ],
        [
            "by case: (ex_minnP (complete exP)) => n; case: (find P n) => // x; exists x.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End InternalTheory.",
            "VernacEndSegment",
            "62d1ea14562bf621bb7525f4c342d38c0cd44071"
        ],
        [
            "End InternalTheory.",
            "VernacEndSegment",
            "62d1ea14562bf621bb7525f4c342d38c0cd44071"
        ],
        [
            "End Choice.",
            "VernacEndSegment",
            "cedef37fba47f6c599d068c53cdeda084ed84809"
        ],
        [
            "Export Choice.Exports.",
            "VernacImport",
            "9404a8fc224a2a6bddcf7b4a8caf9f0c0b68ab1f"
        ],
        [
            "Section ChoiceTheory.",
            "VernacBeginSection",
            "18c7d78952b127b4c4960c2677506d6fa7305386"
        ],
        [
            "Implicit Type T : choiceType.",
            "VernacReserve",
            "ad69471e4077005bb5d4e417242c58ce7a149cac"
        ],
        [
            "Import Choice.InternalTheory CodeSeq.",
            "VernacImport",
            "0fd86d4a79de15fc0cc71c9073d935a9e7df549d"
        ],
        [
            "Local Notation dc := decode.",
            "VernacSyntacticDefinition",
            "a3b8262eef7cb308a1f9cce7d24fa09ab79b154c"
        ],
        [
            "Section OneType.",
            "VernacBeginSection",
            "85568baf75a807b53c4b5f13d3476b4f35b563a0"
        ],
        [
            "Variable T : choiceType.",
            "VernacAssumption",
            "e5a71f2b7fbe826624aa45de919f05159938a9ea"
        ],
        [
            "Implicit Types P Q : pred T.",
            "VernacReserve",
            "41f7150f9daed8c8a64d887acdcc469a88a12301"
        ],
        [
            "Definition xchoose P exP := sval (@xchoose_subproof T P exP).",
            "VernacDefinition",
            "8de1ff2f6c785e78402a5f1840077df061e840da"
        ],
        [
            "Lemma xchooseP P exP : P (@xchoose P exP).",
            "VernacStartTheoremProof",
            "888184f46e740b57e3e1c19f893033d77b4d237e"
        ],
        [
            "by rewrite /xchoose; case: (xchoose_subproof exP) => x /= /correct.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_xchoose P Q exP exQ : P =1 Q -> @xchoose P exP = @xchoose Q exQ.",
            "VernacStartTheoremProof",
            "0caae9486071ff45ea338ce036850e803e8b7f19"
        ],
        [
            "rewrite /xchoose => eqPQ.",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "case: (xchoose_subproof exP) => x; case: (xchoose_subproof exQ) => y /=.",
            "VernacExtend",
            "5887f8022a4f6389ac249140364feb69c4f18799"
        ],
        [
            "case: ex_minnP => n; case: ex_minnP => m.",
            "VernacExtend",
            "5887f8022a4f6389ac249140364feb69c4f18799"
        ],
        [
            "rewrite -(extensional eqPQ) {1}(extensional eqPQ).",
            "VernacExtend",
            "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
        ],
        [
            "move=> Qm minPm Pn minQn; suffices /eqP->: m == n by move=> -> [].",
            "VernacExtend",
            "f8582445b13cd09e9c30648f0ec245f72ecdd43e"
        ],
        [
            "by rewrite eqn_leq minQn ?minPm.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sigW P : (exists x, P x) -> {x | P x}.",
            "VernacStartTheoremProof",
            "70bf0b53b0d415bafa0e8261232c75554e804ee6"
        ],
        [
            "by move=> exP; exists (xchoose exP); apply: xchooseP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sig2W P Q : (exists2 x, P x & Q x) -> {x | P x & Q x}.",
            "VernacStartTheoremProof",
            "ed97dec265d65b9cdce3cb4d8fbf156f1c14496e"
        ],
        [
            "move=> exPQ; have [|x /andP[]] := @sigW (predI P Q); last by exists x.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by have [x Px Qx] := exPQ; exists x; apply/andP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sig_eqW (vT : eqType) (lhs rhs : T -> vT) : (exists x, lhs x = rhs x) -> {x | lhs x = rhs x}.",
            "VernacStartTheoremProof",
            "b82478e7453569f39686eb55c6585735d19f9a0a"
        ],
        [
            "move=> exP; suffices [x /eqP Ex]: {x | lhs x == rhs x} by exists x.",
            "VernacExtend",
            "f8582445b13cd09e9c30648f0ec245f72ecdd43e"
        ],
        [
            "by apply: sigW; have [x /eqP Ex] := exP; exists x.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma sig2_eqW (vT : eqType) (P : pred T) (lhs rhs : T -> vT) : (exists2 x, P x & lhs x = rhs x) -> {x | P x & lhs x = rhs x}.",
            "VernacStartTheoremProof",
            "3779cb0fe62297abcc65b3d46436bef404d990e9"
        ],
        [
            "move=> exP; suffices [x Px /eqP Ex]: {x | P x & lhs x == rhs x} by exists x.",
            "VernacExtend",
            "f8582445b13cd09e9c30648f0ec245f72ecdd43e"
        ],
        [
            "by apply: sig2W; have [x Px /eqP Ex] := exP; exists x.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition choose P x0 := if insub x0 : {? x | P x} is Some (exist x Px) then xchoose (ex_intro [eta P] x Px) else x0.",
            "VernacDefinition",
            "bad41241b00b506eec8b704bd79abffd3a232881"
        ],
        [
            "Lemma chooseP P x0 : P x0 -> P (choose P x0).",
            "VernacStartTheoremProof",
            "6bb06c5534234e31f27c668a7ed1f012f7944703"
        ],
        [
            "by move=> Px0; rewrite /choose insubT xchooseP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma choose_id P x0 y0 : P x0 -> P y0 -> choose P x0 = choose P y0.",
            "VernacStartTheoremProof",
            "8018c2d542639f1719f684fbb8e58f8c7548ae2b"
        ],
        [
            "by move=> Px0 Py0; rewrite /choose !insubT /=; apply: eq_xchoose.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_choose P Q : P =1 Q -> choose P =1 choose Q.",
            "VernacStartTheoremProof",
            "7e5c89d4d48b64ac7cbbd423b9a8580d7245dc03"
        ],
        [
            "rewrite /choose => eqPQ x0.",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "do [case: insubP; rewrite eqPQ] => [[x Px] Qx0 _| ?]; last by rewrite insubN.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by rewrite insubT; apply: eq_xchoose.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Section CanChoice.",
            "VernacBeginSection",
            "55f20cd05f6fecdd3b9a2d19b07568503f859083"
        ],
        [
            "Variables (sT : Type) (f : sT -> T).",
            "VernacAssumption",
            "dd07952534aa75cf8141a0bb286055d470ca42e8"
        ],
        [
            "Lemma PcanChoiceMixin f' : pcancel f f' -> choiceMixin sT.",
            "VernacStartTheoremProof",
            "9fdd0b64863b68b19e32e415807bd55dd3d90268"
        ],
        [
            "move=> fK; pose liftP sP := [pred x | oapp sP false (f' x)].",
            "VernacExtend",
            "fef3c4a8f7fcf70b0824f3cce5fb58f2e0ef07fd"
        ],
        [
            "pose sf sP := [fun n => obind f' (find (liftP sP) n)].",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "exists sf => [sP n x | sP [y sPy] | sP sQ eqPQ n] /=.",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "by case Df: (find _ n) => //= [?] Dx; have:= correct Df; rewrite /= Dx.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "have [|n Pn] := @complete T (liftP sP); first by exists (f y); rewrite /= fK.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "exists n; case Df: (find _ n) Pn => //= [x] _.",
            "VernacExtend",
            "cbbb75496c1025c06e7833ae1a14f90e6dbf6393"
        ],
        [
            "by have:= correct Df => /=; case: (f' x).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by congr (obind _ _); apply: extensional => x /=; case: (f' x) => /=.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition CanChoiceMixin f' (fK : cancel f f') := PcanChoiceMixin (can_pcan fK).",
            "VernacDefinition",
            "04732e39bcd6169d1dc58a6b230facf6e61a33b1"
        ],
        [
            "End CanChoice.",
            "VernacEndSegment",
            "89d1d87f0a59898c78638f02d44035318c061b6b"
        ],
        [
            "Section SubChoice.",
            "VernacBeginSection",
            "2adbecb715741dc74a0bc2c53a523f5d79fdcfbe"
        ],
        [
            "Variables (P : pred T) (sT : subType P).",
            "VernacAssumption",
            "40abc709799257562bad3b9394ba67c225de038f"
        ],
        [
            "Definition sub_choiceMixin := PcanChoiceMixin (@valK T P sT).",
            "VernacDefinition",
            "857b210b589618b527df995915a8d2d584847652"
        ],
        [
            "Definition sub_choiceClass := @Choice.Class sT (sub_eqMixin sT) sub_choiceMixin.",
            "VernacDefinition",
            "1908c8b3ac986a25838aa40786a41debb613ec30"
        ],
        [
            "Canonical sub_choiceType := Choice.Pack sub_choiceClass.",
            "VernacDefinition",
            "4ad6ede7652ead47df0da738ab4db3ba6dc1f3e2"
        ],
        [
            "End SubChoice.",
            "VernacEndSegment",
            "e57b1c89971810b46012f09728a27671d07657e8"
        ],
        [
            "Fact seq_choiceMixin : choiceMixin (seq T).",
            "VernacStartTheoremProof",
            "ae233e8b12d88baedc08ab8f1d217b631688b64a"
        ],
        [
            "pose r f := [fun xs => fun x : T => f (x :: xs) : option (seq T)].",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "pose fix f sP ns xs {struct ns} := if ns is n :: ns1 then let fr := r (f sP ns1) xs in obind fr (find fr n) else if sP xs then Some xs else None.",
            "VernacExtend",
            "be59184aeceac70e4255bd58cff677d981339a6d"
        ],
        [
            "exists (fun sP nn => f sP (dc nn) nil) => [sP n ys | sP [ys] | sP sQ eqPQ n].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "elim: {n}(dc n) nil => [|n ns IHs] xs /=; first by case: ifP => // sPxs [<-].",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by case: (find _ n) => //= [x]; apply: IHs.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "rewrite -(cats0 ys); elim/last_ind: ys nil => [|ys y IHs] xs /=.",
            "VernacExtend",
            "44a8e3b453c9376c468b4e3e0046f5ac33e11d6d"
        ],
        [
            "by move=> sPxs; exists 0; rewrite /= sPxs.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "rewrite cat_rcons => /IHs[n1 sPn1] {IHs}.",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "have /complete[n]: exists z, f sP (dc n1) (z :: xs) by exists y.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "case Df: (find _ n)=> // [x] _; exists (code (n :: dc n1)).",
            "VernacExtend",
            "70d74ce9f1afc29f3e72a76d98f3cd9bda2d2292"
        ],
        [
            "by rewrite codeK /= Df /= (correct Df).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "elim: {n}(dc n) nil => [|n ns IHs] xs /=; first by rewrite eqPQ.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "rewrite (@extensional _ _ (r (f sQ ns) xs)) => [|x]; last by rewrite IHs.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by case: find => /=.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Canonical seq_choiceType := Eval hnf in ChoiceType (seq T) seq_choiceMixin.",
            "VernacDefinition",
            "7fd87984a5d232a0a526e6a8919bb087b0f2de8d"
        ],
        [
            "End OneType.",
            "VernacEndSegment",
            "f4fbc60f96915801bb6fcea26b860ae6d55a09b4"
        ],
        [
            "Section TagChoice.",
            "VernacBeginSection",
            "982a7abb6be1a606512486d08dfbd77f66625b02"
        ],
        [
            "Variables (I : choiceType) (T_ : I -> choiceType).",
            "VernacAssumption",
            "9e3d97d66e977aeac770f8d7652c29943869829e"
        ],
        [
            "Fact tagged_choiceMixin : choiceMixin {i : I & T_ i}.",
            "VernacStartTheoremProof",
            "3475bcb6f682ab251ef9d6c7ced2e2e0dc710542"
        ],
        [
            "pose mkT i (x : T_ i) := Tagged T_ x.",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "pose ft tP n i := omap (mkT i) (find (tP \\o mkT i) n).",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "pose fi tP ni nt := obind (ft tP nt) (find (ft tP nt) ni).",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "pose f tP n := if dc n is [:: ni; nt] then fi tP ni nt else None.",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "exists f => [tP n u | tP [[i x] tPxi] | sP sQ eqPQ n].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "rewrite /f /fi; case: (dc n) => [|ni [|nt []]] //=.",
            "VernacExtend",
            "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
        ],
        [
            "case: (find _ _) => //= [i]; rewrite /ft.",
            "VernacExtend",
            "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
        ],
        [
            "by case Df: (find _ _) => //= [x] [<-]; have:= correct Df.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "have /complete[nt tPnt]: exists y, (tP \\o mkT i) y by exists x.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "have{tPnt}: exists j, ft tP nt j by exists i; rewrite /ft; case: find tPnt.",
            "VernacExtend",
            "406cde1174359c53bf162a2a18c4eede395555f9"
        ],
        [
            "case/complete=> ni tPn; exists (code [:: ni; nt]); rewrite /f codeK /fi.",
            "VernacExtend",
            "c7952652f726da4699f6b37d5f524bbcadf0d418"
        ],
        [
            "by case Df: find tPn => //= [j] _; have:= correct Df.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "rewrite /f /fi; case: (dc n) => [|ni [|nt []]] //=.",
            "VernacExtend",
            "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
        ],
        [
            "rewrite (@extensional _ _ (ft sQ nt)) => [|i].",
            "VernacExtend",
            "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
        ],
        [
            "by case: find => //= i; congr (omap _ _); apply: extensional => x /=.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by congr (omap _ _); apply: extensional => x /=.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Canonical tagged_choiceType := Eval hnf in ChoiceType {i : I & T_ i} tagged_choiceMixin.",
            "VernacDefinition",
            "e63e67c0f6e83388e062e39c19a36982365c37b0"
        ],
        [
            "End TagChoice.",
            "VernacEndSegment",
            "b7103ef89056b7ea4391263f7d0251fb212197e2"
        ],
        [
            "Fact nat_choiceMixin : choiceMixin nat.",
            "VernacStartTheoremProof",
            "ac1fa834db9f2292e50d1697b0a65841b670a0a9"
        ],
        [
            "pose f := [fun (P : pred nat) n => if P n then Some n else None].",
            "VernacExtend",
            "3c5f04de94609049d978298aa02ff35fb35ea7c7"
        ],
        [
            "exists f => [P n m | P [n Pn] | P Q eqPQ n] /=; last by rewrite eqPQ.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by case: ifP => // Pn [<-].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "by exists n; rewrite Pn.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Canonical nat_choiceType := Eval hnf in ChoiceType nat nat_choiceMixin.",
            "VernacDefinition",
            "efb68fe055ab3252875191e7fad88bbb07295ea8"
        ],
        [
            "Definition bool_choiceMixin := CanChoiceMixin oddb.",
            "VernacDefinition",
            "35e1b962e2c39d227e19cfe82c34993c82195eff"
        ],
        [
            "Canonical bool_choiceType := Eval hnf in ChoiceType bool bool_choiceMixin.",
            "VernacDefinition",
            "1b3b0d50530a7125e660a4ef33840ae852295f2d"
        ],
        [
            "Canonical bitseq_choiceType := Eval hnf in [choiceType of bitseq].",
            "VernacDefinition",
            "5b42f3ec649f75fdc30c6c566772e501043f2b9d"
        ],
        [
            "Definition unit_choiceMixin := CanChoiceMixin bool_of_unitK.",
            "VernacDefinition",
            "0677236888f07f864b12b0af3175e59a6607ecbc"
        ],
        [
            "Canonical unit_choiceType := Eval hnf in ChoiceType unit unit_choiceMixin.",
            "VernacDefinition",
            "5eeda599d7d5f6517bbb5b7c32686e4bf41b5956"
        ],
        [
            "Definition option_choiceMixin T := CanChoiceMixin (@seq_of_optK T).",
            "VernacDefinition",
            "7baa2a6b04d082051b862a0f4f83c20d5a7f084a"
        ],
        [
            "Canonical option_choiceType T := Eval hnf in ChoiceType (option T) (option_choiceMixin T).",
            "VernacDefinition",
            "01ed4500e03ebffe748b6201fa770db7b852d811"
        ],
        [
            "Definition sig_choiceMixin T (P : pred T) : choiceMixin {x | P x} := sub_choiceMixin _.",
            "VernacDefinition",
            "b6ea5ba7e6e8225c7ee0f6dea89e070669b5f26e"
        ],
        [
            "Canonical sig_choiceType T (P : pred T) := Eval hnf in ChoiceType {x | P x} (sig_choiceMixin P).",
            "VernacDefinition",
            "2cf962bb5a2499fd48aeca989a02fd63467edf8e"
        ],
        [
            "Definition prod_choiceMixin T1 T2 := CanChoiceMixin (@tag_of_pairK T1 T2).",
            "VernacDefinition",
            "ea557eeea845d44b3c4ca070e7706ace4998c468"
        ],
        [
            "Canonical prod_choiceType T1 T2 := Eval hnf in ChoiceType (T1 * T2) (prod_choiceMixin T1 T2).",
            "VernacDefinition",
            "5b2774057ec6af68d366b30f021a89ddb3d45d88"
        ],
        [
            "Definition sum_choiceMixin T1 T2 := PcanChoiceMixin (@opair_of_sumK T1 T2).",
            "VernacDefinition",
            "b0c7be9c3edc2983444dacb97027b8e5e2d55718"
        ],
        [
            "Canonical sum_choiceType T1 T2 := Eval hnf in ChoiceType (T1 + T2) (sum_choiceMixin T1 T2).",
            "VernacDefinition",
            "c7e1b76685fa2f2da8fe256e92e40dee077ba25b"
        ],
        [
            "Definition tree_choiceMixin T := PcanChoiceMixin (GenTree.codeK T).",
            "VernacDefinition",
            "d57a56589ec1f956c9de7cb36e5a91f73b7b012a"
        ],
        [
            "Canonical tree_choiceType T := ChoiceType (GenTree.tree T) (tree_choiceMixin T).",
            "VernacDefinition",
            "eae3f85c4d490f2ceb4371a934a48eac5b887984"
        ],
        [
            "End ChoiceTheory.",
            "VernacEndSegment",
            "f6f0eb9ab748873528a009c31c875ddff7d2041a"
        ],
        [
            "Prenex Implicits xchoose choose.",
            "VernacExtend",
            "b316c8633a694fcb26de5e749d5c1f3a569e33c4"
        ],
        [
            "Notation \"[ 'choiceMixin' 'of' T 'by' <: ]\" := (sub_choiceMixin _ : choiceMixin T) (at level 0, format \"[ 'choiceMixin' 'of' T 'by' <: ]\") : form_scope.",
            "VernacNotation",
            "bbd68f74d4470071b423a57966fb0d03d6aba009"
        ],
        [
            "Module Countable.",
            "VernacDefineModule",
            "eac8ef85460a5b129c591f1ddb2496b64a017dc6"
        ],
        [
            "Record mixin_of (T : Type) : Type := Mixin { pickle : T -> nat; unpickle : nat -> option T; pickleK : pcancel pickle unpickle }.",
            "VernacInductive",
            "ec2e3b997b64fb8913409aafc82712a6ad0d6a9b"
        ],
        [
            "Definition EqMixin T m := PcanEqMixin (@pickleK T m).",
            "VernacDefinition",
            "73c03e1444c4e44fbea620f5fc7c2c2bc7dbd4ad"
        ],
        [
            "Definition ChoiceMixin T m := PcanChoiceMixin (@pickleK T m).",
            "VernacDefinition",
            "a92af0335888ef0956d3e1912be8865585eecfe9"
        ],
        [
            "Section ClassDef.",
            "VernacBeginSection",
            "a5b792261e6c496f5a1a8d0f7da8c96156ca2fed"
        ],
        [
            "Record class_of T := Class { base : Choice.class_of T; mixin : mixin_of T }.",
            "VernacInductive",
            "c8715ec343d3d1feee4020d2f0adbdca578c0d18"
        ],
        [
            "Local Coercion base : class_of >-> Choice.class_of.",
            "VernacCoercion",
            "d83493046a5d9087ea18e45eb84fd49a84eedb81"
        ],
        [
            "Structure type : Type := Pack {sort : Type; _ : class_of sort}.",
            "VernacInductive",
            "fe005e9e42bd7759257d63deeda273f09f6fd17d"
        ],
        [
            "Local Coercion sort : type >-> Sortclass.",
            "VernacCoercion",
            "e4478cd37693106f84ed020bd073c4970dc87530"
        ],
        [
            "Variables (T : Type) (cT : type).",
            "VernacAssumption",
            "eb35f5737a32cba56acb24ac87490232dc2dfcb9"
        ],
        [
            "Definition class := let: Pack _ c as cT' := cT return class_of cT' in c.",
            "VernacDefinition",
            "0e4a80652d474f8010316ff26a5322b5207d82a3"
        ],
        [
            "Definition clone c of phant_id class c := @Pack T c.",
            "VernacDefinition",
            "e082321bed0d5d4d78139419fead577313b82668"
        ],
        [
            "Let xT := let: Pack T _ := cT in T.",
            "VernacDefinition",
            "0a87c77e3a5ac8febf0910b95d7b998b7cb9cf6d"
        ],
        [
            "Notation xclass := (class : class_of xT).",
            "VernacSyntacticDefinition",
            "e136614fedd7b331a23b54adad5b0bce11895ed4"
        ],
        [
            "Definition pack m := fun bT b & phant_id (Choice.class bT) b => Pack (@Class T b m).",
            "VernacDefinition",
            "1052f934c21b4426e2b39eec9220bf0f553c822e"
        ],
        [
            "Definition eqType := @Equality.Pack cT xclass.",
            "VernacDefinition",
            "6139f412b89e62ff13c9c707c885de4b39151e9d"
        ],
        [
            "Definition choiceType := @Choice.Pack cT xclass.",
            "VernacDefinition",
            "f62d3090382a5ea70b978e0633e0376c4558db55"
        ],
        [
            "End ClassDef.",
            "VernacEndSegment",
            "bce1c8832045d8291c44a3fb67e9767782d2745b"
        ],
        [
            "Module Exports.",
            "VernacDefineModule",
            "d4a1114ec53f746523a7dec57823f7f03e51fa24"
        ],
        [
            "Coercion base : class_of >-> Choice.class_of.",
            "VernacCoercion",
            "0fd77195a8e6f400b16548cfc0dc57a383882923"
        ],
        [
            "Coercion mixin : class_of >-> mixin_of.",
            "VernacCoercion",
            "6e94763ee53fdac946511987d81c3f6daccc67c3"
        ],
        [
            "Coercion sort : type >-> Sortclass.",
            "VernacCoercion",
            "9e1cbf06afa0d2731dbb8bfd6b9ae32be22a8ae7"
        ],
        [
            "Coercion eqType : type >-> Equality.type.",
            "VernacCoercion",
            "58308c67b5e73c9e004d57c486a5071598a25e8c"
        ],
        [
            "Canonical eqType.",
            "VernacCanonical",
            "dd1ac877a396f552e2a8f23e59be45903d8b15ad"
        ],
        [
            "Coercion choiceType : type >-> Choice.type.",
            "VernacCoercion",
            "bdc8d608f4b963a8606cd33ad18b1977a8bcb78d"
        ],
        [
            "Canonical choiceType.",
            "VernacCanonical",
            "af7a1759ddd13e2b7e4e1ce16b6a3595a77b5659"
        ],
        [
            "Notation countType := type.",
            "VernacSyntacticDefinition",
            "cb16fd9729faebde771852f89401d46cdeb78eac"
        ],
        [
            "Notation CountType T m := (@pack T m _ _ id).",
            "VernacSyntacticDefinition",
            "02366b4c1bda1058ddeeedc6762866e7a8955a13"
        ],
        [
            "Notation CountMixin := Mixin.",
            "VernacSyntacticDefinition",
            "a158a7e4e0415a4d632e5a76d23f34e6c957a745"
        ],
        [
            "Notation CountChoiceMixin := ChoiceMixin.",
            "VernacSyntacticDefinition",
            "a455516203025baaf5b769953402c29d7f113456"
        ],
        [
            "Notation \"[ 'countType' 'of' T 'for' cT ]\" := (@clone T cT _ idfun) (at level 0, format \"[ 'countType' 'of' T 'for' cT ]\") : form_scope.",
            "VernacNotation",
            "a2892f1836ef51ce7bc9c18eecb4996cf6de15ce"
        ],
        [
            "Notation \"[ 'countType' 'of' T ]\" := (@clone T _ _ id) (at level 0, format \"[ 'countType' 'of' T ]\") : form_scope.",
            "VernacNotation",
            "21b6de9a4aeee145390d4e2fb7027fd18dcd7464"
        ],
        [
            "End Exports.",
            "VernacEndSegment",
            "71efedae7ccffd696e1ffe5d8ae6baa8a4484918"
        ],
        [
            "End Countable.",
            "VernacEndSegment",
            "cd9cdef6b8f0261730e671c8c3713aed9ad33960"
        ],
        [
            "Export Countable.Exports.",
            "VernacImport",
            "c1d171ff7b6784bf3bf2f2cd0b46ca0f8893f342"
        ],
        [
            "Definition unpickle T := Countable.unpickle (Countable.class T).",
            "VernacDefinition",
            "ab22926033c7647634f7fdaa6362c150fa78533d"
        ],
        [
            "Definition pickle T := Countable.pickle (Countable.class T).",
            "VernacDefinition",
            "2d24fba44aa2ffa55d6d4eb5543939256b9b2047"
        ],
        [
            "Arguments unpickle {T} n.",
            "VernacArguments",
            "4d971ad0e807291b7bdea71c07a1ec13cfadc99a"
        ],
        [
            "Arguments pickle {T} x.",
            "VernacArguments",
            "55a5d5276ca4e9b34232e723bae1abfdd35d24a6"
        ],
        [
            "Section CountableTheory.",
            "VernacBeginSection",
            "af7ce46b55a788498041622f93a171b5000d3500"
        ],
        [
            "Variable T : countType.",
            "VernacAssumption",
            "8bede86bd32132340fd3147693ef6d3798467025"
        ],
        [
            "Lemma pickleK : @pcancel nat T pickle unpickle.",
            "VernacStartTheoremProof",
            "32283045d243b86f5d0720c05562d1a2b2ac37f9"
        ],
        [
            "exact: Countable.pickleK.",
            "VernacExtend",
            "ce637ff86bafca5d8359473e8c02af644dcbdc43"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition pickle_inv n := obind (fun x : T => if pickle x == n then Some x else None) (unpickle n).",
            "VernacDefinition",
            "43106a1b62f65675b17a69f0bde64c09b4ce29a7"
        ],
        [
            "Lemma pickle_invK : ocancel pickle_inv pickle.",
            "VernacStartTheoremProof",
            "c13cd0cf9b3f66613ec4b57c61dde52ed78049f7"
        ],
        [
            "by rewrite /pickle_inv => n; case def_x: (unpickle n) => //= [x]; case: eqP.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pickleK_inv : pcancel pickle pickle_inv.",
            "VernacStartTheoremProof",
            "1e7d07af63d54fdb9da1063df11c6d313fd3cda8"
        ],
        [
            "by rewrite /pickle_inv => x; rewrite pickleK /= eqxx.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma pcan_pickleK sT f f' : @pcancel T sT f f' -> pcancel (pickle \\o f) (pcomp f' unpickle).",
            "VernacStartTheoremProof",
            "a7ea03a68efce08c68c2023387520f0fed081ddf"
        ],
        [
            "by move=> fK x; rewrite /pcomp pickleK /= fK.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition PcanCountMixin sT f f' (fK : pcancel f f') := @CountMixin sT _ _ (pcan_pickleK fK).",
            "VernacDefinition",
            "369b1b994db2932d017873da5fa3ba4cd77055b1"
        ],
        [
            "Definition CanCountMixin sT f f' (fK : cancel f f') := @PcanCountMixin sT _ _ (can_pcan fK).",
            "VernacDefinition",
            "c2193c842e2bb7f5dabc0dd9a27d39be006e86b7"
        ],
        [
            "Definition sub_countMixin P sT := PcanCountMixin (@valK T P sT).",
            "VernacDefinition",
            "64af841ac63aa2cd5339f267bba4d6f4aece31b5"
        ],
        [
            "Definition pickle_seq s := CodeSeq.code (map (@pickle T) s).",
            "VernacDefinition",
            "4c34843c08c3d767b7291da7d93a69c75f8afb1f"
        ],
        [
            "Definition unpickle_seq n := Some (pmap (@unpickle T) (CodeSeq.decode n)).",
            "VernacDefinition",
            "f837847168ada684cd7f4f5d36764ccb27118d12"
        ],
        [
            "Lemma pickle_seqK : pcancel pickle_seq unpickle_seq.",
            "VernacStartTheoremProof",
            "30d4b7ecb5a8ceb6d25f17a891088bf4283bb113"
        ],
        [
            "by move=> s; rewrite /unpickle_seq CodeSeq.codeK (map_pK pickleK).",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition seq_countMixin := CountMixin pickle_seqK.",
            "VernacDefinition",
            "7baeb4a74ae1674cbad673ab2cd5f82eaa18b6ba"
        ],
        [
            "Canonical seq_countType := Eval hnf in CountType (seq T) seq_countMixin.",
            "VernacDefinition",
            "e10eb42e063ccc266d29605d3aee0a65df721c24"
        ],
        [
            "End CountableTheory.",
            "VernacEndSegment",
            "4a0e43b78493826934bf263af4e752daaaf63401"
        ],
        [
            "Notation \"[ 'countMixin' 'of' T 'by' <: ]\" := (sub_countMixin _ : Countable.mixin_of T) (at level 0, format \"[ 'countMixin' 'of' T 'by' <: ]\") : form_scope.",
            "VernacNotation",
            "b268b03123763afeb2b9828d4c227099f4a5d973"
        ],
        [
            "Arguments pickle_inv {T} n.",
            "VernacArguments",
            "3b9fe9d5be72987a6e6977a569244c17565b2caa"
        ],
        [
            "Arguments pickleK {T} x.",
            "VernacArguments",
            "c68e2adb26c5d175bab069a1e0ea55773ccc2295"
        ],
        [
            "Arguments pickleK_inv {T} x.",
            "VernacArguments",
            "f1092aea8e77500ae3335600e8f47195252d46e5"
        ],
        [
            "Arguments pickle_invK {T} n : rename.",
            "VernacArguments",
            "edf9f8995092884de83a4b2aa99ab61d776f4dbb"
        ],
        [
            "Section SubCountType.",
            "VernacBeginSection",
            "b9ba1e7a57e3c01890fd279a81fd0521b01a0332"
        ],
        [
            "Variables (T : choiceType) (P : pred T).",
            "VernacAssumption",
            "3b792989d357bfc128a2304af0196775c4450576"
        ],
        [
            "Import Countable.",
            "VernacImport",
            "bca357830440582b67b6b91cb310b0ec6e818ace"
        ],
        [
            "Structure subCountType : Type := SubCountType {subCount_sort :> subType P; _ : mixin_of subCount_sort}.",
            "VernacInductive",
            "7bce3341a0f9ac9a5f987a4d2b25f8a6b262de47"
        ],
        [
            "Coercion sub_countType (sT : subCountType) := Eval hnf in pack (let: SubCountType _ m := sT return mixin_of sT in m) id.",
            "VernacDefinition",
            "9b36c6d3cc30a143d477a2b3b87051ef624f1748"
        ],
        [
            "Canonical sub_countType.",
            "VernacCanonical",
            "a14565051e285a886c11cbc5a5958b028572b4ba"
        ],
        [
            "Definition pack_subCountType U := fun sT cT & sub_sort sT * sort cT -> U * U => fun b m & phant_id (Class b m) (class cT) => @SubCountType sT m.",
            "VernacDefinition",
            "722b58c662f1bf00f07456c2fdef1591161002a3"
        ],
        [
            "End SubCountType.",
            "VernacEndSegment",
            "630c53b2072929800117963f7481a9f6adbfeaf2"
        ],
        [
            "Notation \"[ 'subCountType' 'of' T ]\" := (@pack_subCountType _ _ T _ _ id _ _ id) (at level 0, format \"[ 'subCountType' 'of' T ]\") : form_scope.",
            "VernacNotation",
            "dd63f9c1f517129182dc610dd9c71ea7148c2d47"
        ],
        [
            "Section TagCountType.",
            "VernacBeginSection",
            "5997964a031d6fb4c04d6bb911148aa039d8f345"
        ],
        [
            "Variables (I : countType) (T_ : I -> countType).",
            "VernacAssumption",
            "1e9a18946a3dc4ff5e4d5b23915376408e896016"
        ],
        [
            "Definition pickle_tagged (u : {i : I & T_ i}) := CodeSeq.code [:: pickle (tag u); pickle (tagged u)].",
            "VernacDefinition",
            "5654edc899438b247ab08d29d893675aff4dcf3f"
        ],
        [
            "Definition unpickle_tagged s := if CodeSeq.decode s is [:: ni; nx] then obind (fun i => omap (@Tagged I i T_) (unpickle nx)) (unpickle ni) else None.",
            "VernacDefinition",
            "a7e86407cf1b96894e93bfbbabbbbc00355dd6c0"
        ],
        [
            "Lemma pickle_taggedK : pcancel pickle_tagged unpickle_tagged.",
            "VernacStartTheoremProof",
            "68a941a63a3596d8dc020ac797f73ab50545a8e5"
        ],
        [
            "by case=> i x; rewrite /unpickle_tagged CodeSeq.codeK /= pickleK /= pickleK.",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition tag_countMixin := CountMixin pickle_taggedK.",
            "VernacDefinition",
            "c61836259cba948fa48a36f7ee109de101d13533"
        ],
        [
            "Canonical tag_countType := Eval hnf in CountType {i : I & T_ i} tag_countMixin.",
            "VernacDefinition",
            "bf5d3650e51d6fdc64351fd2caf1c390facbf43f"
        ],
        [
            "End TagCountType.",
            "VernacEndSegment",
            "4df190c36240afac64785a86459936dcf0640083"
        ],
        [
            "Section CountableDataTypes.",
            "VernacBeginSection",
            "71a141257276097653e23dc7070055af17ac8318"
        ],
        [
            "Implicit Type T : countType.",
            "VernacReserve",
            "196aabc28cb414e1425b651b18f089ea23a5389e"
        ],
        [
            "Lemma nat_pickleK : pcancel id (@Some nat).",
            "VernacStartTheoremProof",
            "0c1948ac1d5263794c22ba40001bf746f3f06555"
        ],
        [
            "by [].",
            "VernacExtend",
            "ee1746465e986ababa06bb4e96ee76be726c914a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition nat_countMixin := CountMixin nat_pickleK.",
            "VernacDefinition",
            "e3b33cb7b6bcf7b5d3a5403c6b7c05f40d0b34f6"
        ],
        [
            "Canonical nat_countType := Eval hnf in CountType nat nat_countMixin.",
            "VernacDefinition",
            "1a27cb39238fc796b9381f723f41d096a668cd43"
        ],
        [
            "Definition bool_countMixin := CanCountMixin oddb.",
            "VernacDefinition",
            "3cc27f9e7bb20884598c778252e8aad653a18a9f"
        ],
        [
            "Canonical bool_countType := Eval hnf in CountType bool bool_countMixin.",
            "VernacDefinition",
            "5b79fcd0b8d516310c1299e03460f07a22f6497d"
        ],
        [
            "Canonical bitseq_countType := Eval hnf in [countType of bitseq].",
            "VernacDefinition",
            "36a607b4248b12ec71ba29617c0be31059ff2396"
        ],
        [
            "Definition unit_countMixin := CanCountMixin bool_of_unitK.",
            "VernacDefinition",
            "c3ab3e3e5f7b9a3215dee009ecce054eb4e587e6"
        ],
        [
            "Canonical unit_countType := Eval hnf in CountType unit unit_countMixin.",
            "VernacDefinition",
            "93ef6c9fe67ec9b3ea7ded52d6e5afeb1d4d0551"
        ],
        [
            "Definition option_countMixin T := CanCountMixin (@seq_of_optK T).",
            "VernacDefinition",
            "3ae31f00277626c1a506a4dbda3a0c3d11db90a1"
        ],
        [
            "Canonical option_countType T := Eval hnf in CountType (option T) (option_countMixin T).",
            "VernacDefinition",
            "33ce642dff921a320f4cb4adc05e34218f31b477"
        ],
        [
            "Definition sig_countMixin T (P : pred T) := [countMixin of {x | P x} by <:].",
            "VernacDefinition",
            "36deedd0eb7ac554eba38390317bb9c261db8918"
        ],
        [
            "Canonical sig_countType T (P : pred T) := Eval hnf in CountType {x | P x} (sig_countMixin P).",
            "VernacDefinition",
            "7f1be62a995e7bb190147ed003566ad7e40fd740"
        ],
        [
            "Canonical sig_subCountType T (P : pred T) := Eval hnf in [subCountType of {x | P x}].",
            "VernacDefinition",
            "5d392b5b8abe9a8d142482123d261c30d6a5c470"
        ],
        [
            "Definition prod_countMixin T1 T2 := CanCountMixin (@tag_of_pairK T1 T2).",
            "VernacDefinition",
            "322d3b541ada9ede67d37055ae5b33442bd91294"
        ],
        [
            "Canonical prod_countType T1 T2 := Eval hnf in CountType (T1 * T2) (prod_countMixin T1 T2).",
            "VernacDefinition",
            "a8dfa5041a79b47f1b9458424e2657269dc230b7"
        ],
        [
            "Definition sum_countMixin T1 T2 := PcanCountMixin (@opair_of_sumK T1 T2).",
            "VernacDefinition",
            "252cd9da915acce4e7bb6f6ad2c24a269759b0de"
        ],
        [
            "Canonical sum_countType T1 T2 := Eval hnf in CountType (T1 + T2) (sum_countMixin T1 T2).",
            "VernacDefinition",
            "041096ae2f1cf08f534b5e512d6e94da8b2a3a33"
        ],
        [
            "Definition tree_countMixin T := PcanCountMixin (GenTree.codeK T).",
            "VernacDefinition",
            "85fc68f1d850c3e7919069f09585bbb180163ff0"
        ],
        [
            "Canonical tree_countType T := CountType (GenTree.tree T) (tree_countMixin T).",
            "VernacDefinition",
            "192b03ec246c269733c9e6b2f17d45c7cd2caf7f"
        ],
        [
            "End CountableDataTypes.",
            "VernacEndSegment",
            "8e132422ffac5f70c702c6ae1c0a26e05d2a324e"
        ]
    ],
    "proofs": [
        {
            "name": "decodeK",
            "line_nb": 9,
            "steps": [
                {
                    "command": [
                        "have m2s: forall n, n.*2 - n = n by move=> n; rewrite -addnn addnK.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "case=> //= n; rewrite -[n.+1]mul1n -(expn0 2) -{3}[n]m2s.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "elim: n {2 4}n {1 3}0 => [|q IHq] [|[|r]] v //=; rewrite {}IHq ?mul1n ?m2s //.",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "by rewrite expnSr -mulnA mul2n.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "codeK",
            "line_nb": 15,
            "steps": [
                {
                    "command": [
                        "elim=> //= v s IHs; rewrite -[_ * _]prednK ?muln_gt0 ?expn_gt0 //=.",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "rewrite -{3}[v]addn0; elim: v {1 4}0 => [|v IHv {IHs}] q.",
                        "VernacExtend",
                        "44a8e3b453c9376c468b4e3e0046f5ac33e11d6d"
                    ]
                },
                {
                    "command": [
                        "rewrite mul1n /= -{1}addnn -{4}IHs; move: (_ s) {IHs} => n.",
                        "VernacExtend",
                        "7e529e80bb2879787ee6d9466056f19f0215c721"
                    ]
                },
                {
                    "command": [
                        "by elim: {1 3}n => //=; case: n.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "rewrite expnS -mulnA mul2n -{1}addnn -[_ * _]prednK ?muln_gt0 ?expn_gt0 //.",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "by rewrite doubleS addSn /= addSnnS; elim: {-2}_.-1 => //=.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ltn_code",
            "line_nb": 23,
            "steps": [
                {
                    "command": [
                        "elim: s => //= i s IHs; rewrite -[_.+1]muln1 leq_mul 1?ltn_expl //=.",
                        "VernacExtend",
                        "de65c8193056a36f6dbb91fe21357bd770b140db"
                    ]
                },
                {
                    "command": [
                        "apply: sub_all IHs => j /leqW lejs; rewrite -[j.+1]mul1n leq_mul ?expn_gt0 //.",
                        "VernacExtend",
                        "56c014161b39aecfb3c54301c2409dba4e8e1857"
                    ]
                },
                {
                    "command": [
                        "by rewrite ltnS -[j]mul1n -mul2n leq_mul.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "gtn_decode",
            "line_nb": 28,
            "steps": [
                {
                    "command": [
                        "by rewrite -{1}[n]decodeK ltn_code.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "seq_of_optK",
            "line_nb": 35,
            "steps": [
                {
                    "command": [
                        "by case.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "tag_of_pairK",
            "line_nb": 40,
            "steps": [
                {
                    "command": [
                        "by case.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pair_of_tagK",
            "line_nb": 43,
            "steps": [
                {
                    "command": [
                        "by case.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "opair_of_sumK",
            "line_nb": 48,
            "steps": [
                {
                    "command": [
                        "by case.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bool_of_unitK",
            "line_nb": 51,
            "steps": [
                {
                    "command": [
                        "by case.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "correct",
            "line_nb": 110,
            "steps": [
                {
                    "command": [
                        "by case: T => _ [_ []] //= in P n x *.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "complete",
            "line_nb": 113,
            "steps": [
                {
                    "command": [
                        "by case: T => _ [_ []] //= in P *.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "extensional",
            "line_nb": 116,
            "steps": [
                {
                    "command": [
                        "by case: T => _ [_ []] //= in P Q *.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "xchoose_subproof",
            "line_nb": 119,
            "steps": [
                {
                    "command": [
                        "by case: (ex_minnP (complete exP)) => n; case: (find P n) => // x; exists x.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "xchooseP",
            "line_nb": 134,
            "steps": [
                {
                    "command": [
                        "by rewrite /xchoose; case: (xchoose_subproof exP) => x /= /correct.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_xchoose",
            "line_nb": 137,
            "steps": [
                {
                    "command": [
                        "rewrite /xchoose => eqPQ.",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "case: (xchoose_subproof exP) => x; case: (xchoose_subproof exQ) => y /=.",
                        "VernacExtend",
                        "5887f8022a4f6389ac249140364feb69c4f18799"
                    ]
                },
                {
                    "command": [
                        "case: ex_minnP => n; case: ex_minnP => m.",
                        "VernacExtend",
                        "5887f8022a4f6389ac249140364feb69c4f18799"
                    ]
                },
                {
                    "command": [
                        "rewrite -(extensional eqPQ) {1}(extensional eqPQ).",
                        "VernacExtend",
                        "2a624b3f8ed2cb60890f98119d86e3031fa09e35"
                    ]
                },
                {
                    "command": [
                        "move=> Qm minPm Pn minQn; suffices /eqP->: m == n by move=> -> [].",
                        "VernacExtend",
                        "f8582445b13cd09e9c30648f0ec245f72ecdd43e"
                    ]
                },
                {
                    "command": [
                        "by rewrite eqn_leq minQn ?minPm.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sigW",
            "line_nb": 145,
            "steps": [
                {
                    "command": [
                        "by move=> exP; exists (xchoose exP); apply: xchooseP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sig2W",
            "line_nb": 148,
            "steps": [
                {
                    "command": [
                        "move=> exPQ; have [|x /andP[]] := @sigW (predI P Q); last by exists x.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by have [x Px Qx] := exPQ; exists x; apply/andP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sig_eqW",
            "line_nb": 152,
            "steps": [
                {
                    "command": [
                        "move=> exP; suffices [x /eqP Ex]: {x | lhs x == rhs x} by exists x.",
                        "VernacExtend",
                        "f8582445b13cd09e9c30648f0ec245f72ecdd43e"
                    ]
                },
                {
                    "command": [
                        "by apply: sigW; have [x /eqP Ex] := exP; exists x.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "sig2_eqW",
            "line_nb": 156,
            "steps": [
                {
                    "command": [
                        "move=> exP; suffices [x Px /eqP Ex]: {x | P x & lhs x == rhs x} by exists x.",
                        "VernacExtend",
                        "f8582445b13cd09e9c30648f0ec245f72ecdd43e"
                    ]
                },
                {
                    "command": [
                        "by apply: sig2W; have [x Px /eqP Ex] := exP; exists x.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "chooseP",
            "line_nb": 161,
            "steps": [
                {
                    "command": [
                        "by move=> Px0; rewrite /choose insubT xchooseP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "choose_id",
            "line_nb": 164,
            "steps": [
                {
                    "command": [
                        "by move=> Px0 Py0; rewrite /choose !insubT /=; apply: eq_xchoose.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_choose",
            "line_nb": 167,
            "steps": [
                {
                    "command": [
                        "rewrite /choose => eqPQ x0.",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "do [case: insubP; rewrite eqPQ] => [[x Px] Qx0 _| ?]; last by rewrite insubN.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by rewrite insubT; apply: eq_xchoose.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "PcanChoiceMixin",
            "line_nb": 174,
            "steps": [
                {
                    "command": [
                        "move=> fK; pose liftP sP := [pred x | oapp sP false (f' x)].",
                        "VernacExtend",
                        "fef3c4a8f7fcf70b0824f3cce5fb58f2e0ef07fd"
                    ]
                },
                {
                    "command": [
                        "pose sf sP := [fun n => obind f' (find (liftP sP) n)].",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "exists sf => [sP n x | sP [y sPy] | sP sQ eqPQ n] /=.",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "by case Df: (find _ n) => //= [?] Dx; have:= correct Df; rewrite /= Dx.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "have [|n Pn] := @complete T (liftP sP); first by exists (f y); rewrite /= fK.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "exists n; case Df: (find _ n) Pn => //= [x] _.",
                        "VernacExtend",
                        "cbbb75496c1025c06e7833ae1a14f90e6dbf6393"
                    ]
                },
                {
                    "command": [
                        "by have:= correct Df => /=; case: (f' x).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by congr (obind _ _); apply: extensional => x /=; case: (f' x) => /=.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "seq_choiceMixin",
            "line_nb": 194,
            "steps": [
                {
                    "command": [
                        "pose r f := [fun xs => fun x : T => f (x :: xs) : option (seq T)].",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "pose fix f sP ns xs {struct ns} := if ns is n :: ns1 then let fr := r (f sP ns1) xs in obind fr (find fr n) else if sP xs then Some xs else None.",
                        "VernacExtend",
                        "be59184aeceac70e4255bd58cff677d981339a6d"
                    ]
                },
                {
                    "command": [
                        "exists (fun sP nn => f sP (dc nn) nil) => [sP n ys | sP [ys] | sP sQ eqPQ n].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "elim: {n}(dc n) nil => [|n ns IHs] xs /=; first by case: ifP => // sPxs [<-].",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by case: (find _ n) => //= [x]; apply: IHs.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "rewrite -(cats0 ys); elim/last_ind: ys nil => [|ys y IHs] xs /=.",
                        "VernacExtend",
                        "44a8e3b453c9376c468b4e3e0046f5ac33e11d6d"
                    ]
                },
                {
                    "command": [
                        "by move=> sPxs; exists 0; rewrite /= sPxs.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "rewrite cat_rcons => /IHs[n1 sPn1] {IHs}.",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "have /complete[n]: exists z, f sP (dc n1) (z :: xs) by exists y.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "case Df: (find _ n)=> // [x] _; exists (code (n :: dc n1)).",
                        "VernacExtend",
                        "70d74ce9f1afc29f3e72a76d98f3cd9bda2d2292"
                    ]
                },
                {
                    "command": [
                        "by rewrite codeK /= Df /= (correct Df).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "elim: {n}(dc n) nil => [|n ns IHs] xs /=; first by rewrite eqPQ.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "rewrite (@extensional _ _ (r (f sQ ns) xs)) => [|x]; last by rewrite IHs.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by case: find => /=.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "tagged_choiceMixin",
            "line_nb": 216,
            "steps": [
                {
                    "command": [
                        "pose mkT i (x : T_ i) := Tagged T_ x.",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "pose ft tP n i := omap (mkT i) (find (tP \\o mkT i) n).",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "pose fi tP ni nt := obind (ft tP nt) (find (ft tP nt) ni).",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "pose f tP n := if dc n is [:: ni; nt] then fi tP ni nt else None.",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "exists f => [tP n u | tP [[i x] tPxi] | sP sQ eqPQ n].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "rewrite /f /fi; case: (dc n) => [|ni [|nt []]] //=.",
                        "VernacExtend",
                        "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
                    ]
                },
                {
                    "command": [
                        "case: (find _ _) => //= [i]; rewrite /ft.",
                        "VernacExtend",
                        "90a2acb29b7a5304b0ab6ba5269c420638ddef63"
                    ]
                },
                {
                    "command": [
                        "by case Df: (find _ _) => //= [x] [<-]; have:= correct Df.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "have /complete[nt tPnt]: exists y, (tP \\o mkT i) y by exists x.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "have{tPnt}: exists j, ft tP nt j by exists i; rewrite /ft; case: find tPnt.",
                        "VernacExtend",
                        "406cde1174359c53bf162a2a18c4eede395555f9"
                    ]
                },
                {
                    "command": [
                        "case/complete=> ni tPn; exists (code [:: ni; nt]); rewrite /f codeK /fi.",
                        "VernacExtend",
                        "c7952652f726da4699f6b37d5f524bbcadf0d418"
                    ]
                },
                {
                    "command": [
                        "by case Df: find tPn => //= [j] _; have:= correct Df.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "rewrite /f /fi; case: (dc n) => [|ni [|nt []]] //=.",
                        "VernacExtend",
                        "712d339e99ee17eb7d5033e19ac614eb3ca6b532"
                    ]
                },
                {
                    "command": [
                        "rewrite (@extensional _ _ (ft sQ nt)) => [|i].",
                        "VernacExtend",
                        "3c42b53d0efc26db114b00541ac5e7fcb29e6aeb"
                    ]
                },
                {
                    "command": [
                        "by case: find => //= i; congr (omap _ _); apply: extensional => x /=.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by congr (omap _ _); apply: extensional => x /=.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "nat_choiceMixin",
            "line_nb": 238,
            "steps": [
                {
                    "command": [
                        "pose f := [fun (P : pred nat) n => if P n then Some n else None].",
                        "VernacExtend",
                        "3c5f04de94609049d978298aa02ff35fb35ea7c7"
                    ]
                },
                {
                    "command": [
                        "exists f => [P n m | P [n Pn] | P Q eqPQ n] /=; last by rewrite eqPQ.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by case: ifP => // Pn [<-].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "by exists n; rewrite Pn.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pickleK",
            "line_nb": 304,
            "steps": [
                {
                    "command": [
                        "exact: Countable.pickleK.",
                        "VernacExtend",
                        "ce637ff86bafca5d8359473e8c02af644dcbdc43"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pickle_invK",
            "line_nb": 308,
            "steps": [
                {
                    "command": [
                        "by rewrite /pickle_inv => n; case def_x: (unpickle n) => //= [x]; case: eqP.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pickleK_inv",
            "line_nb": 311,
            "steps": [
                {
                    "command": [
                        "by rewrite /pickle_inv => x; rewrite pickleK /= eqxx.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pcan_pickleK",
            "line_nb": 314,
            "steps": [
                {
                    "command": [
                        "by move=> fK x; rewrite /pcomp pickleK /= fK.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pickle_seqK",
            "line_nb": 322,
            "steps": [
                {
                    "command": [
                        "by move=> s; rewrite /unpickle_seq CodeSeq.codeK (map_pK pickleK).",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "pickle_taggedK",
            "line_nb": 346,
            "steps": [
                {
                    "command": [
                        "by case=> i x; rewrite /unpickle_tagged CodeSeq.codeK /= pickleK /= pickleK.",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "nat_pickleK",
            "line_nb": 354,
            "steps": [
                {
                    "command": [
                        "by [].",
                        "VernacExtend",
                        "ee1746465e986ababa06bb4e96ee76be726c914a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}