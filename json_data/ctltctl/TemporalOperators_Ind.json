{
    "filename": "TemporalOperators_Ind.v",
    "coq_project": "ctltctl",
    "vernac_cmds": [
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Unset Strict Implicit.",
            "VernacUnsetOption",
            "2842adaf6959318f2042805935c46f513bdc0348"
        ],
        [
            "Require Import time_clocks.",
            "VernacRequire",
            "d1451c92af302f185edbac2e6ab112eb1da83596"
        ],
        [
            "Section TemporalOperators_Ind.",
            "VernacBeginSection",
            "ef66f1e34e7851c97ffd064daf68fb3945819374"
        ],
        [
            "Variable Label : Set.",
            "VernacAssumption",
            "90c34c6ce076b894ed1eb8c14e57233cd3a3abb9"
        ],
        [
            "Variable S : Set.",
            "VernacAssumption",
            "2a0c7ebd77cf024747eefc8ea669e9e85a92c160"
        ],
        [
            "Variable tr : S -> Label -> S -> Prop.",
            "VernacAssumption",
            "0e7b8515fdc1da9deed490b69d9dd2eb6becd4e7"
        ],
        [
            "Variable inv : S -> Prop.",
            "VernacAssumption",
            "0c4ff587ab9507945c846acf05591060615279b8"
        ],
        [
            "Variable inc : S -> Instant -> S.",
            "VernacAssumption",
            "871d61e78778745db2b3050ff372434506f3e997"
        ],
        [
            "Inductive RState (Sini : S) : S -> Prop := | rsIni : RState Sini Sini | rsNextTick : forall s : S, RState Sini s -> inv (inc s tick) -> RState Sini (inc s tick) | rsNextDisc : forall (s1 s2 : S) (l : Label), RState Sini s1 -> tr s1 l s2 -> inv s2 -> RState Sini s2.",
            "VernacInductive",
            "4603d883f279008daf46b995164f1f50b91a8250"
        ],
        [
            "Inductive RState_T (Sini : S) : S -> Instant -> Prop := | rsIni_T : RState_T Sini Sini time0 | rsNextTick_T : forall (s : S) (t : Instant), RState_T Sini s t -> inv (inc s tick) -> RState_T Sini (inc s tick) (Inc t) | rsNextDisc_T : forall (s1 s2 : S) (l : Label) (t : Instant), RState_T Sini s1 t -> tr s1 l s2 -> inv s2 -> RState_T Sini s2 t.",
            "VernacInductive",
            "9bceb2ee32e97ee7ef52d0c8b26c8982bb2ee9a8"
        ],
        [
            "Definition ForAll (Sini : S) (P : S -> Prop) := forall s : S, RState Sini s -> P s.",
            "VernacDefinition",
            "63850a77b1be3831191f3ae5d813d162c4abee67"
        ],
        [
            "Definition ForAll_T (Sini : S) (P : S -> Prop) (bound : Instant -> Prop) := forall (s : S) (t : Instant), bound t -> RState_T Sini s t -> P s.",
            "VernacDefinition",
            "204f24464533dfa5e189e9d457cb5b9ba9b89045"
        ],
        [
            "Inductive Exists (Sini : S) (P : S -> Prop) : Prop := exists_ : forall s : S, RState Sini s -> P s -> Exists Sini P.",
            "VernacInductive",
            "18172901a2850995b5d4979c3a34e0a4587dcad4"
        ],
        [
            "Inductive Exists_T (Sini : S) (P : S -> Prop) (bound : Instant -> Prop) : Prop := exists_T : forall (s : S) (t : Instant), bound t -> RState_T Sini s t -> P s -> Exists_T Sini P bound.",
            "VernacInductive",
            "18d8ba184ed4be09da1c98a4b10d9b0e5c1c76f9"
        ],
        [
            "Theorem Mon_I : forall (Sini : S) (Pg Pp : S -> Prop), ForAll Sini Pg -> (forall s : S, Pg s -> Pp s) -> ForAll Sini Pp.",
            "VernacStartTheoremProof",
            "d6a4c4a3290b35f1c1f4a28fcc6520bec55de89e"
        ],
        [
            "unfold ForAll in |- *; intros.",
            "VernacExtend",
            "9c4fc1a0a6cd409a100445bf2e588896e066cdb1"
        ],
        [
            "apply H0.",
            "VernacExtend",
            "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
        ],
        [
            "apply H; assumption.",
            "VernacExtend",
            "7904d623a02884c927ef4e8b66c90cb12eee7c7a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem Mon_I_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> ForAll_T Sini Pp bound.",
            "VernacStartTheoremProof",
            "b41c82237bfdb2a4b764abfc236897923f586540"
        ],
        [
            "unfold ForAll_T in |- *; intros.",
            "VernacExtend",
            "1c6b5c88e127a2294c4c55ebd0a39e8228dcd00a"
        ],
        [
            "apply H0.",
            "VernacExtend",
            "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
        ],
        [
            "apply (H s t); assumption.",
            "VernacExtend",
            "a19413a52089cf714b927d1aa78e1f3e3b6f6d0c"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem Conj : forall (Sini : S) (P1 P2 : S -> Prop), ForAll Sini P1 -> ForAll Sini P2 -> ForAll Sini (fun s : S => P1 s /\\ P2 s).",
            "VernacStartTheoremProof",
            "bc4affc70806fce8587ddd163e120fff79f20633"
        ],
        [
            "unfold ForAll in |- *; intros.",
            "VernacExtend",
            "9c4fc1a0a6cd409a100445bf2e588896e066cdb1"
        ],
        [
            "split; [ apply H | apply H0 ]; assumption.",
            "VernacExtend",
            "60eeabacf4788d147143e4c4ded0d6adee53c51d"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem Conj_T : forall (Sini : S) (P1 P2 : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P1 bound -> ForAll_T Sini P2 bound -> ForAll_T Sini (fun s : S => P1 s /\\ P2 s) bound.",
            "VernacStartTheoremProof",
            "deeb8b2a10c46ee9285c943bc676d1f5c34f53c0"
        ],
        [
            "unfold ForAll_T in |- *; intros.",
            "VernacExtend",
            "1c6b5c88e127a2294c4c55ebd0a39e8228dcd00a"
        ],
        [
            "split; [ apply (H s t) | apply (H0 s t) ]; assumption.",
            "VernacExtend",
            "5782d87db453ae545cb610a3431857a60961102e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem Mon_I_EX : forall (Sini : S) (Pg Pp : S -> Prop), Exists Sini Pg -> (forall s : S, Pg s -> Pp s) -> Exists Sini Pp.",
            "VernacStartTheoremProof",
            "2650e244c133160a730fff6cc9d65f30a7bac333"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inversion_clear H.",
            "VernacExtend",
            "90909d92eb32e95a21a5b90b29a49dc97bcea342"
        ],
        [
            "apply (exists_ H1 (H0 s H2)).",
            "VernacExtend",
            "ef594ac03198f5582c87fd378d828e417371eacd"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem Mon_I_EX_T : forall (Sini : S) (Pg Pp : S -> Prop) (bound : Instant -> Prop), Exists_T Sini Pg bound -> (forall s : S, Pg s -> Pp s) -> Exists_T Sini Pp bound.",
            "VernacStartTheoremProof",
            "b90ca7924ea555d4251e777bff81943ad6da5e98"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inversion_clear H.",
            "VernacExtend",
            "90909d92eb32e95a21a5b90b29a49dc97bcea342"
        ],
        [
            "apply (exists_T H1 H2 (H0 s H3)).",
            "VernacExtend",
            "b5c0ca7ed6697161190b871b19f894945dca412d"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma RState_Trans : forall s1 s2 s3 : S, RState s1 s2 -> RState s2 s3 -> RState s1 s3.",
            "VernacStartTheoremProof",
            "216c6ee7ab29b696304fff2ede4532207e4981ae"
        ],
        [
            "simple induction 2; intros.",
            "VernacExtend",
            "778f681f5c3ce514deabc10016a447756c28b707"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "apply rsNextTick; trivial.",
            "VernacExtend",
            "3461db5354fe0dce86bc9ce5827c7f7430f33f99"
        ],
        [
            "apply (rsNextDisc H2 H3 H4).",
            "VernacExtend",
            "a31aeba89bb35275781861383774ac5c1293d20f"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma RState_Trans_T : forall (s1 s2 s3 : S) (t1 t2 : Instant), RState_T s1 s2 t1 -> RState_T s2 s3 t2 -> RState_T s1 s3 (plus_Ck t1 t2).",
            "VernacStartTheoremProof",
            "e4a06b2e2f60828f911417fcc653cc16615a82ac"
        ],
        [
            "simple induction 2; unfold plus_Ck in |- *; intros.",
            "VernacExtend",
            "17820a63a6670979cfb7eb33920a983299edc18a"
        ],
        [
            "rewrite (plus_comm t1 time0); unfold time0 in |- *; simpl in |- *; assumption.",
            "VernacExtend",
            "f02b19b0db623a06daaba05402f75982bd80bda2"
        ],
        [
            "unfold Inc in |- *; unfold plus_Ck in |- *; rewrite (plus_assoc t1 t tick).",
            "VernacExtend",
            "c8f16600b98c7d4241e0cba8e1627d0f1be1753d"
        ],
        [
            "apply (rsNextTick_T H2 H3).",
            "VernacExtend",
            "6b48561d620fdf17ade470cbfd6d5a27a7085e0e"
        ],
        [
            "apply (rsNextDisc_T H2 H3 H4).",
            "VernacExtend",
            "6ffcdd1b310d0a76321b430a5654dcf7c2e70a22"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem StepsEX : forall (s1 s2 : S) (P : S -> Prop), RState s1 s2 -> Exists s2 P -> Exists s1 P.",
            "VernacStartTheoremProof",
            "8b74505e572f9449e9e156f3cb2ca2af3f8843d1"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inversion H0.",
            "VernacExtend",
            "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
        ],
        [
            "apply (exists_ (RState_Trans H H1) H2).",
            "VernacExtend",
            "5242ce2a20348870634b7ed0b80015c58bd3685c"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Require Import Classical.",
            "VernacRequire",
            "4cc53198e8d48bbb9dcca109b0e59a015dd7a5bb"
        ],
        [
            "Theorem ForAll_EX : forall (Sini : S) (P : S -> Prop), ForAll Sini P <-> ~ Exists Sini (fun s : S => ~ P s).",
            "VernacStartTheoremProof",
            "819e824fd32f5820016058247363c5eeb3617c77"
        ],
        [
            "unfold not in |- *; unfold ForAll in |- *; red in |- *; intros; split; intros.",
            "VernacExtend",
            "c75b82bf016c5da08bf980127c8713b4d37042d9"
        ],
        [
            "inversion H0.",
            "VernacExtend",
            "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
        ],
        [
            "apply (H2 (H s H1)).",
            "VernacExtend",
            "395ae97bd9a3d4f0da46fe3c8a78c9c1ad4c48b4"
        ],
        [
            "elim (classic (P s)); [ trivial | intro; absurd (Exists Sini (fun s : S => P s -> False)) ].",
            "VernacExtend",
            "e97514022921bb4025f9112f89035925227b7dd1"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "apply exists_ with (1 := H0); assumption.",
            "VernacExtend",
            "ea066a62aa828b723e8181343d33f03cdb688f99"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem ForAll_EX_T : forall (Sini : S) (P : S -> Prop) (bound : Instant -> Prop), ForAll_T Sini P bound <-> ~ Exists_T Sini (fun s : S => ~ P s) bound.",
            "VernacStartTheoremProof",
            "47e21a17418237065747cd6c4eee60c478929c25"
        ],
        [
            "unfold not in |- *; unfold ForAll_T in |- *; red in |- *; intros; split; intros.",
            "VernacExtend",
            "740889e066d0b137f1802ce607355e8ad2f4cc66"
        ],
        [
            "inversion H0.",
            "VernacExtend",
            "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
        ],
        [
            "apply (H3 (H s t H1 H2)).",
            "VernacExtend",
            "621a02f078052b7ca47dbcddb0e6d429bfde3d27"
        ],
        [
            "elim (classic (P s)); [ trivial | intro; absurd (Exists_T Sini (fun s : S => P s -> False) bound) ].",
            "VernacExtend",
            "be545f8559afda58cb1d7e5a497317f3018f9015"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "apply exists_T with (2 := H1); assumption.",
            "VernacExtend",
            "8630f6d2855d5dc20074b210e98a45f70b9b99ef"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition ForAll_from (Sini : S) (Q P : S -> Prop) := ForAll Sini (fun s : S => Q s -> ForAll s P).",
            "VernacDefinition",
            "a453ad43d69bfdbcb87f8409457b853a79db2769"
        ],
        [
            "Definition ForAll_from_T (Sini : S) (Q P : S -> Prop) (bound : Instant -> Prop) := ForAll Sini (fun s : S => Q s -> ForAll_T s P bound).",
            "VernacDefinition",
            "a4d2f6a390318bd15577a8142aee5f1839756c90"
        ],
        [
            "Definition Exists_from (Sini : S) (Q P : S -> Prop) := ForAll Sini (fun s : S => Q s -> Exists s P).",
            "VernacDefinition",
            "77e1d2a15526a7da5775ef60f89bc6d8f1ac36bf"
        ],
        [
            "Definition Exists_from_T (Sini : S) (Q P : S -> Prop) (bound : Instant -> Prop) := ForAll Sini (fun s : S => Q s -> Exists_T s P bound).",
            "VernacDefinition",
            "06c826a70784627565401ac5185a75263d32f88f"
        ],
        [
            "End TemporalOperators_Ind.",
            "VernacEndSegment",
            "9f41bf4e3b7e5b798181c67d4d6926a95252702e"
        ]
    ],
    "proofs": [
        {
            "name": "Mon_I",
            "line_nb": 15,
            "steps": [
                {
                    "command": [
                        "unfold ForAll in |- *; intros.",
                        "VernacExtend",
                        "9c4fc1a0a6cd409a100445bf2e588896e066cdb1"
                    ]
                },
                {
                    "command": [
                        "apply H0.",
                        "VernacExtend",
                        "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
                    ]
                },
                {
                    "command": [
                        "apply H; assumption.",
                        "VernacExtend",
                        "7904d623a02884c927ef4e8b66c90cb12eee7c7a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Mon_I_T",
            "line_nb": 20,
            "steps": [
                {
                    "command": [
                        "unfold ForAll_T in |- *; intros.",
                        "VernacExtend",
                        "1c6b5c88e127a2294c4c55ebd0a39e8228dcd00a"
                    ]
                },
                {
                    "command": [
                        "apply H0.",
                        "VernacExtend",
                        "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
                    ]
                },
                {
                    "command": [
                        "apply (H s t); assumption.",
                        "VernacExtend",
                        "a19413a52089cf714b927d1aa78e1f3e3b6f6d0c"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Conj",
            "line_nb": 25,
            "steps": [
                {
                    "command": [
                        "unfold ForAll in |- *; intros.",
                        "VernacExtend",
                        "9c4fc1a0a6cd409a100445bf2e588896e066cdb1"
                    ]
                },
                {
                    "command": [
                        "split; [ apply H | apply H0 ]; assumption.",
                        "VernacExtend",
                        "60eeabacf4788d147143e4c4ded0d6adee53c51d"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Conj_T",
            "line_nb": 29,
            "steps": [
                {
                    "command": [
                        "unfold ForAll_T in |- *; intros.",
                        "VernacExtend",
                        "1c6b5c88e127a2294c4c55ebd0a39e8228dcd00a"
                    ]
                },
                {
                    "command": [
                        "split; [ apply (H s t) | apply (H0 s t) ]; assumption.",
                        "VernacExtend",
                        "5782d87db453ae545cb610a3431857a60961102e"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Mon_I_EX",
            "line_nb": 33,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "inversion_clear H.",
                        "VernacExtend",
                        "90909d92eb32e95a21a5b90b29a49dc97bcea342"
                    ]
                },
                {
                    "command": [
                        "apply (exists_ H1 (H0 s H2)).",
                        "VernacExtend",
                        "ef594ac03198f5582c87fd378d828e417371eacd"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Mon_I_EX_T",
            "line_nb": 38,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "inversion_clear H.",
                        "VernacExtend",
                        "90909d92eb32e95a21a5b90b29a49dc97bcea342"
                    ]
                },
                {
                    "command": [
                        "apply (exists_T H1 H2 (H0 s H3)).",
                        "VernacExtend",
                        "b5c0ca7ed6697161190b871b19f894945dca412d"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "RState_Trans",
            "line_nb": 43,
            "steps": [
                {
                    "command": [
                        "simple induction 2; intros.",
                        "VernacExtend",
                        "778f681f5c3ce514deabc10016a447756c28b707"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "apply rsNextTick; trivial.",
                        "VernacExtend",
                        "3461db5354fe0dce86bc9ce5827c7f7430f33f99"
                    ]
                },
                {
                    "command": [
                        "apply (rsNextDisc H2 H3 H4).",
                        "VernacExtend",
                        "a31aeba89bb35275781861383774ac5c1293d20f"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "RState_Trans_T",
            "line_nb": 49,
            "steps": [
                {
                    "command": [
                        "simple induction 2; unfold plus_Ck in |- *; intros.",
                        "VernacExtend",
                        "17820a63a6670979cfb7eb33920a983299edc18a"
                    ]
                },
                {
                    "command": [
                        "rewrite (plus_comm t1 time0); unfold time0 in |- *; simpl in |- *; assumption.",
                        "VernacExtend",
                        "f02b19b0db623a06daaba05402f75982bd80bda2"
                    ]
                },
                {
                    "command": [
                        "unfold Inc in |- *; unfold plus_Ck in |- *; rewrite (plus_assoc t1 t tick).",
                        "VernacExtend",
                        "c8f16600b98c7d4241e0cba8e1627d0f1be1753d"
                    ]
                },
                {
                    "command": [
                        "apply (rsNextTick_T H2 H3).",
                        "VernacExtend",
                        "6b48561d620fdf17ade470cbfd6d5a27a7085e0e"
                    ]
                },
                {
                    "command": [
                        "apply (rsNextDisc_T H2 H3 H4).",
                        "VernacExtend",
                        "6ffcdd1b310d0a76321b430a5654dcf7c2e70a22"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "StepsEX",
            "line_nb": 56,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "inversion H0.",
                        "VernacExtend",
                        "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
                    ]
                },
                {
                    "command": [
                        "apply (exists_ (RState_Trans H H1) H2).",
                        "VernacExtend",
                        "5242ce2a20348870634b7ed0b80015c58bd3685c"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ForAll_EX",
            "line_nb": 62,
            "steps": [
                {
                    "command": [
                        "unfold not in |- *; unfold ForAll in |- *; red in |- *; intros; split; intros.",
                        "VernacExtend",
                        "c75b82bf016c5da08bf980127c8713b4d37042d9"
                    ]
                },
                {
                    "command": [
                        "inversion H0.",
                        "VernacExtend",
                        "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
                    ]
                },
                {
                    "command": [
                        "apply (H2 (H s H1)).",
                        "VernacExtend",
                        "395ae97bd9a3d4f0da46fe3c8a78c9c1ad4c48b4"
                    ]
                },
                {
                    "command": [
                        "elim (classic (P s)); [ trivial | intro; absurd (Exists Sini (fun s : S => P s -> False)) ].",
                        "VernacExtend",
                        "e97514022921bb4025f9112f89035925227b7dd1"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "apply exists_ with (1 := H0); assumption.",
                        "VernacExtend",
                        "ea066a62aa828b723e8181343d33f03cdb688f99"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ForAll_EX_T",
            "line_nb": 70,
            "steps": [
                {
                    "command": [
                        "unfold not in |- *; unfold ForAll_T in |- *; red in |- *; intros; split; intros.",
                        "VernacExtend",
                        "740889e066d0b137f1802ce607355e8ad2f4cc66"
                    ]
                },
                {
                    "command": [
                        "inversion H0.",
                        "VernacExtend",
                        "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
                    ]
                },
                {
                    "command": [
                        "apply (H3 (H s t H1 H2)).",
                        "VernacExtend",
                        "621a02f078052b7ca47dbcddb0e6d429bfde3d27"
                    ]
                },
                {
                    "command": [
                        "elim (classic (P s)); [ trivial | intro; absurd (Exists_T Sini (fun s : S => P s -> False) bound) ].",
                        "VernacExtend",
                        "be545f8559afda58cb1d7e5a497317f3018f9015"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "apply exists_T with (2 := H1); assumption.",
                        "VernacExtend",
                        "8630f6d2855d5dc20074b210e98a45f70b9b99ef"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}