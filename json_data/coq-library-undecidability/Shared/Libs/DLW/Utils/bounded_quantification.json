{
    "filename": "Shared/Libs/DLW/Utils/bounded_quantification.v",
    "coq_project": "coq-library-undecidability",
    "vernac_cmds": [
        [
            "Require Import Arith Omega.",
            "VernacRequire",
            "7f8e7c2ae08d85ede94e169d9bc690e35b0fe0d2"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Definition fmap_reifier_t X (Q : nat -> X -> Prop) k : (forall i, i < k -> sig (Q i)) -> { f : forall i, i < k -> X | forall i Hi, Q i (f i Hi) }.",
            "VernacDefinition",
            "dae214fc100655c6573a9e22d4aa87095c520836"
        ],
        [
            "revert Q; induction k as [ | k IHk ]; intros Q HQ.",
            "VernacExtend",
            "efe22ecac801cbde3147c22b3b2d15af73145f70"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "assert (f : forall i, i < 0 -> X) by (intros i Hi; exfalso; revert Hi; apply Nat.nlt_0_r).",
            "VernacExtend",
            "1f35c7abe47d63db230ba6e3e5a89126306918b0"
        ],
        [
            "exists f; intros i Hi; exfalso; revert Hi; apply Nat.nlt_0_r.",
            "VernacExtend",
            "ad2fef02967c2c341242af5e9daecf7139797835"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "destruct (HQ 0) as (f0 & H0).",
            "VernacExtend",
            "3817070f9fc4e9f70d2ee05bd673c145e9fdb93b"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "apply Nat.lt_0_succ.",
            "VernacExtend",
            "71ce36185f1fd4314aab0331b52b3659e0a186db"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "destruct (IHk (fun i => Q (S i))) as (f & Hf).",
            "VernacExtend",
            "b18199713d636474516ee422094f9a0d4d9d6b76"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "intros; apply HQ, lt_n_S; trivial.",
            "VernacExtend",
            "daea6cfae6adf09b9ad04c62bbdd4aa5ecbc5d67"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "set (f' := fun i => match i return i < S k -> X with | 0 => fun _ => f0 | S j => fun Hj => f j (lt_S_n _ _ Hj) end).",
            "VernacExtend",
            "e0a07b311d54da8f0dfbd39cc7c98270276d62b8"
        ],
        [
            "exists f'; intros [ | i ] Hi; simpl; trivial.",
            "VernacExtend",
            "0fb942f333ff5e46f9236f8e4c6f5bfcbe04cf1d"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition fmap_reifier_t_default X (Q : nat -> X -> Prop) k (x : X) : (forall i, i < k -> sig (Q i)) -> { f : nat -> X | forall i, i < k -> Q i (f i) }.",
            "VernacDefinition",
            "ab7c335a0fbeab96949865ff2d08d26cabf4eb51"
        ],
        [
            "intros H.",
            "VernacExtend",
            "5cfae87a34fa7b59a257c9640f1b674f6e6d780b"
        ],
        [
            "apply fmap_reifier_t in H.",
            "VernacExtend",
            "2c83411a926a5f5c4d4414370786e7fc1c266d03"
        ],
        [
            "destruct H as (f & Hf).",
            "VernacExtend",
            "a182f749db6bb93666d39b800ad725844976beee"
        ],
        [
            "exists (fun i => match le_lt_dec k i with | left _ => x | right Hi => f i Hi end).",
            "VernacExtend",
            "a4cf85c787056a78ea0471bb8811f9d2ce126523"
        ],
        [
            "intros i Hi.",
            "VernacExtend",
            "1763a4b461e760b296ffbe398979e15770c7a1bd"
        ],
        [
            "destruct (le_lt_dec k i) as [ H1 | ]; auto.",
            "VernacExtend",
            "180886fc53444805ca1f70cd8614edfee22588ad"
        ],
        [
            "exfalso; revert Hi H1; apply lt_not_le.",
            "VernacExtend",
            "6a3d6771f741a149ae5209082eb4f16e103bc937"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Theorem fmap_bound n P : (forall x, x < n -> ex (P x)) -> exists m, forall x, x < n -> exists y, y < m /\\ P x y.",
            "VernacStartTheoremProof",
            "6cf9a7b3de8911d46b922690737d205b6575d097"
        ],
        [
            "revert P; induction n as [ | n IHn ]; intros P HP.",
            "VernacExtend",
            "1ba089338e67355e60c89396acdf6bb4c057c2d4"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "exists 0; intros; omega.",
            "VernacExtend",
            "2218c309f93cbe13a1ac5efee1605e872151a0a8"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "destruct (HP 0) as (m0 & H0); try omega.",
            "VernacExtend",
            "2d1e52dfc08a8ee638022bc9e2f3f67ba1dc9ec7"
        ],
        [
            "destruct (IHn (fun n => P (S n))) as (m1 & Hm1).",
            "VernacExtend",
            "13f45e7a21a049ec4ebe4e7f4e14949cff26babd"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "intros; apply HP; omega.",
            "VernacExtend",
            "5bab3d9faa705942a0bfee3dc51fb3ecea55e483"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "exists (1+m0+m1); intros [ | x ] Hx.",
            "VernacExtend",
            "03f3ff24a493c84a91dd69fe9238057f28f6d508"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "exists m0; split; auto; omega.",
            "VernacExtend",
            "0cc168cb344db0aff56e2c5fa488f596e91ead13"
        ],
        [
            "*",
            "VernacBullet",
            "8a329d054468e0c41ce333043e0978e30eed7b98"
        ],
        [
            "destruct (Hm1 x) as (y & H1 & H2); try omega.",
            "VernacExtend",
            "bf1c47dafdb04db42aebc398bd17697c2d5f6534"
        ],
        [
            "exists y; split; auto; omega.",
            "VernacExtend",
            "e50d0f8d408f76d57159bb7c428539b72113dbb2"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem fmap_reifier_default X n (P : nat -> X -> Prop) : inhabited X -> (forall x, x < n -> ex (P x)) -> exists f, forall x, x < n -> P x (f x).",
            "VernacStartTheoremProof",
            "9fa136fdf25da0fd50d0d53645818480b1a432cd"
        ],
        [
            "intros [ u ].",
            "VernacExtend",
            "6a3015032f18fe5449831b89fc4378317fff8068"
        ],
        [
            "revert P; induction n as [ | n IHn ]; intros P HP.",
            "VernacExtend",
            "1ba089338e67355e60c89396acdf6bb4c057c2d4"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "exists (fun _ => u); intros; omega.",
            "VernacExtend",
            "017366503346b48c6714eafca939bb48ddeacc4a"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "destruct (IHn (fun i => P (S i))) as (f & Hf).",
            "VernacExtend",
            "604d66438af1f91edeb2622aee3330bf3d60ed80"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros; apply HP; omega.",
            "VernacExtend",
            "5bab3d9faa705942a0bfee3dc51fb3ecea55e483"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "destruct (HP 0) as (x & Hx); try omega.",
            "VernacExtend",
            "33aecf6c99b8860fa99c5ec19b76c13e6ca9c37b"
        ],
        [
            "exists (fun i => match i with 0 => x | S i => f i end).",
            "VernacExtend",
            "a97338b4748bcafd0a3c0b8a6d2b82cba732075c"
        ],
        [
            "intros [|] ?; auto; apply Hf; omega.",
            "VernacExtend",
            "cea16669ebc903692bc01e1f4d9791f79618bd1b"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem fmap_reifer_bound n P : (forall x, x < n -> ex (P x)) -> exists m f, forall x, x < n -> f x < m /\\ P x (f x).",
            "VernacStartTheoremProof",
            "dbf478c82ac687d8e08be76d5cac1f7e1d71f56f"
        ],
        [
            "intros H.",
            "VernacExtend",
            "5cfae87a34fa7b59a257c9640f1b674f6e6d780b"
        ],
        [
            "apply fmap_bound in H.",
            "VernacExtend",
            "9f8900b0d7fdd05cf892523addd1713a1cd566bb"
        ],
        [
            "destruct H as (m & Hm); exists m.",
            "VernacExtend",
            "7701df17dbdad23eb8975c8547077773960417cd"
        ],
        [
            "revert Hm; apply fmap_reifier_default; auto.",
            "VernacExtend",
            "8ca6f57c27a1f414d7404ccd1311674cc6645098"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Local Notation equal_upto := (fun m (f g : nat -> nat) => forall n, n < m -> f n = g n).",
            "VernacSyntacticDefinition",
            "29f94feb7a35bde1c30ec84c72975ef35ac1cf19"
        ],
        [
            "Theorem fmmap_bound p n (P : nat -> (nat -> nat) -> Prop) : (forall x f g, equal_upto p f g -> P x f -> P x g) -> (forall x, x < n -> exists f, P x f) -> exists m, forall x, x < n -> exists f, (forall i, i < p -> f i < m) /\\ P x f.",
            "VernacStartTheoremProof",
            "85f9f82ef7c9ed69de43a87e44ba1060ec9b25bb"
        ],
        [
            "revert P.",
            "VernacExtend",
            "ac5892a1b4da37e0858b37c00ec2a4f4d58dbf3d"
        ],
        [
            "induction p as [ | p IHp ]; intros P HP H.",
            "VernacExtend",
            "ca0a005d23a0e370c34f796b75ee669af4e9bcf4"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "exists 1; intros x Hx.",
            "VernacExtend",
            "668de2566275fea5f22e7c7f2a80b56715c11e55"
        ],
        [
            "destruct (H _ Hx) as (f & Hf).",
            "VernacExtend",
            "58c2c70e0313ec697b54d9dc9abd8fa38dec7646"
        ],
        [
            "exists (fun _ => 0); split; auto.",
            "VernacExtend",
            "a8ac0021603df98eb301a3fd16b9555cb22854d5"
        ],
        [
            "apply (HP x f); auto.",
            "VernacExtend",
            "6cd05210c7ade6d5fc062a855308771944bcd2e5"
        ],
        [
            "intros ? ?; omega.",
            "VernacExtend",
            "83a0a9e3798646d98f8b45a5528243d72e03fb38"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "set (Q x y := exists f, P x (fun i => match i with 0 => y | S i => f i end)).",
            "VernacExtend",
            "6739b3649ed384a749843a1c99ec12a8ccaa3160"
        ],
        [
            "destruct (@fmap_bound n Q) as (m1 & Hm1).",
            "VernacExtend",
            "cd988aa5c8bdb226e3d85bb65245849556f269f1"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros x Hx.",
            "VernacExtend",
            "4f408fcf0db2619f08da1108b4fc92384e2a5db3"
        ],
        [
            "destruct (H _ Hx) as (f & Hf).",
            "VernacExtend",
            "58c2c70e0313ec697b54d9dc9abd8fa38dec7646"
        ],
        [
            "exists (f 0); red.",
            "VernacExtend",
            "27bb9e2859a0358d38047a290f2b5bee0cfbc5fe"
        ],
        [
            "exists (fun i => f (S i)).",
            "VernacExtend",
            "c4f4531a6bd39a79127f8ac2cd5664541fcc2d63"
        ],
        [
            "revert Hf; apply HP.",
            "VernacExtend",
            "9a3c8656fd279e0680fbe5c2bd84ed017bbfa7b6"
        ],
        [
            "intros [ | i ]; auto.",
            "VernacExtend",
            "906c7776c7c800c55550dd0a306e5abf7361da03"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "set (R x f := exists y, y < m1 /\\ P x (fun i => match i with 0 => y | S i => f i end)).",
            "VernacExtend",
            "3818cf9d4871f3a220b2ad92122c4293370733e1"
        ],
        [
            "destruct (IHp R) as (m2 & Hm2).",
            "VernacExtend",
            "5054317fed127193cf35b2723c293793883ea7c3"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros x f g Hfg (y & H1 & H2); exists y; split; auto.",
            "VernacExtend",
            "93ca2438faf6ee747ed9ead59ff17cb637beb7b6"
        ],
        [
            "revert H2; apply HP; intros [ | ]; auto; intros; apply Hfg; omega.",
            "VernacExtend",
            "6929dfdfc81b7220f2fe131375cc34977616e5bf"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros x Hx.",
            "VernacExtend",
            "4f408fcf0db2619f08da1108b4fc92384e2a5db3"
        ],
        [
            "destruct (Hm1 _ Hx) as (y & H1 & f & H2).",
            "VernacExtend",
            "2c856f26fa48d6994c504a0893ef90bc5e443f75"
        ],
        [
            "exists f, y; split; auto.",
            "VernacExtend",
            "ef0ad786e57a6f1321a33aef40c0237a111f4361"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "exists (m1+m2).",
            "VernacExtend",
            "7c7f0641f8f2b3bfb5614ce8b30d2a05f1c96479"
        ],
        [
            "intros x Hx.",
            "VernacExtend",
            "4f408fcf0db2619f08da1108b4fc92384e2a5db3"
        ],
        [
            "destruct (Hm2 _ Hx) as (f & H1 & y & H2 & H3).",
            "VernacExtend",
            "bf3000158710043d2afa4409409cda958e20f40f"
        ],
        [
            "eexists; split; [ | exact H3 ].",
            "VernacExtend",
            "32470a029ef83985ff8615bf12f1d824ca4d21c8"
        ],
        [
            "intros [ | j ] Hj; try omega.",
            "VernacExtend",
            "c1470612669486e580ad373c6b515654624b89a6"
        ],
        [
            "specialize (H1 j); intros; omega.",
            "VernacExtend",
            "36541cd5c6d659b73964a620aef35feafdab9202"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem fmmap_reifer_bound p n (P : nat -> (nat -> nat) -> Prop) : (forall x f g, equal_upto p f g -> P x f -> P x g) -> (forall x, x < n -> exists f, P x f) -> exists m f, forall x, x < n -> (forall j, j < p -> f x j < m) /\\ P x (f x).",
            "VernacStartTheoremProof",
            "2f8d2d01571d1a0b9795e5c304a45d6cb30c2464"
        ],
        [
            "intros H1 H2.",
            "VernacExtend",
            "1a279bc44908e178ace5c31cb5040905c4829477"
        ],
        [
            "apply fmmap_bound with (1 := H1) in H2.",
            "VernacExtend",
            "072b2b5415cbeb575a683a4787b7144d2239f835"
        ],
        [
            "destruct H2 as (m & Hm).",
            "VernacExtend",
            "723985f0286b4e4e1500b0ca2c4fe01dda6c9610"
        ],
        [
            "apply fmap_reifier_default in Hm; auto.",
            "VernacExtend",
            "84881d6b9f46819409b60f8f7177e38bc8e486ca"
        ],
        [
            "destruct Hm as (f & Hf); exists m, f; auto.",
            "VernacExtend",
            "6a696a915ee5e817e4b20d139234fc6b43621610"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ]
    ],
    "proofs": [
        {
            "name": "fmap_reifier_t",
            "line_nb": 2,
            "steps": [
                {
                    "command": [
                        "revert Q; induction k as [ | k IHk ]; intros Q HQ.",
                        "VernacExtend",
                        "efe22ecac801cbde3147c22b3b2d15af73145f70"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "assert (f : forall i, i < 0 -> X) by (intros i Hi; exfalso; revert Hi; apply Nat.nlt_0_r).",
                        "VernacExtend",
                        "1f35c7abe47d63db230ba6e3e5a89126306918b0"
                    ]
                },
                {
                    "command": [
                        "exists f; intros i Hi; exfalso; revert Hi; apply Nat.nlt_0_r.",
                        "VernacExtend",
                        "ad2fef02967c2c341242af5e9daecf7139797835"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "destruct (HQ 0) as (f0 & H0).",
                        "VernacExtend",
                        "3817070f9fc4e9f70d2ee05bd673c145e9fdb93b"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "apply Nat.lt_0_succ.",
                        "VernacExtend",
                        "71ce36185f1fd4314aab0331b52b3659e0a186db"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "destruct (IHk (fun i => Q (S i))) as (f & Hf).",
                        "VernacExtend",
                        "b18199713d636474516ee422094f9a0d4d9d6b76"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "intros; apply HQ, lt_n_S; trivial.",
                        "VernacExtend",
                        "daea6cfae6adf09b9ad04c62bbdd4aa5ecbc5d67"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "set (f' := fun i => match i return i < S k -> X with | 0 => fun _ => f0 | S j => fun Hj => f j (lt_S_n _ _ Hj) end).",
                        "VernacExtend",
                        "e0a07b311d54da8f0dfbd39cc7c98270276d62b8"
                    ]
                },
                {
                    "command": [
                        "exists f'; intros [ | i ] Hi; simpl; trivial.",
                        "VernacExtend",
                        "0fb942f333ff5e46f9236f8e4c6f5bfcbe04cf1d"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "fmap_reifier_t_default",
            "line_nb": 19,
            "steps": [
                {
                    "command": [
                        "intros H.",
                        "VernacExtend",
                        "5cfae87a34fa7b59a257c9640f1b674f6e6d780b"
                    ]
                },
                {
                    "command": [
                        "apply fmap_reifier_t in H.",
                        "VernacExtend",
                        "2c83411a926a5f5c4d4414370786e7fc1c266d03"
                    ]
                },
                {
                    "command": [
                        "destruct H as (f & Hf).",
                        "VernacExtend",
                        "a182f749db6bb93666d39b800ad725844976beee"
                    ]
                },
                {
                    "command": [
                        "exists (fun i => match le_lt_dec k i with | left _ => x | right Hi => f i Hi end).",
                        "VernacExtend",
                        "a4cf85c787056a78ea0471bb8811f9d2ce126523"
                    ]
                },
                {
                    "command": [
                        "intros i Hi.",
                        "VernacExtend",
                        "1763a4b461e760b296ffbe398979e15770c7a1bd"
                    ]
                },
                {
                    "command": [
                        "destruct (le_lt_dec k i) as [ H1 | ]; auto.",
                        "VernacExtend",
                        "180886fc53444805ca1f70cd8614edfee22588ad"
                    ]
                },
                {
                    "command": [
                        "exfalso; revert Hi H1; apply lt_not_le.",
                        "VernacExtend",
                        "6a3d6771f741a149ae5209082eb4f16e103bc937"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "fmap_bound",
            "line_nb": 28,
            "steps": [
                {
                    "command": [
                        "revert P; induction n as [ | n IHn ]; intros P HP.",
                        "VernacExtend",
                        "1ba089338e67355e60c89396acdf6bb4c057c2d4"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "exists 0; intros; omega.",
                        "VernacExtend",
                        "2218c309f93cbe13a1ac5efee1605e872151a0a8"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "destruct (HP 0) as (m0 & H0); try omega.",
                        "VernacExtend",
                        "2d1e52dfc08a8ee638022bc9e2f3f67ba1dc9ec7"
                    ]
                },
                {
                    "command": [
                        "destruct (IHn (fun n => P (S n))) as (m1 & Hm1).",
                        "VernacExtend",
                        "13f45e7a21a049ec4ebe4e7f4e14949cff26babd"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "intros; apply HP; omega.",
                        "VernacExtend",
                        "5bab3d9faa705942a0bfee3dc51fb3ecea55e483"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "exists (1+m0+m1); intros [ | x ] Hx.",
                        "VernacExtend",
                        "03f3ff24a493c84a91dd69fe9238057f28f6d508"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "exists m0; split; auto; omega.",
                        "VernacExtend",
                        "0cc168cb344db0aff56e2c5fa488f596e91ead13"
                    ]
                },
                {
                    "command": [
                        "*",
                        "VernacBullet",
                        "8a329d054468e0c41ce333043e0978e30eed7b98"
                    ]
                },
                {
                    "command": [
                        "destruct (Hm1 x) as (y & H1 & H2); try omega.",
                        "VernacExtend",
                        "bf1c47dafdb04db42aebc398bd17697c2d5f6534"
                    ]
                },
                {
                    "command": [
                        "exists y; split; auto; omega.",
                        "VernacExtend",
                        "e50d0f8d408f76d57159bb7c428539b72113dbb2"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "fmap_reifier_default",
            "line_nb": 45,
            "steps": [
                {
                    "command": [
                        "intros [ u ].",
                        "VernacExtend",
                        "6a3015032f18fe5449831b89fc4378317fff8068"
                    ]
                },
                {
                    "command": [
                        "revert P; induction n as [ | n IHn ]; intros P HP.",
                        "VernacExtend",
                        "1ba089338e67355e60c89396acdf6bb4c057c2d4"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "exists (fun _ => u); intros; omega.",
                        "VernacExtend",
                        "017366503346b48c6714eafca939bb48ddeacc4a"
                    ]
                },
                {
                    "command": [
                        "+",
                        "VernacBullet",
                        "3ddfc0515f916e562bacf863647e0107cb15aa13"
                    ]
                },
                {
                    "command": [
                        "destruct (IHn (fun i => P (S i))) as (f & Hf).",
                        "VernacExtend",
                        "604d66438af1f91edeb2622aee3330bf3d60ed80"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "intros; apply HP; omega.",
                        "VernacExtend",
                        "5bab3d9faa705942a0bfee3dc51fb3ecea55e483"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "destruct (HP 0) as (x & Hx); try omega.",
                        "VernacExtend",
                        "33aecf6c99b8860fa99c5ec19b76c13e6ca9c37b"
                    ]
                },
                {
                    "command": [
                        "exists (fun i => match i with 0 => x | S i => f i end).",
                        "VernacExtend",
                        "a97338b4748bcafd0a3c0b8a6d2b82cba732075c"
                    ]
                },
                {
                    "command": [
                        "intros [|] ?; auto; apply Hf; omega.",
                        "VernacExtend",
                        "cea16669ebc903692bc01e1f4d9791f79618bd1b"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "fmap_reifer_bound",
            "line_nb": 59,
            "steps": [
                {
                    "command": [
                        "intros H.",
                        "VernacExtend",
                        "5cfae87a34fa7b59a257c9640f1b674f6e6d780b"
                    ]
                },
                {
                    "command": [
                        "apply fmap_bound in H.",
                        "VernacExtend",
                        "9f8900b0d7fdd05cf892523addd1713a1cd566bb"
                    ]
                },
                {
                    "command": [
                        "destruct H as (m & Hm); exists m.",
                        "VernacExtend",
                        "7701df17dbdad23eb8975c8547077773960417cd"
                    ]
                },
                {
                    "command": [
                        "revert Hm; apply fmap_reifier_default; auto.",
                        "VernacExtend",
                        "8ca6f57c27a1f414d7404ccd1311674cc6645098"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "fmmap_reifer_bound",
            "line_nb": 104,
            "steps": [
                {
                    "command": [
                        "intros H1 H2.",
                        "VernacExtend",
                        "1a279bc44908e178ace5c31cb5040905c4829477"
                    ]
                },
                {
                    "command": [
                        "apply fmmap_bound with (1 := H1) in H2.",
                        "VernacExtend",
                        "072b2b5415cbeb575a683a4787b7144d2239f835"
                    ]
                },
                {
                    "command": [
                        "destruct H2 as (m & Hm).",
                        "VernacExtend",
                        "723985f0286b4e4e1500b0ca2c4fe01dda6c9610"
                    ]
                },
                {
                    "command": [
                        "apply fmap_reifier_default in Hm; auto.",
                        "VernacExtend",
                        "84881d6b9f46819409b60f8f7177e38bc8e486ca"
                    ]
                },
                {
                    "command": [
                        "destruct Hm as (f & Hf); exists m, f; auto.",
                        "VernacExtend",
                        "6a696a915ee5e817e4b20d139234fc6b43621610"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}