{
    "filename": "Shared/Libs/DLW/Utils/utils_tac.v",
    "coq_project": "coq-library-undecidability",
    "vernac_cmds": [
        [
            "Require Import Arith List Wellfounded.",
            "VernacRequire",
            "fca37454462017bf73ddf1e95aa052f662c1fe12"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Definition eqdec X := forall x y : X, { x = y } + { x <> y }.",
            "VernacDefinition",
            "f0d49e907c4e2fea915cb2ab5de29ff1fffc48b7"
        ],
        [
            "Definition swap {X Y} (c : X * Y) := let (x,y) := c in (y,x).",
            "VernacDefinition",
            "603f684c328be4d8e1c783f41395d9e5c516ca1c"
        ],
        [
            "Theorem measure_rect X (m : X -> nat) (P : X -> Type) : (forall x, (forall y, m y < m x -> P y) -> P x) -> forall x, P x.",
            "VernacStartTheoremProof",
            "5049f0cae872af930307d7643e792593578a8a2b"
        ],
        [
            "apply well_founded_induction_type, wf_inverse_image, lt_wf.",
            "VernacExtend",
            "d7524612e201912ca77dc060ebe7c5063a336d7a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Tactic Notation \"induction\" \"on\" hyp(x) \"as\" ident(IH) \"with\" \"measure\" uconstr(f) := pattern x; revert x; apply measure_rect with (m := fun x => f); intros x IH.",
            "VernacExtend",
            "828c95547306dc2ea0513810435cdafaf8f7392c"
        ],
        [
            "Tactic Notation \"eq\" \"goal\" hyp(H) := match goal with |- ?b => match type of H with ?t => replace b with t; auto end end.",
            "VernacExtend",
            "aea3765c61b911a2d355558dc6470753af6523b4"
        ],
        [
            "Ltac eqgoal := let H := fresh in intro H; eq goal H; clear H.",
            "VernacExtend",
            "ff422b7ef2c396160941b096879539fff48941a8"
        ],
        [
            "Tactic Notation \"spec\" \"in\" hyp(H) := let Q := fresh in match goal with G: ?h -> _ |- _ => match G with | H => assert (h) as Q; [ | specialize (H Q); clear Q ] end end.",
            "VernacExtend",
            "a01820a48387961f83ed0ca0e1e44e6997d40639"
        ],
        [
            "Ltac solve_list_eq := simpl; repeat progress (try rewrite app_ass; try rewrite <- app_nil_end; simpl; auto); auto.",
            "VernacExtend",
            "ba6288053ddcbbf09e1b8562cff091204bf9a9f0"
        ],
        [
            "Tactic Notation \"solve\" \"list\" \"eq\" := solve_list_eq.",
            "VernacExtend",
            "f32079a125e036de1f11213bbbb9bb9548f05871"
        ],
        [
            "Tactic Notation \"solve_list_eq\" \"in\" hyp(H) := generalize H; clear H; solve_list_eq; intro H.",
            "VernacExtend",
            "e2c1935d985aaf9fcca902491392c3f65ff5aa79"
        ],
        [
            "Tactic Notation \"solve\" \"list\" \"eq\" \"in\" hyp(H) := let Q := fresh in match goal with |- ?t => set (Q := t); generalize H; clear H; solve_list_eq; intro H; unfold Q; clear Q end.",
            "VernacExtend",
            "cc31dcd338860fc8e7c1a09f806d5ba09223d9be"
        ],
        [
            "Ltac msplit n := match n with | 0 => idtac | S ?n => split; [ | msplit n ] end.",
            "VernacExtend",
            "3de465a7967d77cdac3fe5dd3164b077044a6a48"
        ],
        [
            "Tactic Notation \"define\" ident(f) \"of\" hyp(n) hyp(m) \"as\" uconstr(t) := match type of n with ?N => match type of m with ?M => pose (f (n:N) (m:M) := t) end end.",
            "VernacExtend",
            "ceb5aeea9fc260bac561b70a5b6a7292b16ec6e0"
        ],
        [
            "Tactic Notation \"induction\" \"on\" hyp(x) hyp(y) \"as\" ident(IH) \"with\" \"measure\" uconstr(f) := generalize I; intro IH; let mes := fresh \"measure\" in let rel := fresh \"relation\" in let loop := fresh \"loop\" in let u := fresh \"u\" in let u' := fresh x in let Hu := fresh \"Hu\" in let v := fresh \"v\" in let v' := fresh y in let Hv := fresh \"Hv\" in clear IH; define mes of x y as (f : nat); set (rel u v := mes (fst u) (snd u) < mes (fst v) (snd v)); unfold fst, snd in rel; pattern x, y; match goal with |- ?T _ _ => refine ((fix loop u v (Hu : Acc rel (u,v)) { struct Hu } : T u v := _) x y _); [ assert (forall u' v', rel (u',v') (u,v) -> T u' v') as IH; [ intros u' v' Hv; apply (loop u' v'), (Acc_inv Hu), Hv | unfold rel, mes in *; clear mes rel Hu loop x y; rename u into x; rename v into y ] | unfold rel; apply wf_inverse_image, lt_wf ] end.",
            "VernacExtend",
            "8f7d78cc8d9b0c825659ffb336084046986562ee"
        ],
        [
            "Section forall_equiv.",
            "VernacBeginSection",
            "904ae4530eb81375a3bc562f44aeedcefc5c613c"
        ],
        [
            "Variable (X : Type) (A P Q : X -> Prop) (HPQ : forall n, A n -> P n <-> Q n).",
            "VernacAssumption",
            "b241c360989b3337e2fc7d6e7ca2cf872766166c"
        ],
        [
            "Theorem forall_bound_equiv : (forall n, A n -> P n) <-> (forall n, A n -> Q n).",
            "VernacStartTheoremProof",
            "47a246853009744bbe941bfb8e6050288c31cc18"
        ],
        [
            "split; intros H n Hn; generalize (H _ Hn); apply HPQ; auto.",
            "VernacExtend",
            "ea72a5e78c26b7710f00c6e9ada4d77b0fde8671"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End forall_equiv.",
            "VernacEndSegment",
            "5f90ed9e2b3b10051c45a9f93c8ec78d23e5af08"
        ],
        [
            "Section exists_equiv.",
            "VernacBeginSection",
            "e2502752a9b3a98529af79cd11d05d03ba5b552c"
        ],
        [
            "Variable (X : Type) (P Q : X -> Prop) (HPQ : forall n, P n <-> Q n).",
            "VernacAssumption",
            "03b6f8345b27d8559223e4d657276d084c084ccd"
        ],
        [
            "Theorem exists_equiv : (exists n, P n) <-> (exists n, Q n).",
            "VernacStartTheoremProof",
            "2c02cb27b8ddec6fce97edcebc3cd72d2bfc801e"
        ],
        [
            "split; intros (n & Hn); exists n; revert Hn; apply HPQ; auto.",
            "VernacExtend",
            "21ad23a2075935027d32da2af42ac8cc61d99b22"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End exists_equiv.",
            "VernacEndSegment",
            "ea9d5c6dc4c6b955b977e20f6193f691fd4631bf"
        ]
    ],
    "proofs": [
        {
            "name": "measure_rect",
            "line_nb": 4,
            "steps": [
                {
                    "command": [
                        "apply well_founded_induction_type, wf_inverse_image, lt_wf.",
                        "VernacExtend",
                        "d7524612e201912ca77dc060ebe7c5063a336d7a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "forall_bound_equiv",
            "line_nb": 20,
            "steps": [
                {
                    "command": [
                        "split; intros H n Hn; generalize (H _ Hn); apply HPQ; auto.",
                        "VernacExtend",
                        "ea72a5e78c26b7710f00c6e9ada4d77b0fde8671"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "exists_equiv",
            "line_nb": 26,
            "steps": [
                {
                    "command": [
                        "split; intros (n & Hn); exists n; revert Hn; apply HPQ; auto.",
                        "VernacExtend",
                        "21ad23a2075935027d32da2af42ac8cc61d99b22"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}