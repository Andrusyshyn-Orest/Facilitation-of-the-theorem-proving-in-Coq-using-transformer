{
    "filename": "qs_definitions.v",
    "coq_project": "quicksort-complexity",
    "vernac_cmds": [
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Require Import util.",
            "VernacRequire",
            "4430f87d7649f96d1418f130d57967666d56d84f"
        ],
        [
            "Require Import List.",
            "VernacRequire",
            "d9bcce4a390afeb160107bf87c6f7abe3d82c6d6"
        ],
        [
            "Require Import Le.",
            "VernacRequire",
            "838bfe0aac98b4a25730898d79830c3f8329aec1"
        ],
        [
            "Require Import Lt.",
            "VernacRequire",
            "fe47d80ebda42c5f075a36fb67288742f8593767"
        ],
        [
            "Require Import Plus.",
            "VernacRequire",
            "a18284a3c28ae9356bfc5084ee8540c5d50631e5"
        ],
        [
            "Require Import monads.",
            "VernacRequire",
            "5b2fd91685e0255ced6df1c87a652a12b8990a39"
        ],
        [
            "Require Import Coq.Program.Wf.",
            "VernacRequire",
            "020696913b1c2b6c01425c8967a530fa30e972fb"
        ],
        [
            "Require Import nat_seqs.",
            "VernacRequire",
            "350f7c7394c4c6b69193e921e8497ea2449f9eb8"
        ],
        [
            "Require Import list_utils.",
            "VernacRequire",
            "f5ce54076a68b3ca9f48d4de158eadf0961b9e1f"
        ],
        [
            "Require Import Bool.",
            "VernacRequire",
            "a27d9a6c92262b970381301472e9a1100c206680"
        ],
        [
            "Require Import Recdef.",
            "VernacRequire",
            "8ffa9cbe33b0c9742b324b18d68b10eb03ac2ead"
        ],
        [
            "Require Import monoid_monad_trans.",
            "VernacRequire",
            "4bb2bf1c803b5281d50c61057d2ecff387723de8"
        ],
        [
            "Require Import Compare_dec.",
            "VernacRequire",
            "96b495dc82d6bd54e62353acae7d6e61222564e6"
        ],
        [
            "Require Coq.Program.Wf.",
            "VernacRequire",
            "2817dd29c54e1c78a433a2c61b378a0ae4fe76ae"
        ],
        [
            "Require Import Wf_nat.",
            "VernacRequire",
            "e78e8b6524a9771b7c95f37880c2b88f96465784"
        ],
        [
            "Require Import arith_lems.",
            "VernacRequire",
            "c122d8f93731b561f73c879ca58fed05abd59dc7"
        ],
        [
            "Require ne_list.",
            "VernacRequire",
            "742372fea7850d4df74629644c14dc442062462b"
        ],
        [
            "Require Import Omega.",
            "VernacRequire",
            "72dd903de5f3320ef9d302d79812066579ed9cdb"
        ],
        [
            "Require fix_measure_utils.",
            "VernacRequire",
            "116fc920cc11f96768057e00a4c45b5e9201f622"
        ],
        [
            "Set Shrink Obligations.",
            "VernacSetOption",
            "f7395d097ae8a78c5b6d9d34117b07c84fe0d248"
        ],
        [
            "Definition numbers: list nat := 3 :: 1 :: 0 :: 4 :: 5 :: 2 :: nil.",
            "VernacDefinition",
            "1f53e65eb761f6699ee55e46e5a073952bd9385e"
        ],
        [
            "Hint Resolve length_filter_le.",
            "VernacHints",
            "a552fe714efe08ba0733937ccf88c780f114c048"
        ],
        [
            "Module nonmonadic.",
            "VernacDefineModule",
            "d811c7bc74d506bac7310713b06ae49cf8d21f30"
        ],
        [
            "Section nonmonadic.",
            "VernacBeginSection",
            "3c679ebcaa73cc4adca6b597318b7baa6c5f7c49"
        ],
        [
            "Variables (T: Set) (le: T -> T -> bool).",
            "VernacAssumption",
            "f931f0d19814bf26daf5e84c3a2348d8c9d82373"
        ],
        [
            "Definition gt (x y: T): bool := negb (le x y).",
            "VernacDefinition",
            "72f90f11ebd1174d9dae403f31beae978792b17f"
        ],
        [
            "Program Fixpoint qs (l: list T) {measure (length l) on lt}: list T := match l with | nil => nil | pivot :: t => qs (filter (gt pivot) t) ++ (pivot :: nil) ++ qs (filter (le pivot) t) end.",
            "VernacFixpoint",
            "70578c93006769965cdbbeeaa5496e2cb0ba66b2"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl; auto with arith.",
            "VernacExtend",
            "ab3fa8d215cdc73141fcf1a11781cfe38de440ec"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl; auto with arith.",
            "VernacExtend",
            "ab3fa8d215cdc73141fcf1a11781cfe38de440ec"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition body (l : list T) (qs0 : {l' : list T | length l' < length l} -> list T) := match l as l0 return (l0 = l -> list T) with | nil => fun _ => nil | pivot :: t0 => fun Heq_l => qs0 (exist (fun l' => length l' < length l) (filter (gt pivot) t0) (qs_obligation_1 (fun l H => qs0 (exist _ l H)) Heq_l)) ++ (pivot :: nil) ++ qs0 (exist (fun l' => length l' < length l) (filter (le pivot) t0) (qs_obligation_2 (fun l H => qs0 (exist _ l H)) Heq_l)) end refl_equal.",
            "VernacDefinition",
            "23602484003271ead5527c9c548ef09471a38d45"
        ],
        [
            "Lemma body_eq: forall (x0 : list T) (g h0 : {y : list T | length y < length x0} -> list T), (forall (x : list T) (p p' : length x < length x0), g (exist (fun y : list T => length y < length x0) x p) = h0 (exist (fun y : list T => length y < length x0) x p')) -> body x0 g = body x0 h0.",
            "VernacStartTheoremProof",
            "7c5ae6a818860666712cfee676b77dbf9d31a382"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct x0...",
            "VernacExtend",
            "3dc81ee3f6f61c6a091f66e987026c21574e3040"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "f_equal...",
            "VernacExtend",
            "34c0a671e75a4f793a7b8803a2f75c5deae218ba"
        ],
        [
            "f_equal...",
            "VernacExtend",
            "34c0a671e75a4f793a7b8803a2f75c5deae218ba"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma unfold: forall l, qs l = Fix_sub (list T) (MR lt (fun l0 : list T => length l0)) qs_obligation_3 (fun _ : list T => list T) body l.",
            "VernacStartTheoremProof",
            "2753cfbe4e306ced42045df72bbcf04f6dd5dee4"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma qs_unfold (t: list T) (h: T): qs (h :: t) = qs (filter (gt h) t) ++ (h :: nil) ++ qs (filter (le h) t).",
            "VernacStartTheoremProof",
            "3c4b8150bd5037bfb616b60db4b95d2b91d1e488"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "unfold qs.",
            "VernacExtend",
            "aabcf467b0395ceb912b170818dbe9294fc93177"
        ],
        [
            "fold body.",
            "VernacExtend",
            "d7fc1834cc45d3344eed2d758f918a8d0c310a56"
        ],
        [
            "rewrite fix_measure_utils.unfold.",
            "VernacExtend",
            "6a8f52b1ba48bbedaafc66aff526ae9f68f8ab40"
        ],
        [
            "unfold body at 1.",
            "VernacExtend",
            "70c929f5ae346586804829ad5b5f37c255562ce5"
        ],
        [
            "simpl proj1_sig.",
            "VernacExtend",
            "5f96d4f17b719de67e5d7478228e33dba85bb4de"
        ],
        [
            "f_equal.",
            "VernacExtend",
            "dfce814d1efcef60f8330516ad88155a3a5ec317"
        ],
        [
            "apply body_eq.",
            "VernacExtend",
            "428fbb622317e6364271368fae07f493f461fb17"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Section rect.",
            "VernacBeginSection",
            "fec9d4b5bf55c12d80da0013268a217b92aa4a50"
        ],
        [
            "Variable P: list T -> list T -> Prop.",
            "VernacAssumption",
            "0b5aa3e554944e71aaaa340e45bc1c5f5cf74c81"
        ],
        [
            "Hypothesis Pnil: P nil nil.",
            "VernacAssumption",
            "13de123430d7ad239468a6477ab160966b367241"
        ],
        [
            "Hypothesis Pcons: forall h t, P (filter (gt h) t) (qs (filter (gt h) t)) -> P (filter (le h) t) (qs (filter (le h) t)) -> P (h :: t) (qs (filter (gt h) t) ++ h :: nil ++ qs (filter (le h) t)).",
            "VernacAssumption",
            "30d8215c015074d4d8f216943aa716b86d078027"
        ],
        [
            "Lemma qs_rect: forall l, P l (qs l).",
            "VernacStartTheoremProof",
            "1ea1866b07a12934d83f1244577ea5c33c00f8f5"
        ],
        [
            "Proof with auto with arith.",
            "VernacProof",
            "007741178d53d6a043487bfdd1e6c77ea6388468"
        ],
        [
            "unfold qs.",
            "VernacExtend",
            "aabcf467b0395ceb912b170818dbe9294fc93177"
        ],
        [
            "fold body.",
            "VernacExtend",
            "d7fc1834cc45d3344eed2d758f918a8d0c310a56"
        ],
        [
            "apply fix_measure_utils.rect.",
            "VernacExtend",
            "4230cf1d8d24a8119d150e792874eceb44776121"
        ],
        [
            "apply body_eq.",
            "VernacExtend",
            "428fbb622317e6364271368fae07f493f461fb17"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct x...",
            "VernacExtend",
            "7765274004a21ba6bfb7c6c03b9ce172306d36ac"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "apply Pcons; apply H; unfold MR; simpl...",
            "VernacExtend",
            "6b021678d570ba642e6eb23d06f291da44544153"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End rect.",
            "VernacEndSegment",
            "108cc15b483744b75f66bcb604a5a657c9b97104"
        ],
        [
            "End nonmonadic.",
            "VernacEndSegment",
            "130c6a2d71f9fbab3087842661b058c25ed3d163"
        ],
        [
            "End nonmonadic.",
            "VernacEndSegment",
            "130c6a2d71f9fbab3087842661b058c25ed3d163"
        ],
        [
            "Module mon_det.",
            "VernacDefineModule",
            "91fe004e27aff1456f7245eaf79ac3b1a87d8210"
        ],
        [
            "Section mon_det.",
            "VernacBeginSection",
            "2a724e2269a33931f4ec63793b086e4be8121ea3"
        ],
        [
            "Variables (M: Monad) (T: Set).",
            "VernacAssumption",
            "e8f28d4df6286302ff2baed1911666a4b7a470c7"
        ],
        [
            "Definition filter (c: T -> M bool) (l: list T): M { l': list T | length l' <= length l }.",
            "VernacDefinition",
            "919e102445e4cd3d2f073a74cb7fd829de78e161"
        ],
        [
            "Proof with auto with arith.",
            "VernacProof",
            "007741178d53d6a043487bfdd1e6c77ea6388468"
        ],
        [
            "induction l.",
            "VernacExtend",
            "1194af70832939708f8c7fde2f18f81c37b97a0c"
        ],
        [
            "refine (ret (exist _ nil _))...",
            "VernacExtend",
            "e9ba06fbe83f9fc3b929537781f06fb950f1da5f"
        ],
        [
            "refine ( b <- c a ; t <- IHl ; ret (if b then exist _ (a :: proj1_sig t) _ else exist _ (proj1_sig t) _) ); simpl; destruct t...",
            "VernacExtend",
            "f4277ed3f500c595e37a2855993d3f0e9a10a853"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma hm (e: extMonad M) c l: forall U (f: list T -> M U) g, ext_eq g (f \u2218 @proj1_sig _ _) -> filter c l >>= g = filterM c l >>= f.",
            "VernacStartTheoremProof",
            "8d6c540e7e5dbb17406864110e8aec3e0dfc2740"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "induction l.",
            "VernacExtend",
            "1194af70832939708f8c7fde2f18f81c37b97a0c"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "repeat rewrite mon_lunit.",
            "VernacExtend",
            "c1e00f64c9e2bf09a655344c03d7ef43a1f94045"
        ],
        [
            "rewrite H.",
            "VernacExtend",
            "6192df8b89486a3ba89a78e26e0d70cae2dc94c2"
        ],
        [
            "unfold compose...",
            "VernacExtend",
            "74917a3d82699f8eb88bcf3eab52f409dd9cbc2c"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "repeat rewrite mon_assoc.",
            "VernacExtend",
            "2f3444a3c5bf65100d904d1542aa5f3c3838de9a"
        ],
        [
            "apply e.",
            "VernacExtend",
            "7e471e9a67d7e270fc9d49b2286b43a098cffb1d"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "repeat rewrite mon_assoc.",
            "VernacExtend",
            "2f3444a3c5bf65100d904d1542aa5f3c3838de9a"
        ],
        [
            "apply IHl.",
            "VernacExtend",
            "af412c6009bba78f939aa53ab07dcd1baaf5888b"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "unfold compose.",
            "VernacExtend",
            "d80e23bf133762584228beafbd8610d99d5d02d5"
        ],
        [
            "repeat rewrite mon_lunit.",
            "VernacExtend",
            "c1e00f64c9e2bf09a655344c03d7ef43a1f94045"
        ],
        [
            "rewrite H.",
            "VernacExtend",
            "6192df8b89486a3ba89a78e26e0d70cae2dc94c2"
        ],
        [
            "unfold compose.",
            "VernacExtend",
            "d80e23bf133762584228beafbd8610d99d5d02d5"
        ],
        [
            "destruct x...",
            "VernacExtend",
            "7765274004a21ba6bfb7c6c03b9ce172306d36ac"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint simple_filter (c: T -> M bool) (l: list T): M (list T) := match l with | nil => ret nil | h :: t => t' <- simple_filter c t ; b <- c h ; ret (if b then h :: t' else t') end.",
            "VernacFixpoint",
            "62b38f68175068ebab9e77ba17941a4c353dfdda"
        ],
        [
            "Definition fold_filter (c: T -> M bool): list T -> M (list T) := foldrM (fun x l => b <- c x ; ret (if b then x :: l else l)) nil.",
            "VernacDefinition",
            "56108b03fae770d1377b7258b955c561cca15477"
        ],
        [
            "Lemma simple_fold_filter: forall c l, simple_filter c l = fold_filter c l.",
            "VernacStartTheoremProof",
            "ea8631af0c78c5e9c43efcd66abfc4a1ccd9cf75"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "unfold fold_filter.",
            "VernacExtend",
            "6e3079b179f9dd1dc849bf488b9fca5accb6ee1e"
        ],
        [
            "induction l...",
            "VernacExtend",
            "a4571710fc634c72b7b07ca630627ad571eee64e"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite IHl...",
            "VernacExtend",
            "a48c59a0d042c7310da6766246ef180a091c8386"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Variable le: T -> T -> M bool.",
            "VernacAssumption",
            "82ba14afcd1e188d5ff593b20448eac06978ad74"
        ],
        [
            "Definition gt (x y: T): M bool := liftM negb (le x y).",
            "VernacDefinition",
            "29a521a3fa9bfbb2f74f8725688949d8a00edb6d"
        ],
        [
            "Program Fixpoint qs (l: list T) {measure (length l) on lt}: M (list T) := match l with | nil => ret nil | pivot :: t => lower <- filter (gt pivot) t >>= (fun l => qs l); upper <- filter (le pivot) t >>= (fun l => qs l); ret (lower ++ pivot :: upper) end.",
            "VernacFixpoint",
            "192fb2284954e35387f4be4cb6d68de054f23ddc"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "auto with arith.",
            "VernacExtend",
            "0a06d2be3685676bb8fa998f149557e231db6506"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "auto with arith.",
            "VernacExtend",
            "0a06d2be3685676bb8fa998f149557e231db6506"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition body (l: list T) (qs0: {l': list T | length l' < length l} -> M (list T)) := match l as l1 return (l1 = l -> M (list T)) with | nil => fun _ => ret (m:=M) nil | pivot :: t => fun Heq_l => lower <- x <- filter (gt pivot) t; qs0 (exist _ (proj1_sig x) (qs_obligation_1 (fun l H => qs0 (exist _ l H)) Heq_l x)); upper <- x <- filter (le pivot) t; qs0 (exist _ (proj1_sig x) (qs_obligation_2 (fun l H => qs0 (exist _ l H)) Heq_l x)); ret (m:=M) (lower ++ pivot :: upper) end refl_equal.",
            "VernacDefinition",
            "5ae8d66288add99cd37e1657fca5f24d53b9da3b"
        ],
        [
            "Lemma unfold: forall l, qs l = Fix_sub (list T) (MR lt (fun l0 : list T => length l0)) qs_obligation_3 (fun _ : list T => M (list T)) body l.",
            "VernacStartTheoremProof",
            "cb317a819d1751c553b1af3f6e5c58a18417d8bd"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Variable e: extMonad M.",
            "VernacAssumption",
            "d759a18a9bafbd1ba5c6656bb3b6bb2d796a1937"
        ],
        [
            "Lemma body_eq: forall (x0 : list T) (g h : {y : list T | length y < length x0} -> M (list T)), (forall (x1 : list T) (p p' : length x1 < length x0), g (exist (fun y : list T => length y < length x0) x1 p) = h (exist (fun y : list T => length y < length x0) x1 p')) -> body x0 g = body x0 h.",
            "VernacStartTheoremProof",
            "5bee6ddc39c015f3632256196ea811f416f9b6b9"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct x0...",
            "VernacExtend",
            "3dc81ee3f6f61c6a091f66e987026c21574e3040"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite mon_assoc.",
            "VernacExtend",
            "d525e32fea8e3519575d67077c59f2480695ca2d"
        ],
        [
            "rewrite mon_assoc.",
            "VernacExtend",
            "d525e32fea8e3519575d67077c59f2480695ca2d"
        ],
        [
            "apply e.",
            "VernacExtend",
            "7e471e9a67d7e270fc9d49b2286b43a098cffb1d"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "simpl @length in H.",
            "VernacExtend",
            "f99e5d3cf5a52b03b2fdce43c0f16085d087cc58"
        ],
        [
            "erewrite H.",
            "VernacExtend",
            "d70d90c0b08de6180714043cd3de593d3f4b6b36"
        ],
        [
            "apply e.",
            "VernacExtend",
            "7e471e9a67d7e270fc9d49b2286b43a098cffb1d"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "do 2 rewrite mon_assoc.",
            "VernacExtend",
            "17785dfb00457478679092214fa376a153d3327e"
        ],
        [
            "apply e.",
            "VernacExtend",
            "7e471e9a67d7e270fc9d49b2286b43a098cffb1d"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "erewrite H...",
            "VernacExtend",
            "546f4c881cbd56370b9db76c196d0901b59497eb"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma unfold' pivot t: qs (pivot :: t) = lower <- filterM (gt pivot) t >>= qs; upper <- filterM (le pivot) t >>= qs; ret (lower ++ pivot :: upper).",
            "VernacStartTheoremProof",
            "6cace9131d4e44bc10235ad2166d9d2bb67aeaca"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "unfold qs at 1.",
            "VernacExtend",
            "995608a13dfb1e7da73c7ddea205a4872a39237b"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "fold body.",
            "VernacExtend",
            "d7fc1834cc45d3344eed2d758f918a8d0c310a56"
        ],
        [
            "rewrite fix_measure_utils.unfold.",
            "VernacExtend",
            "6a8f52b1ba48bbedaafc66aff526ae9f68f8ab40"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "repeat rewrite mon_assoc.",
            "VernacExtend",
            "2f3444a3c5bf65100d904d1542aa5f3c3838de9a"
        ],
        [
            "apply hm...",
            "VernacExtend",
            "247e09d47afdc284ae09b58646a4dfe07b6cbfa2"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "unfold compose.",
            "VernacExtend",
            "d80e23bf133762584228beafbd8610d99d5d02d5"
        ],
        [
            "unfold qs.",
            "VernacExtend",
            "aabcf467b0395ceb912b170818dbe9294fc93177"
        ],
        [
            "fold body.",
            "VernacExtend",
            "d7fc1834cc45d3344eed2d758f918a8d0c310a56"
        ],
        [
            "apply e.",
            "VernacExtend",
            "7e471e9a67d7e270fc9d49b2286b43a098cffb1d"
        ],
        [
            "intro.",
            "VernacExtend",
            "3999be354c758ba0d1866e0fcc78a7288779a224"
        ],
        [
            "repeat rewrite mon_assoc.",
            "VernacExtend",
            "2f3444a3c5bf65100d904d1542aa5f3c3838de9a"
        ],
        [
            "apply hm...",
            "VernacExtend",
            "247e09d47afdc284ae09b58646a4dfe07b6cbfa2"
        ],
        [
            "intro...",
            "VernacExtend",
            "7274cb42adf060ad435addc8c1ce77d7b7ea4ef8"
        ],
        [
            "apply body_eq.",
            "VernacExtend",
            "428fbb622317e6364271368fae07f493f461fb17"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End mon_det.",
            "VernacEndSegment",
            "ae51e154e43027967c45dc74d5c03222ae5abbf8"
        ],
        [
            "End mon_det.",
            "VernacEndSegment",
            "ae51e154e43027967c45dc74d5c03222ae5abbf8"
        ],
        [
            "Arguments mon_det.qs [M T].",
            "VernacArguments",
            "fb31b79b63ce9371b05729b6e392e45abcbb69c7"
        ],
        [
            "Lemma mon_det_nonmonadic_eq (X: Set) (Xle: X -> X -> Prop) (leb: X -> X -> IdMonad.M bool): forall l, mon_det.qs leb l = nonmonadic.qs leb l.",
            "VernacStartTheoremProof",
            "5ae2b32eda17250ff767355109b57189d50c6452"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "pattern l, (nonmonadic.qs leb l).",
            "VernacExtend",
            "b287da4b226dbeb279ab6716b221a5ecc65c8bbf"
        ],
        [
            "apply nonmonadic.qs_rect...",
            "VernacExtend",
            "0716a7dc2391a416a3686e32e8ab5e4caac619dc"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "rewrite mon_det.unfold'.",
            "VernacExtend",
            "dd31a506b01e350949f41478b2dd6e6d761453ed"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "unfold IdMonad.bind, IdMonad.ret.",
            "VernacExtend",
            "fd75bc35bc3a888c7d76eae34ac2353abe82654f"
        ],
        [
            "do 2 rewrite <- filterM_id.",
            "VernacExtend",
            "1bc335ea6b32f9df42ec62bd10fbd617906ccd7d"
        ],
        [
            "rewrite H0.",
            "VernacExtend",
            "1a54b13ac1654793174947eafd5c41a3f024eb49"
        ],
        [
            "unfold mon_det.gt.",
            "VernacExtend",
            "f2ab772c03ed605d18dd2af9dc92441b0c7f7f6b"
        ],
        [
            "unfold nonmonadic.gt in H.",
            "VernacExtend",
            "18711862ede7a4bfcc6e84b7d7168ed5e6b6c39a"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "unfold IdMonad.bind, IdMonad.ret.",
            "VernacExtend",
            "fd75bc35bc3a888c7d76eae34ac2353abe82654f"
        ],
        [
            "rewrite H...",
            "VernacExtend",
            "2ded38871f6ef5ae4e687aa3245494ae541f7202"
        ],
        [
            "intro...",
            "VernacExtend",
            "7274cb42adf060ad435addc8c1ce77d7b7ea4ef8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition profiled_leb (x y: nat): SimplyProfiled bool := (1, leb x y).",
            "VernacDefinition",
            "632fa1d8d5d69bba1c61868b5489cab515d3fc9b"
        ],
        [
            "Eval vm_compute in mon_det.qs profiled_leb numbers.",
            "VernacCheckMayEval",
            "a6d8eed3c54a5a7192430620ea5fa54e9984769d"
        ],
        [
            "Eval vm_compute in mon_det.qs (M:=IdMonad.M) leb numbers.",
            "VernacCheckMayEval",
            "f171b2521abcb8d5cc3aa76950804edad407e7d2"
        ],
        [
            "Module mon_det_partition.",
            "VernacDefineModule",
            "a0cd3cab106ca6a3f00de6ec26c8750036959a48"
        ],
        [
            "Section mon_det_partition.",
            "VernacBeginSection",
            "51e0fc0cb00329ad782111b19a3d1a4a8db0cc68"
        ],
        [
            "Variables (T: Set) (M: Monad) (cmp: T -> T -> M comparison).",
            "VernacAssumption",
            "91f867ee6b933bd328a621ded8afd110bde5aee4"
        ],
        [
            "Fixpoint partition (pivot: T) (l: list T) : M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } := match l return M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } with | nil => ret (@emp T) | h :: t => b <- cmp h pivot; tt <- partition pivot t ; ret (addToPartitioning b h tt) end.",
            "VernacFixpoint",
            "808b4b1f571b1e2065851ff53fc2889da1b8a5ae"
        ],
        [
            "Program Fixpoint qs (l: list T) {measure (length l) on lt}: M (list T) := match l with | nil => ret nil | h :: t => part <- partition h t; low <- qs (part Lt); upp <- qs (part Gt); ret (low ++ h :: part Eq ++ upp) end.",
            "VernacFixpoint",
            "af172842afdb3d7f731dc92288df33103f1b5125"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite <- H.",
            "VernacExtend",
            "95b84807b4afb2ef79b7cc04a1c91a4e3a502e47"
        ],
        [
            "repeat rewrite app_length.",
            "VernacExtend",
            "ee077e629e2b4d6ec77d91a544c1a2ae4c739095"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite <- H.",
            "VernacExtend",
            "95b84807b4afb2ef79b7cc04a1c91a4e3a502e47"
        ],
        [
            "repeat rewrite app_length.",
            "VernacExtend",
            "ee077e629e2b4d6ec77d91a544c1a2ae4c739095"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End mon_det_partition.",
            "VernacEndSegment",
            "69986dbcac6ba7e3b7bb9d4a863ccccb28670255"
        ],
        [
            "End mon_det_partition.",
            "VernacEndSegment",
            "69986dbcac6ba7e3b7bb9d4a863ccccb28670255"
        ],
        [
            "Module mon_nondet.",
            "VernacDefineModule",
            "17b1dc4af30c4f75f4ee5ba707f0cee358188d8b"
        ],
        [
            "Section mon_nondet.",
            "VernacBeginSection",
            "7cdd11104946ed5586fc558766f65eee12596234"
        ],
        [
            "Variables (T: Set) (M: Monad) (cmp: T -> T -> M comparison).",
            "VernacAssumption",
            "91f867ee6b933bd328a621ded8afd110bde5aee4"
        ],
        [
            "Fixpoint partition (pivot: T) (l: list T) : M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } := match l return M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } with | nil => ret (@emp T) | h :: t => b <- cmp h pivot; tt <- partition pivot t ; ret (addToPartitioning b h tt) end.",
            "VernacFixpoint",
            "808b4b1f571b1e2065851ff53fc2889da1b8a5ae"
        ],
        [
            "Variable pick: forall (A: Set), ne_list.L A -> M A.",
            "VernacAssumption",
            "658d72a3cd96efcea433abfb2735ff3b30c3d96e"
        ],
        [
            "Program Fixpoint qs (l: list T) {measure (length l) on lt}: M (list T) := match l with | nil => ret nil | h :: t => i <- pick (ne_list.from_vec (vec.nats 0 (length (h :: t)))); part <- partition (vec.nth (h :: t) i) (vec.remove (h :: t) i); low <- qs (part Lt); upp <- qs (part Gt); ret (low ++ vec.nth (h :: t) i :: part Eq ++ upp) end.",
            "VernacFixpoint",
            "f96a95421b03158174089c5b0272d2b85ed55ee3"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "replace (length t) with (length (vec.remove (h :: t) i)).",
            "VernacExtend",
            "2ca110609cffda5f82109f894c7b6ba0342e0bc3"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite <- H.",
            "VernacExtend",
            "95b84807b4afb2ef79b7cc04a1c91a4e3a502e47"
        ],
        [
            "repeat rewrite app_length.",
            "VernacExtend",
            "ee077e629e2b4d6ec77d91a544c1a2ae4c739095"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "rewrite vec.length.",
            "VernacExtend",
            "89c749459e90298328720cd009eec7d26017266d"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "replace (length t) with (length (vec.remove (h :: t) i)).",
            "VernacExtend",
            "2ca110609cffda5f82109f894c7b6ba0342e0bc3"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite <- H.",
            "VernacExtend",
            "95b84807b4afb2ef79b7cc04a1c91a4e3a502e47"
        ],
        [
            "repeat rewrite app_length.",
            "VernacExtend",
            "ee077e629e2b4d6ec77d91a544c1a2ae4c739095"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "rewrite vec.length.",
            "VernacExtend",
            "89c749459e90298328720cd009eec7d26017266d"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End mon_nondet.",
            "VernacEndSegment",
            "287d4a08198db4d3fa56074461f331d1432e1328"
        ],
        [
            "End mon_nondet.",
            "VernacEndSegment",
            "287d4a08198db4d3fa56074461f331d1432e1328"
        ],
        [
            "Require Import sort_order.",
            "VernacRequire",
            "85a39449b2d00eaee1e45659744d459c465d1213"
        ],
        [
            "Fixpoint simplerPartition (e: E) (d: e) (l: list e) {struct l}: { p: Partitioning e | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } := match l return { p: Partitioning e | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } with | nil => emp e | h :: t => addToPartitioning (Ecmp e h d) _ (simplerPartition e d t) end.",
            "VernacFixpoint",
            "f6d6117833e54163d009f0dcf72bca180bd30750"
        ],
        [
            "Arguments mon_nondet.qs [T M].",
            "VernacArguments",
            "fdf179f686fa1d9950437edf820abcbc31588b0b"
        ],
        [
            "Module nonmonadic_using_Function.",
            "VernacDefineModule",
            "656c94399bc504c20f5dccdf88a5327621d5374e"
        ],
        [
            "Function qs (l: list nat) {measure length l}: list nat := match l with | nil => nil | pivot :: t => qs (filter (geb pivot) t) ++ (pivot :: nil) ++ qs (filter (ltb pivot) t) end.",
            "VernacExtend",
            "40139f878b0ff96d1a4fc4c0770c513a7fd95067"
        ],
        [
            "Proof with simpl; auto with arith.",
            "VernacProof",
            "9d60e0ea6236aa34863d2fdae430d1b0ff4aabc6"
        ],
        [
            "intros...",
            "VernacExtend",
            "1056e51c2defbfe94d2032f9d7008334ba957959"
        ],
        [
            "intros...",
            "VernacExtend",
            "1056e51c2defbfe94d2032f9d7008334ba957959"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "End nonmonadic_using_Function.",
            "VernacEndSegment",
            "59bcd471cd33554542611a04609fdee7ca2e78ac"
        ]
    ],
    "proofs": [
        {
            "name": "qs_obligation_1",
            "line_nb": 28,
            "steps": [
                {
                    "command": [
                        "simpl; auto with arith.",
                        "VernacExtend",
                        "ab3fa8d215cdc73141fcf1a11781cfe38de440ec"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "qs_obligation_2",
            "line_nb": 31,
            "steps": [
                {
                    "command": [
                        "simpl; auto with arith.",
                        "VernacExtend",
                        "ab3fa8d215cdc73141fcf1a11781cfe38de440ec"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "unfold",
            "line_nb": 43,
            "steps": [
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}