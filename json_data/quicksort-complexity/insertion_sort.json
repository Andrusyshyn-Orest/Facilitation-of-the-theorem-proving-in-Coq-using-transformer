{
    "filename": "insertion_sort.v",
    "coq_project": "quicksort-complexity",
    "vernac_cmds": [
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Require Import Bool.",
            "VernacRequire",
            "a27d9a6c92262b970381301472e9a1100c206680"
        ],
        [
            "Require Import Lt.",
            "VernacRequire",
            "fe47d80ebda42c5f075a36fb67288742f8593767"
        ],
        [
            "Require Import Recdef.",
            "VernacRequire",
            "8ffa9cbe33b0c9742b324b18d68b10eb03ac2ead"
        ],
        [
            "Require Import List.",
            "VernacRequire",
            "d9bcce4a390afeb160107bf87c6f7abe3d82c6d6"
        ],
        [
            "Require Import Permutation.",
            "VernacRequire",
            "24483a56a7bd56238bc4fd9692efc17fe0758d88"
        ],
        [
            "Require Import Ring.",
            "VernacRequire",
            "72fc5a862bad61e63c4931b5b51742d39c39050d"
        ],
        [
            "Require Import Plus.",
            "VernacRequire",
            "a18284a3c28ae9356bfc5084ee8540c5d50631e5"
        ],
        [
            "Require Import Mult.",
            "VernacRequire",
            "2f212547234b36011df39fc4af8aa026cbf75aee"
        ],
        [
            "Require Import Compare_dec.",
            "VernacRequire",
            "96b495dc82d6bd54e62353acae7d6e61222564e6"
        ],
        [
            "Require Import monoid_monad_trans.",
            "VernacRequire",
            "4bb2bf1c803b5281d50c61057d2ecff387723de8"
        ],
        [
            "Require Import Le.",
            "VernacRequire",
            "838bfe0aac98b4a25730898d79830c3f8329aec1"
        ],
        [
            "Require Import Div2.",
            "VernacRequire",
            "b85d4c50c97b3f286ca435eeaa679d97ebbe5cfa"
        ],
        [
            "Require Import Arith.",
            "VernacRequire",
            "7f40051ec5b363eee0bbfd802b43ad2f8b97479f"
        ],
        [
            "Require Import Wf_nat.",
            "VernacRequire",
            "e78e8b6524a9771b7c95f37880c2b88f96465784"
        ],
        [
            "Require Import monads.",
            "VernacRequire",
            "5b2fd91685e0255ced6df1c87a652a12b8990a39"
        ],
        [
            "Require Import Arith.",
            "VernacRequire",
            "7f40051ec5b363eee0bbfd802b43ad2f8b97479f"
        ],
        [
            "Require Import Omega.",
            "VernacRequire",
            "72dd903de5f3320ef9d302d79812066579ed9cdb"
        ],
        [
            "Require Import arith_lems.",
            "VernacRequire",
            "c122d8f93731b561f73c879ca58fed05abd59dc7"
        ],
        [
            "Require Import list_utils.",
            "VernacRequire",
            "f5ce54076a68b3ca9f48d4de158eadf0961b9e1f"
        ],
        [
            "Require Import Morphisms.",
            "VernacRequire",
            "6a4eb96d3ed10974e9e35a50ae409cd8bae1c2f4"
        ],
        [
            "Require Import Relation_Definitions.",
            "VernacRequire",
            "ba1086f65c0b2f6754b8273aa4aa004209b8f8b6"
        ],
        [
            "Require vec.",
            "VernacRequire",
            "08616db8153e7c946fd3e24b96d9ac3527cab372"
        ],
        [
            "Definition numbers := 3 :: 2 :: 5 :: 9 :: 7 :: 6 :: 1 :: 0 :: 4 :: 8 :: nil.",
            "VernacDefinition",
            "f0b0c66f21f7c0cfb821871fe144b6738bf16f4a"
        ],
        [
            "Require Vector.",
            "VernacRequire",
            "145bcbe9535700f6fddf277a7fc43bb4df45a9f9"
        ],
        [
            "Hint Constructors vec.sorted.",
            "VernacHints",
            "80be2c40e4d181d7cc18814df82c9f7bff3346d7"
        ],
        [
            "Lemma vec_sorted_impl (X: Set) (P Q: relation X): (forall x y, P x y -> Q x y) -> forall n (l: Vector.t X n), vec.sorted P l -> vec.sorted Q l.",
            "VernacStartTheoremProof",
            "9f1b0c28b83974217cd4679b412276104bf0b347"
        ],
        [
            "induction 2; auto.",
            "VernacExtend",
            "dcfc52477da5ede37c9d912847b566de0e271512"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Module plain.",
            "VernacDefineModule",
            "13a0c4263e47effb09539583a673ae8599b4fa9f"
        ],
        [
            "Section plain.",
            "VernacBeginSection",
            "66a1c5a48f72b9f8338ac7919faa58600c6ad4c5"
        ],
        [
            "Variables (T: Set) (le: T -> T -> bool).",
            "VernacAssumption",
            "f931f0d19814bf26daf5e84c3a2348d8c9d82373"
        ],
        [
            "Let R (x y: T): Prop := le x y = true.",
            "VernacDefinition",
            "fe8bd7e452571978fba974e029ce02299d8ca3a8"
        ],
        [
            "Fixpoint insert (x: T) (l: list T): list T := match l with | nil => x :: nil | h :: t => if le x h then x :: h :: t else h :: insert x t end.",
            "VernacFixpoint",
            "cefe750564d1314b82b0599d6a08c9d540f5cca5"
        ],
        [
            "Lemma insert_perm x l: Permutation (insert x l) (x :: l).",
            "VernacStartTheoremProof",
            "f0648b09352cdf76f32760a51669620fe8bf2c63"
        ],
        [
            "Proof with eauto.",
            "VernacProof",
            "12721c224a5e1fa232c2328aabfe1f5101d235c4"
        ],
        [
            "induction l...",
            "VernacExtend",
            "a4571710fc634c72b7b07ca630627ad571eee64e"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "destruct (le x a)...",
            "VernacExtend",
            "87743d34dab277498d99f42919a8d6551f526b1d"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Instance insert_perm_mor: Proper (eq ==> Permutation ==> Permutation) insert.",
            "VernacInstance",
            "fe57f3b2d61da374838c5b1fda0a72ecd941c95d"
        ],
        [
            "Proof with eauto.",
            "VernacProof",
            "12721c224a5e1fa232c2328aabfe1f5101d235c4"
        ],
        [
            "repeat intro.",
            "VernacExtend",
            "b1b5d9b3004bf4634299c208df98406e88278608"
        ],
        [
            "induction H0; subst; simpl...",
            "VernacExtend",
            "a36a90fe699ecf0e275b5091dc99e7cd3ef19897"
        ],
        [
            "destruct (le y x0)...",
            "VernacExtend",
            "76308e5abb7503fa62d3cc3248cfc459653ebe12"
        ],
        [
            "destruct (le y y0); destruct (le y x0)...",
            "VernacExtend",
            "7db9d7cd93d9ccf2666f3c6fd633554b030be0be"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hypotheses (le_yippee: forall x y, le x y = false -> le y x = true) (preorder_R: preorder _ R).",
            "VernacAssumption",
            "e96fefd9be2e0f7a3715ce60cfe57034ffa01151"
        ],
        [
            "Lemma inserted_ordered x (l: list T): vec.sorted R l -> vec.sorted R (insert x l).",
            "VernacStartTheoremProof",
            "e52265e9b8ec6c22c7c5b6493dda686df00fa880"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "induction l.",
            "VernacExtend",
            "1194af70832939708f8c7fde2f18f81c37b97a0c"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "apply vec.sorted_one.",
            "VernacExtend",
            "29253309cec6006d3bad1fe333887d860aeab18c"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "pose proof (vec.sorted_tail H).",
            "VernacExtend",
            "c91f5b0453858aa399de498867e95d23b275a7dd"
        ],
        [
            "apply IHl in H0.",
            "VernacExtend",
            "323edfafaf2f9bfdda11a897e031ce828d0e2617"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "case_eq (le x a); intro.",
            "VernacExtend",
            "49fff4464e81f055779c5796bd55b94e3e81d2da"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "apply vec.sorted_more...",
            "VernacExtend",
            "d568a863488d0d1c15638eaa94003c03c15b11a8"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "apply vec.sorted_cons'...",
            "VernacExtend",
            "bf5c9c5f38e674fed6cb93aae9b60807a210205d"
        ],
        [
            "pose proof (le_yippee H1).",
            "VernacExtend",
            "04e99767823c7a8cfc7c1503b8462418bb04fcf3"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "rewrite vec.list_round_trip in H3.",
            "VernacExtend",
            "4221129b7586d990f0ed304afb02141cc3f6cda5"
        ],
        [
            "unfold R.",
            "VernacExtend",
            "26834bae8933c0420b69725db02480df48172fd8"
        ],
        [
            "destruct (Permutation_in _ (insert_perm x l) H3).",
            "VernacExtend",
            "b60bf9d1cdc3e2c1bea348b81c9736383ae03e0c"
        ],
        [
            "subst...",
            "VernacExtend",
            "b907a93c53d5c34384373e3aac13eba90f0a4fdc"
        ],
        [
            "simpl in H.",
            "VernacExtend",
            "78dad51b2bb1130f71851d1e55489020824f59f6"
        ],
        [
            "apply (vec.sorted_cons_inv' preorder_R H).",
            "VernacExtend",
            "8ff1f59969c63df0bfb70db999f6a822ff40ca4d"
        ],
        [
            "rewrite vec.list_round_trip...",
            "VernacExtend",
            "f5668f0890211fe3ba70330dd07c3d5d63c2c735"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition isort: list T -> list T := fold_right insert nil.",
            "VernacDefinition",
            "875b55dd0c6a25704e74d756722280b04fdc6812"
        ],
        [
            "Lemma isort_permutes l: Permutation (isort l) l.",
            "VernacStartTheoremProof",
            "06be89097086c85f8edb69e437be26c6d724cfd3"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "induction l...",
            "VernacExtend",
            "a4571710fc634c72b7b07ca630627ad571eee64e"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite IHl.",
            "VernacExtend",
            "d4d0cebbb161cf1462b69fd1ed2d76db253a98c6"
        ],
        [
            "apply insert_perm.",
            "VernacExtend",
            "db7662351caf3dc21a148a7df1536ab36f5b8c75"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Constructors vec.sorted.",
            "VernacHints",
            "80be2c40e4d181d7cc18814df82c9f7bff3346d7"
        ],
        [
            "Lemma isort_sorts l: vec.sorted R (isort l).",
            "VernacStartTheoremProof",
            "6e555337d22cd3b2bcaa1d0b9ced2b3e1ac1f6f0"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "induction l; simpl...",
            "VernacExtend",
            "2b807d50e545b339f4a1eacc1448c456412a54df"
        ],
        [
            "apply inserted_ordered...",
            "VernacExtend",
            "6bde93e6a9f6347b8dec02df837661d6571d8f2a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma isort_sorts' (U: relation T): (forall x y, le x y = true -> U x y) -> forall l, vec.sorted U (isort l).",
            "VernacStartTheoremProof",
            "cd9172dbab3ab4e00f218f7d371b1a44c0c018d9"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "apply (vec_sorted_impl _ H).",
            "VernacExtend",
            "73e7335574ebb714a93ee87536aa4ebdd092dd5e"
        ],
        [
            "apply isort_sorts.",
            "VernacExtend",
            "06cae7a63c12e41ec69ef313032b138d54f0feed"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End plain.",
            "VernacEndSegment",
            "e3426a6ba67c24b64ea2ad3c9fe6310df62cf448"
        ],
        [
            "End plain.",
            "VernacEndSegment",
            "e3426a6ba67c24b64ea2ad3c9fe6310df62cf448"
        ],
        [
            "Module pairs.",
            "VernacDefineModule",
            "8005664b8acd1e210aaa82db9a898be29e99bafe"
        ],
        [
            "Section pairs.",
            "VernacBeginSection",
            "082e1e66ca0f5c84d2628bce1b9fa471babbd02a"
        ],
        [
            "Variables (T: Set) (le: T -> T -> bool).",
            "VernacAssumption",
            "f931f0d19814bf26daf5e84c3a2348d8c9d82373"
        ],
        [
            "Fixpoint insert (l: list T) (x: T) {struct l}: nat * list T := match l with | nil => (0, x :: nil) | h :: t => if le x h then (1, x :: h :: t) else let (n, t') := insert t x in (S n, h :: t') end.",
            "VernacFixpoint",
            "76f4d17f81585d2d27c1955d327a1043b3b6c31e"
        ],
        [
            "Fixpoint insert_many (l l': list T) {struct l'}: nat * list T := match l' with | nil => (0, l) | h :: t => let (n, u) := insert l h in let (m, v) := insert_many u t in (n + m, v) end.",
            "VernacFixpoint",
            "82b92e19130dfdf7de102e4740a558acf9282ebc"
        ],
        [
            "Definition isort: list T -> (nat * list T) := insert_many nil.",
            "VernacDefinition",
            "b210ddfc2719834cf73151664662b4a0ba4a25b8"
        ],
        [
            "End pairs.",
            "VernacEndSegment",
            "af47a802285c3b1db71efc255f61534e842fea93"
        ],
        [
            "End pairs.",
            "VernacEndSegment",
            "af47a802285c3b1db71efc255f61534e842fea93"
        ],
        [
            "Eval compute in (pairs.isort leb numbers).",
            "VernacCheckMayEval",
            "411d01a6dc05056bf37392f4604d785ca47143f0"
        ],
        [
            "Module monadic.",
            "VernacDefineModule",
            "b8aa56d79f1aee31eb2abfa8d7494fbd6fe4b5c0"
        ],
        [
            "Section monadic.",
            "VernacBeginSection",
            "03613873eebdbafa366c7072ac07abd5be15210b"
        ],
        [
            "Variables (M: Monad) (T: Set) (le: T -> T -> M bool).",
            "VernacAssumption",
            "ce6e358de22ae4782a8311f34141567445d63300"
        ],
        [
            "Fixpoint insert (l: list T) (x: T): M (list T) := match l with | nil => ret (x :: nil) | h :: t => r <- le x h ; if r then ret (x :: h :: t) else t' <- insert t x ; ret (h :: t') end.",
            "VernacFixpoint",
            "72e7ef3ed33e6dc82298517e9bb557f1d8d0c9da"
        ],
        [
            "Lemma insert_unfold: forall l x, insert l x = match l with | nil => ret (x :: nil) | h :: t => r <- le x h ; if r then ret (x :: h :: t) else t' <- insert t x ; ret (h :: t') end.",
            "VernacStartTheoremProof",
            "4a68358a5896ab873e02fca682be0780e08f35c2"
        ],
        [
            "destruct l; auto.",
            "VernacExtend",
            "4bfcd2f625a7deb5fd623e7d5faa40328d66978c"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition isort: list T -> M (list T) := foldlM insert nil.",
            "VernacDefinition",
            "d0ddf05d25883d9cf66d1c318a30304ac34c2156"
        ],
        [
            "Hypothesis run: forall U, M U -> U.",
            "VernacAssumption",
            "5836e95de24f46429c1783f4213537855541ed6d"
        ],
        [
            "Arguments run [U].",
            "VernacArguments",
            "406c1ea84ec353f71eca1ad08ac6491e6caa2bc2"
        ],
        [
            "Hypothesis run_ret: forall (U: Set) (x: U), run (ret x) = x.",
            "VernacAssumption",
            "bf5c6824334b149e4f036d5137f31f50b1328661"
        ],
        [
            "Hypothesis run_bind: forall (A B: Set) (x: M A) (f: A -> M B), run (x >>= f) = run (f (run x)).",
            "VernacAssumption",
            "0cd7895b0340ba5674130885e8e0746b1d42e6a1"
        ],
        [
            "Lemma insert_length (x: T) (l: list T): length (run (insert l x)) = S (length l).",
            "VernacStartTheoremProof",
            "8a8e1fc1336351ee01007dada1ac458ae9413cbc"
        ],
        [
            "Proof with simpl; auto with arith.",
            "VernacProof",
            "9d60e0ea6236aa34863d2fdae430d1b0ff4aabc6"
        ],
        [
            "induction l...",
            "VernacExtend",
            "a4571710fc634c72b7b07ca630627ad571eee64e"
        ],
        [
            "rewrite run_ret...",
            "VernacExtend",
            "3fc7f13089821758538936d1814e6d837ce2e270"
        ],
        [
            "rewrite run_bind.",
            "VernacExtend",
            "84864b808a7d5335c1c4ca69aed358ee38f0199a"
        ],
        [
            "destruct (run (U:=bool) (le x a)).",
            "VernacExtend",
            "b9ea4f8ebe6383fed951af644693b253968a3c2c"
        ],
        [
            "rewrite run_ret...",
            "VernacExtend",
            "3fc7f13089821758538936d1814e6d837ce2e270"
        ],
        [
            "unfold liftM.",
            "VernacExtend",
            "a89a318cd1052ff1f55240c80be1febc28fbd7cb"
        ],
        [
            "rewrite run_bind.",
            "VernacExtend",
            "84864b808a7d5335c1c4ca69aed358ee38f0199a"
        ],
        [
            "rewrite run_ret...",
            "VernacExtend",
            "3fc7f13089821758538936d1814e6d837ce2e270"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End monadic.",
            "VernacEndSegment",
            "dd43b76fea14c87606ba6843ef9bedb4182aa4e6"
        ],
        [
            "End monadic.",
            "VernacEndSegment",
            "dd43b76fea14c87606ba6843ef9bedb4182aa4e6"
        ],
        [
            "Section quadratic.",
            "VernacBeginSection",
            "0a4334bc5e55c4dfb8e349414038c3c84b2f80f1"
        ],
        [
            "Import monadic.",
            "VernacImport",
            "ad58aa41a8ffc0f54c57ef469700bf4c77071a18"
        ],
        [
            "Definition plain_leb: nat -> nat -> IdMonad.M bool := leb.",
            "VernacDefinition",
            "9bd2d92257c310d75ed6022bff9f121ce43b90db"
        ],
        [
            "Variables (T: Set) (le: T -> T -> bool).",
            "VernacAssumption",
            "f931f0d19814bf26daf5e84c3a2348d8c9d82373"
        ],
        [
            "Definition mle (x y: T): SimplyProfiled bool := (1, le x y).",
            "VernacDefinition",
            "c33abc747a1d5929a86c765906c8c7af6f315aa0"
        ],
        [
            "Lemma insert_cost (l: list T) (x: T): cost (insert _ mle l x) <= length l.",
            "VernacStartTheoremProof",
            "5c067954eb82d33e705f69e05e34d9fbfa9f12e6"
        ],
        [
            "Proof with auto with arith.",
            "VernacProof",
            "007741178d53d6a043487bfdd1e6c77ea6388468"
        ],
        [
            "induction l...",
            "VernacExtend",
            "a4571710fc634c72b7b07ca630627ad571eee64e"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "rewrite insert_unfold, bind_cost.",
            "VernacExtend",
            "daa57b60b49c2c80440f0e5293565cbedc12eac6"
        ],
        [
            "destruct (result (mle x a)).",
            "VernacExtend",
            "f7d705b15a73bc831e99cc2b17f267b795b7af6d"
        ],
        [
            "rewrite return_cost.",
            "VernacExtend",
            "99a6dea5cbffbf63a875c88c3ab98febb5e72de9"
        ],
        [
            "simpl...",
            "VernacExtend",
            "504f71dca671c3e66b68ade966c1b4804373be90"
        ],
        [
            "rewrite bind_cost, return_cost.",
            "VernacExtend",
            "e83a97c439dd47606e1b23a7096b602c2b85eb98"
        ],
        [
            "deep_le_trans IHl...",
            "VernacExtend",
            "6059321d43d19f6a3709e4454556df59b09967b7"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma fold_insert_cost : forall (x y: list T), cost (foldlM (insert _ mle) y x) <= length y * length x + div2 (sqrd (length x)).",
            "VernacStartTheoremProof",
            "21f01b6778add3fc222d837c8f895be399593cea"
        ],
        [
            "Proof with auto with arith; try omega.",
            "VernacProof",
            "8282ebce1ff75a2b639b5ec4ed6f06685669f280"
        ],
        [
            "induction x; intros.",
            "VernacExtend",
            "967005fa252895ab470aa9876d40c37f363bf6d6"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "rename a into h, x into t.",
            "VernacExtend",
            "90b82d3e60d1b2b293acdee5dad4d97bf3931319"
        ],
        [
            "rewrite foldlM_cons.",
            "VernacExtend",
            "c5ec1d611d8a99fcf5c2a493a285e866ea45b1bb"
        ],
        [
            "rewrite bind_cost.",
            "VernacExtend",
            "f634f31fa30e092aecc868ee966f952461cc2184"
        ],
        [
            "deep_le_trans (insert_cost y h)...",
            "VernacExtend",
            "ba95bb420975a15adb70e7d67670ff122dd790ba"
        ],
        [
            "apply plus_le_compat...",
            "VernacExtend",
            "9ec6ccd03ca61f8fdc740cea699e2792ec1e1e2b"
        ],
        [
            "apply insert_cost.",
            "VernacExtend",
            "3d11aac8960c537a98a2f68462c3952b56d15a6d"
        ],
        [
            "deep_le_trans (IHx (result (insert _ mle y h)))...",
            "VernacExtend",
            "624e4ccc154d8706bd3326292a19e717a035003d"
        ],
        [
            "clear IHx.",
            "VernacExtend",
            "73eb5f0fdccfba18131b4157a5900cee360cdf12"
        ],
        [
            "rewrite insert_length...",
            "VernacExtend",
            "b75f7b0e06bcf6bf464a4d692439f9d93b2555db"
        ],
        [
            "simpl @length.",
            "VernacExtend",
            "09d9b17ca9b0c56bd6f6aba8327511f90a40e2c6"
        ],
        [
            "simpl mult.",
            "VernacExtend",
            "2b5fad0c91c51748ff321a6d8943c47fede70597"
        ],
        [
            "rewrite <- mult_n_Sm.",
            "VernacExtend",
            "91735263987da0af733038b963dd5d1f039440a6"
        ],
        [
            "apply le_trans with ((length y * length t + length y) + (length t + div2 (sqrd (length t))))...",
            "VernacExtend",
            "c54a76d0ab7ee103768905836947fca62e900b7d"
        ],
        [
            "apply plus_le_compat_l.",
            "VernacExtend",
            "0b54a9a94d1f4251de3f3aca0ea73ceff51e1f05"
        ],
        [
            "rewrite plus_comm.",
            "VernacExtend",
            "f2921c049c57ff33e3248947a1d6b2bcd1257393"
        ],
        [
            "apply div2_sqrdSn.",
            "VernacExtend",
            "3f92deee1a99bdb4c6139b2ba587d53c3136c61e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem insertion_sort_quadratic: forall (l: list T), cost (isort _ mle l) <= div2 (sqrd (length l)).",
            "VernacStartTheoremProof",
            "b9549c933e03760e5085d0dfbe403e7ccb8db821"
        ],
        [
            "Proof fun l => fold_insert_cost l nil.",
            "VernacExactProof",
            "5c66a8d2c148cb85e0f7f37c82f4fcded1e88963"
        ],
        [
            "End quadratic.",
            "VernacEndSegment",
            "b5eb295d14858d02797fb77d04f135cc1ef76c85"
        ]
    ],
    "proofs": [
        {
            "name": "vec_sorted_impl",
            "line_nb": 26,
            "steps": [
                {
                    "command": [
                        "induction 2; auto.",
                        "VernacExtend",
                        "dcfc52477da5ede37c9d912847b566de0e271512"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "isort_sorts'",
            "line_nb": 87,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "apply (vec_sorted_impl _ H).",
                        "VernacExtend",
                        "73e7335574ebb714a93ee87536aa4ebdd092dd5e"
                    ]
                },
                {
                    "command": [
                        "apply isort_sorts.",
                        "VernacExtend",
                        "06cae7a63c12e41ec69ef313032b138d54f0feed"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "insert_unfold",
            "line_nb": 107,
            "steps": [
                {
                    "command": [
                        "destruct l; auto.",
                        "VernacExtend",
                        "4bfcd2f625a7deb5fd623e7d5faa40328d66978c"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}