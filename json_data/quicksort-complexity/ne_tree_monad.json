{
    "filename": "ne_tree_monad.v",
    "coq_project": "quicksort-complexity",
    "vernac_cmds": [
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Require Import monads.",
            "VernacRequire",
            "5b2fd91685e0255ced6df1c87a652a12b8990a39"
        ],
        [
            "Require ne_tree.",
            "VernacRequire",
            "56a1799f91a38d50e7c9aa278eaa1444ac8d8ba5"
        ],
        [
            "Require Import util.",
            "VernacRequire",
            "4430f87d7649f96d1418f130d57967666d56d84f"
        ],
        [
            "Definition C := ne_tree.T.",
            "VernacDefinition",
            "e745a0d3589783e49bba0ac1ff7739ce78c82756"
        ],
        [
            "Definition ret {A: Set}: A -> C A := @ne_tree.Leaf A.",
            "VernacDefinition",
            "177577c72920a6e16709d6d509546771f1a19a70"
        ],
        [
            "Fixpoint bind (A B: Set) (m: C A) (k: A -> C B): C B := match m with | ne_tree.Leaf a => k a | ne_tree.Node ts => ne_tree.Node (ne_list.map (fun x => bind x k) ts) end.",
            "VernacFixpoint",
            "ddd4de663e58e54aef1f92fda3b6ae83336b5b4c"
        ],
        [
            "Let runit (a b: Set) (x: a) (f: a -> C b): bind (ret x) f = f x.",
            "VernacDefinition",
            "fba83323e0b6ae3af27c8910509f7affa356c0e2"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint lunit A (f: C A) {struct f}: bind f ret = f := match f return bind f ret = f with | ne_tree.Leaf x => refl_equal | ne_tree.Node l => eq_ind_r (fun l0 => ne_tree.Node l0 = ne_tree.Node l) refl_equal ((fix F (l: ne_list.L (C A)) := match l return ne_list.map (fun u => bind u ret) l = l with | ne_list.one x => eq_ind_r (fun c => ne_list.one c = ne_list.one x) refl_equal (lunit x) | ne_list.cons x y => eq_ind_r (fun c => ne_list.cons c (ne_list.map (fun x => bind x ret) y) = ne_list.cons x y) (eq_ind_r (fun l => ne_list.cons x l = ne_list.cons x y) refl_equal (F y)) (lunit x) end) l) end.",
            "VernacFixpoint",
            "cf28bfcf26cd561b6cfdb77342996197ec55cdec"
        ],
        [
            "Let assoc (a b c: Set) (n: C a) (f: a -> C b) (g: b -> C c): bind (bind n f) g = bind n (fun x: a => bind (f x) g).",
            "VernacDefinition",
            "7066a4518174ff3cb94902a927f946d6ec08c9aa"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "generalize n.",
            "VernacExtend",
            "f8d8bfcf7c72416f0ee92afcd800785b635aabcd"
        ],
        [
            "clear n.",
            "VernacExtend",
            "950078f0511238b7bf11b5533c9ffd133a02ab04"
        ],
        [
            "apply (ne_tree.alt_rect2 (fun n => bind (bind n f) g = bind n (fun x: a => bind (f x) g)) (fun l => ne_list.map (fun x => bind (bind x f) g) l = ne_list.map (fun x => bind x (fun x0 => bind (f x0) g)) l)); intros; simpl...",
            "VernacExtend",
            "e67d0f84e64f1eb976571c5dfccb7a241ae0dd4e"
        ],
        [
            "rewrite ne_list.map_map.",
            "VernacExtend",
            "ddf48628e25707617d370af1fe670083651e7a84"
        ],
        [
            "unfold compose.",
            "VernacExtend",
            "d80e23bf133762584228beafbd8610d99d5d02d5"
        ],
        [
            "rewrite H...",
            "VernacExtend",
            "2ded38871f6ef5ae4e687aa3245494ae541f7202"
        ],
        [
            "rewrite H...",
            "VernacExtend",
            "2ded38871f6ef5ae4e687aa3245494ae541f7202"
        ],
        [
            "rewrite H.",
            "VernacExtend",
            "6192df8b89486a3ba89a78e26e0d70cae2dc94c2"
        ],
        [
            "rewrite H0...",
            "VernacExtend",
            "50fce2eb274e9c787791aa79cecdd73ad9f1e643"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition M: Monad := Build_Monad C bind (@ret) runit lunit assoc.",
            "VernacDefinition",
            "977e791d7340362c8da78456a902e7ab18d202cb"
        ],
        [
            "Lemma ext: extMonad M.",
            "VernacStartTheoremProof",
            "85b265541c0416066dd064029e82100114d16e58"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "unfold extMonad.",
            "VernacExtend",
            "c5f1847dfcc529ae2d71ad2e269fdf47d1ef963b"
        ],
        [
            "induction x using ne_tree.alt_ind; simpl...",
            "VernacExtend",
            "2023fb0c8271cd94350032fc4703af5bd2230552"
        ],
        [
            "replace (ne_list.map (fun x: C A => bind x f) l) with (ne_list.map (fun x: C A => bind x g) l)...",
            "VernacExtend",
            "dc6d829de9afb2c4e7fb835f8573c3192e5c243e"
        ],
        [
            "generalize H0.",
            "VernacExtend",
            "83d8c9bf832ff69c91cc4428b24355f2bade716e"
        ],
        [
            "clear H0.",
            "VernacExtend",
            "fe72360cf92275fb4ba47f89dfeb905e6d21c4a9"
        ],
        [
            "induction l; simpl; intros; rewrite H0...",
            "VernacExtend",
            "0fc973d7acb636cc71aa924104a16822b10a46ee"
        ],
        [
            "rewrite IHl...",
            "VernacExtend",
            "a48c59a0d042c7310da6766246ef180a091c8386"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bind_Leaf (A B: Set) (x: A) (f: A -> M B): bind (ne_tree.Leaf x) f = f x.",
            "VernacStartTheoremProof",
            "dbb520741cd193459c6254b65341a3f67c2e328c"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bind_Node (A B: Set) (x: ne_list.L (ne_tree.T A)) (f: A -> M B): bind (ne_tree.Node x) f = ne_tree.Node (ne_list.map (fun x0: C A => bind x0 f) x).",
            "VernacStartTheoremProof",
            "ec7a47baf768bf29dc17459099661b73826d75e4"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bind_Node_one (X Y: Set) (t: M X) (g: X -> M Y): bind (ne_tree.Node (ne_list.one t)) g = ne_tree.Node (ne_list.one (t >>= g)).",
            "VernacStartTheoremProof",
            "3d489d4d496127dc1dcc337d6522a40a617b890a"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bind_Node_cons (X Y: Set) (t: M X) (l: ne_list.L (M X)) (g: X -> M Y): bind (ne_tree.Node (ne_list.cons t l)) g = ne_tree.Node (ne_list.cons (bind t g) (ne_list.map (fun x => bind x g) l)).",
            "VernacStartTheoremProof",
            "5bac1e647731453adb2e57646900225c5fa6a347"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bind_map (X Y: Set) (f: X -> Y) (x: M X): bind x (ret \u2218 f) = ne_tree.map f x.",
            "VernacStartTheoremProof",
            "65dba895a32c3c9d5a2bbd3696a88a5f3c0d2f7e"
        ],
        [
            "Proof with try reflexivity.",
            "VernacProof",
            "befb56c00cf46fe151a7e47055cee5e4b8abae25"
        ],
        [
            "induction x...",
            "VernacExtend",
            "32a9acd062d9403b496a2f40e432d3e2b104f8c0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite IHx...",
            "VernacExtend",
            "85e4bc430284c663f9c1b88d21e9d1881d6c3435"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite IHx.",
            "VernacExtend",
            "357385fc8aa6d86ac175f8be191ce152840328d1"
        ],
        [
            "f_equal.",
            "VernacExtend",
            "dfce814d1efcef60f8330516ad88155a3a5ec317"
        ],
        [
            "simpl in IHx0.",
            "VernacExtend",
            "869c9f45962dc365e8d5a5f956d06d516c34bf90"
        ],
        [
            "inversion_clear IHx0...",
            "VernacExtend",
            "0a28ee41c4e5315f2eb34b2f99a3921253d65744"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition deterministic (X: Set) (x: M X) (v: X): Prop := x = ne_tree.Leaf v.",
            "VernacDefinition",
            "2e6f5543c970b2c8a788dee32069651a795920c9"
        ],
        [
            "Lemma deterministic_ret (A: Set) (a: A): deterministic (ret a) a.",
            "VernacStartTheoremProof",
            "7304f4f8937c3d18d56c218f07ba8f47e027be6c"
        ],
        [
            "unfold deterministic.",
            "VernacExtend",
            "aa0674cd222a97a294a35b326bf362a1118ad7cd"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ex_deterministic_ret (X: Set) (x: X): exists u, deterministic (ret x) u.",
            "VernacStartTheoremProof",
            "b7f7038cb3309c6f371c83c95edb2ae1181c6ef1"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "exists x.",
            "VernacExtend",
            "800bf7613c74a608ff1ecae6bb20d349d4e8f84d"
        ],
        [
            "apply deterministic_ret.",
            "VernacExtend",
            "c5121d0c5d8a98c1b9fa73b2349581a01410d768"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma deterministic_bind: forall (A: Set) (a: M A) (z: A), deterministic a z -> forall (B: Set) (b: A -> M B) (v: B), deterministic (b z) v -> exists w, deterministic (a >>= b) w.",
            "VernacStartTheoremProof",
            "74855948f41f95e535062000c247971f5185e915"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "unfold deterministic.",
            "VernacExtend",
            "aa0674cd222a97a294a35b326bf362a1118ad7cd"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "exists v...",
            "VernacExtend",
            "b763ddbf91d4f645bb81ef0b5227ace2875f6c60"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma deterministic_bind_weak: forall (A: Set) (a: M A) (z: A), deterministic a z -> forall (B: Set) (b: A -> M B), (forall q, exists v, deterministic (b q) v) -> exists w, deterministic (a >>= b) w.",
            "VernacStartTheoremProof",
            "8bdebca43d6eb2cdb81b1c85dd5bfe093741530b"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct (H0 z).",
            "VernacExtend",
            "7c4571fda3892c1e550427f4672eca07c8ffcc41"
        ],
        [
            "apply (deterministic_bind H _ H1).",
            "VernacExtend",
            "827bff7f0fa41ea0c79d02151f9839bea81e3da0"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ex_deterministic_bind: forall (A: Set) (a: M A) (z: A), deterministic a z -> forall (B: Set) (b: A -> M B), (exists v, deterministic (b z) v) -> exists w, deterministic (a >>= b) w.",
            "VernacStartTheoremProof",
            "1cf5c631f86becbe86a8acca3dca0b680b26565c"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct H0.",
            "VernacExtend",
            "5c8f6cb3dc303d56935d6ec271a1de04f6790225"
        ],
        [
            "apply (deterministic_bind H _ H0).",
            "VernacExtend",
            "c628d1ac0fda6435b832cb550f9445dc9f60b40d"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ex_deterministic_bind_weak: forall (A: Set) (a: M A) (z: A), deterministic a z -> forall (B: Set) (b: A -> M B), (forall q, exists v, deterministic (b q) v) -> exists w, deterministic (a >>= b) w.",
            "VernacStartTheoremProof",
            "8407e11a8416d300a72156b795e17c719699a869"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "apply (deterministic_bind_weak H).",
            "VernacExtend",
            "c667eb85c260913f1dc53dfc108d6789afc114c8"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition pick T: ne_list.L T -> M T := @ne_tree.Node T \u2218 ne_list.map (@ne_tree.Leaf T).",
            "VernacDefinition",
            "32506a59ae964556c500c242ba9892b99c70bdc7"
        ],
        [
            "Lemma In_bind_inv (X Y: Set) (f: X -> M Y) (x: M X) r: ne_tree.In r (bind x f) -> exists z, ne_tree.In z x /\\ ne_tree.In r (f z).",
            "VernacStartTheoremProof",
            "d203a0f2bd70d78ac3d1dc920b76ed9b44ec814e"
        ],
        [
            "Proof with eauto.",
            "VernacProof",
            "12721c224a5e1fa232c2328aabfe1f5101d235c4"
        ],
        [
            "induction x in r |- *...",
            "VernacExtend",
            "a406ad2188281670f6014490e19fbfc4349949b7"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inversion_clear H.",
            "VernacExtend",
            "90909d92eb32e95a21a5b90b29a49dc97bcea342"
        ],
        [
            "inversion_clear H0.",
            "VernacExtend",
            "e21f851b9423020c7f22dae666bca7829c9b1967"
        ],
        [
            "destruct (IHx r H).",
            "VernacExtend",
            "e079ab46681d0a1e123e584fd00aea39ea8148a4"
        ],
        [
            "destruct H0...",
            "VernacExtend",
            "13ba29ac2320e3d9930fee330fd500bf0e67ba1e"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inversion_clear H.",
            "VernacExtend",
            "90909d92eb32e95a21a5b90b29a49dc97bcea342"
        ],
        [
            "inversion_clear H0.",
            "VernacExtend",
            "e21f851b9423020c7f22dae666bca7829c9b1967"
        ],
        [
            "destruct (IHx r H).",
            "VernacExtend",
            "e079ab46681d0a1e123e584fd00aea39ea8148a4"
        ],
        [
            "destruct H0...",
            "VernacExtend",
            "13ba29ac2320e3d9930fee330fd500bf0e67ba1e"
        ],
        [
            "destruct (IHx0 r (ne_tree.InNode H)).",
            "VernacExtend",
            "737bc8418e934b6d915e7a6ab9237f30a4256053"
        ],
        [
            "destruct H0.",
            "VernacExtend",
            "5c8f6cb3dc303d56935d6ec271a1de04f6790225"
        ],
        [
            "inversion_clear H0...",
            "VernacExtend",
            "b903ed9556822431d6a4482f1b3e8ca20896fdd5"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma bind_eq (X X' Y XM: Set) (f: X -> M Y) (f': X' -> M Y) (xm: X -> XM) (xm': X' -> XM): (forall p q, xm p = xm' q -> f p = f' q) -> forall (x: M X) (x': M X'), ne_tree.map xm x = ne_tree.map xm' x' -> bind x f = bind x' f'.",
            "VernacStartTheoremProof",
            "78c5c94f921761f796c28f545ce6b8f8a64ed404"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "induction x; simpl; destruct x'; simpl; intros; try discriminate.",
            "VernacExtend",
            "54514f5334ad8bf3b527aa07008d50ccf20dbe64"
        ],
        [
            "apply H.",
            "VernacExtend",
            "4b47b71ad0f800d57cbdc591d68949e07decb540"
        ],
        [
            "inversion_clear H0...",
            "VernacExtend",
            "b903ed9556822431d6a4482f1b3e8ca20896fdd5"
        ],
        [
            "destruct l; simpl; intros.",
            "VernacExtend",
            "3ecc8e1be5fd405ad86d1fa53a0f77c94174a2f1"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "rewrite (IHx t)...",
            "VernacExtend",
            "218277632100c694271489229e6861d984ecd14e"
        ],
        [
            "inversion_clear H0...",
            "VernacExtend",
            "b903ed9556822431d6a4482f1b3e8ca20896fdd5"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "destruct l0.",
            "VernacExtend",
            "eea6b04db7e7ceacf561786bb347340519f1ca47"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "simpl in H0.",
            "VernacExtend",
            "a4a6a8421870dbf7255f8d031744eec32f12a941"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "inversion H0.",
            "VernacExtend",
            "38a13882efcff2ae2c6c07fc8055d56c6c1776f2"
        ],
        [
            "clear H0.",
            "VernacExtend",
            "fe72360cf92275fb4ba47f89dfeb905e6d21c4a9"
        ],
        [
            "f_equal.",
            "VernacExtend",
            "dfce814d1efcef60f8330516ad88155a3a5ec317"
        ],
        [
            "replace (bind x f) with (bind t f').",
            "VernacExtend",
            "46ebe0bcbbcdb855ca5435b768cf8d1cc889451b"
        ],
        [
            "Focus 2.",
            "VernacFocus",
            "485d4f15aaf5c71ed130bd270976f9fc4e12a61f"
        ],
        [
            "symmetry.",
            "VernacExtend",
            "a08fc0dc04bba893008bded8181f393e2d8db167"
        ],
        [
            "apply IHx...",
            "VernacExtend",
            "504b427692920907a56f1ba4e3a72134350faedf"
        ],
        [
            "replace (ne_list.map (fun x0: C X => bind x0 f) l) with (ne_list.map (fun x0: C X' => bind x0 f') l0)...",
            "VernacExtend",
            "bf595eddcfaeb7e98fc1a2f1bf5ef79b77f1ed6f"
        ],
        [
            "assert (ne_tree.map xm (ne_tree.Node l) = ne_tree.map xm' (ne_tree.Node l0)).",
            "VernacExtend",
            "ec109e47ea8029648d5f44b6f52d62a7e84c0d92"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite H3...",
            "VernacExtend",
            "d8b9aa66d5cb0705ee0fda995c1a8964f828c656"
        ],
        [
            "cset (IHx0 (ne_tree.Node l0) H0).",
            "VernacExtend",
            "a8c5d37630aa1517a71d20b5051c0cd6b53d3ea9"
        ],
        [
            "inversion_clear H1...",
            "VernacExtend",
            "daf2ba2f42c9f4b484982f30e63b9e05659d2b99"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma map_bind (X Y Z: Set) (f: Y -> Z) (g: X -> M Y) (x: M X): ne_tree.map f (bind x g) = bind x (fun xx => ne_tree.map f (g xx)).",
            "VernacStartTheoremProof",
            "910bf9d4499982de0f84b836d0917819ca012d2b"
        ],
        [
            "Proof with auto.",
            "VernacProof",
            "a7e71b78b5628467da426641e148a0229b525f22"
        ],
        [
            "induction x...",
            "VernacExtend",
            "32a9acd062d9403b496a2f40e432d3e2b104f8c0"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite IHx...",
            "VernacExtend",
            "85e4bc430284c663f9c1b88d21e9d1881d6c3435"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite IHx.",
            "VernacExtend",
            "357385fc8aa6d86ac175f8be191ce152840328d1"
        ],
        [
            "f_equal.",
            "VernacExtend",
            "dfce814d1efcef60f8330516ad88155a3a5ec317"
        ],
        [
            "simpl in IHx0.",
            "VernacExtend",
            "869c9f45962dc365e8d5a5f956d06d516c34bf90"
        ],
        [
            "inversion IHx0...",
            "VernacExtend",
            "e422a637e19566dd7a3fbed574aaa81f49afd829"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Coercion ne_tree_isa_monad (A: Set) (a: ne_tree.T A): M A := a.",
            "VernacDefinition",
            "39df78017fac4a3f18008610fb654913f221b96e"
        ]
    ],
    "proofs": [
        {
            "name": "runit",
            "line_nb": 7,
            "steps": [
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bind_Leaf",
            "line_nb": 35,
            "steps": [
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bind_Node",
            "line_nb": 38,
            "steps": [
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bind_Node_one",
            "line_nb": 41,
            "steps": [
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bind_Node_cons",
            "line_nb": 44,
            "steps": [
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "deterministic_ret",
            "line_nb": 59,
            "steps": [
                {
                    "command": [
                        "unfold deterministic.",
                        "VernacExtend",
                        "aa0674cd222a97a294a35b326bf362a1118ad7cd"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ex_deterministic_ret",
            "line_nb": 63,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "exists x.",
                        "VernacExtend",
                        "800bf7613c74a608ff1ecae6bb20d349d4e8f84d"
                    ]
                },
                {
                    "command": [
                        "apply deterministic_ret.",
                        "VernacExtend",
                        "c5121d0c5d8a98c1b9fa73b2349581a01410d768"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ex_deterministic_bind",
            "line_nb": 82,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "destruct H0.",
                        "VernacExtend",
                        "5c8f6cb3dc303d56935d6ec271a1de04f6790225"
                    ]
                },
                {
                    "command": [
                        "apply (deterministic_bind H _ H0).",
                        "VernacExtend",
                        "c628d1ac0fda6435b832cb550f9445dc9f60b40d"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ex_deterministic_bind_weak",
            "line_nb": 87,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "apply (deterministic_bind_weak H).",
                        "VernacExtend",
                        "c667eb85c260913f1dc53dfc108d6789afc114c8"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}