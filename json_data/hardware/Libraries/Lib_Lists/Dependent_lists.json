{
    "filename": "Libraries/Lib_Lists/Dependent_lists.v",
    "coq_project": "hardware",
    "vernac_cmds": [
        [
            "Require Export Eqdep.",
            "VernacRequire",
            "67648e49dd59b7f0c6cd90270b4e7a5075965f99"
        ],
        [
            "Require Export Arith.",
            "VernacRequire",
            "70e550b9603a7aa23f63274fffcc443ce7c8f433"
        ],
        [
            "Global Set Asymmetric Patterns.",
            "VernacSetOption",
            "2cc91d0a437fbd1f49bf43960caf4a2b10040c6b"
        ],
        [
            "Section Dependent_lists.",
            "VernacBeginSection",
            "725b4d94aa20d2d337593246d343491cc7c65763"
        ],
        [
            "Variable A : Set.",
            "VernacAssumption",
            "913b2bc4093d15ed267c28d55b4536b83f6168df"
        ],
        [
            "Inductive list : nat -> Set := | nil : list 0 | cons : forall n : nat, A -> list n -> list (S n).",
            "VernacInductive",
            "0fdf9a4936a7a528a66ce967a58c70da1333b3a1"
        ],
        [
            "Definition eq_list := eq_dep nat list.",
            "VernacDefinition",
            "1d78663425a42601df4a5992f1fbc74c0fba61a7"
        ],
        [
            "Definition hd (n : nat) (l : list n) : Exc A := match l in (list m) return (Exc A) with | nil => error | cons p a l' => value a end.",
            "VernacDefinition",
            "9702f705110086c04647eeb4dbedd811044fa9ab"
        ],
        [
            "Definition head (n : nat) (l : list n) := match l in (list p) return (0 < p -> A) with | nil => fun h : 0 < 0 => False_rec A (lt_irrefl 0 h) | cons p a l' => fun h : 0 < S p => a end.",
            "VernacDefinition",
            "f9d08078886a56b6ee8d040d5a7d36384a02b8d1"
        ],
        [
            "Definition Head (n : nat) (l : list (S n)) := head (S n) l (lt_O_Sn n).",
            "VernacDefinition",
            "1862109cff7b3485229d6cf89cf554c89be976ae"
        ],
        [
            "Definition tl (n : nat) (l : list n) : list (pred n) := match l in (list m) return (list (pred m)) with | nil => nil | cons p a l' => l' end.",
            "VernacDefinition",
            "1a88459a8bfc84ebc7b6f8a208cf2a321705024d"
        ],
        [
            "Lemma empty_dep : forall (n : nat) (l : list n), n = 0 -> eq_list 0 nil n l.",
            "VernacStartTheoremProof",
            "a25a3cb4b25c890770415232bb7b937d7cdca0c7"
        ],
        [
            "unfold eq_list in |- *; intros n l.",
            "VernacExtend",
            "86253ea2236f6ec0953693a645ffcdf8d937e7a4"
        ],
        [
            "dependent inversion_clear l; auto.",
            "VernacExtend",
            "30760761dc8a65cdf1c3ad986815bf90b5084a6b"
        ],
        [
            "intros H; absurd (S n0 = 0); auto.",
            "VernacExtend",
            "acc9ccdb450906e77dcfc945005a3261ff378ef3"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Resolve empty_dep.",
            "VernacHints",
            "429761228e909dccad108a1eff5409f4176bb2f7"
        ],
        [
            "Lemma empty : forall l : list 0, nil = l.",
            "VernacStartTheoremProof",
            "0487dba70396e7c85bdd81e9fd74406b23b3025d"
        ],
        [
            "intros l.",
            "VernacExtend",
            "dd0961f3ab7d1ab267b93180e66e020db2e681bc"
        ],
        [
            "apply (eq_dep_eq nat list 0).",
            "VernacExtend",
            "b9c5c5c57aa90b845ab478329071be2beb42a300"
        ],
        [
            "apply empty_dep; auto.",
            "VernacExtend",
            "9ad39487bd737f2f36a050cc99a40c75f0768b83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Resolve empty.",
            "VernacHints",
            "1954aef2a10ca2aed77ea499bd8783e4579ae886"
        ],
        [
            "Remark non_empty_dep : forall n m : nat, m = S n -> forall l : list (S n), {h : A & {t : list n | eq_list (S n) l (S n) (cons n h t)}}.",
            "VernacStartTheoremProof",
            "309be6ec664b350e4016e15f71a83188508cfe0d"
        ],
        [
            "intros n m H l.",
            "VernacExtend",
            "ecf00e466b51f791b188fb4b63705bbba9b6eaf8"
        ],
        [
            "generalize H; clear H.",
            "VernacExtend",
            "11a8e8bdae40bbaf90ad63809f486c3fcb4cd3a4"
        ],
        [
            "dependent inversion_clear l with (fun (n' : nat) (l : list n') => m = n' -> {a : A & {l' : list n | eq_list n' l (S n) (cons n a l')}}).",
            "VernacExtend",
            "f605db8897890bd7c3f306c41f71c687c6861197"
        ],
        [
            "unfold eq_list in |- *.",
            "VernacExtend",
            "89a43ca7590429e726d5017747e7ff589d6f7c62"
        ],
        [
            "intros H; exists a; exists l0; auto.",
            "VernacExtend",
            "8d3487e72d97d10b4db47c1b6b9fa1cce3414854"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma non_empty : forall (n : nat) (l : list (S n)), {a : A & {t : list n | l = cons n a t}}.",
            "VernacStartTheoremProof",
            "42290bf41256b0c7116d0f881af821cae14ff43d"
        ],
        [
            "intros n l.",
            "VernacExtend",
            "d15a0b6304d5de3931ed94d7fd1378867aca9f17"
        ],
        [
            "cut (sigS (fun a : A => sig (fun t : list n => eq_list (S n) l (S n) (cons n a t)))).",
            "VernacExtend",
            "96bd8e13c6f82aa24f9aad29038969c6b77bc1f6"
        ],
        [
            "intros H; elim H; clear H.",
            "VernacExtend",
            "206e34524188577501b7b0745aee08d01aeed82c"
        ],
        [
            "intros a H; elim H; clear H.",
            "VernacExtend",
            "b1eb2b4e37eae92e1edc2c5564e9301d849de4cc"
        ],
        [
            "intros t H.",
            "VernacExtend",
            "475698d739ae2eaf1c0e4f992363cb01cfb29b5b"
        ],
        [
            "exists a; exists t.",
            "VernacExtend",
            "bfdebdbb0de4881ca06253ac1e178b09fb0c67df"
        ],
        [
            "apply eq_dep_eq with (U := nat) (P := list) (p := S n).",
            "VernacExtend",
            "28bd524a24efc1de4d8efd15657a1d0a9e503b9c"
        ],
        [
            "unfold eq_list in H; auto.",
            "VernacExtend",
            "a3b2645d15984159789acea36df78f44a364b2ba"
        ],
        [
            "apply (non_empty_dep n (S n)); auto.",
            "VernacExtend",
            "d00fb71e5e34038e47655b1e524336e90e011b60"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma split_list : forall (n : nat) (l : list (S n)), l = cons n (head (S n) l (lt_O_Sn n)) (tl (S n) l).",
            "VernacStartTheoremProof",
            "3b18008aa3ec870049dc2d9e548793f77abe7022"
        ],
        [
            "intros n l.",
            "VernacExtend",
            "d15a0b6304d5de3931ed94d7fd1378867aca9f17"
        ],
        [
            "elim (non_empty n l).",
            "VernacExtend",
            "ab769c537561da321fc7d0c4c5fc1e20783c2bea"
        ],
        [
            "intros h H; elim H; clear H.",
            "VernacExtend",
            "74a8d0676abd5e56c233d548e5bacae149b4e5e8"
        ],
        [
            "intros t e.",
            "VernacExtend",
            "5d6b327053e086da25be17d8bca9053af882eba9"
        ],
        [
            "rewrite e; simpl in |- *.",
            "VernacExtend",
            "0d65fe0e1bc02ac9b6ef74dab17b5d7b4dc535e9"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition Hd (n : nat) (l : list (S n)) := let (a, P) return A := non_empty n l in a.",
            "VernacDefinition",
            "55b77304344d38acd5a05c74b1ee4a09b5424943"
        ],
        [
            "Lemma Non_empty_Hd : forall (n : nat) (a : A) (l : list n), Hd n (cons n a l) = a.",
            "VernacStartTheoremProof",
            "171b9fb778d2e8f27786c1b936c9ca2c446f6f69"
        ],
        [
            "intros n a l; unfold Hd in |- *.",
            "VernacExtend",
            "2ae59508b99bf339cb89dc0ef6ec9b149868158a"
        ],
        [
            "elim (non_empty n (cons n a l)).",
            "VernacExtend",
            "997fa47fa634d8eb4d83dcb4fc2fe535c0e05969"
        ],
        [
            "intros x H; elim H.",
            "VernacExtend",
            "590ba31f92bd794a79e8f6e59a09ec390c53d4ee"
        ],
        [
            "clear H; intros X H.",
            "VernacExtend",
            "67eaf9dc5ede9b0da267c9f6c96342de248242f4"
        ],
        [
            "injection H; auto.",
            "VernacExtend",
            "98b10cc71270f203eeea844ff97dc3dbc3665ef4"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Dependent_lists.",
            "VernacEndSegment",
            "9464c53bdef016b1ca376bd8392e01a3e4af43a1"
        ],
        [
            "Hint Resolve empty_dep empty non_empty Non_empty_Hd.",
            "VernacHints",
            "de641ed49a79adbdc326849536673703ef3e8e43"
        ],
        [
            "Fixpoint map (A B : Set) (f : A -> B) (n : nat) (l : list A n) {struct l} : list B n := match l in (list _ x) return (list B x) with | nil => nil B | cons p a t => cons B p (f a) (map A B f p t) end.",
            "VernacFixpoint",
            "3f1e905c3c822506721468ecb4ffafcd50f90a25"
        ]
    ],
    "proofs": [
        {
            "name": "empty_dep",
            "line_nb": 11,
            "steps": [
                {
                    "command": [
                        "unfold eq_list in |- *; intros n l.",
                        "VernacExtend",
                        "86253ea2236f6ec0953693a645ffcdf8d937e7a4"
                    ]
                },
                {
                    "command": [
                        "dependent inversion_clear l; auto.",
                        "VernacExtend",
                        "30760761dc8a65cdf1c3ad986815bf90b5084a6b"
                    ]
                },
                {
                    "command": [
                        "intros H; absurd (S n0 = 0); auto.",
                        "VernacExtend",
                        "acc9ccdb450906e77dcfc945005a3261ff378ef3"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "empty",
            "line_nb": 17,
            "steps": [
                {
                    "command": [
                        "intros l.",
                        "VernacExtend",
                        "dd0961f3ab7d1ab267b93180e66e020db2e681bc"
                    ]
                },
                {
                    "command": [
                        "apply (eq_dep_eq nat list 0).",
                        "VernacExtend",
                        "b9c5c5c57aa90b845ab478329071be2beb42a300"
                    ]
                },
                {
                    "command": [
                        "apply empty_dep; auto.",
                        "VernacExtend",
                        "9ad39487bd737f2f36a050cc99a40c75f0768b83"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "non_empty_dep",
            "line_nb": 23,
            "steps": [
                {
                    "command": [
                        "intros n m H l.",
                        "VernacExtend",
                        "ecf00e466b51f791b188fb4b63705bbba9b6eaf8"
                    ]
                },
                {
                    "command": [
                        "generalize H; clear H.",
                        "VernacExtend",
                        "11a8e8bdae40bbaf90ad63809f486c3fcb4cd3a4"
                    ]
                },
                {
                    "command": [
                        "dependent inversion_clear l with (fun (n' : nat) (l : list n') => m = n' -> {a : A & {l' : list n | eq_list n' l (S n) (cons n a l')}}).",
                        "VernacExtend",
                        "f605db8897890bd7c3f306c41f71c687c6861197"
                    ]
                },
                {
                    "command": [
                        "unfold eq_list in |- *.",
                        "VernacExtend",
                        "89a43ca7590429e726d5017747e7ff589d6f7c62"
                    ]
                },
                {
                    "command": [
                        "intros H; exists a; exists l0; auto.",
                        "VernacExtend",
                        "8d3487e72d97d10b4db47c1b6b9fa1cce3414854"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "non_empty",
            "line_nb": 30,
            "steps": [
                {
                    "command": [
                        "intros n l.",
                        "VernacExtend",
                        "d15a0b6304d5de3931ed94d7fd1378867aca9f17"
                    ]
                },
                {
                    "command": [
                        "cut (sigS (fun a : A => sig (fun t : list n => eq_list (S n) l (S n) (cons n a t)))).",
                        "VernacExtend",
                        "96bd8e13c6f82aa24f9aad29038969c6b77bc1f6"
                    ]
                },
                {
                    "command": [
                        "intros H; elim H; clear H.",
                        "VernacExtend",
                        "206e34524188577501b7b0745aee08d01aeed82c"
                    ]
                },
                {
                    "command": [
                        "intros a H; elim H; clear H.",
                        "VernacExtend",
                        "b1eb2b4e37eae92e1edc2c5564e9301d849de4cc"
                    ]
                },
                {
                    "command": [
                        "intros t H.",
                        "VernacExtend",
                        "475698d739ae2eaf1c0e4f992363cb01cfb29b5b"
                    ]
                },
                {
                    "command": [
                        "exists a; exists t.",
                        "VernacExtend",
                        "bfdebdbb0de4881ca06253ac1e178b09fb0c67df"
                    ]
                },
                {
                    "command": [
                        "apply eq_dep_eq with (U := nat) (P := list) (p := S n).",
                        "VernacExtend",
                        "28bd524a24efc1de4d8efd15657a1d0a9e503b9c"
                    ]
                },
                {
                    "command": [
                        "unfold eq_list in H; auto.",
                        "VernacExtend",
                        "a3b2645d15984159789acea36df78f44a364b2ba"
                    ]
                },
                {
                    "command": [
                        "apply (non_empty_dep n (S n)); auto.",
                        "VernacExtend",
                        "d00fb71e5e34038e47655b1e524336e90e011b60"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "split_list",
            "line_nb": 41,
            "steps": [
                {
                    "command": [
                        "intros n l.",
                        "VernacExtend",
                        "d15a0b6304d5de3931ed94d7fd1378867aca9f17"
                    ]
                },
                {
                    "command": [
                        "elim (non_empty n l).",
                        "VernacExtend",
                        "ab769c537561da321fc7d0c4c5fc1e20783c2bea"
                    ]
                },
                {
                    "command": [
                        "intros h H; elim H; clear H.",
                        "VernacExtend",
                        "74a8d0676abd5e56c233d548e5bacae149b4e5e8"
                    ]
                },
                {
                    "command": [
                        "intros t e.",
                        "VernacExtend",
                        "5d6b327053e086da25be17d8bca9053af882eba9"
                    ]
                },
                {
                    "command": [
                        "rewrite e; simpl in |- *.",
                        "VernacExtend",
                        "0d65fe0e1bc02ac9b6ef74dab17b5d7b4dc535e9"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Non_empty_Hd",
            "line_nb": 50,
            "steps": [
                {
                    "command": [
                        "intros n a l; unfold Hd in |- *.",
                        "VernacExtend",
                        "2ae59508b99bf339cb89dc0ef6ec9b149868158a"
                    ]
                },
                {
                    "command": [
                        "elim (non_empty n (cons n a l)).",
                        "VernacExtend",
                        "997fa47fa634d8eb4d83dcb4fc2fe535c0e05969"
                    ]
                },
                {
                    "command": [
                        "intros x H; elim H.",
                        "VernacExtend",
                        "590ba31f92bd794a79e8f6e59a09ec390c53d4ee"
                    ]
                },
                {
                    "command": [
                        "clear H; intros X H.",
                        "VernacExtend",
                        "67eaf9dc5ede9b0da267c9f6c96342de248242f4"
                    ]
                },
                {
                    "command": [
                        "injection H; auto.",
                        "VernacExtend",
                        "98b10cc71270f203eeea844ff97dc3dbc3665ef4"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}