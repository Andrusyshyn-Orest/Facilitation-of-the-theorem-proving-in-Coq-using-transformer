{
    "filename": "TortoiseHareAlgorithm.v",
    "coq_project": "tortoise-hare-algorithm",
    "vernac_cmds": [
        [
            "Require Export Arith.",
            "VernacRequire",
            "70e550b9603a7aa23f63274fffcc443ce7c8f433"
        ],
        [
            "Require Export Omega.",
            "VernacRequire",
            "0481b56b468f7aa7f5517bbdc71f6985bb9f8b59"
        ],
        [
            "Open Scope nat_scope.",
            "VernacOpenCloseScope",
            "22a30e2fa4fb58b685066c0106e0f666475aba7e"
        ],
        [
            "Parameter A : Set.",
            "VernacAssumption",
            "ad49613e3e06a860e67ad90a6908a12f3d1bd21e"
        ],
        [
            "Parameter eq_A_dec : forall (x y:A), {x=y}+{~x=y}.",
            "VernacAssumption",
            "4e385ed01c99dd96f57aeadbffff7b12782ab0e8"
        ],
        [
            "Parameter f : A -> A.",
            "VernacAssumption",
            "0e0c178a64b1f6d984f74b7ef15c6ee8dd5e86c9"
        ],
        [
            "Parameter x0 : A.",
            "VernacAssumption",
            "36313159eb7a1304684c9af95ae196398b409c26"
        ],
        [
            "Fixpoint x (i:nat) { struct i } : A := match i with | O => x0 | S j => f (x j) end.",
            "VernacFixpoint",
            "c1d3b75eb9256cc422087fc04122fb4156647820"
        ],
        [
            "Parameter lambda : nat.",
            "VernacAssumption",
            "c0cd3b1851e5489a7c98363f3f260da3948693e2"
        ],
        [
            "Parameter mu : nat.",
            "VernacAssumption",
            "89371798235f47ad7d3ded7f7316565721d72bdd"
        ],
        [
            "Axiom mu_positive : mu > 0.",
            "VernacAssumption",
            "c185ea9b3cd5ed42508d8da3d4116447849a7a5d"
        ],
        [
            "Axiom lambda_mu : forall i j, x (lambda+i) = x (lambda+i+j*mu).",
            "VernacAssumption",
            "e43b69b08592918705df7649dd12350fc4f45eb8"
        ],
        [
            "Parameter epsilon : (nat -> Prop) -> nat.",
            "VernacAssumption",
            "35408f0ae168bbbda61b7e4dc3fa36d213e62a4e"
        ],
        [
            "Axiom epsilon_spec : forall P, ex P -> P (epsilon P).",
            "VernacAssumption",
            "0d6d1b96fd33ffaa10da9531bdd4560b4d38a2c7"
        ],
        [
            "Definition sep_x2m_xm m i := x (2*m+i) = x m.",
            "VernacDefinition",
            "cc50c89fb413c59e6cc5a532def3cf4f2b7468e0"
        ],
        [
            "Definition min P i := P i /\\ forall j, P j -> i <= j.",
            "VernacDefinition",
            "027b4fe14fb34ca810d14d1476591e43b95ac258"
        ],
        [
            "Definition dist_x2m_xm m := epsilon (min (sep_x2m_xm m)).",
            "VernacDefinition",
            "8be45af8a6a0ec24b6d9ab0372c2f6c1c76d0f16"
        ],
        [
            "Axiom ex_min_P : forall P, (forall x, {P x}+{~(P x)}) -> ex P -> ex (min P).",
            "VernacAssumption",
            "54024d361dd8ae5175e28f3e255717f46429bdbb"
        ],
        [
            "Axiom div : forall a, a > 0 -> forall b, exists k, k*a >= b.",
            "VernacAssumption",
            "7205fb07765e878b43210c76c862fb9ab34ee5be"
        ],
        [
            "Lemma ex_dist_x2m_xm : forall m, lambda <= m -> ex (min (sep_x2m_xm m)).",
            "VernacStartTheoremProof",
            "17461c28e314235459799294851d0af0a17da6c4"
        ],
        [
            "intros m hm; apply ex_min_P.",
            "VernacExtend",
            "c002097606e321d8d1af4f04ae7bd6e870f14895"
        ],
        [
            "intro i; unfold sep_x2m_xm.",
            "VernacExtend",
            "9d296918242e64558369ae3972d3899acd6302e4"
        ],
        [
            "case (eq_A_dec (x (2 * m + i)) (x m)); auto.",
            "VernacExtend",
            "9718a78786c4b8421d3d47e32aff3d14328bb598"
        ],
        [
            "generalize (div mu mu_positive m); intros (k,hk).",
            "VernacExtend",
            "5645b37551d1eb9e32070a7ff084540f0c7c626a"
        ],
        [
            "exists (k*mu - m); unfold sep_x2m_xm.",
            "VernacExtend",
            "a8c184b432be59565dc99dd74846e2bac06db501"
        ],
        [
            "replace (2 * m + (k * mu - m)) with (lambda + (m-lambda)+k*mu) by omega.",
            "VernacExtend",
            "1646f308d4319802aa2cc84f234085e9668738dd"
        ],
        [
            "rewrite <- lambda_mu.",
            "VernacExtend",
            "9192baebc8b30dea5fbc8c2a1215d8dc9a6cca34"
        ],
        [
            "replace (lambda+(m-lambda)) with m by omega; auto.",
            "VernacExtend",
            "e8141861eeb204c0ff3795b9673fb1cb3c75bb40"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition variant m := (lambda - m, dist_x2m_xm m).",
            "VernacDefinition",
            "35e92963e9a5c821c8f6ff75395c8dd34e4733d0"
        ],
        [
            "Definition lex x y := fst x < fst y \\/ (fst x = fst y /\\ snd x < snd y).",
            "VernacDefinition",
            "e3aa8eafe07911693f6839365b6ce48a14db85ca"
        ],
        [
            "Theorem rec_call_is_wf : forall m, x m <> x (2*m) -> lex (variant (S m)) (variant m).",
            "VernacStartTheoremProof",
            "55e033986863ee9fdbd542678349470ef5fe8800"
        ],
        [
            "unfold lex,variant; simpl.",
            "VernacExtend",
            "2a2eeda619feef57d40e5629916b64fc36867a46"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "assert (h: m < lambda \\/ m >= lambda) by omega.",
            "VernacExtend",
            "96aaf0d4503037d191df8832558583e28a3aea22"
        ],
        [
            "destruct h.",
            "VernacExtend",
            "ac5c00ffcee6d385c2dbd6b1548e82bb5791bade"
        ],
        [
            "left; omega.",
            "VernacExtend",
            "9a0d1509b2ddece54a4a5d691f28c3e86f4a5b72"
        ],
        [
            "right.",
            "VernacExtend",
            "27e417a3497755767e1a1d6ba87753ecddaee6b7"
        ],
        [
            "split; auto with *.",
            "VernacExtend",
            "125de5a0d9b9ba53a0994e8692d1e61e02809166"
        ],
        [
            "unfold dist_x2m_xm.",
            "VernacExtend",
            "f49089cead9ec99f20d01bc8e7a446c6387a7156"
        ],
        [
            "assert (exd1: ex (min (sep_x2m_xm (S m)))).",
            "VernacExtend",
            "f9638d7f9c4998b2a105e8b802384ef5be6f25d9"
        ],
        [
            "apply ex_dist_x2m_xm; auto with *.",
            "VernacExtend",
            "9204812529e6c5ee384033e4be49d8087b9174b0"
        ],
        [
            "generalize (epsilon_spec (min (sep_x2m_xm (S m))) exd1).",
            "VernacExtend",
            "19624c9819b3e4aee5caf2d034ccfd1ed53ecd1b"
        ],
        [
            "assert (exd0: ex (min (sep_x2m_xm m))).",
            "VernacExtend",
            "9b440b3e2e5f495983d6ededaf80cb9bcfa53334"
        ],
        [
            "apply ex_dist_x2m_xm; auto with *.",
            "VernacExtend",
            "9204812529e6c5ee384033e4be49d8087b9174b0"
        ],
        [
            "generalize (epsilon_spec (min (sep_x2m_xm m)) exd0).",
            "VernacExtend",
            "db8964b4c68f5692195addcaed32ee2b5af79de0"
        ],
        [
            "generalize (epsilon (min (sep_x2m_xm m))).",
            "VernacExtend",
            "2d46b98ac8f2aeb2e046c274d9cbc791afdd6098"
        ],
        [
            "generalize (epsilon (min (sep_x2m_xm (S m)))).",
            "VernacExtend",
            "68c61b57493328ed8b843567e2a1344e09095190"
        ],
        [
            "intros d1 d0.",
            "VernacExtend",
            "799409eb133411e89e0389cd4327fdee880c5632"
        ],
        [
            "unfold min,sep_x2m_xm.",
            "VernacExtend",
            "59264e10a0a9a18f227019f21f895ae62c3c789e"
        ],
        [
            "intros (h1,h2) (h3,h4).",
            "VernacExtend",
            "50757c2c59a5e1a17def701abb49b3f83b7d2e00"
        ],
        [
            "assert (x (S(2*m+d0)) = x (S m)).",
            "VernacExtend",
            "b8bd5bacddb6486b668b9e92ebdb646bdda0489b"
        ],
        [
            "simpl; simpl in h1; congruence.",
            "VernacExtend",
            "bedeb526d5a6522c87ffee14cab68273e85041db"
        ],
        [
            "assert (d0 > 0).",
            "VernacExtend",
            "7abf263157468b7955f94079007193a1c254414a"
        ],
        [
            "assert (h: d0=0 \\/ d0>0) by omega.",
            "VernacExtend",
            "19a44575beaf35d53f4c7effc116412812b9cc63"
        ],
        [
            "destruct h; auto.",
            "VernacExtend",
            "d9333d26756cde550a54305016aacddfbfcac72f"
        ],
        [
            "subst d0; absurd (x (2*m)=x m); auto.",
            "VernacExtend",
            "2a8616cf728f4c0c61a15e51b99d27dcb5b8cf41"
        ],
        [
            "replace (2*m+0) with (2*m) in h1; auto.",
            "VernacExtend",
            "7c176956af806a2f9b68d1caf4693002aba14999"
        ],
        [
            "assert (d1 <= d0-1).",
            "VernacExtend",
            "e09df25d0b05299dffd434651eaf241e82b13673"
        ],
        [
            "apply h4.",
            "VernacExtend",
            "e09736d38a1c4a8dbd3563a6131b6854c0bf38e7"
        ],
        [
            "replace (2 * (S m) + (d0 - 1)) with (S (2 * m + d0)) by omega.",
            "VernacExtend",
            "f5a4055f7d56e3419c325ea9f409c18d94e53f51"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition R x y := lex (variant x) (variant y).",
            "VernacDefinition",
            "3caa6180fe9943cdae9ad50e29f22e4fbe2f23f8"
        ],
        [
            "Axiom R_wf : well_founded R.",
            "VernacAssumption",
            "4cb86389e1a53c7f283d52005061584f309cbe84"
        ],
        [
            "Definition find_cycle_rec : forall (m:nat) (xm x2m:A), m > 0 -> xm=x m -> x2m=x (2*m) -> { m:nat | m > 0 /\\ x m = x (2*m) }.",
            "VernacDefinition",
            "f6599a25cdf44e4fa682d1408e7246bb2e788e48"
        ],
        [
            "induction m using (well_founded_induction R_wf).",
            "VernacExtend",
            "fc35d316a21250c3f642119d01267bd009c7a1b3"
        ],
        [
            "intros xm x2m h hm h2m.",
            "VernacExtend",
            "2810f8409a7a095024e674b0fbee784652d66289"
        ],
        [
            "destruct (eq_A_dec xm x2m).",
            "VernacExtend",
            "5d3e55e79560d10b414d3ba04d685baf264cd302"
        ],
        [
            "exists m; subst xm x2m; auto.",
            "VernacExtend",
            "a475b53e4e5e4ed0c80776d584831cead0276e34"
        ],
        [
            "apply (H (S m)) with (f xm) (f (f x2m)); subst xm x2m; auto with *.",
            "VernacExtend",
            "a564720c76fe8c6e324faf23d5f5d2ebd3e20748"
        ],
        [
            "unfold R; apply rec_call_is_wf; auto.",
            "VernacExtend",
            "e2cbe699820ee4c450a565456f87fd86b2652d28"
        ],
        [
            "replace (2*(S m)) with (S (S (2*m))) by omega; auto.",
            "VernacExtend",
            "b18a998209d9c4aff29bbc3d86dbb89bb2345d45"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Definition find_cycle : { m:nat | m > 0 /\\ x m = x (2*m) }.",
            "VernacDefinition",
            "5087fd0861b92ec80cde6dc9837aa43cfe18d814"
        ],
        [
            "apply (find_cycle_rec (S O) (f x0) (f (f x0))); auto with *.",
            "VernacExtend",
            "45c3637086c059a8592b9ceb9bf23666969f8d90"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ]
    ],
    "proofs": [
        {
            "name": "ex_dist_x2m_xm",
            "line_nb": 19,
            "steps": [
                {
                    "command": [
                        "intros m hm; apply ex_min_P.",
                        "VernacExtend",
                        "c002097606e321d8d1af4f04ae7bd6e870f14895"
                    ]
                },
                {
                    "command": [
                        "intro i; unfold sep_x2m_xm.",
                        "VernacExtend",
                        "9d296918242e64558369ae3972d3899acd6302e4"
                    ]
                },
                {
                    "command": [
                        "case (eq_A_dec (x (2 * m + i)) (x m)); auto.",
                        "VernacExtend",
                        "9718a78786c4b8421d3d47e32aff3d14328bb598"
                    ]
                },
                {
                    "command": [
                        "generalize (div mu mu_positive m); intros (k,hk).",
                        "VernacExtend",
                        "5645b37551d1eb9e32070a7ff084540f0c7c626a"
                    ]
                },
                {
                    "command": [
                        "exists (k*mu - m); unfold sep_x2m_xm.",
                        "VernacExtend",
                        "a8c184b432be59565dc99dd74846e2bac06db501"
                    ]
                },
                {
                    "command": [
                        "replace (2 * m + (k * mu - m)) with (lambda + (m-lambda)+k*mu) by omega.",
                        "VernacExtend",
                        "1646f308d4319802aa2cc84f234085e9668738dd"
                    ]
                },
                {
                    "command": [
                        "rewrite <- lambda_mu.",
                        "VernacExtend",
                        "9192baebc8b30dea5fbc8c2a1215d8dc9a6cca34"
                    ]
                },
                {
                    "command": [
                        "replace (lambda+(m-lambda)) with m by omega; auto.",
                        "VernacExtend",
                        "e8141861eeb204c0ff3795b9673fb1cb3c75bb40"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "rec_call_is_wf",
            "line_nb": 31,
            "steps": [
                {
                    "command": [
                        "unfold lex,variant; simpl.",
                        "VernacExtend",
                        "2a2eeda619feef57d40e5629916b64fc36867a46"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "assert (h: m < lambda \\/ m >= lambda) by omega.",
                        "VernacExtend",
                        "96aaf0d4503037d191df8832558583e28a3aea22"
                    ]
                },
                {
                    "command": [
                        "destruct h.",
                        "VernacExtend",
                        "ac5c00ffcee6d385c2dbd6b1548e82bb5791bade"
                    ]
                },
                {
                    "command": [
                        "left; omega.",
                        "VernacExtend",
                        "9a0d1509b2ddece54a4a5d691f28c3e86f4a5b72"
                    ]
                },
                {
                    "command": [
                        "right.",
                        "VernacExtend",
                        "27e417a3497755767e1a1d6ba87753ecddaee6b7"
                    ]
                },
                {
                    "command": [
                        "split; auto with *.",
                        "VernacExtend",
                        "125de5a0d9b9ba53a0994e8692d1e61e02809166"
                    ]
                },
                {
                    "command": [
                        "unfold dist_x2m_xm.",
                        "VernacExtend",
                        "f49089cead9ec99f20d01bc8e7a446c6387a7156"
                    ]
                },
                {
                    "command": [
                        "assert (exd1: ex (min (sep_x2m_xm (S m)))).",
                        "VernacExtend",
                        "f9638d7f9c4998b2a105e8b802384ef5be6f25d9"
                    ]
                },
                {
                    "command": [
                        "apply ex_dist_x2m_xm; auto with *.",
                        "VernacExtend",
                        "9204812529e6c5ee384033e4be49d8087b9174b0"
                    ]
                },
                {
                    "command": [
                        "generalize (epsilon_spec (min (sep_x2m_xm (S m))) exd1).",
                        "VernacExtend",
                        "19624c9819b3e4aee5caf2d034ccfd1ed53ecd1b"
                    ]
                },
                {
                    "command": [
                        "assert (exd0: ex (min (sep_x2m_xm m))).",
                        "VernacExtend",
                        "9b440b3e2e5f495983d6ededaf80cb9bcfa53334"
                    ]
                },
                {
                    "command": [
                        "apply ex_dist_x2m_xm; auto with *.",
                        "VernacExtend",
                        "9204812529e6c5ee384033e4be49d8087b9174b0"
                    ]
                },
                {
                    "command": [
                        "generalize (epsilon_spec (min (sep_x2m_xm m)) exd0).",
                        "VernacExtend",
                        "db8964b4c68f5692195addcaed32ee2b5af79de0"
                    ]
                },
                {
                    "command": [
                        "generalize (epsilon (min (sep_x2m_xm m))).",
                        "VernacExtend",
                        "2d46b98ac8f2aeb2e046c274d9cbc791afdd6098"
                    ]
                },
                {
                    "command": [
                        "generalize (epsilon (min (sep_x2m_xm (S m)))).",
                        "VernacExtend",
                        "68c61b57493328ed8b843567e2a1344e09095190"
                    ]
                },
                {
                    "command": [
                        "intros d1 d0.",
                        "VernacExtend",
                        "799409eb133411e89e0389cd4327fdee880c5632"
                    ]
                },
                {
                    "command": [
                        "unfold min,sep_x2m_xm.",
                        "VernacExtend",
                        "59264e10a0a9a18f227019f21f895ae62c3c789e"
                    ]
                },
                {
                    "command": [
                        "intros (h1,h2) (h3,h4).",
                        "VernacExtend",
                        "50757c2c59a5e1a17def701abb49b3f83b7d2e00"
                    ]
                },
                {
                    "command": [
                        "assert (x (S(2*m+d0)) = x (S m)).",
                        "VernacExtend",
                        "b8bd5bacddb6486b668b9e92ebdb646bdda0489b"
                    ]
                },
                {
                    "command": [
                        "simpl; simpl in h1; congruence.",
                        "VernacExtend",
                        "bedeb526d5a6522c87ffee14cab68273e85041db"
                    ]
                },
                {
                    "command": [
                        "assert (d0 > 0).",
                        "VernacExtend",
                        "7abf263157468b7955f94079007193a1c254414a"
                    ]
                },
                {
                    "command": [
                        "assert (h: d0=0 \\/ d0>0) by omega.",
                        "VernacExtend",
                        "19a44575beaf35d53f4c7effc116412812b9cc63"
                    ]
                },
                {
                    "command": [
                        "destruct h; auto.",
                        "VernacExtend",
                        "d9333d26756cde550a54305016aacddfbfcac72f"
                    ]
                },
                {
                    "command": [
                        "subst d0; absurd (x (2*m)=x m); auto.",
                        "VernacExtend",
                        "2a8616cf728f4c0c61a15e51b99d27dcb5b8cf41"
                    ]
                },
                {
                    "command": [
                        "replace (2*m+0) with (2*m) in h1; auto.",
                        "VernacExtend",
                        "7c176956af806a2f9b68d1caf4693002aba14999"
                    ]
                },
                {
                    "command": [
                        "assert (d1 <= d0-1).",
                        "VernacExtend",
                        "e09df25d0b05299dffd434651eaf241e82b13673"
                    ]
                },
                {
                    "command": [
                        "apply h4.",
                        "VernacExtend",
                        "e09736d38a1c4a8dbd3563a6131b6854c0bf38e7"
                    ]
                },
                {
                    "command": [
                        "replace (2 * (S m) + (d0 - 1)) with (S (2 * m + d0)) by omega.",
                        "VernacExtend",
                        "f5a4055f7d56e3419c325ea9f409c18d94e53f51"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "omega.",
                        "VernacExtend",
                        "32c6c865d255452c7e10c77111456d1981cede39"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "find_cycle_rec",
            "line_nb": 66,
            "steps": [
                {
                    "command": [
                        "induction m using (well_founded_induction R_wf).",
                        "VernacExtend",
                        "fc35d316a21250c3f642119d01267bd009c7a1b3"
                    ]
                },
                {
                    "command": [
                        "intros xm x2m h hm h2m.",
                        "VernacExtend",
                        "2810f8409a7a095024e674b0fbee784652d66289"
                    ]
                },
                {
                    "command": [
                        "destruct (eq_A_dec xm x2m).",
                        "VernacExtend",
                        "5d3e55e79560d10b414d3ba04d685baf264cd302"
                    ]
                },
                {
                    "command": [
                        "exists m; subst xm x2m; auto.",
                        "VernacExtend",
                        "a475b53e4e5e4ed0c80776d584831cead0276e34"
                    ]
                },
                {
                    "command": [
                        "apply (H (S m)) with (f xm) (f (f x2m)); subst xm x2m; auto with *.",
                        "VernacExtend",
                        "a564720c76fe8c6e324faf23d5f5d2ebd3e20748"
                    ]
                },
                {
                    "command": [
                        "unfold R; apply rec_call_is_wf; auto.",
                        "VernacExtend",
                        "e2cbe699820ee4c450a565456f87fd86b2652d28"
                    ]
                },
                {
                    "command": [
                        "replace (2*(S m)) with (S (S (2*m))) by omega; auto.",
                        "VernacExtend",
                        "b18a998209d9c4aff29bbc3d86dbb89bb2345d45"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "find_cycle",
            "line_nb": 75,
            "steps": [
                {
                    "command": [
                        "apply (find_cycle_rec (S O) (f x0) (f (f x0))); auto with *.",
                        "VernacExtend",
                        "45c3637086c059a8592b9ceb9bf23666969f8d90"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        }
    ]
}