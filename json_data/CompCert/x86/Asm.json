{
    "filename": "x86/Asm.v",
    "coq_project": "CompCert",
    "vernac_cmds": [
        [
            "Require Import Coqlib Maps.",
            "VernacRequire",
            "2eb17a425fb3d46ed3d3895043ba33b1c484f324"
        ],
        [
            "Require Import AST Integers Floats Values Memory Events Globalenvs Smallstep.",
            "VernacRequire",
            "f31d967b2da2c5671f09ff48af4ee191130e019f"
        ],
        [
            "Require Import Locations Stacklayout Conventions.",
            "VernacRequire",
            "3ce55c24a265bc90b8fc3867044b896336bdd2c6"
        ],
        [
            "Inductive ireg: Type := | RAX | RBX | RCX | RDX | RSI | RDI | RBP | RSP | R8 | R9 | R10 | R11 | R12 | R13 | R14 | R15.",
            "VernacInductive",
            "b722443588459f69832b828f81def0cb44ff481e"
        ],
        [
            "Inductive freg: Type := | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM8 | XMM9 | XMM10 | XMM11 | XMM12 | XMM13 | XMM14 | XMM15.",
            "VernacInductive",
            "816e6f19f75d9d9bab622c1e704a7cdc3948265b"
        ],
        [
            "Lemma ireg_eq: forall (x y: ireg), {x=y} + {x<>y}.",
            "VernacStartTheoremProof",
            "5cf82029866dfc29c69c389400b4b19e254ef69b"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Lemma freg_eq: forall (x y: freg), {x=y} + {x<>y}.",
            "VernacStartTheoremProof",
            "a65bcd839cf79dbadd56b3f3280d1e3b2be902d4"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Inductive crbit: Type := | ZF | CF | PF | SF | OF.",
            "VernacInductive",
            "2a7bf8fc18161bbf08131b473d89efdeaa6a5693"
        ],
        [
            "Inductive preg: Type := | PC: preg | IR: ireg -> preg | FR: freg -> preg | ST0: preg | CR: crbit -> preg | RA: preg.",
            "VernacInductive",
            "d20f10fc4c2d5e0de36009de15eea342f626350c"
        ],
        [
            "Coercion IR: ireg >-> preg.",
            "VernacCoercion",
            "c4470d96a1126eac012542615cf507e619256d22"
        ],
        [
            "Coercion FR: freg >-> preg.",
            "VernacCoercion",
            "ba33f4c9f9d703e45ac83f1a4390f7eb3661753d"
        ],
        [
            "Coercion CR: crbit >-> preg.",
            "VernacCoercion",
            "d4acd84590255217f0c21faceb8719215363dec4"
        ],
        [
            "Notation SP := RSP (only parsing).",
            "VernacSyntacticDefinition",
            "016cfb7bfd2684efa6bdf264bc77eb9659524c1c"
        ],
        [
            "Definition label := positive.",
            "VernacDefinition",
            "b3ed4a55821db8060cfbffebfd0f3c543b6ea158"
        ],
        [
            "Inductive addrmode: Type := | Addrmode (base: option ireg) (ofs: option (ireg * Z)) (const: Z + ident * ptrofs).",
            "VernacInductive",
            "0fda6f98c3c8a173c3e6d8d5bc1f58791d88935c"
        ],
        [
            "Inductive testcond: Type := | Cond_e | Cond_ne | Cond_b | Cond_be | Cond_ae | Cond_a | Cond_l | Cond_le | Cond_ge | Cond_g | Cond_p | Cond_np.",
            "VernacInductive",
            "b6cce91cbfbbdb9d9ada6319d0ab9e0d64e9ff8d"
        ],
        [
            "Inductive instruction: Type := | Pmov_rr (rd: ireg) (r1: ireg) | Pmovl_ri (rd: ireg) (n: int) | Pmovq_ri (rd: ireg) (n: int64) | Pmov_rs (rd: ireg) (id: ident) | Pmovl_rm (rd: ireg) (a: addrmode) | Pmovq_rm (rd: ireg) (a: addrmode) | Pmovl_mr (a: addrmode) (rs: ireg) | Pmovq_mr (a: addrmode) (rs: ireg) | Pmovsd_ff (rd: freg) (r1: freg) | Pmovsd_fi (rd: freg) (n: float) | Pmovsd_fm (rd: freg) (a: addrmode) | Pmovsd_mf (a: addrmode) (r1: freg) | Pmovss_fi (rd: freg) (n: float32) | Pmovss_fm (rd: freg) (a: addrmode) | Pmovss_mf (a: addrmode) (r1: freg) | Pfldl_m (a: addrmode) | Pfstpl_m (a: addrmode) | Pflds_m (a: addrmode) | Pfstps_m (a: addrmode) | Pmovb_mr (a: addrmode) (rs: ireg) | Pmovw_mr (a: addrmode) (rs: ireg) | Pmovzb_rr (rd: ireg) (rs: ireg) | Pmovzb_rm (rd: ireg) (a: addrmode) | Pmovsb_rr (rd: ireg) (rs: ireg) | Pmovsb_rm (rd: ireg) (a: addrmode) | Pmovzw_rr (rd: ireg) (rs: ireg) | Pmovzw_rm (rd: ireg) (a: addrmode) | Pmovsw_rr (rd: ireg) (rs: ireg) | Pmovsw_rm (rd: ireg) (a: addrmode) | Pmovzl_rr (rd: ireg) (rs: ireg) | Pmovsl_rr (rd: ireg) (rs: ireg) | Pmovls_rr (rd: ireg) | Pcvtsd2ss_ff (rd: freg) (r1: freg) | Pcvtss2sd_ff (rd: freg) (r1: freg) | Pcvttsd2si_rf (rd: ireg) (r1: freg) | Pcvtsi2sd_fr (rd: freg) (r1: ireg) | Pcvttss2si_rf (rd: ireg) (r1: freg) | Pcvtsi2ss_fr (rd: freg) (r1: ireg) | Pcvttsd2sl_rf (rd: ireg) (r1: freg) | Pcvtsl2sd_fr (rd: freg) (r1: ireg) | Pcvttss2sl_rf (rd: ireg) (r1: freg) | Pcvtsl2ss_fr (rd: freg) (r1: ireg) | Pleal (rd: ireg) (a: addrmode) | Pleaq (rd: ireg) (a: addrmode) | Pnegl (rd: ireg) | Pnegq (rd: ireg) | Paddl_ri (rd: ireg) (n: int) | Paddq_ri (rd: ireg) (n: int64) | Psubl_rr (rd: ireg) (r1: ireg) | Psubq_rr (rd: ireg) (r1: ireg) | Pimull_rr (rd: ireg) (r1: ireg) | Pimulq_rr (rd: ireg) (r1: ireg) | Pimull_ri (rd: ireg) (n: int) | Pimulq_ri (rd: ireg) (n: int64) | Pimull_r (r1: ireg) | Pimulq_r (r1: ireg) | Pmull_r (r1: ireg) | Pmulq_r (r1: ireg) | Pcltd | Pcqto | Pdivl (r1: ireg) | Pdivq (r1: ireg) | Pidivl (r1: ireg) | Pidivq (r1: ireg) | Pandl_rr (rd: ireg) (r1: ireg) | Pandq_rr (rd: ireg) (r1: ireg) | Pandl_ri (rd: ireg) (n: int) | Pandq_ri (rd: ireg) (n: int64) | Porl_rr (rd: ireg) (r1: ireg) | Porq_rr (rd: ireg) (r1: ireg) | Porl_ri (rd: ireg) (n: int) | Porq_ri (rd: ireg) (n: int64) | Pxorl_r (rd: ireg) | Pxorq_r (rd: ireg) | Pxorl_rr (rd: ireg) (r1: ireg) | Pxorq_rr (rd: ireg) (r1: ireg) | Pxorl_ri (rd: ireg) (n: int) | Pxorq_ri (rd: ireg) (n: int64) | Pnotl (rd: ireg) | Pnotq (rd: ireg) | Psall_rcl (rd: ireg) | Psalq_rcl (rd: ireg) | Psall_ri (rd: ireg) (n: int) | Psalq_ri (rd: ireg) (n: int) | Pshrl_rcl (rd: ireg) | Pshrq_rcl (rd: ireg) | Pshrl_ri (rd: ireg) (n: int) | Pshrq_ri (rd: ireg) (n: int) | Psarl_rcl (rd: ireg) | Psarq_rcl (rd: ireg) | Psarl_ri (rd: ireg) (n: int) | Psarq_ri (rd: ireg) (n: int) | Pshld_ri (rd: ireg) (r1: ireg) (n: int) | Prorl_ri (rd: ireg) (n: int) | Prorq_ri (rd: ireg) (n: int) | Pcmpl_rr (r1 r2: ireg) | Pcmpq_rr (r1 r2: ireg) | Pcmpl_ri (r1: ireg) (n: int) | Pcmpq_ri (r1: ireg) (n: int64) | Ptestl_rr (r1 r2: ireg) | Ptestq_rr (r1 r2: ireg) | Ptestl_ri (r1: ireg) (n: int) | Ptestq_ri (r1: ireg) (n: int64) | Pcmov (c: testcond) (rd: ireg) (r1: ireg) | Psetcc (c: testcond) (rd: ireg) | Paddd_ff (rd: freg) (r1: freg) | Psubd_ff (rd: freg) (r1: freg) | Pmuld_ff (rd: freg) (r1: freg) | Pdivd_ff (rd: freg) (r1: freg) | Pnegd (rd: freg) | Pabsd (rd: freg) | Pcomisd_ff (r1 r2: freg) | Pxorpd_f (rd: freg) | Padds_ff (rd: freg) (r1: freg) | Psubs_ff (rd: freg) (r1: freg) | Pmuls_ff (rd: freg) (r1: freg) | Pdivs_ff (rd: freg) (r1: freg) | Pnegs (rd: freg) | Pabss (rd: freg) | Pcomiss_ff (r1 r2: freg) | Pxorps_f (rd: freg) | Pjmp_l (l: label) | Pjmp_s (symb: ident) (sg: signature) | Pjmp_r (r: ireg) (sg: signature) | Pjcc (c: testcond)(l: label) | Pjcc2 (c1 c2: testcond)(l: label) | Pjmptbl (r: ireg) (tbl: list label) | Pcall_s (symb: ident) (sg: signature) | Pcall_r (r: ireg) (sg: signature) | Pret | Pmov_rm_a (rd: ireg) (a: addrmode) | Pmov_mr_a (a: addrmode) (rs: ireg) | Pmovsd_fm_a (rd: freg) (a: addrmode) | Pmovsd_mf_a (a: addrmode) (r1: freg) | Plabel(l: label) | Pallocframe(sz: Z)(ofs_ra ofs_link: ptrofs) | Pfreeframe(sz: Z)(ofs_ra ofs_link: ptrofs) | Pbuiltin(ef: external_function)(args: list (builtin_arg preg))(res: builtin_res preg) | Padcl_ri (rd: ireg) (n: int) | Padcl_rr (rd: ireg) (r2: ireg) | Paddl_mi (a: addrmode) (n: int) | Paddl_rr (rd: ireg) (r2: ireg) | Pbsfl (rd: ireg) (r1: ireg) | Pbsfq (rd: ireg) (r1: ireg) | Pbsrl (rd: ireg) (r1: ireg) | Pbsrq (rd: ireg) (r1: ireg) | Pbswap64 (rd: ireg) | Pbswap32 (rd: ireg) | Pbswap16 (rd: ireg) | Pcfi_adjust (n: int) | Pfmadd132 (rd: freg) (r2: freg) (r3: freg) | Pfmadd213 (rd: freg) (r2: freg) (r3: freg) | Pfmadd231 (rd: freg) (r2: freg) (r3: freg) | Pfmsub132 (rd: freg) (r2: freg) (r3: freg) | Pfmsub213 (rd: freg) (r2: freg) (r3: freg) | Pfmsub231 (rd: freg) (r2: freg) (r3: freg) | Pfnmadd132 (rd: freg) (r2: freg) (r3: freg) | Pfnmadd213 (rd: freg) (r2: freg) (r3: freg) | Pfnmadd231 (rd: freg) (r2: freg) (r3: freg) | Pfnmsub132 (rd: freg) (r2: freg) (r3: freg) | Pfnmsub213 (rd: freg) (r2: freg) (r3: freg) | Pfnmsub231 (rd: freg) (r2: freg) (r3: freg) | Pmaxsd (rd: freg) (r2: freg) | Pminsd (rd: freg) (r2: freg) | Pmovb_rm (rd: ireg) (a: addrmode) | Pmovsq_mr (a: addrmode) (rs: freg) | Pmovsq_rm (rd: freg) (a: addrmode) | Pmovsb | Pmovsw | Pmovw_rm (rd: ireg) (ad: addrmode) | Pnop | Prep_movsl | Psbbl_rr (rd: ireg) (r2: ireg) | Psqrtsd (rd: freg) (r1: freg) | Psubl_ri (rd: ireg) (n: int) | Psubq_ri (rd: ireg) (n: int64).",
            "VernacInductive",
            "419b0c1ca5d44383af3e5084bd1eb70c15634cca"
        ],
        [
            "Definition code := list instruction.",
            "VernacDefinition",
            "bf10af1cb9540888e9804f1124948b8d224ad655"
        ],
        [
            "Record function : Type := mkfunction { fn_sig: signature; fn_code: code }.",
            "VernacInductive",
            "f77883998d400384cd102e2084514c6c8b831266"
        ],
        [
            "Definition fundef := AST.fundef function.",
            "VernacDefinition",
            "9cf622c746a9b58a51cebc97469342b997e49284"
        ],
        [
            "Definition program := AST.program fundef unit.",
            "VernacDefinition",
            "cfadb9a12e6df9faa40df706d0e99e4d4aa89bc3"
        ],
        [
            "Lemma preg_eq: forall (x y: preg), {x=y} + {x<>y}.",
            "VernacStartTheoremProof",
            "cda82f4d4dda6ae7a874341598a6e87845dbfea8"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "apply ireg_eq.",
            "VernacExtend",
            "f09307906da7b3ca8c9fdf2ef3c0a69358899ce2"
        ],
        [
            "apply freg_eq.",
            "VernacExtend",
            "eb5566fc8d55300e43b4163480cd9c79e8398757"
        ],
        [
            "decide equality.",
            "VernacExtend",
            "10aba07d521545accbb51a4c2e0695a9ddce3199"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Module PregEq.",
            "VernacDefineModule",
            "6308f75de206d16f4e3847e981da0728ebbb9081"
        ],
        [
            "Definition t := preg.",
            "VernacDefinition",
            "ddbbe8e433f8976ae940de2677a8f6758a8f12f4"
        ],
        [
            "Definition eq := preg_eq.",
            "VernacDefinition",
            "a06d9978a7197abc42bcf4b35d61aeee8a7cf818"
        ],
        [
            "End PregEq.",
            "VernacEndSegment",
            "864967aa7a0b2072bc7cb24db2bb4ba7e497f792"
        ],
        [
            "Module Pregmap := EMap(PregEq).",
            "VernacDefineModule",
            "5c63abc41dca5912f5adc7f33b7888b478cdd83c"
        ],
        [
            "Definition regset := Pregmap.t val.",
            "VernacDefinition",
            "56e7c2c5fe8fc37bf1c00726b8ac418c63fcd9cd"
        ],
        [
            "Definition genv := Genv.t fundef unit.",
            "VernacDefinition",
            "558ae6d6506288d7eeb39bb497dd26e4fa2a28e4"
        ],
        [
            "Notation \"a # b\" := (a b) (at level 1, only parsing) : asm.",
            "VernacNotation",
            "67c8cc4548da11dac75072d22c258f39a20a46ff"
        ],
        [
            "Notation \"a # b <- c\" := (Pregmap.set b c a) (at level 1, b at next level) : asm.",
            "VernacNotation",
            "b948ca0e9c578636573b0db92e82e551d5d675fe"
        ],
        [
            "Open Scope asm.",
            "VernacOpenCloseScope",
            "90006c089e72098e758485dbfcbc47b911bc89c7"
        ],
        [
            "Fixpoint undef_regs (l: list preg) (rs: regset) : regset := match l with | nil => rs | r :: l' => undef_regs l' (rs#r <- Vundef) end.",
            "VernacFixpoint",
            "446b20f56d118fb12f04127fd0d45060d01b69df"
        ],
        [
            "Definition set_pair (p: rpair preg) (v: val) (rs: regset) : regset := match p with | One r => rs#r <- v | Twolong rhi rlo => rs#rhi <- (Val.hiword v) #rlo <- (Val.loword v) end.",
            "VernacDefinition",
            "a529dd53cbf12a68a5c78a280c10785354362dae"
        ],
        [
            "Fixpoint set_res (res: builtin_res preg) (v: val) (rs: regset) : regset := match res with | BR r => rs#r <- v | BR_none => rs | BR_splitlong hi lo => set_res lo (Val.loword v) (set_res hi (Val.hiword v) rs) end.",
            "VernacFixpoint",
            "b4d6e0f02dc38019fb1f2567ffdbe1b207db8248"
        ],
        [
            "Section RELSEM.",
            "VernacBeginSection",
            "56cea622d6c9a9251b433cfd4de33058b7d80bb5"
        ],
        [
            "Fixpoint find_instr (pos: Z) (c: code) {struct c} : option instruction := match c with | nil => None | i :: il => if zeq pos 0 then Some i else find_instr (pos - 1) il end.",
            "VernacFixpoint",
            "5242c51df0f6563ac12711dc69bfadcfede3e7ca"
        ],
        [
            "Definition is_label (lbl: label) (instr: instruction) : bool := match instr with | Plabel lbl' => if peq lbl lbl' then true else false | _ => false end.",
            "VernacDefinition",
            "bbf6d7613a0d717d00f0fa40c998b31e54fb64d9"
        ],
        [
            "Lemma is_label_correct: forall lbl instr, if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl.",
            "VernacStartTheoremProof",
            "f28dceb872911cf8b36cbbeba7ea70ba965ec479"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct instr; simpl; try discriminate.",
            "VernacExtend",
            "69eb2b76ff74e79d3df1681b795dbcd9a14f383b"
        ],
        [
            "case (peq lbl l); intro; congruence.",
            "VernacExtend",
            "879442c196163a9742376276714507f7b5709f97"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint label_pos (lbl: label) (pos: Z) (c: code) {struct c} : option Z := match c with | nil => None | instr :: c' => if is_label lbl instr then Some (pos + 1) else label_pos lbl (pos + 1) c' end.",
            "VernacFixpoint",
            "2cc9e0e1ef5be93bd454a9264054d627f30c3e46"
        ],
        [
            "Variable ge: genv.",
            "VernacAssumption",
            "5dcbd76196753bb6e2da03561ae76151d62a94d8"
        ],
        [
            "Definition eval_addrmode32 (a: addrmode) (rs: regset) : val := let '(Addrmode base ofs const) := a in Val.add (match base with | None => Vint Int.zero | Some r => rs r end) (Val.add (match ofs with | None => Vint Int.zero | Some(r, sc) => if zeq sc 1 then rs r else Val.mul (rs r) (Vint (Int.repr sc)) end) (match const with | inl ofs => Vint (Int.repr ofs) | inr(id, ofs) => Genv.symbol_address ge id ofs end)).",
            "VernacDefinition",
            "12331472eff12bf8fb225a656161bc1ef7e3af1a"
        ],
        [
            "Definition eval_addrmode64 (a: addrmode) (rs: regset) : val := let '(Addrmode base ofs const) := a in Val.addl (match base with | None => Vlong Int64.zero | Some r => rs r end) (Val.addl (match ofs with | None => Vlong Int64.zero | Some(r, sc) => if zeq sc 1 then rs r else Val.mull (rs r) (Vlong (Int64.repr sc)) end) (match const with | inl ofs => Vlong (Int64.repr ofs) | inr(id, ofs) => Genv.symbol_address ge id ofs end)).",
            "VernacDefinition",
            "c2ab2b6e008dc7ec4b6360d6cb1fc0b001657f2f"
        ],
        [
            "Definition eval_addrmode (a: addrmode) (rs: regset) : val := if Archi.ptr64 then eval_addrmode64 a rs else eval_addrmode32 a rs.",
            "VernacDefinition",
            "2c477eb0b552d05be0195a78d5c1315c59d1bb7a"
        ],
        [
            "Definition compare_ints (x y: val) (rs: regset) (m: mem): regset := rs #ZF <- (Val.cmpu (Mem.valid_pointer m) Ceq x y) #CF <- (Val.cmpu (Mem.valid_pointer m) Clt x y) #SF <- (Val.negative (Val.sub x y)) #OF <- (Val.sub_overflow x y) #PF <- Vundef.",
            "VernacDefinition",
            "05fca9081418a403ad4919822a86d2e036aa1a88"
        ],
        [
            "Definition compare_longs (x y: val) (rs: regset) (m: mem): regset := rs #ZF <- (Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq x y)) #CF <- (Val.maketotal (Val.cmplu (Mem.valid_pointer m) Clt x y)) #SF <- (Val.negativel (Val.subl x y)) #OF <- (Val.subl_overflow x y) #PF <- Vundef.",
            "VernacDefinition",
            "54fc9cb00610e05286b00437e033339a4121d8f7"
        ],
        [
            "Definition compare_floats (vx vy: val) (rs: regset) : regset := match vx, vy with | Vfloat x, Vfloat y => rs #ZF <- (Val.of_bool (Float.cmp Ceq x y || negb (Float.ordered x y))) #CF <- (Val.of_bool (negb (Float.cmp Cge x y))) #PF <- (Val.of_bool (negb (Float.ordered x y))) #SF <- Vundef #OF <- Vundef | _, _ => undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) rs end.",
            "VernacDefinition",
            "6975eb2c41820dc71eadc27c763b8a769cb8cf3f"
        ],
        [
            "Definition compare_floats32 (vx vy: val) (rs: regset) : regset := match vx, vy with | Vsingle x, Vsingle y => rs #ZF <- (Val.of_bool (Float32.cmp Ceq x y || negb (Float32.ordered x y))) #CF <- (Val.of_bool (negb (Float32.cmp Cge x y))) #PF <- (Val.of_bool (negb (Float32.ordered x y))) #SF <- Vundef #OF <- Vundef | _, _ => undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) rs end.",
            "VernacDefinition",
            "b826feff15dc9b68a0699a334e2a07bd951e24b3"
        ],
        [
            "Definition eval_testcond (c: testcond) (rs: regset) : option bool := match c with | Cond_e => match rs ZF with | Vint n => Some (Int.eq n Int.one) | _ => None end | Cond_ne => match rs ZF with | Vint n => Some (Int.eq n Int.zero) | _ => None end | Cond_b => match rs CF with | Vint n => Some (Int.eq n Int.one) | _ => None end | Cond_be => match rs CF, rs ZF with | Vint c, Vint z => Some (Int.eq c Int.one || Int.eq z Int.one) | _, _ => None end | Cond_ae => match rs CF with | Vint n => Some (Int.eq n Int.zero) | _ => None end | Cond_a => match rs CF, rs ZF with | Vint c, Vint z => Some (Int.eq c Int.zero && Int.eq z Int.zero) | _, _ => None end | Cond_l => match rs OF, rs SF with | Vint o, Vint s => Some (Int.eq (Int.xor o s) Int.one) | _, _ => None end | Cond_le => match rs OF, rs SF, rs ZF with | Vint o, Vint s, Vint z => Some (Int.eq (Int.xor o s) Int.one || Int.eq z Int.one) | _, _, _ => None end | Cond_ge => match rs OF, rs SF with | Vint o, Vint s => Some (Int.eq (Int.xor o s) Int.zero) | _, _ => None end | Cond_g => match rs OF, rs SF, rs ZF with | Vint o, Vint s, Vint z => Some (Int.eq (Int.xor o s) Int.zero && Int.eq z Int.zero) | _, _, _ => None end | Cond_p => match rs PF with | Vint n => Some (Int.eq n Int.one) | _ => None end | Cond_np => match rs PF with | Vint n => Some (Int.eq n Int.zero) | _ => None end end.",
            "VernacDefinition",
            "cbf150397ac8b36b2424529d28c8f9fe86f517e5"
        ],
        [
            "Inductive outcome: Type := | Next: regset -> mem -> outcome | Stuck: outcome.",
            "VernacInductive",
            "81b447dbd240021feae1bdfc2c568d12d04fade9"
        ],
        [
            "Definition nextinstr (rs: regset) := rs#PC <- (Val.offset_ptr rs#PC Ptrofs.one).",
            "VernacDefinition",
            "a527b955dd09408cea7699798d9f918010c487ff"
        ],
        [
            "Definition nextinstr_nf (rs: regset) : regset := nextinstr (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) rs).",
            "VernacDefinition",
            "a342ab0ba5c189c4cec5976594be1d0336479958"
        ],
        [
            "Definition goto_label (f: function) (lbl: label) (rs: regset) (m: mem) := match label_pos lbl 0 (fn_code f) with | None => Stuck | Some pos => match rs#PC with | Vptr b ofs => Next (rs#PC <- (Vptr b (Ptrofs.repr pos))) m | _ => Stuck end end.",
            "VernacDefinition",
            "4477c991372e842aee2323829c2f78250cb0026f"
        ],
        [
            "Definition exec_load (chunk: memory_chunk) (m: mem) (a: addrmode) (rs: regset) (rd: preg) := match Mem.loadv chunk m (eval_addrmode a rs) with | Some v => Next (nextinstr_nf (rs#rd <- v)) m | None => Stuck end.",
            "VernacDefinition",
            "b10653b6e8810d66a227b475bcae0a39178dafd2"
        ],
        [
            "Definition exec_store (chunk: memory_chunk) (m: mem) (a: addrmode) (rs: regset) (r1: preg) (destroyed: list preg) := match Mem.storev chunk m (eval_addrmode a rs) (rs r1) with | Some m' => Next (nextinstr_nf (undef_regs destroyed rs)) m' | None => Stuck end.",
            "VernacDefinition",
            "6fde4893b0829e099e1ff23c9b53a0f7271d719c"
        ],
        [
            "Definition exec_instr (f: function) (i: instruction) (rs: regset) (m: mem) : outcome := match i with | Pmov_rr rd r1 => Next (nextinstr (rs#rd <- (rs r1))) m | Pmovl_ri rd n => Next (nextinstr_nf (rs#rd <- (Vint n))) m | Pmovq_ri rd n => Next (nextinstr_nf (rs#rd <- (Vlong n))) m | Pmov_rs rd id => Next (nextinstr_nf (rs#rd <- (Genv.symbol_address ge id Ptrofs.zero))) m | Pmovl_rm rd a => exec_load Mint32 m a rs rd | Pmovq_rm rd a => exec_load Mint64 m a rs rd | Pmovl_mr a r1 => exec_store Mint32 m a rs r1 nil | Pmovq_mr a r1 => exec_store Mint64 m a rs r1 nil | Pmovsd_ff rd r1 => Next (nextinstr (rs#rd <- (rs r1))) m | Pmovsd_fi rd n => Next (nextinstr (rs#rd <- (Vfloat n))) m | Pmovsd_fm rd a => exec_load Mfloat64 m a rs rd | Pmovsd_mf a r1 => exec_store Mfloat64 m a rs r1 nil | Pmovss_fi rd n => Next (nextinstr (rs#rd <- (Vsingle n))) m | Pmovss_fm rd a => exec_load Mfloat32 m a rs rd | Pmovss_mf a r1 => exec_store Mfloat32 m a rs r1 nil | Pfldl_m a => exec_load Mfloat64 m a rs ST0 | Pfstpl_m a => exec_store Mfloat64 m a rs ST0 (ST0 :: nil) | Pflds_m a => exec_load Mfloat32 m a rs ST0 | Pfstps_m a => exec_store Mfloat32 m a rs ST0 (ST0 :: nil) | Pmovb_mr a r1 => exec_store Mint8unsigned m a rs r1 nil | Pmovw_mr a r1 => exec_store Mint16unsigned m a rs r1 nil | Pmovzb_rr rd r1 => Next (nextinstr (rs#rd <- (Val.zero_ext 8 rs#r1))) m | Pmovzb_rm rd a => exec_load Mint8unsigned m a rs rd | Pmovsb_rr rd r1 => Next (nextinstr (rs#rd <- (Val.sign_ext 8 rs#r1))) m | Pmovsb_rm rd a => exec_load Mint8signed m a rs rd | Pmovzw_rr rd r1 => Next (nextinstr (rs#rd <- (Val.zero_ext 16 rs#r1))) m | Pmovzw_rm rd a => exec_load Mint16unsigned m a rs rd | Pmovsw_rr rd r1 => Next (nextinstr (rs#rd <- (Val.sign_ext 16 rs#r1))) m | Pmovsw_rm rd a => exec_load Mint16signed m a rs rd | Pmovzl_rr rd r1 => Next (nextinstr (rs#rd <- (Val.longofintu rs#r1))) m | Pmovsl_rr rd r1 => Next (nextinstr (rs#rd <- (Val.longofint rs#r1))) m | Pmovls_rr rd => Next (nextinstr (rs#rd <- (Val.loword rs#rd))) m | Pcvtsd2ss_ff rd r1 => Next (nextinstr (rs#rd <- (Val.singleoffloat rs#r1))) m | Pcvtss2sd_ff rd r1 => Next (nextinstr (rs#rd <- (Val.floatofsingle rs#r1))) m | Pcvttsd2si_rf rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.intoffloat rs#r1)))) m | Pcvtsi2sd_fr rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.floatofint rs#r1)))) m | Pcvttss2si_rf rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.intofsingle rs#r1)))) m | Pcvtsi2ss_fr rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.singleofint rs#r1)))) m | Pcvttsd2sl_rf rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.longoffloat rs#r1)))) m | Pcvtsl2sd_fr rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.floatoflong rs#r1)))) m | Pcvttss2sl_rf rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.longofsingle rs#r1)))) m | Pcvtsl2ss_fr rd r1 => Next (nextinstr (rs#rd <- (Val.maketotal (Val.singleoflong rs#r1)))) m | Pleal rd a => Next (nextinstr (rs#rd <- (eval_addrmode32 a rs))) m | Pleaq rd a => Next (nextinstr (rs#rd <- (eval_addrmode64 a rs))) m | Pnegl rd => Next (nextinstr_nf (rs#rd <- (Val.neg rs#rd))) m | Pnegq rd => Next (nextinstr_nf (rs#rd <- (Val.negl rs#rd))) m | Paddl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.add rs#rd (Vint n)))) m | Paddq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.addl rs#rd (Vlong n)))) m | Psubl_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.sub rs#rd rs#r1))) m | Psubq_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.subl rs#rd rs#r1))) m | Pimull_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.mul rs#rd rs#r1))) m | Pimulq_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.mull rs#rd rs#r1))) m | Pimull_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.mul rs#rd (Vint n)))) m | Pimulq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.mull rs#rd (Vlong n)))) m | Pimull_r r1 => Next (nextinstr_nf (rs#RAX <- (Val.mul rs#RAX rs#r1) #RDX <- (Val.mulhs rs#RAX rs#r1))) m | Pimulq_r r1 => Next (nextinstr_nf (rs#RAX <- (Val.mull rs#RAX rs#r1) #RDX <- (Val.mullhs rs#RAX rs#r1))) m | Pmull_r r1 => Next (nextinstr_nf (rs#RAX <- (Val.mul rs#RAX rs#r1) #RDX <- (Val.mulhu rs#RAX rs#r1))) m | Pmulq_r r1 => Next (nextinstr_nf (rs#RAX <- (Val.mull rs#RAX rs#r1) #RDX <- (Val.mullhu rs#RAX rs#r1))) m | Pcltd => Next (nextinstr_nf (rs#RDX <- (Val.shr rs#RAX (Vint (Int.repr 31))))) m | Pcqto => Next (nextinstr_nf (rs#RDX <- (Val.shrl rs#RAX (Vint (Int.repr 63))))) m | Pdivl r1 => match rs#RDX, rs#RAX, rs#r1 with | Vint nh, Vint nl, Vint d => match Int.divmodu2 nh nl d with | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vint q) #RDX <- (Vint r))) m | None => Stuck end | _, _, _ => Stuck end | Pdivq r1 => match rs#RDX, rs#RAX, rs#r1 with | Vlong nh, Vlong nl, Vlong d => match Int64.divmodu2 nh nl d with | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vlong q) #RDX <- (Vlong r))) m | None => Stuck end | _, _, _ => Stuck end | Pidivl r1 => match rs#RDX, rs#RAX, rs#r1 with | Vint nh, Vint nl, Vint d => match Int.divmods2 nh nl d with | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vint q) #RDX <- (Vint r))) m | None => Stuck end | _, _, _ => Stuck end | Pidivq r1 => match rs#RDX, rs#RAX, rs#r1 with | Vlong nh, Vlong nl, Vlong d => match Int64.divmods2 nh nl d with | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vlong q) #RDX <- (Vlong r))) m | None => Stuck end | _, _, _ => Stuck end | Pandl_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.and rs#rd rs#r1))) m | Pandq_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.andl rs#rd rs#r1))) m | Pandl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.and rs#rd (Vint n)))) m | Pandq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.andl rs#rd (Vlong n)))) m | Porl_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.or rs#rd rs#r1))) m | Porq_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.orl rs#rd rs#r1))) m | Porl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.or rs#rd (Vint n)))) m | Porq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.orl rs#rd (Vlong n)))) m | Pxorl_r rd => Next (nextinstr_nf (rs#rd <- Vzero)) m | Pxorq_r rd => Next (nextinstr_nf (rs#rd <- (Vlong Int64.zero))) m | Pxorl_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.xor rs#rd rs#r1))) m | Pxorq_rr rd r1 => Next (nextinstr_nf (rs#rd <- (Val.xorl rs#rd rs#r1))) m | Pxorl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.xor rs#rd (Vint n)))) m | Pxorq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.xorl rs#rd (Vlong n)))) m | Pnotl rd => Next (nextinstr_nf (rs#rd <- (Val.notint rs#rd))) m | Pnotq rd => Next (nextinstr_nf (rs#rd <- (Val.notl rs#rd))) m | Psall_rcl rd => Next (nextinstr_nf (rs#rd <- (Val.shl rs#rd rs#RCX))) m | Psalq_rcl rd => Next (nextinstr_nf (rs#rd <- (Val.shll rs#rd rs#RCX))) m | Psall_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.shl rs#rd (Vint n)))) m | Psalq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.shll rs#rd (Vint n)))) m | Pshrl_rcl rd => Next (nextinstr_nf (rs#rd <- (Val.shru rs#rd rs#RCX))) m | Pshrq_rcl rd => Next (nextinstr_nf (rs#rd <- (Val.shrlu rs#rd rs#RCX))) m | Pshrl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.shru rs#rd (Vint n)))) m | Pshrq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.shrlu rs#rd (Vint n)))) m | Psarl_rcl rd => Next (nextinstr_nf (rs#rd <- (Val.shr rs#rd rs#RCX))) m | Psarq_rcl rd => Next (nextinstr_nf (rs#rd <- (Val.shrl rs#rd rs#RCX))) m | Psarl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.shr rs#rd (Vint n)))) m | Psarq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.shrl rs#rd (Vint n)))) m | Pshld_ri rd r1 n => Next (nextinstr_nf (rs#rd <- (Val.or (Val.shl rs#rd (Vint n)) (Val.shru rs#r1 (Vint (Int.sub Int.iwordsize n)))))) m | Prorl_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.ror rs#rd (Vint n)))) m | Prorq_ri rd n => Next (nextinstr_nf (rs#rd <- (Val.rorl rs#rd (Vint n)))) m | Pcmpl_rr r1 r2 => Next (nextinstr (compare_ints (rs r1) (rs r2) rs m)) m | Pcmpq_rr r1 r2 => Next (nextinstr (compare_longs (rs r1) (rs r2) rs m)) m | Pcmpl_ri r1 n => Next (nextinstr (compare_ints (rs r1) (Vint n) rs m)) m | Pcmpq_ri r1 n => Next (nextinstr (compare_longs (rs r1) (Vlong n) rs m)) m | Ptestl_rr r1 r2 => Next (nextinstr (compare_ints (Val.and (rs r1) (rs r2)) Vzero rs m)) m | Ptestq_rr r1 r2 => Next (nextinstr (compare_longs (Val.andl (rs r1) (rs r2)) (Vlong Int64.zero) rs m)) m | Ptestl_ri r1 n => Next (nextinstr (compare_ints (Val.and (rs r1) (Vint n)) Vzero rs m)) m | Ptestq_ri r1 n => Next (nextinstr (compare_longs (Val.andl (rs r1) (Vlong n)) (Vlong Int64.zero) rs m)) m | Pcmov c rd r1 => match eval_testcond c rs with | Some true => Next (nextinstr (rs#rd <- (rs#r1))) m | Some false => Next (nextinstr rs) m | None => Next (nextinstr (rs#rd <- Vundef)) m end | Psetcc c rd => Next (nextinstr (rs#rd <- (Val.of_optbool (eval_testcond c rs)))) m | Paddd_ff rd r1 => Next (nextinstr (rs#rd <- (Val.addf rs#rd rs#r1))) m | Psubd_ff rd r1 => Next (nextinstr (rs#rd <- (Val.subf rs#rd rs#r1))) m | Pmuld_ff rd r1 => Next (nextinstr (rs#rd <- (Val.mulf rs#rd rs#r1))) m | Pdivd_ff rd r1 => Next (nextinstr (rs#rd <- (Val.divf rs#rd rs#r1))) m | Pnegd rd => Next (nextinstr (rs#rd <- (Val.negf rs#rd))) m | Pabsd rd => Next (nextinstr (rs#rd <- (Val.absf rs#rd))) m | Pcomisd_ff r1 r2 => Next (nextinstr (compare_floats (rs r1) (rs r2) rs)) m | Pxorpd_f rd => Next (nextinstr_nf (rs#rd <- (Vfloat Float.zero))) m | Padds_ff rd r1 => Next (nextinstr (rs#rd <- (Val.addfs rs#rd rs#r1))) m | Psubs_ff rd r1 => Next (nextinstr (rs#rd <- (Val.subfs rs#rd rs#r1))) m | Pmuls_ff rd r1 => Next (nextinstr (rs#rd <- (Val.mulfs rs#rd rs#r1))) m | Pdivs_ff rd r1 => Next (nextinstr (rs#rd <- (Val.divfs rs#rd rs#r1))) m | Pnegs rd => Next (nextinstr (rs#rd <- (Val.negfs rs#rd))) m | Pabss rd => Next (nextinstr (rs#rd <- (Val.absfs rs#rd))) m | Pcomiss_ff r1 r2 => Next (nextinstr (compare_floats32 (rs r1) (rs r2) rs)) m | Pxorps_f rd => Next (nextinstr_nf (rs#rd <- (Vsingle Float32.zero))) m | Pjmp_l lbl => goto_label f lbl rs m | Pjmp_s id sg => Next (rs#PC <- (Genv.symbol_address ge id Ptrofs.zero)) m | Pjmp_r r sg => Next (rs#PC <- (rs r)) m | Pjcc cond lbl => match eval_testcond cond rs with | Some true => goto_label f lbl rs m | Some false => Next (nextinstr rs) m | None => Stuck end | Pjcc2 cond1 cond2 lbl => match eval_testcond cond1 rs, eval_testcond cond2 rs with | Some true, Some true => goto_label f lbl rs m | Some _, Some _ => Next (nextinstr rs) m | _, _ => Stuck end | Pjmptbl r tbl => match rs#r with | Vint n => match list_nth_z tbl (Int.unsigned n) with | None => Stuck | Some lbl => goto_label f lbl (rs #RAX <- Vundef #RDX <- Vundef) m end | _ => Stuck end | Pcall_s id sg => Next (rs#RA <- (Val.offset_ptr rs#PC Ptrofs.one) #PC <- (Genv.symbol_address ge id Ptrofs.zero)) m | Pcall_r r sg => Next (rs#RA <- (Val.offset_ptr rs#PC Ptrofs.one) #PC <- (rs r)) m | Pret => Next (rs#PC <- (rs#RA)) m | Pmov_rm_a rd a => exec_load (if Archi.ptr64 then Many64 else Many32) m a rs rd | Pmov_mr_a a r1 => exec_store (if Archi.ptr64 then Many64 else Many32) m a rs r1 nil | Pmovsd_fm_a rd a => exec_load Many64 m a rs rd | Pmovsd_mf_a a r1 => exec_store Many64 m a rs r1 nil | Plabel lbl => Next (nextinstr rs) m | Pallocframe sz ofs_ra ofs_link => let (m1, stk) := Mem.alloc m 0 sz in let sp := Vptr stk Ptrofs.zero in match Mem.storev Mptr m1 (Val.offset_ptr sp ofs_link) rs#RSP with | None => Stuck | Some m2 => match Mem.storev Mptr m2 (Val.offset_ptr sp ofs_ra) rs#RA with | None => Stuck | Some m3 => Next (nextinstr (rs #RAX <- (rs#RSP) #RSP <- sp)) m3 end end | Pfreeframe sz ofs_ra ofs_link => match Mem.loadv Mptr m (Val.offset_ptr rs#RSP ofs_ra) with | None => Stuck | Some ra => match Mem.loadv Mptr m (Val.offset_ptr rs#RSP ofs_link) with | None => Stuck | Some sp => match rs#RSP with | Vptr stk ofs => match Mem.free m stk 0 sz with | None => Stuck | Some m' => Next (nextinstr (rs#RSP <- sp #RA <- ra)) m' end | _ => Stuck end end end | Pbuiltin ef args res => Stuck | Padcl_ri _ _ | Padcl_rr _ _ | Paddl_mi _ _ | Paddl_rr _ _ | Pbsfl _ _ | Pbsfq _ _ | Pbsrl _ _ | Pbsrq _ _ | Pbswap64 _ | Pbswap32 _ | Pbswap16 _ | Pcfi_adjust _ | Pfmadd132 _ _ _ | Pfmadd213 _ _ _ | Pfmadd231 _ _ _ | Pfmsub132 _ _ _ | Pfmsub213 _ _ _ | Pfmsub231 _ _ _ | Pfnmadd132 _ _ _ | Pfnmadd213 _ _ _ | Pfnmadd231 _ _ _ | Pfnmsub132 _ _ _ | Pfnmsub213 _ _ _ | Pfnmsub231 _ _ _ | Pmaxsd _ _ | Pminsd _ _ | Pmovb_rm _ _ | Pmovsq_rm _ _ | Pmovsq_mr _ _ | Pmovsb | Pmovsw | Pmovw_rm _ _ | Pnop | Prep_movsl | Psbbl_rr _ _ | Psqrtsd _ _ | Psubl_ri _ _ | Psubq_ri _ _ => Stuck end.",
            "VernacDefinition",
            "d83a2f094e54514a0b8d22a748c52cbfbd7f802a"
        ],
        [
            "Definition preg_of (r: mreg) : preg := match r with | AX => IR RAX | BX => IR RBX | CX => IR RCX | DX => IR RDX | SI => IR RSI | DI => IR RDI | BP => IR RBP | Machregs.R8 => IR R8 | Machregs.R9 => IR R9 | Machregs.R10 => IR R10 | Machregs.R11 => IR R11 | Machregs.R12 => IR R12 | Machregs.R13 => IR R13 | Machregs.R14 => IR R14 | Machregs.R15 => IR R15 | X0 => FR XMM0 | X1 => FR XMM1 | X2 => FR XMM2 | X3 => FR XMM3 | X4 => FR XMM4 | X5 => FR XMM5 | X6 => FR XMM6 | X7 => FR XMM7 | X8 => FR XMM8 | X9 => FR XMM9 | X10 => FR XMM10 | X11 => FR XMM11 | X12 => FR XMM12 | X13 => FR XMM13 | X14 => FR XMM14 | X15 => FR XMM15 | FP0 => ST0 end.",
            "VernacDefinition",
            "4de8a5becf9b5f9634a20c64a426b3b172c30517"
        ],
        [
            "Definition undef_caller_save_regs (rs: regset) : regset := fun r => if preg_eq r SP || In_dec preg_eq r (List.map preg_of (List.filter is_callee_save all_mregs)) then rs r else Vundef.",
            "VernacDefinition",
            "fb73d3da69bda22eda8f72828cd2b68d057d27f7"
        ],
        [
            "Inductive extcall_arg (rs: regset) (m: mem): loc -> val -> Prop := | extcall_arg_reg: forall r, extcall_arg rs m (R r) (rs (preg_of r)) | extcall_arg_stack: forall ofs ty bofs v, bofs = Stacklayout.fe_ofs_arg + 4 * ofs -> Mem.loadv (chunk_of_type ty) m (Val.offset_ptr (rs (IR RSP)) (Ptrofs.repr bofs)) = Some v -> extcall_arg rs m (S Outgoing ofs ty) v.",
            "VernacInductive",
            "b851dbfdc88f8c231ee12c6ec6fe81b787afe204"
        ],
        [
            "Inductive extcall_arg_pair (rs: regset) (m: mem): rpair loc -> val -> Prop := | extcall_arg_one: forall l v, extcall_arg rs m l v -> extcall_arg_pair rs m (One l) v | extcall_arg_twolong: forall hi lo vhi vlo, extcall_arg rs m hi vhi -> extcall_arg rs m lo vlo -> extcall_arg_pair rs m (Twolong hi lo) (Val.longofwords vhi vlo).",
            "VernacInductive",
            "b1e1fab3ca94fc4d107d5f034ce0e8721f646ccf"
        ],
        [
            "Definition extcall_arguments (rs: regset) (m: mem) (sg: signature) (args: list val) : Prop := list_forall2 (extcall_arg_pair rs m) (loc_arguments sg) args.",
            "VernacDefinition",
            "5d8886bbcd1987b56721d730cca89d5e62542527"
        ],
        [
            "Definition loc_external_result (sg: signature) : rpair preg := map_rpair preg_of (loc_result sg).",
            "VernacDefinition",
            "8c17959af376ecdadb086448c190d330e39d3f77"
        ],
        [
            "Inductive state: Type := | State: regset -> mem -> state.",
            "VernacInductive",
            "0a1533ade2a78cbed27e6ebe0a0aae2d6be64b9d"
        ],
        [
            "Inductive step: state -> trace -> state -> Prop := | exec_step_internal: forall b ofs f i rs m rs' m', rs PC = Vptr b ofs -> Genv.find_funct_ptr ge b = Some (Internal f) -> find_instr (Ptrofs.unsigned ofs) f.(fn_code) = Some i -> exec_instr f i rs m = Next rs' m' -> step (State rs m) E0 (State rs' m') | exec_step_builtin: forall b ofs f ef args res rs m vargs t vres rs' m', rs PC = Vptr b ofs -> Genv.find_funct_ptr ge b = Some (Internal f) -> find_instr (Ptrofs.unsigned ofs) f.(fn_code) = Some (Pbuiltin ef args res) -> eval_builtin_args ge rs (rs RSP) m args vargs -> external_call ef ge vargs m t vres m' -> rs' = nextinstr_nf (set_res res vres (undef_regs (map preg_of (destroyed_by_builtin ef)) rs)) -> step (State rs m) t (State rs' m') | exec_step_external: forall b ef args res rs m t rs' m', rs PC = Vptr b Ptrofs.zero -> Genv.find_funct_ptr ge b = Some (External ef) -> extcall_arguments rs m (ef_sig ef) args -> external_call ef ge args m t res m' -> rs' = (set_pair (loc_external_result (ef_sig ef)) res (undef_caller_save_regs rs)) #PC <- (rs RA) -> step (State rs m) t (State rs' m').",
            "VernacInductive",
            "66e9c084d3dbac84d65410e04dbb7d602568c7e3"
        ],
        [
            "End RELSEM.",
            "VernacEndSegment",
            "5456b4faa708cb7309b5b1832a554cb5674e5dd1"
        ],
        [
            "Inductive initial_state (p: program): state -> Prop := | initial_state_intro: forall m0, Genv.init_mem p = Some m0 -> let ge := Genv.globalenv p in let rs0 := (Pregmap.init Vundef) # PC <- (Genv.symbol_address ge p.(prog_main) Ptrofs.zero) # RA <- Vnullptr # RSP <- Vnullptr in initial_state p (State rs0 m0).",
            "VernacInductive",
            "b6c264644f35d9ed4fd4d5c8d29d455a23c0d643"
        ],
        [
            "Inductive final_state: state -> int -> Prop := | final_state_intro: forall rs m r, rs#PC = Vnullptr -> rs#RAX = Vint r -> final_state (State rs m) r.",
            "VernacInductive",
            "41ff17e3f735209fc1fa6defadeb24e97768a283"
        ],
        [
            "Definition semantics (p: program) := Semantics step (initial_state p) final_state (Genv.globalenv p).",
            "VernacDefinition",
            "ea50aca4c4f5ef70e455221b5ef33d1d328493b4"
        ],
        [
            "Remark extcall_arguments_determ: forall rs m sg args1 args2, extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2.",
            "VernacStartTheoremProof",
            "0f3268c7d775662aa9024e24375b60075609433c"
        ],
        [
            "intros until m.",
            "VernacExtend",
            "2300f96ca7e85976c805b4d0d06b3983c4f22278"
        ],
        [
            "assert (A: forall l v1 v2, extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2).",
            "VernacExtend",
            "95edb81bd45597181a92e960a7f6685d07971d7c"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inv H; inv H0; congruence.",
            "VernacExtend",
            "314274c625bb380681485166b870c11eb8f09ff3"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "assert (B: forall p v1 v2, extcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2).",
            "VernacExtend",
            "3229394404bffde87ff651e9c923ec50887ed1ca"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inv H; inv H0.",
            "VernacExtend",
            "082d940903d796c6497571a56c1c3caf675f5e8d"
        ],
        [
            "eapply A; eauto.",
            "VernacExtend",
            "9b924320e329fc6ac1e04403134f32fc478929d0"
        ],
        [
            "f_equal; eapply A; eauto.",
            "VernacExtend",
            "41ad4a6b0775a65a3746302746d8f39ab687145e"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "assert (C: forall ll vl1, list_forall2 (extcall_arg_pair rs m) ll vl1 -> forall vl2, list_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2).",
            "VernacExtend",
            "1212bc64eb2e0d81d8d8d51e777211255e1fc043"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "induction 1; intros vl2 EA; inv EA.",
            "VernacExtend",
            "9822f0c629080c2a14392f948e3aaf5bdeeae261"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "f_equal; eauto.",
            "VernacExtend",
            "0aaae116840c77af05ab473518cd728dcb792af6"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "eapply C; eauto.",
            "VernacExtend",
            "5b64c35a722dcddc5ae7553a29e7ee2c1b550426"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma semantics_determinate: forall p, determinate (semantics p).",
            "VernacStartTheoremProof",
            "6c795fe7bf7092028e0479d7f8bf1724093c716e"
        ],
        [
            "Ltac Equalities := match goal with | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] => rewrite H1 in H2; inv H2; Equalities | _ => idtac end.",
            "VernacExtend",
            "b90686e6ff5c48b10e91a36249b6c7cf44e35500"
        ],
        [
            "intros; constructor; simpl; intros.",
            "VernacExtend",
            "29a4a77048790ae35538f487f15c32bf1728ce6b"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "inv H; inv H0; Equalities.",
            "VernacExtend",
            "ad2c630542971f916c4f2d37172973a8772ac5d5"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "constructor.",
            "VernacExtend",
            "3c77e6be855b5086df5e918bf2a0537e1010479a"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "assert (vargs0 = vargs) by (eapply eval_builtin_args_determ; eauto).",
            "VernacExtend",
            "8c06743bab4fa1a0b191c7664aa108c6e3d5a515"
        ],
        [
            "subst vargs0.",
            "VernacExtend",
            "46fbe9323b1a3b6ef6bb6cc732e13a7a95641c76"
        ],
        [
            "exploit external_call_determ.",
            "VernacExtend",
            "d3874e116ff9221ac3229b9c2e1563ba19acf7f6"
        ],
        [
            "eexact H5.",
            "VernacExtend",
            "2d68beb655110f1eb99e8e5d133a86c67bd2671e"
        ],
        [
            "eexact H11.",
            "VernacExtend",
            "581061b0b9e3e4514d88ec1bbe28fa40b3ebf3e8"
        ],
        [
            "intros [A B].",
            "VernacExtend",
            "269ecc1b12a78cad85161d58003fb0ebdea8ebc3"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct B; auto.",
            "VernacExtend",
            "5fb8990d0cc2b5f0d474b772ae3e261572571504"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "+",
            "VernacBullet",
            "3ddfc0515f916e562bacf863647e0107cb15aa13"
        ],
        [
            "assert (args0 = args) by (eapply extcall_arguments_determ; eauto).",
            "VernacExtend",
            "4cdee683956f80e403385387af628f82260703e8"
        ],
        [
            "subst args0.",
            "VernacExtend",
            "85e824898f05daa30f36548ddb5bc171b1d13cbc"
        ],
        [
            "exploit external_call_determ.",
            "VernacExtend",
            "d3874e116ff9221ac3229b9c2e1563ba19acf7f6"
        ],
        [
            "eexact H4.",
            "VernacExtend",
            "f3463fda67184e4a52445b6a2bb5300191542e62"
        ],
        [
            "eexact H9.",
            "VernacExtend",
            "5c79aaf24855cc8025e01368525d0b6dc0c796d3"
        ],
        [
            "intros [A B].",
            "VernacExtend",
            "269ecc1b12a78cad85161d58003fb0ebdea8ebc3"
        ],
        [
            "split.",
            "VernacExtend",
            "55abc140132bd88981001ac656020469a8d503eb"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct B; auto.",
            "VernacExtend",
            "5fb8990d0cc2b5f0d474b772ae3e261572571504"
        ],
        [
            "subst.",
            "VernacExtend",
            "ccc9cb848804101be22a0bb6c324861981c5c7f1"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "red; intros; inv H; simpl.",
            "VernacExtend",
            "20312836be999076addf5d6e785b0f2ae09e125d"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "eapply external_call_trace_length; eauto.",
            "VernacExtend",
            "fc64ba54b5a49450d119093603ca66dec9a15f8d"
        ],
        [
            "eapply external_call_trace_length; eauto.",
            "VernacExtend",
            "fc64ba54b5a49450d119093603ca66dec9a15f8d"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "inv H; inv H0.",
            "VernacExtend",
            "082d940903d796c6497571a56c1c3caf675f5e8d"
        ],
        [
            "f_equal.",
            "VernacExtend",
            "dfce814d1efcef60f8330516ad88155a3a5ec317"
        ],
        [
            "congruence.",
            "VernacExtend",
            "d8c818f6cffeaee6a722a71acc77f2d6e5199eb9"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "assert (NOTNULL: forall b ofs, Vnullptr <> Vptr b ofs).",
            "VernacExtend",
            "3739ada5b048d626bdc6c4e6185942b876299f19"
        ],
        [
            "{",
            "VernacSubproof",
            "184cabd02aa0a33f23f10474ea95789b1f149361"
        ],
        [
            "intros; unfold Vnullptr; destruct Archi.ptr64; congruence.",
            "VernacExtend",
            "5644d65f61ff525cde95e9982a8624981bd0abe1"
        ],
        [
            "}",
            "VernacEndSubproof",
            "85f27874ef16421341373f4b062b6d1605043af9"
        ],
        [
            "inv H.",
            "VernacExtend",
            "711efba707a6a75ce2cd6ff4b80f031c0d63ab98"
        ],
        [
            "red; intros; red; intros.",
            "VernacExtend",
            "fb480e2c66195204c872578c19e43aa4ed49e216"
        ],
        [
            "inv H; rewrite H0 in *; eelim NOTNULL; eauto.",
            "VernacExtend",
            "5cacef4a6c705be526fe769cb8d081472d851259"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "inv H; inv H0.",
            "VernacExtend",
            "082d940903d796c6497571a56c1c3caf675f5e8d"
        ],
        [
            "congruence.",
            "VernacExtend",
            "d8c818f6cffeaee6a722a71acc77f2d6e5199eb9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition data_preg (r: preg) : bool := match r with | PC => false | IR _ => true | FR _ => true | ST0 => true | CR _ => false | RA => false end.",
            "VernacDefinition",
            "bd9f725cefcbfc05921977c30129c24105ecbc8f"
        ]
    ],
    "proofs": [
        {
            "name": "ireg_eq",
            "line_nb": 5,
            "steps": [
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "freg_eq",
            "line_nb": 8,
            "steps": [
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "preg_eq",
            "line_nb": 25,
            "steps": [
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "apply ireg_eq.",
                        "VernacExtend",
                        "f09307906da7b3ca8c9fdf2ef3c0a69358899ce2"
                    ]
                },
                {
                    "command": [
                        "apply freg_eq.",
                        "VernacExtend",
                        "eb5566fc8d55300e43b4163480cd9c79e8398757"
                    ]
                },
                {
                    "command": [
                        "decide equality.",
                        "VernacExtend",
                        "10aba07d521545accbb51a4c2e0695a9ddce3199"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "is_label_correct",
            "line_nb": 47,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "destruct instr; simpl; try discriminate.",
                        "VernacExtend",
                        "69eb2b76ff74e79d3df1681b795dbcd9a14f383b"
                    ]
                },
                {
                    "command": [
                        "case (peq lbl l); intro; congruence.",
                        "VernacExtend",
                        "879442c196163a9742376276714507f7b5709f97"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "extcall_arguments_determ",
            "line_nb": 81,
            "steps": [
                {
                    "command": [
                        "intros until m.",
                        "VernacExtend",
                        "2300f96ca7e85976c805b4d0d06b3983c4f22278"
                    ]
                },
                {
                    "command": [
                        "assert (A: forall l v1 v2, extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2).",
                        "VernacExtend",
                        "95edb81bd45597181a92e960a7f6685d07971d7c"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "inv H; inv H0; congruence.",
                        "VernacExtend",
                        "314274c625bb380681485166b870c11eb8f09ff3"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "assert (B: forall p v1 v2, extcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2).",
                        "VernacExtend",
                        "3229394404bffde87ff651e9c923ec50887ed1ca"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "inv H; inv H0.",
                        "VernacExtend",
                        "082d940903d796c6497571a56c1c3caf675f5e8d"
                    ]
                },
                {
                    "command": [
                        "eapply A; eauto.",
                        "VernacExtend",
                        "9b924320e329fc6ac1e04403134f32fc478929d0"
                    ]
                },
                {
                    "command": [
                        "f_equal; eapply A; eauto.",
                        "VernacExtend",
                        "41ad4a6b0775a65a3746302746d8f39ab687145e"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "assert (C: forall ll vl1, list_forall2 (extcall_arg_pair rs m) ll vl1 -> forall vl2, list_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2).",
                        "VernacExtend",
                        "1212bc64eb2e0d81d8d8d51e777211255e1fc043"
                    ]
                },
                {
                    "command": [
                        "{",
                        "VernacSubproof",
                        "184cabd02aa0a33f23f10474ea95789b1f149361"
                    ]
                },
                {
                    "command": [
                        "induction 1; intros vl2 EA; inv EA.",
                        "VernacExtend",
                        "9822f0c629080c2a14392f948e3aaf5bdeeae261"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "f_equal; eauto.",
                        "VernacExtend",
                        "0aaae116840c77af05ab473518cd728dcb792af6"
                    ]
                },
                {
                    "command": [
                        "}",
                        "VernacEndSubproof",
                        "85f27874ef16421341373f4b062b6d1605043af9"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "eapply C; eauto.",
                        "VernacExtend",
                        "5b64c35a722dcddc5ae7553a29e7ee2c1b550426"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}