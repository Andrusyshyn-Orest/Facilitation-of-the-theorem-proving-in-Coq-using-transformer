{
    "filename": "backend/CminorSel.v",
    "coq_project": "CompCert",
    "vernac_cmds": [
        [
            "Require Import Coqlib.",
            "VernacRequire",
            "bbbe15041aca3a03300067f7acd445b462d537cc"
        ],
        [
            "Require Import Maps.",
            "VernacRequire",
            "f9a27637102e60e06a3c1ceb5a01819e80b9f645"
        ],
        [
            "Require Import AST.",
            "VernacRequire",
            "d103ecb096c06f34167fba01dd861491b0d5e84e"
        ],
        [
            "Require Import Integers.",
            "VernacRequire",
            "688f068e3335df7950b569ef75a5e993414c9874"
        ],
        [
            "Require Import Events.",
            "VernacRequire",
            "8d12cd63a382accc976f222cc44b7a14814a06b9"
        ],
        [
            "Require Import Values.",
            "VernacRequire",
            "f69762569c40def2ecf819f8117763d2ee924d2a"
        ],
        [
            "Require Import Memory.",
            "VernacRequire",
            "2705b33fd6d3e12818791c70e219eee6a06d5191"
        ],
        [
            "Require Import Cminor.",
            "VernacRequire",
            "2bce6485ead42145fdc91dc6fe8893872f42f62e"
        ],
        [
            "Require Import Op.",
            "VernacRequire",
            "ade4899dcb267df47fd0e69e3c413086816e6a6f"
        ],
        [
            "Require Import Globalenvs.",
            "VernacRequire",
            "04fc9ef3af45317f021e6c5326bb64982be447d7"
        ],
        [
            "Require Import Smallstep.",
            "VernacRequire",
            "84c69dcbdb1069c688ce977fea648ae7688f06a8"
        ],
        [
            "Inductive expr : Type := | Evar : ident -> expr | Eop : operation -> exprlist -> expr | Eload : memory_chunk -> addressing -> exprlist -> expr | Econdition : condexpr -> expr -> expr -> expr | Elet : expr -> expr -> expr | Eletvar : nat -> expr | Ebuiltin : external_function -> exprlist -> expr | Eexternal : ident -> signature -> exprlist -> expr with exprlist : Type := | Enil: exprlist | Econs: expr -> exprlist -> exprlist with condexpr : Type := | CEcond : condition -> exprlist -> condexpr | CEcondition : condexpr -> condexpr -> condexpr -> condexpr | CElet: expr -> condexpr -> condexpr.",
            "VernacInductive",
            "b3be558f770491c6546e7338f5df570d7dd278b2"
        ],
        [
            "Infix \":::\" := Econs (at level 60, right associativity) : cminorsel_scope.",
            "VernacInfix",
            "9c1e8fdd08ad610a1dce09e3c7ac36d0b112ea11"
        ],
        [
            "Inductive exitexpr : Type := | XEexit: nat -> exitexpr | XEjumptable: expr -> list nat -> exitexpr | XEcondition: condexpr -> exitexpr -> exitexpr -> exitexpr | XElet: expr -> exitexpr -> exitexpr.",
            "VernacInductive",
            "ac243314e0fb6239607a1005e8f61107f3b4129f"
        ],
        [
            "Inductive stmt : Type := | Sskip: stmt | Sassign : ident -> expr -> stmt | Sstore : memory_chunk -> addressing -> exprlist -> expr -> stmt | Scall : option ident -> signature -> expr + ident -> exprlist -> stmt | Stailcall: signature -> expr + ident -> exprlist -> stmt | Sbuiltin : builtin_res ident -> external_function -> list (builtin_arg expr) -> stmt | Sseq: stmt -> stmt -> stmt | Sifthenelse: condexpr -> stmt -> stmt -> stmt | Sloop: stmt -> stmt | Sblock: stmt -> stmt | Sexit: nat -> stmt | Sswitch: exitexpr -> stmt | Sreturn: option expr -> stmt | Slabel: label -> stmt -> stmt | Sgoto: label -> stmt.",
            "VernacInductive",
            "9f29b90b32aa3f3751bc2c181f85ffa3c6c67502"
        ],
        [
            "Record function : Type := mkfunction { fn_sig: signature; fn_params: list ident; fn_vars: list ident; fn_stackspace: Z; fn_body: stmt }.",
            "VernacInductive",
            "d9f82ca7b71dae7a587e73023a7ad8776a9b5115"
        ],
        [
            "Definition fundef := AST.fundef function.",
            "VernacDefinition",
            "9cf622c746a9b58a51cebc97469342b997e49284"
        ],
        [
            "Definition program := AST.program fundef unit.",
            "VernacDefinition",
            "cfadb9a12e6df9faa40df706d0e99e4d4aa89bc3"
        ],
        [
            "Definition funsig (fd: fundef) := match fd with | Internal f => fn_sig f | External ef => ef_sig ef end.",
            "VernacDefinition",
            "3019fbefbd0cd5f95111e16722a932ed704587d5"
        ],
        [
            "Definition genv := Genv.t fundef unit.",
            "VernacDefinition",
            "558ae6d6506288d7eeb39bb497dd26e4fa2a28e4"
        ],
        [
            "Definition letenv := list val.",
            "VernacDefinition",
            "5bf60dfaa5ed67f9e25af019874f54889aa9a689"
        ],
        [
            "Inductive cont: Type := | Kstop: cont | Kseq: stmt -> cont -> cont | Kblock: cont -> cont | Kcall: option ident -> function -> val -> env -> cont -> cont.",
            "VernacInductive",
            "24f93bba652c4a05e9973f1cb36ba43d964300b6"
        ],
        [
            "Inductive state: Type := | State: forall (f: function) (s: stmt) (k: cont) (sp: val) (e: env) (m: mem), state | Callstate: forall (f: fundef) (args: list val) (k: cont) (m: mem), state | Returnstate: forall (v: val) (k: cont) (m: mem), state.",
            "VernacInductive",
            "9604e5b87907a3201ec0152193d12eb2e756cc1f"
        ],
        [
            "Section RELSEM.",
            "VernacBeginSection",
            "56cea622d6c9a9251b433cfd4de33058b7d80bb5"
        ],
        [
            "Variable ge: genv.",
            "VernacAssumption",
            "5dcbd76196753bb6e2da03561ae76151d62a94d8"
        ],
        [
            "Section EVAL_EXPR.",
            "VernacBeginSection",
            "19acab3de7ff2904e64052b15e0c53a67d401973"
        ],
        [
            "Variable sp: val.",
            "VernacAssumption",
            "b2e20427c402e8af5ba5f5d0ebd2eec1f2cc6944"
        ],
        [
            "Variable e: env.",
            "VernacAssumption",
            "246a24d9eb5be930b928cc64176ad206a11440ce"
        ],
        [
            "Variable m: mem.",
            "VernacAssumption",
            "253337f404928b0a16b3940626ec20c52cfd3aad"
        ],
        [
            "Inductive eval_expr: letenv -> expr -> val -> Prop := | eval_Evar: forall le id v, PTree.get id e = Some v -> eval_expr le (Evar id) v | eval_Eop: forall le op al vl v, eval_exprlist le al vl -> eval_operation ge sp op vl m = Some v -> eval_expr le (Eop op al) v | eval_Eload: forall le chunk addr al vl vaddr v, eval_exprlist le al vl -> eval_addressing ge sp addr vl = Some vaddr -> Mem.loadv chunk m vaddr = Some v -> eval_expr le (Eload chunk addr al) v | eval_Econdition: forall le a b c va v, eval_condexpr le a va -> eval_expr le (if va then b else c) v -> eval_expr le (Econdition a b c) v | eval_Elet: forall le a b v1 v2, eval_expr le a v1 -> eval_expr (v1 :: le) b v2 -> eval_expr le (Elet a b) v2 | eval_Eletvar: forall le n v, nth_error le n = Some v -> eval_expr le (Eletvar n) v | eval_Ebuiltin: forall le ef al vl v, eval_exprlist le al vl -> external_call ef ge vl m E0 v m -> eval_expr le (Ebuiltin ef al) v | eval_Eexternal: forall le id sg al b ef vl v, Genv.find_symbol ge id = Some b -> Genv.find_funct_ptr ge b = Some (External ef) -> ef_sig ef = sg -> eval_exprlist le al vl -> external_call ef ge vl m E0 v m -> eval_expr le (Eexternal id sg al) v with eval_exprlist: letenv -> exprlist -> list val -> Prop := | eval_Enil: forall le, eval_exprlist le Enil nil | eval_Econs: forall le a1 al v1 vl, eval_expr le a1 v1 -> eval_exprlist le al vl -> eval_exprlist le (Econs a1 al) (v1 :: vl) with eval_condexpr: letenv -> condexpr -> bool -> Prop := | eval_CEcond: forall le cond al vl vb, eval_exprlist le al vl -> eval_condition cond vl m = Some vb -> eval_condexpr le (CEcond cond al) vb | eval_CEcondition: forall le a b c va v, eval_condexpr le a va -> eval_condexpr le (if va then b else c) v -> eval_condexpr le (CEcondition a b c) v | eval_CElet: forall le a b v1 v2, eval_expr le a v1 -> eval_condexpr (v1 :: le) b v2 -> eval_condexpr le (CElet a b) v2.",
            "VernacInductive",
            "b5b641a4c3ca324ac856396ad07048f9122c898f"
        ],
        [
            "Scheme eval_expr_ind3 := Minimality for eval_expr Sort Prop with eval_exprlist_ind3 := Minimality for eval_exprlist Sort Prop with eval_condexpr_ind3 := Minimality for eval_condexpr Sort Prop.",
            "VernacScheme",
            "ccc4df98174ec4bebff53cd64f9361ece895bbe7"
        ],
        [
            "Inductive eval_exitexpr: letenv -> exitexpr -> nat -> Prop := | eval_XEexit: forall le x, eval_exitexpr le (XEexit x) x | eval_XEjumptable: forall le a tbl n x, eval_expr le a (Vint n) -> list_nth_z tbl (Int.unsigned n) = Some x -> eval_exitexpr le (XEjumptable a tbl) x | eval_XEcondition: forall le a b c va x, eval_condexpr le a va -> eval_exitexpr le (if va then b else c) x -> eval_exitexpr le (XEcondition a b c) x | eval_XElet: forall le a b v x, eval_expr le a v -> eval_exitexpr (v :: le) b x -> eval_exitexpr le (XElet a b) x.",
            "VernacInductive",
            "c2398bf587ee575f8c7143d8e76f34b69d1ce37e"
        ],
        [
            "Inductive eval_expr_or_symbol: letenv -> expr + ident -> val -> Prop := | eval_eos_e: forall le e v, eval_expr le e v -> eval_expr_or_symbol le (inl _ e) v | eval_eos_s: forall le id b, Genv.find_symbol ge id = Some b -> eval_expr_or_symbol le (inr _ id) (Vptr b Ptrofs.zero).",
            "VernacInductive",
            "347ced67d50b0e8f8155e006b42e3a53541d1057"
        ],
        [
            "Inductive eval_builtin_arg: builtin_arg expr -> val -> Prop := | eval_BA: forall a v, eval_expr nil a v -> eval_builtin_arg (BA a) v | eval_BA_int: forall n, eval_builtin_arg (BA_int n) (Vint n) | eval_BA_long: forall n, eval_builtin_arg (BA_long n) (Vlong n) | eval_BA_float: forall n, eval_builtin_arg (BA_float n) (Vfloat n) | eval_BA_single: forall n, eval_builtin_arg (BA_single n) (Vsingle n) | eval_BA_loadstack: forall chunk ofs v, Mem.loadv chunk m (Val.offset_ptr sp ofs) = Some v -> eval_builtin_arg (BA_loadstack chunk ofs) v | eval_BA_addrstack: forall ofs, eval_builtin_arg (BA_addrstack ofs) (Val.offset_ptr sp ofs) | eval_BA_loadglobal: forall chunk id ofs v, Mem.loadv chunk m (Genv.symbol_address ge id ofs) = Some v -> eval_builtin_arg (BA_loadglobal chunk id ofs) v | eval_BA_addrglobal: forall id ofs, eval_builtin_arg (BA_addrglobal id ofs) (Genv.symbol_address ge id ofs) | eval_BA_splitlong: forall a1 a2 v1 v2, eval_expr nil a1 v1 -> eval_expr nil a2 v2 -> eval_builtin_arg (BA_splitlong (BA a1) (BA a2)) (Val.longofwords v1 v2) | eval_BA_addptr: forall a1 v1 a2 v2, eval_builtin_arg a1 v1 -> eval_builtin_arg a2 v2 -> eval_builtin_arg (BA_addptr a1 a2) (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2).",
            "VernacInductive",
            "35b8c75d94721ca54ac88747a569dbe90f52ecef"
        ],
        [
            "End EVAL_EXPR.",
            "VernacEndSegment",
            "3ac164eecd8fdd56f715c627e3a0a5b8dcdceb23"
        ],
        [
            "Definition set_builtin_res (res: builtin_res ident) (v: val) (e: env) : env := match res with | BR id => PTree.set id v e | _ => e end.",
            "VernacDefinition",
            "fa4bbb5f7593f9bcaaf3080add647592c9504fdd"
        ],
        [
            "Fixpoint call_cont (k: cont) : cont := match k with | Kseq s k => call_cont k | Kblock k => call_cont k | _ => k end.",
            "VernacFixpoint",
            "b5f2c507698ae7af3b007922b072c1eaea4236a2"
        ],
        [
            "Definition is_call_cont (k: cont) : Prop := match k with | Kstop => True | Kcall _ _ _ _ _ => True | _ => False end.",
            "VernacDefinition",
            "01cf6b0b307893ab5b62adfd4fdfebafa0d295e7"
        ],
        [
            "Fixpoint find_label (lbl: label) (s: stmt) (k: cont) {struct s}: option (stmt * cont) := match s with | Sseq s1 s2 => match find_label lbl s1 (Kseq s2 k) with | Some sk => Some sk | None => find_label lbl s2 k end | Sifthenelse c s1 s2 => match find_label lbl s1 k with | Some sk => Some sk | None => find_label lbl s2 k end | Sloop s1 => find_label lbl s1 (Kseq (Sloop s1) k) | Sblock s1 => find_label lbl s1 (Kblock k) | Slabel lbl' s' => if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k | _ => None end.",
            "VernacFixpoint",
            "9f9920c3d25dfcaae6a6a1f87a4ab6c6599a292a"
        ],
        [
            "Inductive step: state -> trace -> state -> Prop := | step_skip_seq: forall f s k sp e m, step (State f Sskip (Kseq s k) sp e m) E0 (State f s k sp e m) | step_skip_block: forall f k sp e m, step (State f Sskip (Kblock k) sp e m) E0 (State f Sskip k sp e m) | step_skip_call: forall f k sp e m m', is_call_cont k -> Mem.free m sp 0 f.(fn_stackspace) = Some m' -> step (State f Sskip k (Vptr sp Ptrofs.zero) e m) E0 (Returnstate Vundef k m') | step_assign: forall f id a k sp e m v, eval_expr sp e m nil a v -> step (State f (Sassign id a) k sp e m) E0 (State f Sskip k sp (PTree.set id v e) m) | step_store: forall f chunk addr al b k sp e m vl v vaddr m', eval_exprlist sp e m nil al vl -> eval_expr sp e m nil b v -> eval_addressing ge sp addr vl = Some vaddr -> Mem.storev chunk m vaddr v = Some m' -> step (State f (Sstore chunk addr al b) k sp e m) E0 (State f Sskip k sp e m') | step_call: forall f optid sig a bl k sp e m vf vargs fd, eval_expr_or_symbol sp e m nil a vf -> eval_exprlist sp e m nil bl vargs -> Genv.find_funct ge vf = Some fd -> funsig fd = sig -> step (State f (Scall optid sig a bl) k sp e m) E0 (Callstate fd vargs (Kcall optid f sp e k) m) | step_tailcall: forall f sig a bl k sp e m vf vargs fd m', eval_expr_or_symbol (Vptr sp Ptrofs.zero) e m nil a vf -> eval_exprlist (Vptr sp Ptrofs.zero) e m nil bl vargs -> Genv.find_funct ge vf = Some fd -> funsig fd = sig -> Mem.free m sp 0 f.(fn_stackspace) = Some m' -> step (State f (Stailcall sig a bl) k (Vptr sp Ptrofs.zero) e m) E0 (Callstate fd vargs (call_cont k) m') | step_builtin: forall f res ef al k sp e m vl t v m', list_forall2 (eval_builtin_arg sp e m) al vl -> external_call ef ge vl m t v m' -> step (State f (Sbuiltin res ef al) k sp e m) t (State f Sskip k sp (set_builtin_res res v e) m') | step_seq: forall f s1 s2 k sp e m, step (State f (Sseq s1 s2) k sp e m) E0 (State f s1 (Kseq s2 k) sp e m) | step_ifthenelse: forall f c s1 s2 k sp e m b, eval_condexpr sp e m nil c b -> step (State f (Sifthenelse c s1 s2) k sp e m) E0 (State f (if b then s1 else s2) k sp e m) | step_loop: forall f s k sp e m, step (State f (Sloop s) k sp e m) E0 (State f s (Kseq (Sloop s) k) sp e m) | step_block: forall f s k sp e m, step (State f (Sblock s) k sp e m) E0 (State f s (Kblock k) sp e m) | step_exit_seq: forall f n s k sp e m, step (State f (Sexit n) (Kseq s k) sp e m) E0 (State f (Sexit n) k sp e m) | step_exit_block_0: forall f k sp e m, step (State f (Sexit O) (Kblock k) sp e m) E0 (State f Sskip k sp e m) | step_exit_block_S: forall f n k sp e m, step (State f (Sexit (S n)) (Kblock k) sp e m) E0 (State f (Sexit n) k sp e m) | step_switch: forall f a k sp e m n, eval_exitexpr sp e m nil a n -> step (State f (Sswitch a) k sp e m) E0 (State f (Sexit n) k sp e m) | step_return_0: forall f k sp e m m', Mem.free m sp 0 f.(fn_stackspace) = Some m' -> step (State f (Sreturn None) k (Vptr sp Ptrofs.zero) e m) E0 (Returnstate Vundef (call_cont k) m') | step_return_1: forall f a k sp e m v m', eval_expr (Vptr sp Ptrofs.zero) e m nil a v -> Mem.free m sp 0 f.(fn_stackspace) = Some m' -> step (State f (Sreturn (Some a)) k (Vptr sp Ptrofs.zero) e m) E0 (Returnstate v (call_cont k) m') | step_label: forall f lbl s k sp e m, step (State f (Slabel lbl s) k sp e m) E0 (State f s k sp e m) | step_goto: forall f lbl k sp e m s' k', find_label lbl f.(fn_body) (call_cont k) = Some(s', k') -> step (State f (Sgoto lbl) k sp e m) E0 (State f s' k' sp e m) | step_internal_function: forall f vargs k m m' sp e, Mem.alloc m 0 f.(fn_stackspace) = (m', sp) -> set_locals f.(fn_vars) (set_params vargs f.(fn_params)) = e -> step (Callstate (Internal f) vargs k m) E0 (State f f.(fn_body) k (Vptr sp Ptrofs.zero) e m') | step_external_function: forall ef vargs k m t vres m', external_call ef ge vargs m t vres m' -> step (Callstate (External ef) vargs k m) t (Returnstate vres k m') | step_return: forall v optid f sp e k m, step (Returnstate v (Kcall optid f sp e k) m) E0 (State f Sskip k sp (set_optvar optid v e) m).",
            "VernacInductive",
            "33ffcba1ae062b9ed878c14404af0fb139e70530"
        ],
        [
            "End RELSEM.",
            "VernacEndSegment",
            "5456b4faa708cb7309b5b1832a554cb5674e5dd1"
        ],
        [
            "Inductive initial_state (p: program): state -> Prop := | initial_state_intro: forall b f m0, let ge := Genv.globalenv p in Genv.init_mem p = Some m0 -> Genv.find_symbol ge p.(prog_main) = Some b -> Genv.find_funct_ptr ge b = Some f -> funsig f = signature_main -> initial_state p (Callstate f nil Kstop m0).",
            "VernacInductive",
            "85d1222d1e0fdc34219430004f55a93c5ca6fa16"
        ],
        [
            "Inductive final_state: state -> int -> Prop := | final_state_intro: forall r m, final_state (Returnstate (Vint r) Kstop m) r.",
            "VernacInductive",
            "75fe23adc0c3ad2f7f029f008cf5f90d4e98c2dc"
        ],
        [
            "Definition semantics (p: program) := Semantics step (initial_state p) final_state (Genv.globalenv p).",
            "VernacDefinition",
            "ea50aca4c4f5ef70e455221b5ef33d1d328493b4"
        ],
        [
            "Hint Constructors eval_expr eval_exprlist eval_condexpr: evalexpr.",
            "VernacHints",
            "d723ca89d40ec1321c8bcfd15c58dfe89278df73"
        ],
        [
            "Fixpoint lift_expr (p: nat) (a: expr) {struct a}: expr := match a with | Evar id => Evar id | Eop op bl => Eop op (lift_exprlist p bl) | Eload chunk addr bl => Eload chunk addr (lift_exprlist p bl) | Econdition a b c => Econdition (lift_condexpr p a) (lift_expr p b) (lift_expr p c) | Elet b c => Elet (lift_expr p b) (lift_expr (S p) c) | Eletvar n => if le_gt_dec p n then Eletvar (S n) else Eletvar n | Ebuiltin ef bl => Ebuiltin ef (lift_exprlist p bl) | Eexternal id sg bl => Eexternal id sg (lift_exprlist p bl) end with lift_exprlist (p: nat) (a: exprlist) {struct a}: exprlist := match a with | Enil => Enil | Econs b cl => Econs (lift_expr p b) (lift_exprlist p cl) end with lift_condexpr (p: nat) (a: condexpr) {struct a}: condexpr := match a with | CEcond c al => CEcond c (lift_exprlist p al) | CEcondition a b c => CEcondition (lift_condexpr p a) (lift_condexpr p b) (lift_condexpr p c) | CElet a b => CElet (lift_expr p a) (lift_condexpr (S p) b) end.",
            "VernacFixpoint",
            "b0dd00e6125e7b0255cda790d4b999c673a5601f"
        ],
        [
            "Definition lift (a: expr): expr := lift_expr O a.",
            "VernacDefinition",
            "1f9764fa306ba8649a9a42ce97d02d30bdf84340"
        ],
        [
            "Inductive insert_lenv: letenv -> nat -> val -> letenv -> Prop := | insert_lenv_0: forall le v, insert_lenv le O v (v :: le) | insert_lenv_S: forall le p w le' v, insert_lenv le p w le' -> insert_lenv (v :: le) (S p) w (v :: le').",
            "VernacInductive",
            "a12232f6446fa4699736a031a1f7fd17fa4baf00"
        ],
        [
            "Lemma insert_lenv_lookup1: forall le p w le', insert_lenv le p w le' -> forall n v, nth_error le n = Some v -> (p > n)%nat -> nth_error le' n = Some v.",
            "VernacStartTheoremProof",
            "012b3e45d919ac9666f7d8a76a44667221403053"
        ],
        [
            "induction 1; intros.",
            "VernacExtend",
            "176684f910d62ec20fbc75549575bf1cd34fa8ec"
        ],
        [
            "omegaContradiction.",
            "VernacExtend",
            "329a0d87fada76e54a403fa49705e937670711cd"
        ],
        [
            "destruct n; simpl; simpl in H0.",
            "VernacExtend",
            "992c8fcbc371f2781df9d0edd992907c0bea161b"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "apply IHinsert_lenv.",
            "VernacExtend",
            "ec53715686c5b92c8a69c9b621a33047b13653c7"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma insert_lenv_lookup2: forall le p w le', insert_lenv le p w le' -> forall n v, nth_error le n = Some v -> (p <= n)%nat -> nth_error le' (S n) = Some v.",
            "VernacStartTheoremProof",
            "b9e49e0fdddf71323dcaf3351e2dc44ec29da7b8"
        ],
        [
            "induction 1; intros.",
            "VernacExtend",
            "176684f910d62ec20fbc75549575bf1cd34fa8ec"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "assumption.",
            "VernacExtend",
            "41f0308313ff87e6ab2782f90d6021ec4b55d932"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "destruct n.",
            "VernacExtend",
            "1582bf847770c098bee882393a48b146dcc37a8c"
        ],
        [
            "omegaContradiction.",
            "VernacExtend",
            "329a0d87fada76e54a403fa49705e937670711cd"
        ],
        [
            "apply IHinsert_lenv.",
            "VernacExtend",
            "ec53715686c5b92c8a69c9b621a33047b13653c7"
        ],
        [
            "exact H0.",
            "VernacExtend",
            "3920fece303e3c4728f9cdc71daff99239237dbd"
        ],
        [
            "omega.",
            "VernacExtend",
            "32c6c865d255452c7e10c77111456d1981cede39"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eval_lift_expr: forall ge sp e m w le a v, eval_expr ge sp e m le a v -> forall p le', insert_lenv le p w le' -> eval_expr ge sp e m le' (lift_expr p a) v.",
            "VernacStartTheoremProof",
            "355833b61133b93e5bf9e3572c32af9a773edbb8"
        ],
        [
            "intros until w.",
            "VernacExtend",
            "288abfc2cf672aa6f6f67712b82872fa3d099169"
        ],
        [
            "apply (eval_expr_ind3 ge sp e m (fun le a v => forall p le', insert_lenv le p w le' -> eval_expr ge sp e m le' (lift_expr p a) v) (fun le al vl => forall p le', insert_lenv le p w le' -> eval_exprlist ge sp e m le' (lift_exprlist p al) vl) (fun le a b => forall p le', insert_lenv le p w le' -> eval_condexpr ge sp e m le' (lift_condexpr p a) b)); simpl; intros; eauto with evalexpr.",
            "VernacExtend",
            "50e77beae429ce494170e250ecee314f3d30f168"
        ],
        [
            "eapply eval_Econdition; eauto.",
            "VernacExtend",
            "ecd1c021c922268ffc7ced56ff129ce948598207"
        ],
        [
            "destruct va; eauto.",
            "VernacExtend",
            "921020e9e4fbb63a226fbb88246ae271caa65bf7"
        ],
        [
            "eapply eval_Elet.",
            "VernacExtend",
            "7c5996a040046f95cf7e526fefb880a274936c11"
        ],
        [
            "eauto.",
            "VernacExtend",
            "d5f3a05ca887c29bb0b422fc64ae2775fea3935e"
        ],
        [
            "apply H2.",
            "VernacExtend",
            "17101978526a14fb5ad41816224a2fc35cc3d256"
        ],
        [
            "apply insert_lenv_S; auto.",
            "VernacExtend",
            "ae2e94592931bedbd43f4c26a336b9de6ccc5fd1"
        ],
        [
            "case (le_gt_dec p n); intro.",
            "VernacExtend",
            "9946ecdb877b89bb3c31a9ac8f11bada9ad279be"
        ],
        [
            "apply eval_Eletvar.",
            "VernacExtend",
            "7c17aa2c473a919757c2ac85368bd733e9fffe97"
        ],
        [
            "eapply insert_lenv_lookup2; eauto.",
            "VernacExtend",
            "9e371d9f06a1bbd8f7b04ac43a9ca2cdfcfb5a20"
        ],
        [
            "apply eval_Eletvar.",
            "VernacExtend",
            "7c17aa2c473a919757c2ac85368bd733e9fffe97"
        ],
        [
            "eapply insert_lenv_lookup1; eauto.",
            "VernacExtend",
            "6ec3228fcd8bbfd3589c2c38642a821e8f5fa53a"
        ],
        [
            "eapply eval_CEcondition; eauto.",
            "VernacExtend",
            "87f917b29ca0085fdceaaac1e49b44a9ec0a88c1"
        ],
        [
            "destruct va; eauto.",
            "VernacExtend",
            "921020e9e4fbb63a226fbb88246ae271caa65bf7"
        ],
        [
            "eapply eval_CElet; eauto.",
            "VernacExtend",
            "960bfee9e1dca8e929f2e1ac6380dbdf5789b6ba"
        ],
        [
            "apply H2.",
            "VernacExtend",
            "17101978526a14fb5ad41816224a2fc35cc3d256"
        ],
        [
            "constructor; auto.",
            "VernacExtend",
            "686f227fe0f57af60032eb35216aef1e62d0c0e5"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eval_lift: forall ge sp e m le a v w, eval_expr ge sp e m le a v -> eval_expr ge sp e m (w::le) (lift a) v.",
            "VernacStartTheoremProof",
            "35f7a66c0c0e6d0224df0a30f90306e33b922752"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "unfold lift.",
            "VernacExtend",
            "7e0fd6d9f64400444835954fc83d0eb0b32b5a08"
        ],
        [
            "eapply eval_lift_expr.",
            "VernacExtend",
            "e6cc8af49098433cd9b76ec0dbb00f3338f35788"
        ],
        [
            "eexact H.",
            "VernacExtend",
            "c5b6c47c093b83147394b6464b63583df0ea333c"
        ],
        [
            "apply insert_lenv_0.",
            "VernacExtend",
            "1773e70405f807ba694559a9e884f25851ea5d01"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Resolve eval_lift: evalexpr.",
            "VernacHints",
            "8e2ec4db48ac97edccf64b58bc2d2e4e1470d396"
        ]
    ],
    "proofs": [
        {
            "name": "insert_lenv_lookup1",
            "line_nb": 48,
            "steps": [
                {
                    "command": [
                        "induction 1; intros.",
                        "VernacExtend",
                        "176684f910d62ec20fbc75549575bf1cd34fa8ec"
                    ]
                },
                {
                    "command": [
                        "omegaContradiction.",
                        "VernacExtend",
                        "329a0d87fada76e54a403fa49705e937670711cd"
                    ]
                },
                {
                    "command": [
                        "destruct n; simpl; simpl in H0.",
                        "VernacExtend",
                        "992c8fcbc371f2781df9d0edd992907c0bea161b"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "apply IHinsert_lenv.",
                        "VernacExtend",
                        "ec53715686c5b92c8a69c9b621a33047b13653c7"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "omega.",
                        "VernacExtend",
                        "32c6c865d255452c7e10c77111456d1981cede39"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "insert_lenv_lookup2",
            "line_nb": 57,
            "steps": [
                {
                    "command": [
                        "induction 1; intros.",
                        "VernacExtend",
                        "176684f910d62ec20fbc75549575bf1cd34fa8ec"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "assumption.",
                        "VernacExtend",
                        "41f0308313ff87e6ab2782f90d6021ec4b55d932"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "destruct n.",
                        "VernacExtend",
                        "1582bf847770c098bee882393a48b146dcc37a8c"
                    ]
                },
                {
                    "command": [
                        "omegaContradiction.",
                        "VernacExtend",
                        "329a0d87fada76e54a403fa49705e937670711cd"
                    ]
                },
                {
                    "command": [
                        "apply IHinsert_lenv.",
                        "VernacExtend",
                        "ec53715686c5b92c8a69c9b621a33047b13653c7"
                    ]
                },
                {
                    "command": [
                        "exact H0.",
                        "VernacExtend",
                        "3920fece303e3c4728f9cdc71daff99239237dbd"
                    ]
                },
                {
                    "command": [
                        "omega.",
                        "VernacExtend",
                        "32c6c865d255452c7e10c77111456d1981cede39"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}