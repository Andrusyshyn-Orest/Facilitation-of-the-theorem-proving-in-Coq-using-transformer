{
    "filename": "backend/Mach.v",
    "coq_project": "CompCert",
    "vernac_cmds": [
        [
            "Require Import Coqlib.",
            "VernacRequire",
            "bbbe15041aca3a03300067f7acd445b462d537cc"
        ],
        [
            "Require Import Maps.",
            "VernacRequire",
            "f9a27637102e60e06a3c1ceb5a01819e80b9f645"
        ],
        [
            "Require Import AST.",
            "VernacRequire",
            "d103ecb096c06f34167fba01dd861491b0d5e84e"
        ],
        [
            "Require Import Integers.",
            "VernacRequire",
            "688f068e3335df7950b569ef75a5e993414c9874"
        ],
        [
            "Require Import Values.",
            "VernacRequire",
            "f69762569c40def2ecf819f8117763d2ee924d2a"
        ],
        [
            "Require Import Memory.",
            "VernacRequire",
            "2705b33fd6d3e12818791c70e219eee6a06d5191"
        ],
        [
            "Require Import Globalenvs.",
            "VernacRequire",
            "04fc9ef3af45317f021e6c5326bb64982be447d7"
        ],
        [
            "Require Import Events.",
            "VernacRequire",
            "8d12cd63a382accc976f222cc44b7a14814a06b9"
        ],
        [
            "Require Import Smallstep.",
            "VernacRequire",
            "84c69dcbdb1069c688ce977fea648ae7688f06a8"
        ],
        [
            "Require Import Op.",
            "VernacRequire",
            "ade4899dcb267df47fd0e69e3c413086816e6a6f"
        ],
        [
            "Require Import Locations.",
            "VernacRequire",
            "1ceb8afd6877edcf3d0f42dd5c0a0b6d74a958c3"
        ],
        [
            "Require Import Conventions.",
            "VernacRequire",
            "f1826ea15691cda45c441a79f6d3660735f6ecb1"
        ],
        [
            "Require Stacklayout.",
            "VernacRequire",
            "f568bda40113206375f9027f48c58882c8135664"
        ],
        [
            "Definition label := positive.",
            "VernacDefinition",
            "b3ed4a55821db8060cfbffebfd0f3c543b6ea158"
        ],
        [
            "Inductive instruction: Type := | Mgetstack: ptrofs -> typ -> mreg -> instruction | Msetstack: mreg -> ptrofs -> typ -> instruction | Mgetparam: ptrofs -> typ -> mreg -> instruction | Mop: operation -> list mreg -> mreg -> instruction | Mload: memory_chunk -> addressing -> list mreg -> mreg -> instruction | Mstore: memory_chunk -> addressing -> list mreg -> mreg -> instruction | Mcall: signature -> mreg + ident -> instruction | Mtailcall: signature -> mreg + ident -> instruction | Mbuiltin: external_function -> list (builtin_arg mreg) -> builtin_res mreg -> instruction | Mlabel: label -> instruction | Mgoto: label -> instruction | Mcond: condition -> list mreg -> label -> instruction | Mjumptable: mreg -> list label -> instruction | Mreturn: instruction.",
            "VernacInductive",
            "9f779c8ee279b23286055ecf309928c1b5fff416"
        ],
        [
            "Definition code := list instruction.",
            "VernacDefinition",
            "bf10af1cb9540888e9804f1124948b8d224ad655"
        ],
        [
            "Record function: Type := mkfunction { fn_sig: signature; fn_code: code; fn_stacksize: Z; fn_link_ofs: ptrofs; fn_retaddr_ofs: ptrofs }.",
            "VernacInductive",
            "e0eacc25dcd9a2b7456ded160a383090b3db3d36"
        ],
        [
            "Definition fundef := AST.fundef function.",
            "VernacDefinition",
            "9cf622c746a9b58a51cebc97469342b997e49284"
        ],
        [
            "Definition program := AST.program fundef unit.",
            "VernacDefinition",
            "cfadb9a12e6df9faa40df706d0e99e4d4aa89bc3"
        ],
        [
            "Definition funsig (fd: fundef) := match fd with | Internal f => fn_sig f | External ef => ef_sig ef end.",
            "VernacDefinition",
            "3019fbefbd0cd5f95111e16722a932ed704587d5"
        ],
        [
            "Definition genv := Genv.t fundef unit.",
            "VernacDefinition",
            "558ae6d6506288d7eeb39bb497dd26e4fa2a28e4"
        ],
        [
            "Definition load_stack (m: mem) (sp: val) (ty: typ) (ofs: ptrofs) := Mem.loadv (chunk_of_type ty) m (Val.offset_ptr sp ofs).",
            "VernacDefinition",
            "9b424e70d245688e8c0e93153cfc5a8a1afbf3a5"
        ],
        [
            "Definition store_stack (m: mem) (sp: val) (ty: typ) (ofs: ptrofs) (v: val) := Mem.storev (chunk_of_type ty) m (Val.offset_ptr sp ofs) v.",
            "VernacDefinition",
            "e826eed2bbec6ba76ef61010cbe2bcdeb75d3bc1"
        ],
        [
            "Module RegEq.",
            "VernacDefineModule",
            "81ce4dcbed5dd2696786c3f1ef57a6b517b259ce"
        ],
        [
            "Definition t := mreg.",
            "VernacDefinition",
            "1b3fdcd882a832af4e52a8db154f288c0476f625"
        ],
        [
            "Definition eq := mreg_eq.",
            "VernacDefinition",
            "185d088c4523e7ae6112c5f9915c9c403f94a834"
        ],
        [
            "End RegEq.",
            "VernacEndSegment",
            "2d0e786ab3d690f75f51b6228361a38ba23f510c"
        ],
        [
            "Module Regmap := EMap(RegEq).",
            "VernacDefineModule",
            "972f1a9a880ccd1d04efc3fb6647aff4391b5edc"
        ],
        [
            "Definition regset := Regmap.t val.",
            "VernacDefinition",
            "4728a0fded07f8d7323d8a8d957f46a6d56e4a5e"
        ],
        [
            "Notation \"a ## b\" := (List.map a b) (at level 1).",
            "VernacNotation",
            "c94bd4c881eb3e1c195a3d4cd38448326d60a8a1"
        ],
        [
            "Notation \"a # b <- c\" := (Regmap.set b c a) (at level 1, b at next level).",
            "VernacNotation",
            "f267ad61f97908c15f336216ef26314b517d5b42"
        ],
        [
            "Fixpoint undef_regs (rl: list mreg) (rs: regset) {struct rl} : regset := match rl with | nil => rs | r1 :: rl' => Regmap.set r1 Vundef (undef_regs rl' rs) end.",
            "VernacFixpoint",
            "edd1fe1746b368dd0fe0c7132ba732c7fd68226d"
        ],
        [
            "Lemma undef_regs_other: forall r rl rs, ~In r rl -> undef_regs rl rs r = rs r.",
            "VernacStartTheoremProof",
            "d597c5d9dbcd5d47791629a844bc536528480717"
        ],
        [
            "induction rl; simpl; intros.",
            "VernacExtend",
            "93a42d2609122accf03eae47e66d88f36c63f5bd"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "rewrite Regmap.gso.",
            "VernacExtend",
            "debbb756a67cecfdb6f0e8f8567c8d61fc5a4f82"
        ],
        [
            "apply IHrl.",
            "VernacExtend",
            "5367ce6384c0b7c29ba7aebd32a88d1aafdf523d"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "intuition.",
            "VernacExtend",
            "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma undef_regs_same: forall r rl rs, In r rl -> undef_regs rl rs r = Vundef.",
            "VernacStartTheoremProof",
            "4683ce7c255684e683f52805dcd4bd4ccfdbd162"
        ],
        [
            "induction rl; simpl; intros.",
            "VernacExtend",
            "93a42d2609122accf03eae47e66d88f36c63f5bd"
        ],
        [
            "tauto.",
            "VernacExtend",
            "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
        ],
        [
            "destruct H.",
            "VernacExtend",
            "8b2bca015429da94c456243b461e17a2a0582c40"
        ],
        [
            "subst a.",
            "VernacExtend",
            "d7670e5f9c196bd417b16b29da3532f33d34884d"
        ],
        [
            "apply Regmap.gss.",
            "VernacExtend",
            "2bdf34e7b98bf54221cf2922d5b5c0a755636d9d"
        ],
        [
            "unfold Regmap.set.",
            "VernacExtend",
            "8e5f2f777043b40e15dca644b44d2eaa73eb9a62"
        ],
        [
            "destruct (RegEq.eq r a); auto.",
            "VernacExtend",
            "b9533cb79d96a297286aef8ac3f0feec5eaabfbe"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition undef_caller_save_regs (rs: regset) : regset := fun r => if is_callee_save r then rs r else Vundef.",
            "VernacDefinition",
            "401f38bc48af4f81e8a05ebad9021137769f0c03"
        ],
        [
            "Definition set_pair (p: rpair mreg) (v: val) (rs: regset) : regset := match p with | One r => rs#r <- v | Twolong rhi rlo => rs#rhi <- (Val.hiword v) #rlo <- (Val.loword v) end.",
            "VernacDefinition",
            "ee906b5a1a4de3cc3d6848bcf722b68d0f5df122"
        ],
        [
            "Fixpoint set_res (res: builtin_res mreg) (v: val) (rs: regset) : regset := match res with | BR r => Regmap.set r v rs | BR_none => rs | BR_splitlong hi lo => set_res lo (Val.loword v) (set_res hi (Val.hiword v) rs) end.",
            "VernacFixpoint",
            "7b833a37eb213fd0841a7a278f9b0afb73208d0a"
        ],
        [
            "Definition is_label (lbl: label) (instr: instruction) : bool := match instr with | Mlabel lbl' => if peq lbl lbl' then true else false | _ => false end.",
            "VernacDefinition",
            "24183a2528a556b9a051a92c598d2ac85798bca8"
        ],
        [
            "Lemma is_label_correct: forall lbl instr, if is_label lbl instr then instr = Mlabel lbl else instr <> Mlabel lbl.",
            "VernacStartTheoremProof",
            "92cab96b0b19d0ae029c37dcb31dea478885b017"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct instr; simpl; try discriminate.",
            "VernacExtend",
            "69eb2b76ff74e79d3df1681b795dbcd9a14f383b"
        ],
        [
            "case (peq lbl l); intro; congruence.",
            "VernacExtend",
            "879442c196163a9742376276714507f7b5709f97"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint find_label (lbl: label) (c: code) {struct c} : option code := match c with | nil => None | i1 :: il => if is_label lbl i1 then Some il else find_label lbl il end.",
            "VernacFixpoint",
            "94cc2ae168c2b10b5fc9a3722966289ae6788a6e"
        ],
        [
            "Lemma find_label_tail: forall lbl c c', find_label lbl c = Some c' -> is_tail c' c.",
            "VernacStartTheoremProof",
            "d55dc461f3cae169f822a56a4db8d85134388284"
        ],
        [
            "induction c; simpl; intros.",
            "VernacExtend",
            "35ad6631ea868b97a2d7796e2e731fd479dfa24c"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "destruct (is_label lbl a).",
            "VernacExtend",
            "d9bab1a058aead7ca4b9a31b75c5923f2e525b19"
        ],
        [
            "inv H.",
            "VernacExtend",
            "711efba707a6a75ce2cd6ff4b80f031c0d63ab98"
        ],
        [
            "auto with coqlib.",
            "VernacExtend",
            "bf4be239b4d8868fa0ff9785d68d66d28f74c632"
        ],
        [
            "eauto with coqlib.",
            "VernacExtend",
            "936a8c3fe80f3a176ab34cf7ab6314fa7dda6de1"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma find_label_incl: forall lbl c c', find_label lbl c = Some c' -> incl c' c.",
            "VernacStartTheoremProof",
            "7787c89d4b3e41f85635200538c4be4e05a113a8"
        ],
        [
            "intros; red; intros.",
            "VernacExtend",
            "51aeefe3bf0889d494d662b4f3305dd8bbc97324"
        ],
        [
            "eapply is_tail_incl; eauto.",
            "VernacExtend",
            "8b1f2e73145866b6d31eacd8391c1b2baeb5484e"
        ],
        [
            "eapply find_label_tail; eauto.",
            "VernacExtend",
            "074ae5daa44d62e6d68b5f55459014e4deb7b9d7"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Section RELSEM.",
            "VernacBeginSection",
            "56cea622d6c9a9251b433cfd4de33058b7d80bb5"
        ],
        [
            "Variable return_address_offset: function -> code -> ptrofs -> Prop.",
            "VernacAssumption",
            "063f5a931ab5b8670e946cf5b22b23d5999c002b"
        ],
        [
            "Variable ge: genv.",
            "VernacAssumption",
            "5dcbd76196753bb6e2da03561ae76151d62a94d8"
        ],
        [
            "Definition find_function_ptr (ge: genv) (ros: mreg + ident) (rs: regset) : option block := match ros with | inl r => match rs r with | Vptr b ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b else None | _ => None end | inr symb => Genv.find_symbol ge symb end.",
            "VernacDefinition",
            "8b9611127da827b4acde9bd4e1efa11814a686e2"
        ],
        [
            "Inductive extcall_arg (rs: regset) (m: mem) (sp: val): loc -> val -> Prop := | extcall_arg_reg: forall r, extcall_arg rs m sp (R r) (rs r) | extcall_arg_stack: forall ofs ty v, load_stack m sp ty (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs)) = Some v -> extcall_arg rs m sp (S Outgoing ofs ty) v.",
            "VernacInductive",
            "cad8032c76585226590fab4341b62f48d74b80d0"
        ],
        [
            "Inductive extcall_arg_pair (rs: regset) (m: mem) (sp: val): rpair loc -> val -> Prop := | extcall_arg_one: forall l v, extcall_arg rs m sp l v -> extcall_arg_pair rs m sp (One l) v | extcall_arg_twolong: forall hi lo vhi vlo, extcall_arg rs m sp hi vhi -> extcall_arg rs m sp lo vlo -> extcall_arg_pair rs m sp (Twolong hi lo) (Val.longofwords vhi vlo).",
            "VernacInductive",
            "548cffd5778beb8fec82df7f1b222ae1f2149478"
        ],
        [
            "Definition extcall_arguments (rs: regset) (m: mem) (sp: val) (sg: signature) (args: list val) : Prop := list_forall2 (extcall_arg_pair rs m sp) (loc_arguments sg) args.",
            "VernacDefinition",
            "e9f394c3d6022b496eb6ecc134e5c0defca38ad4"
        ],
        [
            "Inductive stackframe: Type := | Stackframe: forall (f: block) (sp: val) (retaddr: val) (c: code), stackframe.",
            "VernacInductive",
            "6d4e0dabf192d482ae24b08db99215242c75392d"
        ],
        [
            "Inductive state: Type := | State: forall (stack: list stackframe) (f: block) (sp: val) (c: code) (rs: regset) (m: mem), state | Callstate: forall (stack: list stackframe) (f: block) (rs: regset) (m: mem), state | Returnstate: forall (stack: list stackframe) (rs: regset) (m: mem), state.",
            "VernacInductive",
            "82342a63d0561f6bb638d518c6959eca1c83e448"
        ],
        [
            "Definition parent_sp (s: list stackframe) : val := match s with | nil => Vnullptr | Stackframe f sp ra c :: s' => sp end.",
            "VernacDefinition",
            "f8004524961897885dfcf9c70604e73ec5050cb7"
        ],
        [
            "Definition parent_ra (s: list stackframe) : val := match s with | nil => Vnullptr | Stackframe f sp ra c :: s' => ra end.",
            "VernacDefinition",
            "40c76562911abb77af544c8ec6f4181c85f8459f"
        ],
        [
            "Inductive step: state -> trace -> state -> Prop := | exec_Mlabel: forall s f sp lbl c rs m, step (State s f sp (Mlabel lbl :: c) rs m) E0 (State s f sp c rs m) | exec_Mgetstack: forall s f sp ofs ty dst c rs m v, load_stack m sp ty ofs = Some v -> step (State s f sp (Mgetstack ofs ty dst :: c) rs m) E0 (State s f sp c (rs#dst <- v) m) | exec_Msetstack: forall s f sp src ofs ty c rs m m' rs', store_stack m sp ty ofs (rs src) = Some m' -> rs' = undef_regs (destroyed_by_setstack ty) rs -> step (State s f sp (Msetstack src ofs ty :: c) rs m) E0 (State s f sp c rs' m') | exec_Mgetparam: forall s fb f sp ofs ty dst c rs m v rs', Genv.find_funct_ptr ge fb = Some (Internal f) -> load_stack m sp Tptr f.(fn_link_ofs) = Some (parent_sp s) -> load_stack m (parent_sp s) ty ofs = Some v -> rs' = (rs # temp_for_parent_frame <- Vundef # dst <- v) -> step (State s fb sp (Mgetparam ofs ty dst :: c) rs m) E0 (State s fb sp c rs' m) | exec_Mop: forall s f sp op args res c rs m v rs', eval_operation ge sp op rs##args m = Some v -> rs' = ((undef_regs (destroyed_by_op op) rs)#res <- v) -> step (State s f sp (Mop op args res :: c) rs m) E0 (State s f sp c rs' m) | exec_Mload: forall s f sp chunk addr args dst c rs m a v rs', eval_addressing ge sp addr rs##args = Some a -> Mem.loadv chunk m a = Some v -> rs' = ((undef_regs (destroyed_by_load chunk addr) rs)#dst <- v) -> step (State s f sp (Mload chunk addr args dst :: c) rs m) E0 (State s f sp c rs' m) | exec_Mstore: forall s f sp chunk addr args src c rs m m' a rs', eval_addressing ge sp addr rs##args = Some a -> Mem.storev chunk m a (rs src) = Some m' -> rs' = undef_regs (destroyed_by_store chunk addr) rs -> step (State s f sp (Mstore chunk addr args src :: c) rs m) E0 (State s f sp c rs' m') | exec_Mcall: forall s fb sp sig ros c rs m f f' ra, find_function_ptr ge ros rs = Some f' -> Genv.find_funct_ptr ge fb = Some (Internal f) -> return_address_offset f c ra -> step (State s fb sp (Mcall sig ros :: c) rs m) E0 (Callstate (Stackframe fb sp (Vptr fb ra) c :: s) f' rs m) | exec_Mtailcall: forall s fb stk soff sig ros c rs m f f' m', find_function_ptr ge ros rs = Some f' -> Genv.find_funct_ptr ge fb = Some (Internal f) -> load_stack m (Vptr stk soff) Tptr f.(fn_link_ofs) = Some (parent_sp s) -> load_stack m (Vptr stk soff) Tptr f.(fn_retaddr_ofs) = Some (parent_ra s) -> Mem.free m stk 0 f.(fn_stacksize) = Some m' -> step (State s fb (Vptr stk soff) (Mtailcall sig ros :: c) rs m) E0 (Callstate s f' rs m') | exec_Mbuiltin: forall s f sp rs m ef args res b vargs t vres rs' m', eval_builtin_args ge rs sp m args vargs -> external_call ef ge vargs m t vres m' -> rs' = set_res res vres (undef_regs (destroyed_by_builtin ef) rs) -> step (State s f sp (Mbuiltin ef args res :: b) rs m) t (State s f sp b rs' m') | exec_Mgoto: forall s fb f sp lbl c rs m c', Genv.find_funct_ptr ge fb = Some (Internal f) -> find_label lbl f.(fn_code) = Some c' -> step (State s fb sp (Mgoto lbl :: c) rs m) E0 (State s fb sp c' rs m) | exec_Mcond_true: forall s fb f sp cond args lbl c rs m c' rs', eval_condition cond rs##args m = Some true -> Genv.find_funct_ptr ge fb = Some (Internal f) -> find_label lbl f.(fn_code) = Some c' -> rs' = undef_regs (destroyed_by_cond cond) rs -> step (State s fb sp (Mcond cond args lbl :: c) rs m) E0 (State s fb sp c' rs' m) | exec_Mcond_false: forall s f sp cond args lbl c rs m rs', eval_condition cond rs##args m = Some false -> rs' = undef_regs (destroyed_by_cond cond) rs -> step (State s f sp (Mcond cond args lbl :: c) rs m) E0 (State s f sp c rs' m) | exec_Mjumptable: forall s fb f sp arg tbl c rs m n lbl c' rs', rs arg = Vint n -> list_nth_z tbl (Int.unsigned n) = Some lbl -> Genv.find_funct_ptr ge fb = Some (Internal f) -> find_label lbl f.(fn_code) = Some c' -> rs' = undef_regs destroyed_by_jumptable rs -> step (State s fb sp (Mjumptable arg tbl :: c) rs m) E0 (State s fb sp c' rs' m) | exec_Mreturn: forall s fb stk soff c rs m f m', Genv.find_funct_ptr ge fb = Some (Internal f) -> load_stack m (Vptr stk soff) Tptr f.(fn_link_ofs) = Some (parent_sp s) -> load_stack m (Vptr stk soff) Tptr f.(fn_retaddr_ofs) = Some (parent_ra s) -> Mem.free m stk 0 f.(fn_stacksize) = Some m' -> step (State s fb (Vptr stk soff) (Mreturn :: c) rs m) E0 (Returnstate s rs m') | exec_function_internal: forall s fb rs m f m1 m2 m3 stk rs', Genv.find_funct_ptr ge fb = Some (Internal f) -> Mem.alloc m 0 f.(fn_stacksize) = (m1, stk) -> let sp := Vptr stk Ptrofs.zero in store_stack m1 sp Tptr f.(fn_link_ofs) (parent_sp s) = Some m2 -> store_stack m2 sp Tptr f.(fn_retaddr_ofs) (parent_ra s) = Some m3 -> rs' = undef_regs destroyed_at_function_entry rs -> step (Callstate s fb rs m) E0 (State s fb sp f.(fn_code) rs' m3) | exec_function_external: forall s fb rs m t rs' ef args res m', Genv.find_funct_ptr ge fb = Some (External ef) -> extcall_arguments rs m (parent_sp s) (ef_sig ef) args -> external_call ef ge args m t res m' -> rs' = set_pair (loc_result (ef_sig ef)) res (undef_caller_save_regs rs) -> step (Callstate s fb rs m) t (Returnstate s rs' m') | exec_return: forall s f sp ra c rs m, step (Returnstate (Stackframe f sp ra c :: s) rs m) E0 (State s f sp c rs m).",
            "VernacInductive",
            "5ae445038ee49c38007a77c0325b260f71e2b4ad"
        ],
        [
            "End RELSEM.",
            "VernacEndSegment",
            "5456b4faa708cb7309b5b1832a554cb5674e5dd1"
        ],
        [
            "Inductive initial_state (p: program): state -> Prop := | initial_state_intro: forall fb m0, let ge := Genv.globalenv p in Genv.init_mem p = Some m0 -> Genv.find_symbol ge p.(prog_main) = Some fb -> initial_state p (Callstate nil fb (Regmap.init Vundef) m0).",
            "VernacInductive",
            "a860bb1f0993ca5f197d90a503b197fdbc233c6c"
        ],
        [
            "Inductive final_state: state -> int -> Prop := | final_state_intro: forall rs m r retcode, loc_result signature_main = One r -> rs r = Vint retcode -> final_state (Returnstate nil rs m) retcode.",
            "VernacInductive",
            "e77a533469daa58eb137cb61485ba8e451723cab"
        ],
        [
            "Definition semantics (rao: function -> code -> ptrofs -> Prop) (p: program) := Semantics (step rao) (initial_state p) final_state (Genv.globalenv p).",
            "VernacDefinition",
            "c0001329ee1477550a72b593b2828d85af5e1a27"
        ],
        [
            "Definition is_leaf_function (f: function) : bool := List.forallb (fun i => match i with Mcall _ _ => false | _ => true end) f.(fn_code).",
            "VernacDefinition",
            "f3edc44e2fa17d1735a2deb1321f330b340a5645"
        ],
        [
            "Section WF_STATES.",
            "VernacBeginSection",
            "4ae5326bf9af017ef923ef01583a94224b038d77"
        ],
        [
            "Variable rao: function -> code -> ptrofs -> Prop.",
            "VernacAssumption",
            "c62e3a83d9217d8ace41107ba014a89cd41d845e"
        ],
        [
            "Variable ge: genv.",
            "VernacAssumption",
            "5dcbd76196753bb6e2da03561ae76151d62a94d8"
        ],
        [
            "Inductive wf_frame: stackframe -> Prop := | wf_stackframe_intro: forall fb sp ra c f (CODE: Genv.find_funct_ptr ge fb = Some (Internal f)) (LEAF: is_leaf_function f = false) (TAIL: is_tail c f.(fn_code)), wf_frame (Stackframe fb sp ra c).",
            "VernacInductive",
            "ce8cb61ccbd0d3f5c5eb7acebeffbb2d21168347"
        ],
        [
            "Inductive wf_state: state -> Prop := | wf_normal_state: forall s fb sp c rs m f (STACK: Forall wf_frame s) (CODE: Genv.find_funct_ptr ge fb = Some (Internal f)) (TAIL: is_tail c f.(fn_code)), wf_state (State s fb sp c rs m) | wf_call_state: forall s fb rs m (STACK: Forall wf_frame s), wf_state (Callstate s fb rs m) | wf_return_state: forall s rs m (STACK: Forall wf_frame s), wf_state (Returnstate s rs m).",
            "VernacInductive",
            "33eddaf0ca8060dd375ff74b8190af3c0d89fbfc"
        ],
        [
            "Lemma wf_step: forall S1 t S2, step rao ge S1 t S2 -> wf_state S1 -> wf_state S2.",
            "VernacStartTheoremProof",
            "7d97cc26ec1463697abe082f52b0a862c0c9e074"
        ],
        [
            "induction 1; intros WF; inv WF; try (econstructor; now eauto with coqlib).",
            "VernacExtend",
            "c35cabe3910acfcc564d6dd0038839705bf0d13e"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "assert (f0 = f) by congruence.",
            "VernacExtend",
            "352ea7d014268f74b09a7cfe257f27309b80fa0c"
        ],
        [
            "subst f0.",
            "VernacExtend",
            "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
        ],
        [
            "constructor.",
            "VernacExtend",
            "3c77e6be855b5086df5e918bf2a0537e1010479a"
        ],
        [
            "constructor; auto.",
            "VernacExtend",
            "686f227fe0f57af60032eb35216aef1e62d0c0e5"
        ],
        [
            "econstructor; eauto with coqlib.",
            "VernacExtend",
            "16e114cab580d38bfe03daa0436d5d4987d2c0d2"
        ],
        [
            "destruct (is_leaf_function f) eqn:E; auto.",
            "VernacExtend",
            "7d3278e1103afd4614429974df5d878dff77a66b"
        ],
        [
            "unfold is_leaf_function in E; rewrite forallb_forall in E.",
            "VernacExtend",
            "4fdac6ef01ace381fe9a0de2ea3bba89d2cd80ed"
        ],
        [
            "symmetry.",
            "VernacExtend",
            "a08fc0dc04bba893008bded8181f393e2d8db167"
        ],
        [
            "apply (E (Mcall sig ros)).",
            "VernacExtend",
            "04b634064e0843a9d297950c1136e9392dfeb952"
        ],
        [
            "eapply is_tail_in; eauto.",
            "VernacExtend",
            "4f04118796a6368f5cab1e87c5ef191ad66fac7f"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "assert (f0 = f) by congruence.",
            "VernacExtend",
            "352ea7d014268f74b09a7cfe257f27309b80fa0c"
        ],
        [
            "subst f0.",
            "VernacExtend",
            "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
        ],
        [
            "econstructor; eauto using find_label_tail.",
            "VernacExtend",
            "a8e3c0cbb9c88303467a2971ab577a3f7a0ec305"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "assert (f0 = f) by congruence.",
            "VernacExtend",
            "352ea7d014268f74b09a7cfe257f27309b80fa0c"
        ],
        [
            "subst f0.",
            "VernacExtend",
            "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
        ],
        [
            "econstructor; eauto using find_label_tail.",
            "VernacExtend",
            "a8e3c0cbb9c88303467a2971ab577a3f7a0ec305"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "assert (f0 = f) by congruence.",
            "VernacExtend",
            "352ea7d014268f74b09a7cfe257f27309b80fa0c"
        ],
        [
            "subst f0.",
            "VernacExtend",
            "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
        ],
        [
            "econstructor; eauto using find_label_tail.",
            "VernacExtend",
            "a8e3c0cbb9c88303467a2971ab577a3f7a0ec305"
        ],
        [
            "-",
            "VernacBullet",
            "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
        ],
        [
            "inv STACK.",
            "VernacExtend",
            "e6875fb6239ad13b9d79be2d51d64607df0790ca"
        ],
        [
            "inv H1.",
            "VernacExtend",
            "2c43d1971eb5aa98166f6ec686cc2a4f1886b0a4"
        ],
        [
            "econstructor; eauto.",
            "VernacExtend",
            "faa93781fb8bbf289e651728c4588af1c4169d34"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End WF_STATES.",
            "VernacEndSegment",
            "e9167b7415037371c9425edbbd0210d34acef4a6"
        ],
        [
            "Lemma wf_initial: forall p S, initial_state p S -> wf_state (Genv.globalenv p) S.",
            "VernacStartTheoremProof",
            "46c7cdd9900ce1a9700f8954c866043dc8000f89"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "inv H.",
            "VernacExtend",
            "711efba707a6a75ce2cd6ff4b80f031c0d63ab98"
        ],
        [
            "fold ge.",
            "VernacExtend",
            "4659bad5524c9a7dc97b90759fe762df945529cb"
        ],
        [
            "constructor.",
            "VernacExtend",
            "3c77e6be855b5086df5e918bf2a0537e1010479a"
        ],
        [
            "constructor.",
            "VernacExtend",
            "3c77e6be855b5086df5e918bf2a0537e1010479a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ]
    ],
    "proofs": [
        {
            "name": "undef_regs_other",
            "line_nb": 32,
            "steps": [
                {
                    "command": [
                        "induction rl; simpl; intros.",
                        "VernacExtend",
                        "93a42d2609122accf03eae47e66d88f36c63f5bd"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "rewrite Regmap.gso.",
                        "VernacExtend",
                        "debbb756a67cecfdb6f0e8f8567c8d61fc5a4f82"
                    ]
                },
                {
                    "command": [
                        "apply IHrl.",
                        "VernacExtend",
                        "5367ce6384c0b7c29ba7aebd32a88d1aafdf523d"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "intuition.",
                        "VernacExtend",
                        "ebd9388eeb482972743f9cce5cbddbd85ca5bdfd"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "undef_regs_same",
            "line_nb": 40,
            "steps": [
                {
                    "command": [
                        "induction rl; simpl; intros.",
                        "VernacExtend",
                        "93a42d2609122accf03eae47e66d88f36c63f5bd"
                    ]
                },
                {
                    "command": [
                        "tauto.",
                        "VernacExtend",
                        "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
                    ]
                },
                {
                    "command": [
                        "destruct H.",
                        "VernacExtend",
                        "8b2bca015429da94c456243b461e17a2a0582c40"
                    ]
                },
                {
                    "command": [
                        "subst a.",
                        "VernacExtend",
                        "d7670e5f9c196bd417b16b29da3532f33d34884d"
                    ]
                },
                {
                    "command": [
                        "apply Regmap.gss.",
                        "VernacExtend",
                        "2bdf34e7b98bf54221cf2922d5b5c0a755636d9d"
                    ]
                },
                {
                    "command": [
                        "unfold Regmap.set.",
                        "VernacExtend",
                        "8e5f2f777043b40e15dca644b44d2eaa73eb9a62"
                    ]
                },
                {
                    "command": [
                        "destruct (RegEq.eq r a); auto.",
                        "VernacExtend",
                        "b9533cb79d96a297286aef8ac3f0feec5eaabfbe"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "is_label_correct",
            "line_nb": 53,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "destruct instr; simpl; try discriminate.",
                        "VernacExtend",
                        "69eb2b76ff74e79d3df1681b795dbcd9a14f383b"
                    ]
                },
                {
                    "command": [
                        "case (peq lbl l); intro; congruence.",
                        "VernacExtend",
                        "879442c196163a9742376276714507f7b5709f97"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "find_label_tail",
            "line_nb": 59,
            "steps": [
                {
                    "command": [
                        "induction c; simpl; intros.",
                        "VernacExtend",
                        "35ad6631ea868b97a2d7796e2e731fd479dfa24c"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "destruct (is_label lbl a).",
                        "VernacExtend",
                        "d9bab1a058aead7ca4b9a31b75c5923f2e525b19"
                    ]
                },
                {
                    "command": [
                        "inv H.",
                        "VernacExtend",
                        "711efba707a6a75ce2cd6ff4b80f031c0d63ab98"
                    ]
                },
                {
                    "command": [
                        "auto with coqlib.",
                        "VernacExtend",
                        "bf4be239b4d8868fa0ff9785d68d66d28f74c632"
                    ]
                },
                {
                    "command": [
                        "eauto with coqlib.",
                        "VernacExtend",
                        "936a8c3fe80f3a176ab34cf7ab6314fa7dda6de1"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "find_label_incl",
            "line_nb": 67,
            "steps": [
                {
                    "command": [
                        "intros; red; intros.",
                        "VernacExtend",
                        "51aeefe3bf0889d494d662b4f3305dd8bbc97324"
                    ]
                },
                {
                    "command": [
                        "eapply is_tail_incl; eauto.",
                        "VernacExtend",
                        "8b1f2e73145866b6d31eacd8391c1b2baeb5484e"
                    ]
                },
                {
                    "command": [
                        "eapply find_label_tail; eauto.",
                        "VernacExtend",
                        "074ae5daa44d62e6d68b5f55459014e4deb7b9d7"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "wf_step",
            "line_nb": 94,
            "steps": [
                {
                    "command": [
                        "induction 1; intros WF; inv WF; try (econstructor; now eauto with coqlib).",
                        "VernacExtend",
                        "c35cabe3910acfcc564d6dd0038839705bf0d13e"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "assert (f0 = f) by congruence.",
                        "VernacExtend",
                        "352ea7d014268f74b09a7cfe257f27309b80fa0c"
                    ]
                },
                {
                    "command": [
                        "subst f0.",
                        "VernacExtend",
                        "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
                    ]
                },
                {
                    "command": [
                        "constructor.",
                        "VernacExtend",
                        "3c77e6be855b5086df5e918bf2a0537e1010479a"
                    ]
                },
                {
                    "command": [
                        "constructor; auto.",
                        "VernacExtend",
                        "686f227fe0f57af60032eb35216aef1e62d0c0e5"
                    ]
                },
                {
                    "command": [
                        "econstructor; eauto with coqlib.",
                        "VernacExtend",
                        "16e114cab580d38bfe03daa0436d5d4987d2c0d2"
                    ]
                },
                {
                    "command": [
                        "destruct (is_leaf_function f) eqn:E; auto.",
                        "VernacExtend",
                        "7d3278e1103afd4614429974df5d878dff77a66b"
                    ]
                },
                {
                    "command": [
                        "unfold is_leaf_function in E; rewrite forallb_forall in E.",
                        "VernacExtend",
                        "4fdac6ef01ace381fe9a0de2ea3bba89d2cd80ed"
                    ]
                },
                {
                    "command": [
                        "symmetry.",
                        "VernacExtend",
                        "a08fc0dc04bba893008bded8181f393e2d8db167"
                    ]
                },
                {
                    "command": [
                        "apply (E (Mcall sig ros)).",
                        "VernacExtend",
                        "04b634064e0843a9d297950c1136e9392dfeb952"
                    ]
                },
                {
                    "command": [
                        "eapply is_tail_in; eauto.",
                        "VernacExtend",
                        "4f04118796a6368f5cab1e87c5ef191ad66fac7f"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "assert (f0 = f) by congruence.",
                        "VernacExtend",
                        "352ea7d014268f74b09a7cfe257f27309b80fa0c"
                    ]
                },
                {
                    "command": [
                        "subst f0.",
                        "VernacExtend",
                        "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
                    ]
                },
                {
                    "command": [
                        "econstructor; eauto using find_label_tail.",
                        "VernacExtend",
                        "a8e3c0cbb9c88303467a2971ab577a3f7a0ec305"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "assert (f0 = f) by congruence.",
                        "VernacExtend",
                        "352ea7d014268f74b09a7cfe257f27309b80fa0c"
                    ]
                },
                {
                    "command": [
                        "subst f0.",
                        "VernacExtend",
                        "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
                    ]
                },
                {
                    "command": [
                        "econstructor; eauto using find_label_tail.",
                        "VernacExtend",
                        "a8e3c0cbb9c88303467a2971ab577a3f7a0ec305"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "assert (f0 = f) by congruence.",
                        "VernacExtend",
                        "352ea7d014268f74b09a7cfe257f27309b80fa0c"
                    ]
                },
                {
                    "command": [
                        "subst f0.",
                        "VernacExtend",
                        "60936ebda541f6ea0c8b60a65d5ffdb9b3c52860"
                    ]
                },
                {
                    "command": [
                        "econstructor; eauto using find_label_tail.",
                        "VernacExtend",
                        "a8e3c0cbb9c88303467a2971ab577a3f7a0ec305"
                    ]
                },
                {
                    "command": [
                        "-",
                        "VernacBullet",
                        "581cab4bf49fa4b495e569bbda96fc8d28fddcc0"
                    ]
                },
                {
                    "command": [
                        "inv STACK.",
                        "VernacExtend",
                        "e6875fb6239ad13b9d79be2d51d64607df0790ca"
                    ]
                },
                {
                    "command": [
                        "inv H1.",
                        "VernacExtend",
                        "2c43d1971eb5aa98166f6ec686cc2a4f1886b0a4"
                    ]
                },
                {
                    "command": [
                        "econstructor; eauto.",
                        "VernacExtend",
                        "faa93781fb8bbf289e651728c4588af1c4169d34"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "wf_initial",
            "line_nb": 125,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "inv H.",
                        "VernacExtend",
                        "711efba707a6a75ce2cd6ff4b80f031c0d63ab98"
                    ]
                },
                {
                    "command": [
                        "fold ge.",
                        "VernacExtend",
                        "4659bad5524c9a7dc97b90759fe762df945529cb"
                    ]
                },
                {
                    "command": [
                        "constructor.",
                        "VernacExtend",
                        "3c77e6be855b5086df5e918bf2a0537e1010479a"
                    ]
                },
                {
                    "command": [
                        "constructor.",
                        "VernacExtend",
                        "3c77e6be855b5086df5e918bf2a0537e1010479a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}