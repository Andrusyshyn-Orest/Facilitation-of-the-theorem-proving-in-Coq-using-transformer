{
    "filename": "backend/CSE.v",
    "coq_project": "CompCert",
    "vernac_cmds": [
        [
            "Require Import Coqlib Maps Errors Integers Floats Lattice Kildall.",
            "VernacRequire",
            "9832f531c9d87e4ffe9b011930a238761c45d2e6"
        ],
        [
            "Require Import AST Linking.",
            "VernacRequire",
            "7d6948a67271bb4c4ddf7fe1b423c370d8e8ffef"
        ],
        [
            "Require Import Values Memory.",
            "VernacRequire",
            "fd8cb018c88ae6512b0c85638cfadb7ac01ebbf8"
        ],
        [
            "Require Import Op Registers RTL.",
            "VernacRequire",
            "03ebb9363dd6eb9b1ad8ac1a29077839d73c0733"
        ],
        [
            "Require Import ValueDomain ValueAnalysis CSEdomain CombineOp.",
            "VernacRequire",
            "ea4fa3c3338ec509a545bbacfc68617e694c550e"
        ],
        [
            "Definition valnum_reg (n: numbering) (r: reg) : numbering * valnum := match PTree.get r n.(num_reg) with | Some v => (n, v) | None => let v := n.(num_next) in ( {| num_next := Pos.succ v; num_eqs := n.(num_eqs); num_reg := PTree.set r v n.(num_reg); num_val := PMap.set v (r :: nil) n.(num_val) |}, v) end.",
            "VernacDefinition",
            "7c72e7c3702dbdb3d5a90ccdbe745f1514a4c5d8"
        ],
        [
            "Fixpoint valnum_regs (n: numbering) (rl: list reg) {struct rl} : numbering * list valnum := match rl with | nil => (n, nil) | r1 :: rs => let (n1, v1) := valnum_reg n r1 in let (ns, vs) := valnum_regs n1 rs in (ns, v1 :: vs) end.",
            "VernacFixpoint",
            "3a20d215e61b4d746d0633f2e4e4d35bb0448727"
        ],
        [
            "Fixpoint find_valnum_rhs (r: rhs) (eqs: list equation) {struct eqs} : option valnum := match eqs with | nil => None | Eq v str r' :: eqs1 => if str && eq_rhs r r' then Some v else find_valnum_rhs r eqs1 end.",
            "VernacFixpoint",
            "8ce4a045b33c67ad15241bba281ce6b6ade2bbbe"
        ],
        [
            "Fixpoint find_valnum_rhs' (r: rhs) (eqs: list equation) {struct eqs} : option valnum := match eqs with | nil => None | Eq v str r' :: eqs1 => if eq_rhs r r' then Some v else find_valnum_rhs' r eqs1 end.",
            "VernacFixpoint",
            "21a19b9f35de3887b13b21dbd631d5eb9ff012c2"
        ],
        [
            "Fixpoint find_valnum_num (v: valnum) (eqs: list equation) {struct eqs} : option rhs := match eqs with | nil => None | Eq v' str r' :: eqs1 => if str && peq v v' then Some r' else find_valnum_num v eqs1 end.",
            "VernacFixpoint",
            "493d34001ebe13551633610bb1a9945222f9f46f"
        ],
        [
            "Definition reg_valnum (n: numbering) (vn: valnum) : option reg := match PMap.get vn n.(num_val) with | nil => None | r :: rs => Some r end.",
            "VernacDefinition",
            "7b5b5e645427aa06d6dbd2180c9f61657ab3eebe"
        ],
        [
            "Fixpoint regs_valnums (n: numbering) (vl: list valnum) : option (list reg) := match vl with | nil => Some nil | v1 :: vs => match reg_valnum n v1, regs_valnums n vs with | Some r1, Some rs => Some (r1 :: rs) | _, _ => None end end.",
            "VernacFixpoint",
            "f2f827a94d2510b94ce718d64a0bf5455d2959a3"
        ],
        [
            "Definition find_rhs (n: numbering) (rh: rhs) : option reg := match find_valnum_rhs' rh n.(num_eqs) with | None => None | Some vres => reg_valnum n vres end.",
            "VernacDefinition",
            "8d743265316878dcc2f89eddc636e17fa2dd083b"
        ],
        [
            "Definition forget_reg (n: numbering) (rd: reg) : PMap.t (list reg) := match PTree.get rd n.(num_reg) with | None => n.(num_val) | Some v => PMap.set v (List.remove peq rd (PMap.get v n.(num_val))) n.(num_val) end.",
            "VernacDefinition",
            "af202dce489881630fb04822ab449be305dc48af"
        ],
        [
            "Definition update_reg (n: numbering) (rd: reg) (vn: valnum) : PMap.t (list reg) := let nv := forget_reg n rd in PMap.set vn (rd :: PMap.get vn nv) nv.",
            "VernacDefinition",
            "4ec90b62c3f61971e750e97c9d6c0d74c0087911"
        ],
        [
            "Definition add_rhs (n: numbering) (rd: reg) (rh: rhs) : numbering := match find_valnum_rhs rh n.(num_eqs) with | Some vres => {| num_next := n.(num_next); num_eqs := n.(num_eqs); num_reg := PTree.set rd vres n.(num_reg); num_val := update_reg n rd vres |} | None => {| num_next := Pos.succ n.(num_next); num_eqs := Eq n.(num_next) true rh :: n.(num_eqs); num_reg := PTree.set rd n.(num_next) n.(num_reg); num_val := update_reg n rd n.(num_next) |} end.",
            "VernacDefinition",
            "5c393025515f2b2b1bb29aee19bf8f08e6513ec1"
        ],
        [
            "Definition add_op (n: numbering) (rd: reg) (op: operation) (rs: list reg) := match is_move_operation op rs with | Some r => let (n1, v) := valnum_reg n r in {| num_next := n1.(num_next); num_eqs := n1.(num_eqs); num_reg := PTree.set rd v n1.(num_reg); num_val := update_reg n1 rd v |} | None => let (n1, vs) := valnum_regs n rs in add_rhs n1 rd (Op op vs) end.",
            "VernacDefinition",
            "884a5b52908d7c4ca597b7d8d4c86cb3afaef94c"
        ],
        [
            "Definition add_load (n: numbering) (rd: reg) (chunk: memory_chunk) (addr: addressing) (rs: list reg) := let (n1, vs) := valnum_regs n rs in add_rhs n1 rd (Load chunk addr vs).",
            "VernacDefinition",
            "7e2deef8e52a8d6dc6f54c0db7af92228df19821"
        ],
        [
            "Definition set_unknown (n: numbering) (rd: reg) := {| num_next := n.(num_next); num_eqs := n.(num_eqs); num_reg := PTree.remove rd n.(num_reg); num_val := forget_reg n rd |}.",
            "VernacDefinition",
            "8a27ef4fd0847103dcefdff7f196e512c57c132a"
        ],
        [
            "Definition set_res_unknown (n: numbering) (res: builtin_res reg) := match res with | BR r => set_unknown n r | _ => n end.",
            "VernacDefinition",
            "c997e06708b4020d03b598d3d40c8471201f1dd3"
        ],
        [
            "Fixpoint kill_eqs (pred: rhs -> bool) (eqs: list equation) : list equation := match eqs with | nil => nil | (Eq l strict r) as eq :: rem => if pred r then kill_eqs pred rem else eq :: kill_eqs pred rem end.",
            "VernacFixpoint",
            "49ba227afee0f95862696ffc2267a1e97af15e49"
        ],
        [
            "Definition kill_equations (pred: rhs -> bool) (n: numbering) : numbering := {| num_next := n.(num_next); num_eqs := kill_eqs pred n.(num_eqs); num_reg := n.(num_reg); num_val := n.(num_val) |}.",
            "VernacDefinition",
            "4de261f868565719516120c0b939d3604a6199d2"
        ],
        [
            "Definition filter_loads (r: rhs) : bool := match r with | Op op _ => op_depends_on_memory op | Load _ _ _ => true end.",
            "VernacDefinition",
            "601a6d992260fab4e6ab5f6912a60ad86c45a22f"
        ],
        [
            "Definition kill_all_loads (n: numbering) : numbering := kill_equations filter_loads n.",
            "VernacDefinition",
            "8c361a7ba06e4593ed1c907c98988feeeeace99c"
        ],
        [
            "Definition filter_after_store (app: VA.t) (n: numbering) (p: aptr) (sz: Z) (r: rhs) := match r with | Op op vl => op_depends_on_memory op | Load chunk addr vl => match regs_valnums n vl with | None => true | Some rl => negb (pdisjoint (aaddressing app addr rl) (size_chunk chunk) p sz) end end.",
            "VernacDefinition",
            "3b6812d09528c7e1aee56907c85c1cd2dd9e2999"
        ],
        [
            "Definition kill_loads_after_store (app: VA.t) (n: numbering) (chunk: memory_chunk) (addr: addressing) (args: list reg) := let p := aaddressing app addr args in kill_equations (filter_after_store app n p (size_chunk chunk)) n.",
            "VernacDefinition",
            "00a87e3864650be9c5098d1253f28e621f398585"
        ],
        [
            "Definition store_normalized_range (chunk: memory_chunk) : aval := match chunk with | Mint8signed => Sgn Ptop 8 | Mint8unsigned => Uns Ptop 8 | Mint16signed => Sgn Ptop 16 | Mint16unsigned => Uns Ptop 16 | _ => Vtop end.",
            "VernacDefinition",
            "404e72adfdae4eddfd6263d963a79a178c797d2b"
        ],
        [
            "Definition add_store_result (app: VA.t) (n: numbering) (chunk: memory_chunk) (addr: addressing) (rargs: list reg) (rsrc: reg) := if vincl (avalue app rsrc) (store_normalized_range chunk) then let (n1, vsrc) := valnum_reg n rsrc in let (n2, vargs) := valnum_regs n1 rargs in {| num_next := n2.(num_next); num_eqs := Eq vsrc false (Load chunk addr vargs) :: n2.(num_eqs); num_reg := n2.(num_reg); num_val := n2.(num_val) |} else n.",
            "VernacDefinition",
            "336a2072f2fa42545b81abd3ea61410842ddb67d"
        ],
        [
            "Definition kill_loads_after_storebytes (app: VA.t) (n: numbering) (dst: aptr) (sz: Z) := kill_equations (filter_after_store app n dst sz) n.",
            "VernacDefinition",
            "f1cf7606840e0def5b9a66585968b6279959ead5"
        ],
        [
            "Definition shift_memcpy_eq (src sz delta: Z) (e: equation) := match e with | Eq l strict (Load chunk (Ainstack i) _) => let i := Ptrofs.unsigned i in let j := i + delta in if zle src i && zle (i + size_chunk chunk) (src + sz) && zeq (Z.modulo delta (align_chunk chunk)) 0 && zle 0 j && zle j Ptrofs.max_unsigned then Some(Eq l strict (Load chunk (Ainstack (Ptrofs.repr j)) nil)) else None | _ => None end.",
            "VernacDefinition",
            "af00f24b1cba3877257dd6b850f1ceb917401bc3"
        ],
        [
            "Fixpoint add_memcpy_eqs (src sz delta: Z) (eqs1 eqs2: list equation) := match eqs1 with | nil => eqs2 | e :: eqs => match shift_memcpy_eq src sz delta e with | None => add_memcpy_eqs src sz delta eqs eqs2 | Some e' => e' :: add_memcpy_eqs src sz delta eqs eqs2 end end.",
            "VernacFixpoint",
            "b6d921be93cecc4943cffebc356b2458bb40b0d9"
        ],
        [
            "Definition add_memcpy (n1 n2: numbering) (asrc adst: aptr) (sz: Z) := match asrc, adst with | Stk src, Stk dst => {| num_next := n2.(num_next); num_eqs := add_memcpy_eqs (Ptrofs.unsigned src) sz (Ptrofs.unsigned dst - Ptrofs.unsigned src) n1.(num_eqs) n2.(num_eqs); num_reg := n2.(num_reg); num_val := n2.(num_val) |} | _, _ => n2 end.",
            "VernacDefinition",
            "493e73b6399df072dc46865f6aa3910071a131ca"
        ],
        [
            "Section REDUCE.",
            "VernacBeginSection",
            "c03a2250cee5e2a18a5d9a3aba64a64162d34796"
        ],
        [
            "Variable A: Type.",
            "VernacAssumption",
            "8c1a433b6dc10de37f30039d70ed7113b3dab0e0"
        ],
        [
            "Variable f: (valnum -> option rhs) -> A -> list valnum -> option (A * list valnum).",
            "VernacAssumption",
            "736661e5a972cb195b89377b9824afbcd96e4a5c"
        ],
        [
            "Variable n: numbering.",
            "VernacAssumption",
            "2f17890d8eafa6dfffe41709cc0ea2ac1caa6c83"
        ],
        [
            "Fixpoint reduce_rec (niter: nat) (op: A) (args: list valnum) : option(A * list reg) := match niter with | O => None | Datatypes.S niter' => match f (fun v => find_valnum_num v n.(num_eqs)) op args with | None => None | Some(op', args') => match reduce_rec niter' op' args' with | None => match regs_valnums n args' with Some rl => Some(op', rl) | None => None end | Some _ as res => res end end end.",
            "VernacFixpoint",
            "8a227349756b9696b448d984536492b7c3a7fd6e"
        ],
        [
            "Definition reduce (op: A) (rl: list reg) (vl: list valnum) : A * list reg := match reduce_rec 4%nat op vl with | None => (op, rl) | Some res => res end.",
            "VernacDefinition",
            "1d7e0a912171ad70690859282d80f6f9ce002428"
        ],
        [
            "End REDUCE.",
            "VernacEndSegment",
            "e70f86c9bce98d9af6ba05a7452719e137bc5116"
        ],
        [
            "Module Numbering.",
            "VernacDefineModule",
            "9c81b523f445f712852f9c328398d3347ef37f5a"
        ],
        [
            "Definition t := numbering.",
            "VernacDefinition",
            "c328392491e16ab231354258a599c0ef1a50d7c7"
        ],
        [
            "Definition ge (n1 n2: numbering) : Prop := forall valu ge sp rs m, numbering_holds valu ge sp rs m n2 -> numbering_holds valu ge sp rs m n1.",
            "VernacDefinition",
            "b09a96c28dd9317548ab89822d3414ac5802b45a"
        ],
        [
            "Definition top := empty_numbering.",
            "VernacDefinition",
            "f83fb74b2725f129228a6036c5ed4272400326d3"
        ],
        [
            "Lemma top_ge: forall x, ge top x.",
            "VernacStartTheoremProof",
            "d4907b221a34aa7ddd8e1cc493d23a6803bd5604"
        ],
        [
            "intros; red; intros.",
            "VernacExtend",
            "51aeefe3bf0889d494d662b4f3305dd8bbc97324"
        ],
        [
            "unfold top.",
            "VernacExtend",
            "cefa5e7ba1e59fa59203bb2e084597f70a7db71f"
        ],
        [
            "apply empty_numbering_holds.",
            "VernacExtend",
            "fb617718310a2d36bf09d974c6c50fea8928db71"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma refl_ge: forall x, ge x x.",
            "VernacStartTheoremProof",
            "126b6170526563b842870ff7d0beba6050bcf5ad"
        ],
        [
            "intros; red; auto.",
            "VernacExtend",
            "e12580bea13ae84b97d0df81fcaaa98eb2b8c871"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End Numbering.",
            "VernacEndSegment",
            "605c9150a77839e8e5b00ae459820bba61d8f2d1"
        ],
        [
            "Module Solver := BBlock_solver(Numbering).",
            "VernacDefineModule",
            "1aff81ff42836a1388a1009c8b890e42f8509bd4"
        ],
        [
            "Definition transfer (f: function) (approx: PMap.t VA.t) (pc: node) (before: numbering) := match f.(fn_code)!pc with | None => before | Some i => match i with | Inop s => before | Iop op args res s => add_op before res op args | Iload chunk addr args dst s => add_load before dst chunk addr args | Istore chunk addr args src s => let app := approx!!pc in let n := kill_loads_after_store app before chunk addr args in add_store_result app n chunk addr args src | Icall sig ros args res s => empty_numbering | Itailcall sig ros args => empty_numbering | Ibuiltin ef args res s => match ef with | EF_external _ _ | EF_runtime _ _ | EF_malloc | EF_free | EF_inline_asm _ _ _ => empty_numbering | EF_builtin _ _ | EF_vstore _ => set_res_unknown (kill_all_loads before) res | EF_memcpy sz al => match args with | dst :: src :: nil => let app := approx!!pc in let adst := aaddr_arg app dst in let asrc := aaddr_arg app src in let n := kill_loads_after_storebytes app before adst sz in set_res_unknown (add_memcpy before n asrc adst sz) res | _ => empty_numbering end | EF_vload _ | EF_annot _ _ _ | EF_annot_val _ _ _ | EF_debug _ _ _ => set_res_unknown before res end | Icond cond args ifso ifnot => before | Ijumptable arg tbl => before | Ireturn optarg => before end end.",
            "VernacDefinition",
            "19b4024fd35136282b09cb6f1c79e78d5ab39d9b"
        ],
        [
            "Definition analyze (f: RTL.function) (approx: PMap.t VA.t): option (PMap.t numbering) := Solver.fixpoint (fn_code f) successors_instr (transfer f approx) f.(fn_entrypoint).",
            "VernacDefinition",
            "1ec78cc93925297f4f31606bd7b87a17af52a719"
        ],
        [
            "Definition transf_instr (n: numbering) (instr: instruction) := match instr with | Iop op args res s => if is_trivial_op op then instr else let (n1, vl) := valnum_regs n args in match find_rhs n1 (Op op vl) with | Some r => Iop Omove (r :: nil) res s | None => let (op', args') := reduce _ combine_op n1 op args vl in Iop op' args' res s end | Iload chunk addr args dst s => let (n1, vl) := valnum_regs n args in match find_rhs n1 (Load chunk addr vl) with | Some r => Iop Omove (r :: nil) dst s | None => let (addr', args') := reduce _ combine_addr n1 addr args vl in Iload chunk addr' args' dst s end | Istore chunk addr args src s => let (n1, vl) := valnum_regs n args in let (addr', args') := reduce _ combine_addr n1 addr args vl in Istore chunk addr' args' src s | Icond cond args s1 s2 => let (n1, vl) := valnum_regs n args in let (cond', args') := reduce _ combine_cond n1 cond args vl in Icond cond' args' s1 s2 | _ => instr end.",
            "VernacDefinition",
            "e34996a520f24621713573f267d08ff14f97e364"
        ],
        [
            "Definition transf_code (approxs: PMap.t numbering) (instrs: code) : code := PTree.map (fun pc instr => transf_instr approxs!!pc instr) instrs.",
            "VernacDefinition",
            "d82417d0bbadb88e738a88f6d2838aad9a269a20"
        ],
        [
            "Definition vanalyze := ValueAnalysis.analyze.",
            "VernacDefinition",
            "8cfb3ef1ff3cb59f275128932bc6d3618d82d86d"
        ],
        [
            "Definition transf_function (rm: romem) (f: function) : res function := let approx := vanalyze rm f in match analyze f approx with | None => Error (msg \"CSE failure\") | Some approxs => OK(mkfunction f.(fn_sig) f.(fn_params) f.(fn_stacksize) (transf_code approxs f.(fn_code)) f.(fn_entrypoint)) end.",
            "VernacDefinition",
            "c15a02d505a9b788cc758f0629d85962531eb2eb"
        ],
        [
            "Definition transf_fundef (rm: romem) (f: fundef) : res fundef := AST.transf_partial_fundef (transf_function rm) f.",
            "VernacDefinition",
            "0d9812826dde99dd13374e2b6a26a8b4baff0464"
        ],
        [
            "Definition transf_program (p: program) : res program := transform_partial_program (transf_fundef (romem_for p)) p.",
            "VernacDefinition",
            "2fd030adef2a27652b3131cc2de4471a92e3ae9d"
        ]
    ],
    "proofs": [
        {
            "name": "top_ge",
            "line_nb": 43,
            "steps": [
                {
                    "command": [
                        "intros; red; intros.",
                        "VernacExtend",
                        "51aeefe3bf0889d494d662b4f3305dd8bbc97324"
                    ]
                },
                {
                    "command": [
                        "unfold top.",
                        "VernacExtend",
                        "cefa5e7ba1e59fa59203bb2e084597f70a7db71f"
                    ]
                },
                {
                    "command": [
                        "apply empty_numbering_holds.",
                        "VernacExtend",
                        "fb617718310a2d36bf09d974c6c50fea8928db71"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "refl_ge",
            "line_nb": 48,
            "steps": [
                {
                    "command": [
                        "intros; red; auto.",
                        "VernacExtend",
                        "e12580bea13ae84b97d0df81fcaaa98eb2b8c871"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}