{
    "filename": "common/Errors.v",
    "coq_project": "CompCert",
    "vernac_cmds": [
        [
            "Require Import String.",
            "VernacRequire",
            "c8f60f008dd1a565dde55d26cee568a599a023b3"
        ],
        [
            "Require Import Coqlib.",
            "VernacRequire",
            "bbbe15041aca3a03300067f7acd445b462d537cc"
        ],
        [
            "Close Scope string_scope.",
            "VernacOpenCloseScope",
            "29b82236f8405468b1ed841b8d732b1fe484598b"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Inductive errcode: Type := | MSG: string -> errcode | CTX: positive -> errcode | POS: positive -> errcode.",
            "VernacInductive",
            "f4f9cbe67c6f790eb347ae9c94d972041c7d39cc"
        ],
        [
            "Definition errmsg: Type := list errcode.",
            "VernacDefinition",
            "f023a1e729b386cfd42abd4a4be976054f3c2dea"
        ],
        [
            "Definition msg (s: string) : errmsg := MSG s :: nil.",
            "VernacDefinition",
            "beb79183f96a5ba85a7bebf3aae9ebe0cbb92952"
        ],
        [
            "Inductive res (A: Type) : Type := | OK: A -> res A | Error: errmsg -> res A.",
            "VernacInductive",
            "54cd5f6c97498c75103c9653e3aea0cfdd7c66a7"
        ],
        [
            "Arguments Error [A].",
            "VernacArguments",
            "5266713a0b148a1ccbd4616bae280f760bb5712a"
        ],
        [
            "Definition bind (A B: Type) (f: res A) (g: A -> res B) : res B := match f with | OK x => g x | Error msg => Error msg end.",
            "VernacDefinition",
            "7e3ae830b1e3f7cda9acd08e1128404277900ac2"
        ],
        [
            "Definition bind2 (A B C: Type) (f: res (A * B)) (g: A -> B -> res C) : res C := match f with | OK (x, y) => g x y | Error msg => Error msg end.",
            "VernacDefinition",
            "3acc81337d98e4632e1467935391d72df2b4e6c8"
        ],
        [
            "Notation \"'do' X <- A ; B\" := (bind A (fun X => B)) (at level 200, X ident, A at level 100, B at level 200) : error_monad_scope.",
            "VernacNotation",
            "6424f025add3a3cc193232be5783840b3204f729"
        ],
        [
            "Notation \"'do' ( X , Y ) <- A ; B\" := (bind2 A (fun X Y => B)) (at level 200, X ident, Y ident, A at level 100, B at level 200) : error_monad_scope.",
            "VernacNotation",
            "2b2fba17bf184fa63e1a2fdc6e5842c53a11a3f1"
        ],
        [
            "Remark bind_inversion: forall (A B: Type) (f: res A) (g: A -> res B) (y: B), bind f g = OK y -> exists x, f = OK x /\\ g x = OK y.",
            "VernacStartTheoremProof",
            "377ebec8561347d5f90acd57f11476d180fd14c6"
        ],
        [
            "intros until y.",
            "VernacExtend",
            "d1d10153f927031bceccac11dd74d452de2e238a"
        ],
        [
            "destruct f; simpl; intros.",
            "VernacExtend",
            "116f5a96e733033ae39bf8706d62e82b1e7fdd58"
        ],
        [
            "exists a; auto.",
            "VernacExtend",
            "dd5a786237df3984e1d2bb0f96b1da3befb55aac"
        ],
        [
            "discriminate.",
            "VernacExtend",
            "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Remark bind2_inversion: forall (A B C: Type) (f: res (A*B)) (g: A -> B -> res C) (z: C), bind2 f g = OK z -> exists x, exists y, f = OK (x, y) /\\ g x y = OK z.",
            "VernacStartTheoremProof",
            "2364a174b358446ad1fd1b2d6197f5435884ae71"
        ],
        [
            "intros until z.",
            "VernacExtend",
            "e6a2f4f35444093b1f9f0a28f433301ca5f2800a"
        ],
        [
            "destruct f; simpl.",
            "VernacExtend",
            "5ab77c865e5ffb10c040a3c8d321e06dea47ffb1"
        ],
        [
            "destruct p; simpl; intros.",
            "VernacExtend",
            "3cedbd6e820cfd5fc946901d75af7d3ac08b17fb"
        ],
        [
            "exists a; exists b; auto.",
            "VernacExtend",
            "589f337b14a0275128d2942b5380a993547fe0fb"
        ],
        [
            "intros; discriminate.",
            "VernacExtend",
            "1ec997c70ceedc981f8865c1573c00554b73dfd4"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition assertion_failed {A: Type} : res A := Error(msg \"Assertion failed\").",
            "VernacDefinition",
            "9f7ba7ace324c95570d76bd62ddd58c11eec1c09"
        ],
        [
            "Notation \"'assertion' A ; B\" := (if A then B else assertion_failed) (at level 200, A at level 100, B at level 200) : error_monad_scope.",
            "VernacNotation",
            "13cd96d9deee38b7b9192ed01523949da6c001c2"
        ],
        [
            "Local Open Scope error_monad_scope.",
            "VernacOpenCloseScope",
            "c40f2a3704d268aa6535e825182aaec0e665bbd5"
        ],
        [
            "Fixpoint mmap (A B: Type) (f: A -> res B) (l: list A) {struct l} : res (list B) := match l with | nil => OK nil | hd :: tl => do hd' <- f hd; do tl' <- mmap f tl; OK (hd' :: tl') end.",
            "VernacFixpoint",
            "7b37848cd93c7e778e2f8ed53bfd0f32ddb6ee74"
        ],
        [
            "Remark mmap_inversion: forall (A B: Type) (f: A -> res B) (l: list A) (l': list B), mmap f l = OK l' -> list_forall2 (fun x y => f x = OK y) l l'.",
            "VernacStartTheoremProof",
            "04aaf1a5bee22cabd3cb57e76ac083994f351007"
        ],
        [
            "induction l; simpl; intros.",
            "VernacExtend",
            "34e9ea5965da389dfe8faf53c8ea4965d4fdcc22"
        ],
        [
            "inversion_clear H.",
            "VernacExtend",
            "90909d92eb32e95a21a5b90b29a49dc97bcea342"
        ],
        [
            "constructor.",
            "VernacExtend",
            "3c77e6be855b5086df5e918bf2a0537e1010479a"
        ],
        [
            "destruct (bind_inversion _ _ H) as [hd' [P Q]].",
            "VernacExtend",
            "354c71ddb36c91156d560427e235461dc58d3c7e"
        ],
        [
            "destruct (bind_inversion _ _ Q) as [tl' [R S]].",
            "VernacExtend",
            "a22adcceb8495491179e77b36ba6887093613ab2"
        ],
        [
            "inversion_clear S.",
            "VernacExtend",
            "2e172b20d1f4737adc0a2cf958660a7ac2899462"
        ],
        [
            "constructor.",
            "VernacExtend",
            "3c77e6be855b5086df5e918bf2a0537e1010479a"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "auto.",
            "VernacExtend",
            "1f09da0addd069b3b65326f8c71967acc1e985af"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Ltac monadInv1 H := match type of H with | (OK _ = OK _) => inversion H; clear H; try subst | (Error _ = OK _) => discriminate | (bind ?F ?G = OK ?X) => let x := fresh \"x\" in ( let EQ1 := fresh \"EQ\" in ( let EQ2 := fresh \"EQ\" in ( destruct (bind_inversion F G H) as [x [EQ1 EQ2]]; clear H; try (monadInv1 EQ2)))) | (bind2 ?F ?G = OK ?X) => let x1 := fresh \"x\" in ( let x2 := fresh \"x\" in ( let EQ1 := fresh \"EQ\" in ( let EQ2 := fresh \"EQ\" in ( destruct (bind2_inversion F G H) as [x1 [x2 [EQ1 EQ2]]]; clear H; try (monadInv1 EQ2))))) | (match ?X with left _ => _ | right _ => assertion_failed end = OK _) => destruct X; [try (monadInv1 H) | discriminate] | (match (negb ?X) with true => _ | false => assertion_failed end = OK _) => destruct X as [] eqn:?; [discriminate | try (monadInv1 H)] | (match ?X with true => _ | false => assertion_failed end = OK _) => destruct X as [] eqn:?; [try (monadInv1 H) | discriminate] | (mmap ?F ?L = OK ?M) => generalize (mmap_inversion F L H); intro end.",
            "VernacExtend",
            "cf6e2e4a3da39e6af24a52d4d99ca3dce4c49dca"
        ],
        [
            "Ltac monadInv H := monadInv1 H || match type of H with | (?F _ _ _ _ _ _ _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ _ _ _ _ _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ _ _ _ _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ _ _ _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ _ _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H | (?F _ = OK _) => ((progress simpl in H) || unfold F in H); monadInv1 H end.",
            "VernacExtend",
            "b94420d50b8e8f511cdda2341beaf3811b298308"
        ]
    ],
    "proofs": [
        {
            "name": "bind_inversion",
            "line_nb": 13,
            "steps": [
                {
                    "command": [
                        "intros until y.",
                        "VernacExtend",
                        "d1d10153f927031bceccac11dd74d452de2e238a"
                    ]
                },
                {
                    "command": [
                        "destruct f; simpl; intros.",
                        "VernacExtend",
                        "116f5a96e733033ae39bf8706d62e82b1e7fdd58"
                    ]
                },
                {
                    "command": [
                        "exists a; auto.",
                        "VernacExtend",
                        "dd5a786237df3984e1d2bb0f96b1da3befb55aac"
                    ]
                },
                {
                    "command": [
                        "discriminate.",
                        "VernacExtend",
                        "66ca81b65e1a53372a2515fdfdd2a6b0677cb9c8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bind2_inversion",
            "line_nb": 19,
            "steps": [
                {
                    "command": [
                        "intros until z.",
                        "VernacExtend",
                        "e6a2f4f35444093b1f9f0a28f433301ca5f2800a"
                    ]
                },
                {
                    "command": [
                        "destruct f; simpl.",
                        "VernacExtend",
                        "5ab77c865e5ffb10c040a3c8d321e06dea47ffb1"
                    ]
                },
                {
                    "command": [
                        "destruct p; simpl; intros.",
                        "VernacExtend",
                        "3cedbd6e820cfd5fc946901d75af7d3ac08b17fb"
                    ]
                },
                {
                    "command": [
                        "exists a; exists b; auto.",
                        "VernacExtend",
                        "589f337b14a0275128d2942b5380a993547fe0fb"
                    ]
                },
                {
                    "command": [
                        "intros; discriminate.",
                        "VernacExtend",
                        "1ec997c70ceedc981f8865c1573c00554b73dfd4"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "mmap_inversion",
            "line_nb": 30,
            "steps": [
                {
                    "command": [
                        "induction l; simpl; intros.",
                        "VernacExtend",
                        "34e9ea5965da389dfe8faf53c8ea4965d4fdcc22"
                    ]
                },
                {
                    "command": [
                        "inversion_clear H.",
                        "VernacExtend",
                        "90909d92eb32e95a21a5b90b29a49dc97bcea342"
                    ]
                },
                {
                    "command": [
                        "constructor.",
                        "VernacExtend",
                        "3c77e6be855b5086df5e918bf2a0537e1010479a"
                    ]
                },
                {
                    "command": [
                        "destruct (bind_inversion _ _ H) as [hd' [P Q]].",
                        "VernacExtend",
                        "354c71ddb36c91156d560427e235461dc58d3c7e"
                    ]
                },
                {
                    "command": [
                        "destruct (bind_inversion _ _ Q) as [tl' [R S]].",
                        "VernacExtend",
                        "a22adcceb8495491179e77b36ba6887093613ab2"
                    ]
                },
                {
                    "command": [
                        "inversion_clear S.",
                        "VernacExtend",
                        "2e172b20d1f4737adc0a2cf958660a7ac2899462"
                    ]
                },
                {
                    "command": [
                        "constructor.",
                        "VernacExtend",
                        "3c77e6be855b5086df5e918bf2a0537e1010479a"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "auto.",
                        "VernacExtend",
                        "1f09da0addd069b3b65326f8c71967acc1e985af"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}