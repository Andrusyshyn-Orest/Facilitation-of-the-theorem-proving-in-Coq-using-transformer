{
    "filename": "cfrontend/Cminorgen.v",
    "coq_project": "CompCert",
    "vernac_cmds": [
        [
            "Require Import FSets FSetAVL Orders Mergesort.",
            "VernacRequire",
            "c2976d6d326e230f8c15ec2e43942b95a132a012"
        ],
        [
            "Require Import Coqlib Maps Ordered Errors Integers Floats.",
            "VernacRequire",
            "d2ef5cab246deadea999984f23ad6603e7541067"
        ],
        [
            "Require Import AST Linking.",
            "VernacRequire",
            "7d6948a67271bb4c4ddf7fe1b423c370d8e8ffef"
        ],
        [
            "Require Import Csharpminor Cminor.",
            "VernacRequire",
            "bc7484be81d8665517ba36fe7f8e5105f53d9777"
        ],
        [
            "Local Open Scope string_scope.",
            "VernacOpenCloseScope",
            "347f91aff322dccfab9c81382e495d8430d8e803"
        ],
        [
            "Local Open Scope error_monad_scope.",
            "VernacOpenCloseScope",
            "c40f2a3704d268aa6535e825182aaec0e665bbd5"
        ],
        [
            "Definition compilenv := PTree.t Z.",
            "VernacDefinition",
            "e0cf9f958a5f49e38069430d6f81c202d32c1a28"
        ],
        [
            "Definition var_addr (cenv: compilenv) (id: ident): expr := match PTree.get id cenv with | Some ofs => Econst (Oaddrstack (Ptrofs.repr ofs)) | None => Econst (Oaddrsymbol id Ptrofs.zero) end.",
            "VernacDefinition",
            "0a95f3e420c03a922f95cefd3b6b8c9ab759981f"
        ],
        [
            "Definition transl_constant (cst: Csharpminor.constant): constant := match cst with | Csharpminor.Ointconst n => Ointconst n | Csharpminor.Ofloatconst n => Ofloatconst n | Csharpminor.Osingleconst n => Osingleconst n | Csharpminor.Olongconst n => Olongconst n end.",
            "VernacDefinition",
            "b2991fb69e27ce877b0f6668a996721e1bbe7da0"
        ],
        [
            "Fixpoint transl_expr (cenv: compilenv) (e: Csharpminor.expr) {struct e}: res expr := match e with | Csharpminor.Evar id => OK (Evar id) | Csharpminor.Eaddrof id => OK (var_addr cenv id) | Csharpminor.Econst cst => OK (Econst (transl_constant cst)) | Csharpminor.Eunop op e1 => do te1 <- transl_expr cenv e1; OK (Eunop op te1) | Csharpminor.Ebinop op e1 e2 => do te1 <- transl_expr cenv e1; do te2 <- transl_expr cenv e2; OK (Ebinop op te1 te2) | Csharpminor.Eload chunk e => do te <- transl_expr cenv e; OK (Eload chunk te) end.",
            "VernacFixpoint",
            "eec2252fd27dd599228bf189a1bca546e60a6fdd"
        ],
        [
            "Fixpoint transl_exprlist (cenv: compilenv) (el: list Csharpminor.expr) {struct el}: res (list expr) := match el with | nil => OK nil | e1 :: e2 => do te1 <- transl_expr cenv e1; do te2 <- transl_exprlist cenv e2; OK (te1 :: te2) end.",
            "VernacFixpoint",
            "c6933d4b181063f941d069887361570e475eb6a8"
        ],
        [
            "Definition exit_env := list bool.",
            "VernacDefinition",
            "75c6b118d6d85f77fcfbef18fe95e954463863bd"
        ],
        [
            "Fixpoint shift_exit (e: exit_env) (n: nat) {struct e} : nat := match e, n with | nil, _ => n | false :: e', _ => S (shift_exit e' n) | true :: e', O => O | true :: e', S m => S (shift_exit e' m) end.",
            "VernacFixpoint",
            "1453c94c7036dd0cd675c0435ce31a4ce70497ca"
        ],
        [
            "Fixpoint switch_table (ls: lbl_stmt) (k: nat) {struct ls} : list (Z * nat) * nat := match ls with | LSnil => (nil, k) | LScons None _ rem => let (tbl, dfl) := switch_table rem (S k) in (tbl, k) | LScons (Some ni) _ rem => let (tbl, dfl) := switch_table rem (S k) in ((ni, k) :: tbl, dfl) end.",
            "VernacFixpoint",
            "5a679e5aa3a3613683d50692815ea7b1fa3b176f"
        ],
        [
            "Fixpoint switch_env (ls: lbl_stmt) (e: exit_env) {struct ls}: exit_env := match ls with | LSnil => e | LScons _ _ ls' => false :: switch_env ls' e end.",
            "VernacFixpoint",
            "0c7ec7576dacbba57b604d140e38589349fdbeac"
        ],
        [
            "Fixpoint transl_stmt (cenv: compilenv) (xenv: exit_env) (s: Csharpminor.stmt) {struct s}: res stmt := match s with | Csharpminor.Sskip => OK Sskip | Csharpminor.Sset id e => do te <- transl_expr cenv e; OK (Sassign id te) | Csharpminor.Sstore chunk e1 e2 => do te1 <- transl_expr cenv e1; do te2 <- transl_expr cenv e2; OK (Sstore chunk te1 te2) | Csharpminor.Scall optid sig e el => do te <- transl_expr cenv e; do tel <- transl_exprlist cenv el; OK (Scall optid sig te tel) | Csharpminor.Sbuiltin optid ef el => do tel <- transl_exprlist cenv el; OK (Sbuiltin optid ef tel) | Csharpminor.Sseq s1 s2 => do ts1 <- transl_stmt cenv xenv s1; do ts2 <- transl_stmt cenv xenv s2; OK (Sseq ts1 ts2) | Csharpminor.Sifthenelse e s1 s2 => do te <- transl_expr cenv e; do ts1 <- transl_stmt cenv xenv s1; do ts2 <- transl_stmt cenv xenv s2; OK (Sifthenelse te ts1 ts2) | Csharpminor.Sloop s => do ts <- transl_stmt cenv xenv s; OK (Sloop ts) | Csharpminor.Sblock s => do ts <- transl_stmt cenv (true :: xenv) s; OK (Sblock ts) | Csharpminor.Sexit n => OK (Sexit (shift_exit xenv n)) | Csharpminor.Sswitch long e ls => let (tbl, dfl) := switch_table ls O in do te <- transl_expr cenv e; transl_lblstmt cenv (switch_env ls xenv) ls (Sswitch long te tbl dfl) | Csharpminor.Sreturn None => OK (Sreturn None) | Csharpminor.Sreturn (Some e) => do te <- transl_expr cenv e; OK (Sreturn (Some te)) | Csharpminor.Slabel lbl s => do ts <- transl_stmt cenv xenv s; OK (Slabel lbl ts) | Csharpminor.Sgoto lbl => OK (Sgoto lbl) end with transl_lblstmt (cenv: compilenv) (xenv: exit_env) (ls: Csharpminor.lbl_stmt) (body: stmt) {struct ls}: res stmt := match ls with | Csharpminor.LSnil => OK (Sseq (Sblock body) Sskip) | Csharpminor.LScons _ s ls' => do ts <- transl_stmt cenv xenv s; transl_lblstmt cenv (List.tail xenv) ls' (Sseq (Sblock body) ts) end.",
            "VernacFixpoint",
            "54f9d87fbd96aab9f4f2b0697e986fd3907c0562"
        ],
        [
            "Definition block_alignment (sz: Z) : Z := if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8.",
            "VernacDefinition",
            "4db4e431143f5dda5fffa54337a94b546fb4aabb"
        ],
        [
            "Definition assign_variable (cenv_stacksize: compilenv * Z) (id_sz: ident * Z) : compilenv * Z := let (id, sz) := id_sz in let (cenv, stacksize) := cenv_stacksize in let ofs := align stacksize (block_alignment sz) in (PTree.set id ofs cenv, ofs + Z.max 0 sz).",
            "VernacDefinition",
            "6d1e730e62404d0e5546439eb5e6d0cb20140e3b"
        ],
        [
            "Definition assign_variables (cenv_stacksize: compilenv * Z) (vars: list (ident * Z)) : compilenv * Z := List.fold_left assign_variable vars cenv_stacksize.",
            "VernacDefinition",
            "7efc2da907737b4fcc12dfd9e09f44968db6815f"
        ],
        [
            "Module VarOrder <: TotalLeBool.",
            "VernacDefineModule",
            "147d75221ae08f657bf2b71f387cde9806ebe3f8"
        ],
        [
            "Definition t := (ident * Z)%type.",
            "VernacDefinition",
            "e7d4f9950a418f611930b222a8fd55d4fe538c49"
        ],
        [
            "Definition leb (v1 v2: t) : bool := zle (snd v1) (snd v2).",
            "VernacDefinition",
            "799641cdd2e7af3c5d773ea21a5b17b5fe0b0de2"
        ],
        [
            "Theorem leb_total: forall v1 v2, leb v1 v2 = true \\/ leb v2 v1 = true.",
            "VernacStartTheoremProof",
            "d755745a2a98279b3670866d6683bfb9f8ef7b7c"
        ],
        [
            "unfold leb; intros.",
            "VernacExtend",
            "0d7dac64225c8faf3373476ef561e68a50921f54"
        ],
        [
            "assert (snd v1 <= snd v2 \\/ snd v2 <= snd v1) by omega.",
            "VernacExtend",
            "79d6f8b1e3caffdc6ee666e61263bd54f12fba2a"
        ],
        [
            "unfold proj_sumbool.",
            "VernacExtend",
            "9486e2b04f32f63b41268a30bc0b2a9032f4c304"
        ],
        [
            "destruct H; [left|right]; apply zle_true; auto.",
            "VernacExtend",
            "5c0bc79d51e5956a152faa9e23b64bf6c8e4f8ed"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End VarOrder.",
            "VernacEndSegment",
            "98d6a0c879bf9a483f74892e3c7bde4521ed4303"
        ],
        [
            "Module VarSort := Mergesort.Sort(VarOrder).",
            "VernacDefineModule",
            "1953317079679fcb1c14ac27e7e6e3b7f724432a"
        ],
        [
            "Definition build_compilenv (f: Csharpminor.function) : compilenv * Z := assign_variables (PTree.empty Z, 0) (VarSort.sort (Csharpminor.fn_vars f)).",
            "VernacDefinition",
            "b59049ffe66190104b2e24392db9a245dd404e2b"
        ],
        [
            "Definition transl_funbody (cenv: compilenv) (stacksize: Z) (f: Csharpminor.function): res function := do tbody <- transl_stmt cenv nil f.(Csharpminor.fn_body); OK (mkfunction (Csharpminor.fn_sig f) (Csharpminor.fn_params f) (Csharpminor.fn_temps f) stacksize tbody).",
            "VernacDefinition",
            "abe8b468ab495d32d5cf191c9c411b1b707054c0"
        ],
        [
            "Definition transl_function (f: Csharpminor.function): res function := let (cenv, stacksize) := build_compilenv f in if zle stacksize Ptrofs.max_unsigned then transl_funbody cenv stacksize f else Error(msg \"Cminorgen: too many local variables, stack size exceeded\").",
            "VernacDefinition",
            "9545232c6c1aa24d64733f7e4ee93f86eaafdb71"
        ],
        [
            "Definition transl_fundef (f: Csharpminor.fundef): res fundef := transf_partial_fundef transl_function f.",
            "VernacDefinition",
            "fea925558ad58e9c1106fc09d4f97cb612a9f53e"
        ],
        [
            "Definition transl_program (p: Csharpminor.program) : res program := transform_partial_program transl_fundef p.",
            "VernacDefinition",
            "34dbe21906438e8d9f97360b2f219f0f58799090"
        ]
    ],
    "proofs": [
        {
            "name": "leb_total",
            "line_nb": 22,
            "steps": [
                {
                    "command": [
                        "unfold leb; intros.",
                        "VernacExtend",
                        "0d7dac64225c8faf3373476ef561e68a50921f54"
                    ]
                },
                {
                    "command": [
                        "assert (snd v1 <= snd v2 \\/ snd v2 <= snd v1) by omega.",
                        "VernacExtend",
                        "79d6f8b1e3caffdc6ee666e61263bd54f12fba2a"
                    ]
                },
                {
                    "command": [
                        "unfold proj_sumbool.",
                        "VernacExtend",
                        "9486e2b04f32f63b41268a30bc0b2a9032f4c304"
                    ]
                },
                {
                    "command": [
                        "destruct H; [left|right]; apply zle_true; auto.",
                        "VernacExtend",
                        "5c0bc79d51e5956a152faa9e23b64bf6c8e4f8ed"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}