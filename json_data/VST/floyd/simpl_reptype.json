{
    "filename": "floyd/simpl_reptype.v",
    "coq_project": "VST",
    "vernac_cmds": [
        [
            "Require Import VST.floyd.base2.",
            "VernacRequire",
            "c9732b06b9c2316526989f551596fbf382fa6641"
        ],
        [
            "Require Import VST.floyd.functional_base.",
            "VernacRequire",
            "386f5a876c06dba949227f498f26a58bb6ebd9d8"
        ],
        [
            "Require Import VST.floyd.nested_field_lemmas.",
            "VernacRequire",
            "2ae988fac26931aaa409a9389758d750e8ca6601"
        ],
        [
            "Require Import VST.floyd.reptype_lemmas.",
            "VernacRequire",
            "67895477ec539ad1bf901b33e9b181c1c2cf58be"
        ],
        [
            "Require Import VST.floyd.proj_reptype_lemmas.",
            "VernacRequire",
            "f23e23e56fbc43071b2da91d2fb5090e3239f8a3"
        ],
        [
            "Require Import VST.floyd.replace_refill_reptype_lemmas.",
            "VernacRequire",
            "6f4a17f3b2a7a55d1dc134842116182719e05b1c"
        ],
        [
            "Require Import VST.floyd.simple_reify.",
            "VernacRequire",
            "1c0df0b2b2e060d5fde0a1382adbfaf5d41dc29a"
        ],
        [
            "Definition int_signed_or_unsigned (t: type) : int -> Z := match typeconv t with | Tint _ Signed _ => Int.signed | Tint _ Unsigned _ => Int.unsigned | _ => fun _ => 0 end.",
            "VernacDefinition",
            "9f2ce5b856a4a6504075788ee372ed0f83f11b0e"
        ],
        [
            "Section SIMPL_REPTYPE.",
            "VernacBeginSection",
            "5b33b5e39cb33b6c48e4753216ec3162c424071a"
        ],
        [
            "Context {cs: compspecs}.",
            "VernacContext",
            "54247ea3591f081b4582667d94ae6f9e673bf9e3"
        ],
        [
            "Definition is_effective_array (t: type) (n: Z) (a: attr) (i: Z) (v: reptype_skeleton) : option reptype_skeleton := None.",
            "VernacDefinition",
            "7675df38706b5fd2330ed0d8e596ca895e9359a7"
        ],
        [
            "Fixpoint is_effective_struct i (m: members) (v: reptype_skeleton) : option reptype_skeleton := match m with | nil => None | _ :: nil => Some v | (i', _) :: tl => match v with | RepPair v1 v2 => if (ident_eq i i') then Some v1 else is_effective_struct i tl v2 | _ => None end end.",
            "VernacFixpoint",
            "eeee8c0c74a90fda9c409125942cc933b5282bd6"
        ],
        [
            "Fixpoint is_effective_union i (m: members) (v: reptype_skeleton) : option reptype_skeleton := match m with | nil => None | _ :: nil => Some v | (i', _) :: tl => match v with | RepInl v0 => if (ident_eq i i') then Some v0 else None | RepInr v0 => if (ident_eq i i') then None else is_effective_struct i tl v0 | _ => None end end.",
            "VernacFixpoint",
            "e8ef3e36836717391ea4e6b114a1d4b4129348de"
        ],
        [
            "Definition is_effective (t: type) (gf: gfield) (v: reptype_skeleton) : option reptype_skeleton := match t, gf with | Tarray t0 hi a, ArraySubsc i => is_effective_array t0 hi a i v | Tstruct id _, StructField i => is_effective_struct i (co_members (get_co id)) v | Tunion id _, UnionField i => is_effective_union i (co_members (get_co id)) v | _, _ => None end.",
            "VernacDefinition",
            "891fe7873d453b73cd2ba32816fb06d7a7189d02"
        ],
        [
            "Fixpoint effective_len (t: type) (gfs: list gfield) (v: reptype_skeleton) : nat := length gfs.",
            "VernacFixpoint",
            "41138a2c8c3502f094530c43f9d72f730aacec1a"
        ],
        [
            "End SIMPL_REPTYPE.",
            "VernacEndSegment",
            "7d8ea0bba9b0b0ffd704a5806964a695342a844b"
        ],
        [
            "Ltac firstn_tac A n l := match n with | 0%nat => constr:(@nil A) | S ?n0 => match l with | @nil A => constr: (@nil A) | @cons A ?a ?l => let res := firstn_tac A n0 l in constr: (@cons A a res) end end.",
            "VernacExtend",
            "98b4b07e71491997e9d61dad317cbdaad18a67b4"
        ],
        [
            "Ltac skipn_tac A n l := match n with | 0%nat => constr: (l) | S ?n0 => match l with | @nil A => constr: (@nil A) | @cons A ?a ?l => let res := skipn_tac A n0 l in constr: (res) end end.",
            "VernacExtend",
            "793b3a05950f74c73e7ce7c356a5ad634d9a82ec"
        ],
        [
            "Ltac remember_indexes gfs := match gfs with | ArraySubsc ?i :: ?g' => remember i; remember_indexes g' | _ :: ?g' => remember_indexes g' | nil => idtac end.",
            "VernacExtend",
            "50f8dd6f04e8450deee8ef6f3da16285d8441002"
        ],
        [
            "Ltac solve_load_rule_evaluation_old := clear; repeat match goal with | A : _ |- _ => clear A | A := _ |- _ => clear A end; match goal with | |- JMeq (@proj_reptype _ _ ?name_of_gfs ?name_of_v) _ => subst name_of_gfs; try subst name_of_v end; match goal with | |- JMeq (@proj_reptype _ _ ?gfs _) _ => remember_indexes gfs end; match goal with | |- JMeq (@proj_reptype ?cs ?t ?gfs ?v) _ => let s := simple_reify.simple_reify v in let len_opaque := eval vm_compute in (length gfs - effective_len t gfs s)%nat in let gfs_opaque := (firstn_tac gfield len_opaque gfs) in let gfs_compute := (skipn_tac gfield len_opaque gfs) in match gfs_opaque with | nil => let opaque_function := fresh \"opaque_function\" in let opaque_v := fresh \"v\" in pose (proj_reptype (nested_field_type t gfs_compute) gfs_opaque) as opaque_function; set (opaque_v := v); lazy beta zeta iota delta - [opaque_v sublist.Znth Int.repr]; subst opaque_v; subst; apply JMeq_refl | @cons _ _ _ => let opaque_function := fresh \"opaque_function\" in let opaque_v := fresh \"v\" in pose (proj_reptype (nested_field_type t gfs_compute) gfs_opaque) as opaque_function; set (opaque_v := v); lazy beta zeta iota delta - [opaque_function opaque_v sublist.Znth Int.repr]; subst opaque_v opaque_function; subst; apply JMeq_refl end end.",
            "VernacExtend",
            "f5ba751383331fac6031f4ff2318d6859887b77d"
        ],
        [
            "Ltac default_canon_load_result := repeat ( first [ rewrite Znth_map_Vbyte | rewrite (@Znth_map int _) | rewrite (@Znth_map int64 _) | rewrite (@Znth_map val _) | rewrite (@Znth_map Z _) ]; [ | solve [auto; list_solve] + match goal with | |- ?Bounds => fail 10 \"Make sure list_solve or auto can prove\" Bounds end ] ).",
            "VernacExtend",
            "a39da53554e1fd1e0ad4e30bd573d3253ca72e0f"
        ],
        [
            "Ltac canon_load_result := default_canon_load_result.",
            "VernacExtend",
            "4d218d2a04bbca80ea757c35d094edde55570e60"
        ],
        [
            "Ltac solve_load_rule_evaluation := eapply JMeq_trans; [ clear; repeat match goal with | A : _ |- _ => clear A | A := _ |- _ => clear A end; match goal with | |- JMeq (@proj_reptype _ _ ?gfs _) _ => remember_indexes gfs end; match goal with | |- JMeq (@proj_reptype ?cs ?t ?gfs ?v) _ => let opaque_v := fresh \"opaque_v\" in set (opaque_v := v); cbv - [opaque_v sublist.Znth Int.repr JMeq]; subst opaque_v; subst; apply JMeq_refl end | canon_load_result; apply JMeq_refl ].",
            "VernacExtend",
            "8a5a3d90eae354cda63d717a545c68900c560f8d"
        ],
        [
            "Ltac simplify_casts := cbv beta iota delta [ Cop.cast_int_int Cop.cast_int_float Cop.cast_float_int Cop.cast_int_single Cop.cast_single_int Cop.cast_int_long Cop.cast_long_float Cop.cast_long_single Cop.cast_float_long Cop.cast_single_long ]; rewrite ?sign_ext_inrange by (let z := fresh \"z\" in set (z := two_p (Zpos _ - 1)); compute in z; subst z; rewrite Int.signed_repr by rep_omega; rep_omega).",
            "VernacExtend",
            "58d58421b7f347d92e0fdc545132656ad1882dac"
        ],
        [
            "Lemma cons_congr: forall {A} (a a': A) bl bl', a=a' -> bl=bl' -> a::bl = a'::bl'.",
            "VernacStartTheoremProof",
            "0c8402c882c71bd30e9f3231e1a7ed0a38b7ee56"
        ],
        [
            "intros; f_equal; auto.",
            "VernacExtend",
            "5a31003e6ba104e4a8e4fdb7d631f8976ef4ecc7"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Ltac subst_indexes gfs := match gfs with | ArraySubsc ?i :: ?g' => match goal with H: ?x = i |- _ => is_var x; subst x; subst_indexes g' end | _ :: ?g' => subst_indexes g' | nil => idtac end.",
            "VernacExtend",
            "48d97ac90c5e7382538d017962d5f919ff65c579"
        ],
        [
            "Ltac solve_store_rule_evaluation := match goal with |- upd_reptype ?t ?gfs ?v0 ?v1 = ?B => let rhs := fresh \"rhs\" in set (rhs := B); lazy beta zeta iota delta [reptype reptype_gen] in rhs; simpl in rhs; let h0 := fresh \"h0\" in let h1 := fresh \"h1\" in set (h0:=v0); set (h1:=v1); change (upd_reptype t gfs h0 h1 = rhs); remember_indexes gfs; let j := fresh \"j\" in match type of h0 with ?J => set (j := J) in h0 end; lazy beta zeta iota delta in j; subst j; lazy beta zeta iota delta - [rhs h0 h1 upd_Znth Zlength]; try unfold v1 in h1; revert h1; simplify_casts; cbv zeta; subst rhs h0; subst_indexes gfs; apply eq_refl end.",
            "VernacExtend",
            "7cffa13a9f5d6086dfc34e873bbf4688060455fd"
        ]
    ],
    "proofs": [
        {
            "name": "cons_congr",
            "line_nb": 24,
            "steps": [
                {
                    "command": [
                        "intros; f_equal; auto.",
                        "VernacExtend",
                        "5a31003e6ba104e4a8e4fdb7d631f8976ef4ecc7"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}