{
    "filename": "plugins/ssr/ssreflect.v",
    "coq_project": "coq",
    "vernac_cmds": [
        [
            "Require Import Bool.",
            "VernacRequire",
            "a27d9a6c92262b970381301472e9a1100c206680"
        ],
        [
            "Require Import ssrmatching.",
            "VernacRequire",
            "3931c150f7fe00902e714094d651748ed3de3317"
        ],
        [
            "Declare ML Module \"ssreflect_plugin\".",
            "VernacDeclareMLModule",
            "1cbb3b96ace1402b1be898eb8601d3e534dd7bcb"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Unset Strict Implicit.",
            "VernacUnsetOption",
            "2842adaf6959318f2042805935c46f513bdc0348"
        ],
        [
            "Unset Printing Implicit Defensive.",
            "VernacUnsetOption",
            "444e5f0be4b25d9b1fd556943a447ec10046d151"
        ],
        [
            "Module SsrSyntax.",
            "VernacDefineModule",
            "089772b8db60e990274dc23589e5165dce751ff9"
        ],
        [
            "Reserved Notation \"(* x 'is' y 'of' z 'isn't' // /= //= *)\" (at level 8).",
            "VernacSyntaxExtension",
            "1bcbf09b095a5a0c0bbc2db1ef03748f3b018d64"
        ],
        [
            "Reserved Notation \"(* 69 *)\" (at level 69).",
            "VernacSyntaxExtension",
            "53966f811026e0c998c333d7aee1cffa520a4058"
        ],
        [
            "Reserved Notation \"(* Use to test if 'SsrSyntax_is_Imported' *)\" (at level 8).",
            "VernacSyntaxExtension",
            "214bcff462311acb005ee15a4dd677eeef7af582"
        ],
        [
            "Reserved Notation \"<hidden n >\" (at level 200).",
            "VernacSyntaxExtension",
            "4f11a2f0770554549d2f00843c020fe673ac8f26"
        ],
        [
            "Reserved Notation \"T (* n *)\" (at level 200, format \"T (* n *)\").",
            "VernacSyntaxExtension",
            "7a6fd88657e81633d1f6f5b8f8055a582b1e794d"
        ],
        [
            "End SsrSyntax.",
            "VernacEndSegment",
            "a8503e5e32fda29e917811c5b44749eeab880964"
        ],
        [
            "Export SsrMatchingSyntax.",
            "VernacImport",
            "f6205bba3a51eb4661d67ff65069816ec03f11e9"
        ],
        [
            "Export SsrSyntax.",
            "VernacImport",
            "dee3d9e40ae95d061a0e78b7909686fc59c4e880"
        ],
        [
            "Delimit Scope general_if_scope with GEN_IF.",
            "VernacDelimiters",
            "e5a132bf70792dab86e6ca9327109412e283b3a0"
        ],
        [
            "Notation \"'if' c 'then' v1 'else' v2\" := (if c then v1 else v2) (at level 200, c, v1, v2 at level 200, only parsing) : general_if_scope.",
            "VernacNotation",
            "a85f0c12c81ac4ff625aaeded75ee96978474511"
        ],
        [
            "Notation \"'if' c 'return' t 'then' v1 'else' v2\" := (if c return t then v1 else v2) (at level 200, c, t, v1, v2 at level 200, only parsing) : general_if_scope.",
            "VernacNotation",
            "5d52f59666c4310fbf8871a2525cf92a4d2a35db"
        ],
        [
            "Notation \"'if' c 'as' x 'return' t 'then' v1 'else' v2\" := (if c as x return t then v1 else v2) (at level 200, c, t, v1, v2 at level 200, x ident, only parsing) : general_if_scope.",
            "VernacNotation",
            "5fc689cc22f34341ed8c3ca39013728fd5105a18"
        ],
        [
            "Delimit Scope boolean_if_scope with BOOL_IF.",
            "VernacDelimiters",
            "d76b95cee53183dfcff84739b5c948938170993d"
        ],
        [
            "Notation \"'if' c 'return' t 'then' v1 'else' v2\" := (if c%bool is true in bool return t then v1 else v2) : boolean_if_scope.",
            "VernacNotation",
            "2a0eb0b7ed39c1365a182dfa6d2faaf03dda2068"
        ],
        [
            "Notation \"'if' c 'then' v1 'else' v2\" := (if c%bool is true in bool return _ then v1 else v2) : boolean_if_scope.",
            "VernacNotation",
            "321f617b09f10259f30aa615106ad6b58b42e80e"
        ],
        [
            "Notation \"'if' c 'as' x 'return' t 'then' v1 'else' v2\" := (if c%bool is true as x in bool return t then v1 else v2) : boolean_if_scope.",
            "VernacNotation",
            "68a2b0652810f15e57e738d7cba761f21fb15398"
        ],
        [
            "Open Scope boolean_if_scope.",
            "VernacOpenCloseScope",
            "e1a0bc14da42a8d41552888db3e12f022333a117"
        ],
        [
            "Delimit Scope form_scope with FORM.",
            "VernacDelimiters",
            "4cbc0440d49f8963d0eb90e9637621875f92baa8"
        ],
        [
            "Open Scope form_scope.",
            "VernacOpenCloseScope",
            "3dfbc3dfc95e74577ed6c1334d3575062716e9b1"
        ],
        [
            "Notation \"x : T\" := (x : T) (at level 100, right associativity, format \"'[hv' x '/ ' : T ']'\") : core_scope.",
            "VernacNotation",
            "134df04a3fe2b208630b945e81c440dc81caf944"
        ],
        [
            "Notation \"T : 'Type'\" := (T%type : Type) (at level 100, only parsing) : core_scope.",
            "VernacNotation",
            "29ed74cf7a98cdfc2a7f3d5d6d1729ec2d707bee"
        ],
        [
            "Notation \"P : 'Prop'\" := (P%type : Prop) (at level 100, only parsing) : core_scope.",
            "VernacNotation",
            "2abc2a1611771ca623b69d588e95dfdf42087458"
        ],
        [
            "Definition abstract_lock := unit.",
            "VernacDefinition",
            "af45030eb19d18b69126cb72d1a82523d02d6d90"
        ],
        [
            "Definition abstract_key := tt.",
            "VernacDefinition",
            "466ff73ff04d17908b98233520f8e83f92c479f2"
        ],
        [
            "Definition abstract (statement : Type) (id : nat) (lock : abstract_lock) := let: tt := lock in statement.",
            "VernacDefinition",
            "f23058b5574399940fa77c6e098409750bef8953"
        ],
        [
            "Notation \"<hidden n >\" := (abstract _ n _).",
            "VernacNotation",
            "260bbf69a33c38845e8802522765a38b01b4081e"
        ],
        [
            "Notation \"T (* n *)\" := (abstract T n abstract_key).",
            "VernacNotation",
            "f95e2b4c2c3ceaf1d1027759920ee689d574786d"
        ],
        [
            "Inductive external_view : Type := tactic_view of Type.",
            "VernacInductive",
            "b5267d523519001746972a86995095375a758675"
        ],
        [
            "Module TheCanonical.",
            "VernacDefineModule",
            "7974e5c8894536c2f7e8df696292f23556bd68ca"
        ],
        [
            "Variant put vT sT (v1 v2 : vT) (s : sT) := Put.",
            "VernacInductive",
            "e8b95cb737a9a5c002e95889cda63e78821b6571"
        ],
        [
            "Definition get vT sT v s (p : @put vT sT v v s) := let: Put _ _ _ := p in s.",
            "VernacDefinition",
            "69b90293d0adcbb5649b39aa5798cec871cdba46"
        ],
        [
            "Definition get_by vT sT of sT -> vT := @get vT sT.",
            "VernacDefinition",
            "7c1a2dfc7f4e1218b4640d7a97071439c05b2753"
        ],
        [
            "End TheCanonical.",
            "VernacEndSegment",
            "5e094d2df07754920379f358610a44269cbb274f"
        ],
        [
            "Import TheCanonical.",
            "VernacImport",
            "6e114fd51e4f021416d128ecf71c9e1e5c18565b"
        ],
        [
            "Local Arguments get_by _%type_scope _%type_scope _ _ _ _.",
            "VernacArguments",
            "cdfa00ade1985099febb8f89f8ff53c0f25be6f9"
        ],
        [
            "Notation \"[ 'the' sT 'of' v 'by' f ]\" := (@get_by _ sT f _ _ ((fun v' (s : sT) => Put v' (f s) s) v _)) (at level 0, only parsing) : form_scope.",
            "VernacNotation",
            "028d544895e1feb31ff8530968280713069c58f8"
        ],
        [
            "Notation \"[ 'the' sT 'of' v ]\" := (get ((fun s : sT => Put v s s) _)) (at level 0, only parsing) : form_scope.",
            "VernacNotation",
            "c79d5888875fd67a9b083abdc7da9ad962db08e9"
        ],
        [
            "Notation \"[ 'th' 'e' sT 'of' v 'by' f ]\" := (@get_by _ sT f v _ _) (at level 0, format \"[ 'th' 'e' sT 'of' v 'by' f ]\") : form_scope.",
            "VernacNotation",
            "beb9cc99b684087bbed5cea9371be5a772b75c70"
        ],
        [
            "Notation \"[ 'th' 'e' sT 'of' v ]\" := (@get _ sT v _ _) (at level 0, format \"[ 'th' 'e' sT 'of' v ]\") : form_scope.",
            "VernacNotation",
            "ddbbd1637eb03cb4054c9eaf2a25244b2d85f77d"
        ],
        [
            "Definition argumentType T P & forall x : T, P x := T.",
            "VernacDefinition",
            "d05aaec88075633cee31b213c1fbce5715158d59"
        ],
        [
            "Definition dependentReturnType T P & forall x : T, P x := P.",
            "VernacDefinition",
            "4449b64cd11533e1690ec58113ad19acdb1a3614"
        ],
        [
            "Definition returnType aT rT & aT -> rT := rT.",
            "VernacDefinition",
            "1934fa3d1184b1e77f3ab970d9e627e3510d3caf"
        ],
        [
            "Notation \"{ 'type' 'of' c 'for' s }\" := (dependentReturnType c s) (at level 0, format \"{ 'type' 'of' c 'for' s }\") : type_scope.",
            "VernacNotation",
            "54cce68683670e5ccb577c8d97b2bddd97b7382a"
        ],
        [
            "Variant phantom T (p : T) := Phantom.",
            "VernacInductive",
            "6b98b310d929e76eb352778fcc612b389004482d"
        ],
        [
            "Arguments phantom : clear implicits.",
            "VernacArguments",
            "3c4402d859c97028fe72184ae224e43b3427cd87"
        ],
        [
            "Arguments Phantom : clear implicits.",
            "VernacArguments",
            "0ce2bfff453c02356b4c15dc6b9bb172c614aa85"
        ],
        [
            "Variant phant (p : Type) := Phant.",
            "VernacInductive",
            "3895018a854c634bbc3d14230c90872485c5ff3a"
        ],
        [
            "Definition protect_term (A : Type) (x : A) : A := x.",
            "VernacDefinition",
            "0e044b2135b1bf4bf51d8530aa5501fef1204a6b"
        ],
        [
            "Notation unkeyed x := (let flex := x in flex).",
            "VernacSyntacticDefinition",
            "8c682623c40a0ad7804dcb237c0a87d1cbb70ad9"
        ],
        [
            "Definition ssr_converse R (r : R) := (Logic.I, r).",
            "VernacDefinition",
            "11b4eca96453c3cc3fc27a3aeacc1ac54f3d0074"
        ],
        [
            "Notation \"=^~ r\" := (ssr_converse r) (at level 100) : form_scope.",
            "VernacNotation",
            "a6655a5c277d37890c3a7c5ce85a8cdd790c4978"
        ],
        [
            "Notation nosimpl t := (let: tt := tt in t).",
            "VernacSyntacticDefinition",
            "01de0c4278ce722e970115f692558f82df213f3a"
        ],
        [
            "Lemma master_key : unit.",
            "VernacStartTheoremProof",
            "a10551d681f1a0c201b5c50cbcb07485003aaab3"
        ],
        [
            "exact tt.",
            "VernacExtend",
            "ee7ec194b92962e268f39f5f6f91046c4cd0c478"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition locked A := let: tt := master_key in fun x : A => x.",
            "VernacDefinition",
            "9be6bfaf76725bd59ee7728e5241196cdd27b13c"
        ],
        [
            "Lemma lock A x : x = locked x :> A.",
            "VernacStartTheoremProof",
            "89e4f16338af9fbc35f79577697a8d70d4c41a1e"
        ],
        [
            "unlock; reflexivity.",
            "VernacExtend",
            "a10515ad761a895a7c2ac7e58624142535bd1eb6"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma not_locked_false_eq_true : locked false <> true.",
            "VernacStartTheoremProof",
            "c9c9868bb4444eab591cd154a4303e4c2df698d3"
        ],
        [
            "unlock; discriminate.",
            "VernacExtend",
            "b19930600199709d92c605f32230fee08f7067d5"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Ltac done := trivial; hnf; intros; solve [ do ![solve [trivial | apply: sym_equal; trivial] | discriminate | contradiction | split] | case not_locked_false_eq_true; assumption | match goal with H : ~ _ |- _ => solve [case H; trivial] end ].",
            "VernacExtend",
            "9442a2db3d5f44759d9741ea8f428a9660179ef2"
        ],
        [
            "Ltac ssrdone0 := trivial; hnf; intros; solve [ do ![solve [trivial | apply: sym_equal; trivial] | discriminate | contradiction ] | case not_locked_false_eq_true; assumption | match goal with H : ~ _ |- _ => solve [case H; trivial] end ].",
            "VernacExtend",
            "3e735940dd5e76f369bcb53a0e13f8c89c058ce4"
        ],
        [
            "Structure unlockable T v := Unlockable {unlocked : T; _ : unlocked = v}.",
            "VernacInductive",
            "05160f67e2fc4c930415bf434bf8244431f47fa2"
        ],
        [
            "Lemma unlock T x C : @unlocked T x C = x.",
            "VernacStartTheoremProof",
            "19742d765d8c4f40333889a4dea9ee71711ccbb5"
        ],
        [
            "by case: C.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Notation \"[ 'unlockable' 'of' C ]\" := (@Unlockable _ _ C (unlock _)) (at level 0, format \"[ 'unlockable' 'of' C ]\") : form_scope.",
            "VernacNotation",
            "158ad2a70e54135d98b548b8b09975aedd8597a2"
        ],
        [
            "Notation \"[ 'unlockable' 'fun' C ]\" := (@Unlockable _ (fun _ => _) C (unlock _)) (at level 0, format \"[ 'unlockable' 'fun' C ]\") : form_scope.",
            "VernacNotation",
            "7affddcdaafddf1fdb961f1100c950e36614962c"
        ],
        [
            "Definition locked_with k := let: tt := k in fun T x => x : T.",
            "VernacDefinition",
            "6ab3943662309c48c1cbe4e27adde5d856ec8a00"
        ],
        [
            "Lemma locked_withE T k x : unkeyed (locked_with k x) = x :> T.",
            "VernacStartTheoremProof",
            "494ab56b3b3c601fc9a375efa84f3b9a018ec0be"
        ],
        [
            "by case: k.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Canonical locked_with_unlockable T k x := @Unlockable T x (locked_with k x) (locked_withE k x).",
            "VernacDefinition",
            "98c753b44be6583d54f691aa510a1f76b0002e61"
        ],
        [
            "Lemma unlock_with T k x : unlocked (locked_with_unlockable k x) = x :> T.",
            "VernacStartTheoremProof",
            "17c25d351a1e9364fe2a8fe8115b047c7b0f8f20"
        ],
        [
            "exact: unlock.",
            "VernacExtend",
            "ecc84cd07889559a1f88cfbe94e8d2486c2083fa"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition ssr_have Plemma Pgoal (step : Plemma) rest : Pgoal := rest step.",
            "VernacDefinition",
            "a6fd0de4a030cecaa022b280f2dce2544d14f68d"
        ],
        [
            "Arguments ssr_have Plemma [Pgoal].",
            "VernacArguments",
            "f70e8af05d022bc803209adf5d104a678d23d762"
        ],
        [
            "Definition ssr_have_let Pgoal Plemma step (rest : let x : Plemma := step in Pgoal) : Pgoal := rest.",
            "VernacDefinition",
            "dcc17dbfdc0c6dc43f69690e358e8e8dafa4b38d"
        ],
        [
            "Arguments ssr_have_let [Pgoal].",
            "VernacArguments",
            "ece93ccdd19f3af21ae8db5846f76f76402c1086"
        ],
        [
            "Definition ssr_suff Plemma Pgoal step (rest : Plemma) : Pgoal := step rest.",
            "VernacDefinition",
            "6ee229beba5cb0c554bce382f1ed6f1aa9baa87a"
        ],
        [
            "Arguments ssr_suff Plemma [Pgoal].",
            "VernacArguments",
            "59f5fa9c73793e7b705b4cc12dd3b09e348f3c63"
        ],
        [
            "Definition ssr_wlog := ssr_suff.",
            "VernacDefinition",
            "7acbfb4875bef9866ba8a3c8750c43ed9336ac53"
        ],
        [
            "Arguments ssr_wlog Plemma [Pgoal].",
            "VernacArguments",
            "2a602afc530caa5940d6637907b532c9fa88324f"
        ],
        [
            "Fixpoint nary_congruence_statement (n : nat) : (forall B, (B -> B -> Prop) -> Prop) -> Prop := match n with | O => fun k => forall B, k B (fun x1 x2 : B => x1 = x2) | S n' => let k' A B e (f1 f2 : A -> B) := forall x1 x2, x1 = x2 -> (e (f1 x1) (f2 x2) : Prop) in fun k => forall A, nary_congruence_statement n' (fun B e => k _ (k' A B e)) end.",
            "VernacFixpoint",
            "c30ae4042fe90fd75efc89266fba7936d7cd2990"
        ],
        [
            "Lemma nary_congruence n (k := fun B e => forall y : B, (e y y : Prop)) : nary_congruence_statement n k.",
            "VernacStartTheoremProof",
            "53ea70653e2372ece14fe590eee5141fded40948"
        ],
        [
            "have: k _ _ := _; rewrite {1}/k.",
            "VernacExtend",
            "85487f2249cdba7ae38c2b91c9e0889f7e933cee"
        ],
        [
            "elim: n k => [|n IHn] k k_P /= A; first exact: k_P.",
            "VernacExtend",
            "3763a4b8db689af316a7372b722bb29806ab4fb6"
        ],
        [
            "by apply: IHn => B e He; apply: k_P => f x1 x2 <-.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma ssr_congr_arrow Plemma Pgoal : Plemma = Pgoal -> Plemma -> Pgoal.",
            "VernacStartTheoremProof",
            "913a5efcbcf95508e97cca039e99dd727ad5f2aa"
        ],
        [
            "by move->.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Arguments ssr_congr_arrow : clear implicits.",
            "VernacArguments",
            "11a1c0daeb723cf6299f457b7fd18a3939b69ff9"
        ],
        [
            "Section ApplyIff.",
            "VernacBeginSection",
            "877614d1d3df194eba8e57455b5911e4d97de268"
        ],
        [
            "Variables P Q : Prop.",
            "VernacAssumption",
            "73194bb290d23dc3f7d83ca8da700fc041c5255c"
        ],
        [
            "Hypothesis eqPQ : P <-> Q.",
            "VernacAssumption",
            "8d7677b25961f56d2c22fc2311319583ca4ce6eb"
        ],
        [
            "Lemma iffLR : P -> Q.",
            "VernacStartTheoremProof",
            "54a3f95bb12767ecc2fad15f17fad140e1051d51"
        ],
        [
            "by case: eqPQ.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma iffRL : Q -> P.",
            "VernacStartTheoremProof",
            "2c86d909b80f364b0a8e05dc6f48efdfe7d216de"
        ],
        [
            "by case: eqPQ.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma iffLRn : ~P -> ~Q.",
            "VernacStartTheoremProof",
            "df6d5d2f001131dd03c84a578f2afbe59c434d13"
        ],
        [
            "by move=> nP tQ; case: nP; case: eqPQ tQ.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma iffRLn : ~Q -> ~P.",
            "VernacStartTheoremProof",
            "0583f8419860506d5de99cf7a41831012e1a8572"
        ],
        [
            "by move=> nQ tP; case: nQ; case: eqPQ tP.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End ApplyIff.",
            "VernacEndSegment",
            "96f4783c5d39062dbf5a13684154fcecc2b689ec"
        ],
        [
            "Hint View for move/ iffLRn|2 iffRLn|2 iffLR|2 iffRL|2.",
            "VernacExtend",
            "7c574212accfde44662066099df3e72c85419216"
        ],
        [
            "Hint View for apply/ iffRLn|2 iffLRn|2 iffRL|2 iffLR|2.",
            "VernacExtend",
            "7c574212accfde44662066099df3e72c85419216"
        ],
        [
            "Lemma abstract_context T (P : T -> Type) x : (forall Q, Q = P -> Q x) -> P x.",
            "VernacStartTheoremProof",
            "1e31c9575c8a9a360a3b192ee679c744a28906c3"
        ],
        [
            "by move=> /(_ P); apply.",
            "VernacExtend",
            "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ]
    ],
    "proofs": [
        {
            "name": "master_key",
            "line_nb": 59,
            "steps": [
                {
                    "command": [
                        "exact tt.",
                        "VernacExtend",
                        "ee7ec194b92962e268f39f5f6f91046c4cd0c478"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "lock",
            "line_nb": 63,
            "steps": [
                {
                    "command": [
                        "unlock; reflexivity.",
                        "VernacExtend",
                        "a10515ad761a895a7c2ac7e58624142535bd1eb6"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "not_locked_false_eq_true",
            "line_nb": 66,
            "steps": [
                {
                    "command": [
                        "unlock; discriminate.",
                        "VernacExtend",
                        "b19930600199709d92c605f32230fee08f7067d5"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "unlock",
            "line_nb": 72,
            "steps": [
                {
                    "command": [
                        "by case: C.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "locked_withE",
            "line_nb": 78,
            "steps": [
                {
                    "command": [
                        "by case: k.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "unlock_with",
            "line_nb": 82,
            "steps": [
                {
                    "command": [
                        "exact: unlock.",
                        "VernacExtend",
                        "ecc84cd07889559a1f88cfbe94e8d2486c2083fa"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "nary_congruence",
            "line_nb": 94,
            "steps": [
                {
                    "command": [
                        "have: k _ _ := _; rewrite {1}/k.",
                        "VernacExtend",
                        "85487f2249cdba7ae38c2b91c9e0889f7e933cee"
                    ]
                },
                {
                    "command": [
                        "elim: n k => [|n IHn] k k_P /= A; first exact: k_P.",
                        "VernacExtend",
                        "3763a4b8db689af316a7372b722bb29806ab4fb6"
                    ]
                },
                {
                    "command": [
                        "by apply: IHn => B e He; apply: k_P => f x1 x2 <-.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "ssr_congr_arrow",
            "line_nb": 99,
            "steps": [
                {
                    "command": [
                        "by move->.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "iffLR",
            "line_nb": 106,
            "steps": [
                {
                    "command": [
                        "by case: eqPQ.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "iffRL",
            "line_nb": 109,
            "steps": [
                {
                    "command": [
                        "by case: eqPQ.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "iffLRn",
            "line_nb": 112,
            "steps": [
                {
                    "command": [
                        "by move=> nP tQ; case: nP; case: eqPQ tQ.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "iffRLn",
            "line_nb": 115,
            "steps": [
                {
                    "command": [
                        "by move=> nQ tP; case: nQ; case: eqPQ tP.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "abstract_context",
            "line_nb": 121,
            "steps": [
                {
                    "command": [
                        "by move=> /(_ P); apply.",
                        "VernacExtend",
                        "54a8862ad3e0e6c98a46e5e638cd4fb1607ee133"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}