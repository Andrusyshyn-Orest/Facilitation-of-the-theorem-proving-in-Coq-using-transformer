{
    "filename": "theories/Logic/ClassicalDescription.v",
    "coq_project": "coq",
    "vernac_cmds": [
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Require Export Classical.",
            "VernacRequire",
            "931639e04b7f4b817db4e158c9ff078a0a2025f4"
        ],
        [
            "Require Export Description.",
            "VernacRequire",
            "6829b26a7f2b9cf93230b1a3398482144f7acdfd"
        ],
        [
            "Require Import ChoiceFacts.",
            "VernacRequire",
            "707afaaed3b0657ff42b934f7a76a76875081ed8"
        ],
        [
            "Local Notation inhabited A := A (only parsing).",
            "VernacSyntacticDefinition",
            "345186f55d5016107f16644711c216ee47a3e93c"
        ],
        [
            "Theorem excluded_middle_informative : forall P:Prop, {P} + {~ P}.",
            "VernacStartTheoremProof",
            "35b46ee11f1330dd209c52cae30dc24e6ff1bf41"
        ],
        [
            "apply (constructive_definite_descr_excluded_middle constructive_definite_description classic).",
            "VernacExtend",
            "e588bd0c2a3ef221c1d536417fd6de4ac8a5f3f0"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem classical_definite_description : forall (A : Type) (P : A->Prop), inhabited A -> { x : A | (exists! x : A, P x) -> P x }.",
            "VernacStartTheoremProof",
            "0694d5dbac1d633a10c6d01e2e68c998099a620c"
        ],
        [
            "intros A P i.",
            "VernacExtend",
            "f55624366e5b1c393cd7de53f5fb01c39357be46"
        ],
        [
            "destruct (excluded_middle_informative (exists! x, P x)) as [Hex|HnonP].",
            "VernacExtend",
            "77a627fced9b67947c8e236739c6d7cf27b39fa2"
        ],
        [
            "apply constructive_definite_description with (P:= fun x => (exists! x : A, P x) -> P x).",
            "VernacExtend",
            "fec58ca7c9dcce2b915d298a0704febaffa99f78"
        ],
        [
            "destruct Hex as (x,(Hx,Huni)).",
            "VernacExtend",
            "066ed6a2b6a62454b5a5b78a8f854b174679cf31"
        ],
        [
            "exists x; split.",
            "VernacExtend",
            "f9266ddab0754060cc1803dfa28547707d7da7dd"
        ],
        [
            "intros _; exact Hx.",
            "VernacExtend",
            "eb0c845abcdc305705a5b01ccea641d52a3868d8"
        ],
        [
            "firstorder.",
            "VernacExtend",
            "ceb9f57e98a5f5a73ee421cf30fd2f4f09432d14"
        ],
        [
            "exists i; tauto.",
            "VernacExtend",
            "c12072aac2416429ecc8cbc79348d202bd5952b8"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Definition iota (A : Type) (i:inhabited A) (P : A->Prop) : A := proj1_sig (classical_definite_description P i).",
            "VernacDefinition",
            "c5d8753102736b634e45558def45508fdc23a40a"
        ],
        [
            "Definition iota_spec (A : Type) (i:inhabited A) (P : A->Prop) : (exists! x:A, P x) -> P (iota i P) := proj2_sig (classical_definite_description P i).",
            "VernacDefinition",
            "167c9371e84c9894cef1825359f067be855c3830"
        ],
        [
            "Theorem dependent_unique_choice : forall (A:Type) (B:A -> Type) (R:forall x:A, B x -> Prop), (forall x:A, exists! y : B x, R x y) -> (exists f : (forall x:A, B x), forall x:A, R x (f x)).",
            "VernacStartTheoremProof",
            "0b735acdc0646606e47bbd447c4fe0cd581ec65e"
        ],
        [
            "intros A B R H.",
            "VernacExtend",
            "3ecae2b43e0e07b9a66aabaa8ce4a930fae8cdfe"
        ],
        [
            "assert (Hexuni:forall x, exists! y, R x y).",
            "VernacExtend",
            "10beb1f44a7c414817fee8295295bf0c947fa216"
        ],
        [
            "intro x.",
            "VernacExtend",
            "f7163633eedf12f483fa0d8c0c119dd59431ca1e"
        ],
        [
            "apply H.",
            "VernacExtend",
            "4b47b71ad0f800d57cbdc591d68949e07decb540"
        ],
        [
            "exists (fun x => proj1_sig (constructive_definite_description (R x) (Hexuni x))).",
            "VernacExtend",
            "9f88f0d8eca5c43b0a057268781cb0615915dadd"
        ],
        [
            "intro x.",
            "VernacExtend",
            "f7163633eedf12f483fa0d8c0c119dd59431ca1e"
        ],
        [
            "apply (proj2_sig (constructive_definite_description (R x) (Hexuni x))).",
            "VernacExtend",
            "1fb8e81750b4440803dd689a0f52af0e68824435"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem unique_choice : forall (A B:Type) (R:A -> B -> Prop), (forall x:A, exists! y : B, R x y) -> (exists f : A -> B, forall x:A, R x (f x)).",
            "VernacStartTheoremProof",
            "c94833c40c51e13951ec9b8f220ff0f06ccb2ee5"
        ],
        [
            "intros A B.",
            "VernacExtend",
            "f0fdd14fe43c412ab9e9cf2b93b27330098322c4"
        ],
        [
            "apply dependent_unique_choice with (B:=fun _:A => B).",
            "VernacExtend",
            "1368cc54283c9979305614c273d286f9c4cbc732"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Unset Implicit Arguments.",
            "VernacUnsetOption",
            "cacc0f023301fae157e1bbb31e84419045fc8198"
        ],
        [
            "Definition dependent_description := dependent_unique_choice.",
            "VernacDefinition",
            "5176a66bc6da2503510ed4150ee7b2ea1787b5e7"
        ],
        [
            "Definition description := unique_choice.",
            "VernacDefinition",
            "6dfd7c98eb8e9c382102c6f857796c859676ae4a"
        ]
    ],
    "proofs": [
        {
            "name": "excluded_middle_informative",
            "line_nb": 5,
            "steps": [
                {
                    "command": [
                        "apply (constructive_definite_descr_excluded_middle constructive_definite_description classic).",
                        "VernacExtend",
                        "e588bd0c2a3ef221c1d536417fd6de4ac8a5f3f0"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "classical_definite_description",
            "line_nb": 8,
            "steps": [
                {
                    "command": [
                        "intros A P i.",
                        "VernacExtend",
                        "f55624366e5b1c393cd7de53f5fb01c39357be46"
                    ]
                },
                {
                    "command": [
                        "destruct (excluded_middle_informative (exists! x, P x)) as [Hex|HnonP].",
                        "VernacExtend",
                        "77a627fced9b67947c8e236739c6d7cf27b39fa2"
                    ]
                },
                {
                    "command": [
                        "apply constructive_definite_description with (P:= fun x => (exists! x : A, P x) -> P x).",
                        "VernacExtend",
                        "fec58ca7c9dcce2b915d298a0704febaffa99f78"
                    ]
                },
                {
                    "command": [
                        "destruct Hex as (x,(Hx,Huni)).",
                        "VernacExtend",
                        "066ed6a2b6a62454b5a5b78a8f854b174679cf31"
                    ]
                },
                {
                    "command": [
                        "exists x; split.",
                        "VernacExtend",
                        "f9266ddab0754060cc1803dfa28547707d7da7dd"
                    ]
                },
                {
                    "command": [
                        "intros _; exact Hx.",
                        "VernacExtend",
                        "eb0c845abcdc305705a5b01ccea641d52a3868d8"
                    ]
                },
                {
                    "command": [
                        "firstorder.",
                        "VernacExtend",
                        "ceb9f57e98a5f5a73ee421cf30fd2f4f09432d14"
                    ]
                },
                {
                    "command": [
                        "exists i; tauto.",
                        "VernacExtend",
                        "c12072aac2416429ecc8cbc79348d202bd5952b8"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "dependent_unique_choice",
            "line_nb": 20,
            "steps": [
                {
                    "command": [
                        "intros A B R H.",
                        "VernacExtend",
                        "3ecae2b43e0e07b9a66aabaa8ce4a930fae8cdfe"
                    ]
                },
                {
                    "command": [
                        "assert (Hexuni:forall x, exists! y, R x y).",
                        "VernacExtend",
                        "10beb1f44a7c414817fee8295295bf0c947fa216"
                    ]
                },
                {
                    "command": [
                        "intro x.",
                        "VernacExtend",
                        "f7163633eedf12f483fa0d8c0c119dd59431ca1e"
                    ]
                },
                {
                    "command": [
                        "apply H.",
                        "VernacExtend",
                        "4b47b71ad0f800d57cbdc591d68949e07decb540"
                    ]
                },
                {
                    "command": [
                        "exists (fun x => proj1_sig (constructive_definite_description (R x) (Hexuni x))).",
                        "VernacExtend",
                        "9f88f0d8eca5c43b0a057268781cb0615915dadd"
                    ]
                },
                {
                    "command": [
                        "intro x.",
                        "VernacExtend",
                        "f7163633eedf12f483fa0d8c0c119dd59431ca1e"
                    ]
                },
                {
                    "command": [
                        "apply (proj2_sig (constructive_definite_description (R x) (Hexuni x))).",
                        "VernacExtend",
                        "1fb8e81750b4440803dd689a0f52af0e68824435"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "unique_choice",
            "line_nb": 29,
            "steps": [
                {
                    "command": [
                        "intros A B.",
                        "VernacExtend",
                        "f0fdd14fe43c412ab9e9cf2b93b27330098322c4"
                    ]
                },
                {
                    "command": [
                        "apply dependent_unique_choice with (B:=fun _:A => B).",
                        "VernacExtend",
                        "1368cc54283c9979305614c273d286f9c4cbc732"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}