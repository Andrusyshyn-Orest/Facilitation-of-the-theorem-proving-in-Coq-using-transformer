{
    "filename": "theories/Init/Tactics.v",
    "coq_project": "coq",
    "vernac_cmds": [
        [
            "Require Import Notations.",
            "VernacRequire",
            "a417ebd977b31297f271a9380cd8e45e4058428d"
        ],
        [
            "Require Import Logic.",
            "VernacRequire",
            "2ca6e83156f5377790b2a99f2b4cfefc04ad2cf8"
        ],
        [
            "Require Import Specif.",
            "VernacRequire",
            "9abd81d9b71dec7fc1e6e561f0560a2b00d0ac5c"
        ],
        [
            "Ltac exfalso := elimtype False.",
            "VernacExtend",
            "c9505391bfced5111f241cec879aca1d5b29baba"
        ],
        [
            "Ltac contradict H := let save tac H := let x:=fresh in intro x; tac H; rename x into H in let negpos H := case H; clear H in let negneg H := save negpos H in let pospos H := let A := type of H in (exfalso; revert H; try fold (~A)) in let posneg H := save pospos H in let neg H := match goal with | |- (~_) => negneg H | |- (_->False) => negneg H | |- _ => negpos H end in let pos H := match goal with | |- (~_) => posneg H | |- (_->False) => posneg H | |- _ => pospos H end in match type of H with | (~_) => neg H | (_->False) => neg H | _ => (elim H;fail) || pos H end.",
            "VernacExtend",
            "3fe1ceef1bfc5f383d1f859f81eaa9b4f5c15cdc"
        ],
        [
            "Ltac absurd_hyp H := idtac \"absurd_hyp is OBSOLETE: use contradict instead.\"; let T := type of H in absurd T.",
            "VernacExtend",
            "6729e0600acc398e142b67b8cbdaa2cc9f7dd71d"
        ],
        [
            "Ltac false_hyp H G := let T := type of H in absurd T; [ apply G | assumption ].",
            "VernacExtend",
            "23ce1bcb6ad0cba7c3cd670bdc3c923b393baa2b"
        ],
        [
            "Ltac case_eq x := generalize (eq_refl x); pattern x at -1; case x.",
            "VernacExtend",
            "5e9fee8570fbbb4823337b63bc1d6d271d584ab3"
        ],
        [
            "Ltac destr_eq H := discriminate H || (try (injection H as H)).",
            "VernacExtend",
            "3b6abe822f15271b1d995af5c9dfdb159c9cc058"
        ],
        [
            "Tactic Notation \"destruct_with_eqn\" constr(x) := destruct x eqn:?.",
            "VernacExtend",
            "c222dfd4e5cd1fbd605bc91ef8377431040adbd9"
        ],
        [
            "Tactic Notation \"destruct_with_eqn\" ident(n) := try intros until n; destruct n eqn:?.",
            "VernacExtend",
            "35c55237bcf4a55646ed1e7f675668b782558427"
        ],
        [
            "Tactic Notation \"destruct_with_eqn\" \":\" ident(H) constr(x) := destruct x eqn:H.",
            "VernacExtend",
            "f11b02981ed0e8defd13ee1a2716eb41c12b65ff"
        ],
        [
            "Tactic Notation \"destruct_with_eqn\" \":\" ident(H) ident(n) := try intros until n; destruct n eqn:H.",
            "VernacExtend",
            "52d2b72674238d1ae43ceaf039443ba3914665bc"
        ],
        [
            "Ltac destruct_all t := match goal with | x : t |- _ => destruct x; destruct_all t | _ => idtac end.",
            "VernacExtend",
            "96808dd7b94f9d9b9081bf9da0900e855f4dca06"
        ],
        [
            "Tactic Notation \"rewrite_all\" constr(eq) := repeat rewrite eq in *.",
            "VernacExtend",
            "736dc4fe5198ca40de54acd3bc1b682404095cda"
        ],
        [
            "Tactic Notation \"rewrite_all\" \"<-\" constr(eq) := repeat rewrite <- eq in *.",
            "VernacExtend",
            "fe33eb4f5eafc4ae31bbb15251ca0e6689fe2c81"
        ],
        [
            "Ltac find_equiv H := let T := type of H in lazymatch T with | ?A -> ?B => let H1 := fresh in let H2 := fresh in cut A; [intro H1; pose proof (H H1) as H2; clear H H1; rename H2 into H; find_equiv H | clear H] | forall x : ?t, _ => let a := fresh \"a\" with H1 := fresh \"H\" in evar (a : t); pose proof (H a) as H1; unfold a in H1; clear a; clear H; rename H1 into H; find_equiv H | ?A <-> ?B => idtac | _ => fail \"The given statement does not seem to end with an equivalence.\" end.",
            "VernacExtend",
            "da28988a89d7f7bc626e2f2e9509bfdde56259fe"
        ],
        [
            "Ltac bapply lemma todo := let H := fresh in pose proof lemma as H; find_equiv H; [todo H; clear H | .. ].",
            "VernacExtend",
            "6f5f7ac5436073a25656c88ad9d1d601551e4ced"
        ],
        [
            "Tactic Notation \"apply\" \"->\" constr(lemma) := bapply lemma ltac:(fun H => destruct H as [H _]; apply H).",
            "VernacExtend",
            "f8433ef1674eb37a110b47f3f9e3586f94e29ffe"
        ],
        [
            "Tactic Notation \"apply\" \"<-\" constr(lemma) := bapply lemma ltac:(fun H => destruct H as [_ H]; apply H).",
            "VernacExtend",
            "f96fb063225717a1b1295e670e8dac824108b0de"
        ],
        [
            "Tactic Notation \"apply\" \"->\" constr(lemma) \"in\" hyp(J) := bapply lemma ltac:(fun H => destruct H as [H _]; apply H in J).",
            "VernacExtend",
            "0eb752c5afe80afd6ba29b52fb312dfa4f8b64c3"
        ],
        [
            "Tactic Notation \"apply\" \"<-\" constr(lemma) \"in\" hyp(J) := bapply lemma ltac:(fun H => destruct H as [_ H]; apply H in J).",
            "VernacExtend",
            "b4e4a386f086ccd22583c01e70066656787dd2a8"
        ],
        [
            "Ltac easy := let rec use_hyp H := match type of H with | _ /\\ _ => exact H || destruct_hyp H | _ => try solve [inversion H] end with do_intro := let H := fresh in intro H; use_hyp H with destruct_hyp H := case H; clear H; do_intro; do_intro in let rec use_hyps := match goal with | H : _ /\\ _ |- _ => exact H || (destruct_hyp H; use_hyps) | H : _ |- _ => solve [inversion H] | _ => idtac end in let do_atom := solve [ trivial with eq_true | reflexivity | symmetry; trivial | contradiction ] in let rec do_ccl := try do_atom; repeat (do_intro; try do_atom); solve [ split; do_ccl ] in solve [ do_atom | use_hyps; do_ccl ] || fail \"Cannot solve this goal\".",
            "VernacExtend",
            "0e2eaf023a87a5f31bac662b94c9010d0784add0"
        ],
        [
            "Tactic Notation \"now\" tactic(t) := t; easy.",
            "VernacExtend",
            "865ac195bc1f3d3bd02d52e8eac8c1e47b7946eb"
        ],
        [
            "Ltac easy' := repeat split; simpl; easy || now destruct 1.",
            "VernacExtend",
            "6bb3df4c03980999d582d4aeb1a27851d30a31e0"
        ],
        [
            "Ltac now_show c := change c.",
            "VernacExtend",
            "f64e5e29480b57b85e930837e805ae0cabe8d4a1"
        ],
        [
            "Set Implicit Arguments.",
            "VernacSetOption",
            "9e84ff8896f028601d8aded48c1d4aebe60aa584"
        ],
        [
            "Lemma decide_left : forall (C:Prop) (decide:{C}+{~C}), C -> forall P:{C}+{~C}->Prop, (forall H:C, P (left _ H)) -> P decide.",
            "VernacStartTheoremProof",
            "5f5506c5a112b90bc1ba330e77577627e250b847"
        ],
        [
            "intros; destruct decide.",
            "VernacExtend",
            "dbc5c2a685908cffe12f14629f1ad85c081940ad"
        ],
        [
            "apply H0.",
            "VernacExtend",
            "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
        ],
        [
            "contradiction.",
            "VernacExtend",
            "9b6a5c45e1144cbbccd544effb2a97082518704a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma decide_right : forall (C:Prop) (decide:{C}+{~C}), ~C -> forall P:{C}+{~C}->Prop, (forall H:~C, P (right _ H)) -> P decide.",
            "VernacStartTheoremProof",
            "6b70d227ec06bb05cc136f097357b634c7d6606e"
        ],
        [
            "intros; destruct decide.",
            "VernacExtend",
            "dbc5c2a685908cffe12f14629f1ad85c081940ad"
        ],
        [
            "contradiction.",
            "VernacExtend",
            "9b6a5c45e1144cbbccd544effb2a97082518704a"
        ],
        [
            "apply H0.",
            "VernacExtend",
            "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Tactic Notation \"decide\" constr(lemma) \"with\" constr(H) := let try_to_merge_hyps H := try (clear H; intro H) || (let H' := fresh H \"bis\" in intro H'; try clear H') || (let H' := fresh in intro H'; try clear H') in match type of H with | ~ ?C => apply (decide_right lemma H); try_to_merge_hyps H | ?C -> False => apply (decide_right lemma H); try_to_merge_hyps H | _ => apply (decide_left lemma H); try_to_merge_hyps H end.",
            "VernacExtend",
            "8bf424be62218659db9affeb75aaeea02959c9a2"
        ],
        [
            "Tactic Notation \"clear\" \"dependent\" hyp(h) := let rec depclear h := clear h || match goal with | H : context [ h ] |- _ => depclear H; depclear h end || fail \"hypothesis to clear is used in the conclusion (maybe indirectly)\" in depclear h.",
            "VernacExtend",
            "d63675d48193b67b06a7e00aa85c7b407b369cc4"
        ],
        [
            "Tactic Notation \"revert\" \"dependent\" hyp(h) := generalize dependent h.",
            "VernacExtend",
            "1efa165933a3f8d386066015fc29f0d9e46fe339"
        ],
        [
            "Tactic Notation \"dependent\" \"induction\" ident(H) := fail \"To use dependent induction, first [Require Import Coq.Program.Equality.]\".",
            "VernacExtend",
            "0088546a52e515af2aaf2b879d2da019cdaf3b35"
        ],
        [
            "Ltac simpl_proj_exist_in H := repeat match type of H with | context G[proj1_sig (exist _ ?x ?p)] => let G' := context G[x] in change G' in H | context G[proj2_sig (exist _ ?x ?p)] => let G' := context G[p] in change G' in H | context G[projT1 (existT _ ?x ?p)] => let G' := context G[x] in change G' in H | context G[projT2 (existT _ ?x ?p)] => let G' := context G[p] in change G' in H | context G[proj3_sig (exist2 _ _ ?x ?p ?q)] => let G' := context G[q] in change G' in H | context G[projT3 (existT2 _ _ ?x ?p ?q)] => let G' := context G[q] in change G' in H | context G[sig_of_sig2 (@exist2 ?A ?P ?Q ?x ?p ?q)] => let G' := context G[@exist A P x p] in change G' in H | context G[sigT_of_sigT2 (@existT2 ?A ?P ?Q ?x ?p ?q)] => let G' := context G[@existT A P x p] in change G' in H end.",
            "VernacExtend",
            "e86290cf4673b528e67a475d1ecf47e063eacaf2"
        ],
        [
            "Ltac induction_sigma_in_using H rect := let H0 := fresh H in let H1 := fresh H in induction H as [H0 H1] using (rect _ _ _ _); simpl_proj_exist_in H0; simpl_proj_exist_in H1.",
            "VernacExtend",
            "61e737cd3e6998c5d2edda502bf28c3918225e39"
        ],
        [
            "Ltac induction_sigma2_in_using H rect := let H0 := fresh H in let H1 := fresh H in let H2 := fresh H in induction H as [H0 H1 H2] using (rect _ _ _ _ _); simpl_proj_exist_in H0; simpl_proj_exist_in H1; simpl_proj_exist_in H2.",
            "VernacExtend",
            "ded00f1e140d6fba57d10db92fcb45dd41e22162"
        ],
        [
            "Ltac inversion_sigma_step := match goal with | [ H : _ = exist _ _ _ |- _ ] => induction_sigma_in_using H @eq_sig_rect | [ H : _ = existT _ _ _ |- _ ] => induction_sigma_in_using H @eq_sigT_rect | [ H : exist _ _ _ = _ |- _ ] => induction_sigma_in_using H @eq_sig_rect | [ H : existT _ _ _ = _ |- _ ] => induction_sigma_in_using H @eq_sigT_rect | [ H : _ = exist2 _ _ _ _ _ |- _ ] => induction_sigma2_in_using H @eq_sig2_rect | [ H : _ = existT2 _ _ _ _ _ |- _ ] => induction_sigma2_in_using H @eq_sigT2_rect | [ H : exist2 _ _ _ _ _ = _ |- _ ] => induction_sigma_in_using H @eq_sig2_rect | [ H : existT2 _ _ _ _ _ = _ |- _ ] => induction_sigma_in_using H @eq_sigT2_rect end.",
            "VernacExtend",
            "9910603d5709bf5c92e220075908d8789530a1ba"
        ],
        [
            "Ltac inversion_sigma := repeat inversion_sigma_step.",
            "VernacExtend",
            "7e123d159e5ce259336ba8c966402f123b49a3ab"
        ],
        [
            "Ltac time_constr tac := let eval_early := match goal with _ => restart_timer end in let ret := tac () in let eval_early := match goal with _ => finish_timing ( \"Tactic evaluation\" ) end in ret.",
            "VernacExtend",
            "f8b50bc554a657879c9d0f51925918fb913f1591"
        ],
        [
            "Ltac assert_fails tac := tryif tac then fail 0 tac \"succeeds\" else idtac.",
            "VernacExtend",
            "7d9e96a0cb1d2117eeb0bdcf324d718be9e887f3"
        ],
        [
            "Ltac assert_succeeds tac := tryif (assert_fails tac) then fail 0 tac \"fails\" else idtac.",
            "VernacExtend",
            "506852a968cfb91725a671735d908ee023352e44"
        ],
        [
            "Tactic Notation \"assert_succeeds\" tactic3(tac) := assert_succeeds tac.",
            "VernacExtend",
            "265ad8c054bfab6063d563967f7223159a0fd9fe"
        ],
        [
            "Tactic Notation \"assert_fails\" tactic3(tac) := assert_fails tac.",
            "VernacExtend",
            "6e2e662b9f71c157b23f12dbb5ebfee31c50bc5f"
        ]
    ],
    "proofs": [
        {
            "name": "decide_left",
            "line_nb": 27,
            "steps": [
                {
                    "command": [
                        "intros; destruct decide.",
                        "VernacExtend",
                        "dbc5c2a685908cffe12f14629f1ad85c081940ad"
                    ]
                },
                {
                    "command": [
                        "apply H0.",
                        "VernacExtend",
                        "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
                    ]
                },
                {
                    "command": [
                        "contradiction.",
                        "VernacExtend",
                        "9b6a5c45e1144cbbccd544effb2a97082518704a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "decide_right",
            "line_nb": 32,
            "steps": [
                {
                    "command": [
                        "intros; destruct decide.",
                        "VernacExtend",
                        "dbc5c2a685908cffe12f14629f1ad85c081940ad"
                    ]
                },
                {
                    "command": [
                        "contradiction.",
                        "VernacExtend",
                        "9b6a5c45e1144cbbccd544effb2a97082518704a"
                    ]
                },
                {
                    "command": [
                        "apply H0.",
                        "VernacExtend",
                        "c75b3371fc84f2aae811de7e80b1bdb43e4d249a"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}