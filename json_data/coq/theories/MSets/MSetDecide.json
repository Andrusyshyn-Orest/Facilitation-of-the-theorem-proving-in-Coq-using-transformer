{
    "filename": "theories/MSets/MSetDecide.v",
    "coq_project": "coq",
    "vernac_cmds": [
        [
            "Require Import Decidable Setoid DecidableTypeEx MSetFacts.",
            "VernacRequire",
            "44d70a3aa7cd6fdc5206336e77ed3e148774db47"
        ],
        [
            "Module WDecideOn (E : DecidableType)(Import M : WSetsOn E).",
            "VernacDefineModule",
            "ff713d0c601380fa52c4fbd31ff1fef1d883d83d"
        ],
        [
            "Module F := MSetFacts.WFactsOn E M.",
            "VernacDefineModule",
            "e7e8515840447aa58404df0c00c07fb9bfa97010"
        ],
        [
            "Module MSetLogicalFacts.",
            "VernacDefineModule",
            "e26df1e64514798952dcd9062dde1233aba8bf05"
        ],
        [
            "Export Decidable.",
            "VernacImport",
            "66eb7e6a2950df9ca4d095189589cd0014f2ef2d"
        ],
        [
            "Export Setoid.",
            "VernacImport",
            "46cff0d3f01da9aad58f8269ed818c10f3288829"
        ],
        [
            "Tactic Notation \"fold\" \"any\" \"not\" := repeat ( match goal with | H: context [?P -> False] |- _ => fold (~ P) in H | |- context [?P -> False] => fold (~ P) end).",
            "VernacExtend",
            "81210c2d2bd57a41909c294f7108b62f43a7b8d2"
        ],
        [
            "Ltac or_not_l_iff P Q tac := (rewrite (or_not_l_iff_1 P Q) by tac) || (rewrite (or_not_l_iff_2 P Q) by tac).",
            "VernacExtend",
            "c1a831c48b87c040dfab64457d8a86108204da07"
        ],
        [
            "Ltac or_not_r_iff P Q tac := (rewrite (or_not_r_iff_1 P Q) by tac) || (rewrite (or_not_r_iff_2 P Q) by tac).",
            "VernacExtend",
            "e19f72051159c7757af0eea129d3d31d29b7c2dd"
        ],
        [
            "Ltac or_not_l_iff_in P Q H tac := (rewrite (or_not_l_iff_1 P Q) in H by tac) || (rewrite (or_not_l_iff_2 P Q) in H by tac).",
            "VernacExtend",
            "1a4e6fa08dc14c6de4674cda1bd9ede1d81d9ecb"
        ],
        [
            "Ltac or_not_r_iff_in P Q H tac := (rewrite (or_not_r_iff_1 P Q) in H by tac) || (rewrite (or_not_r_iff_2 P Q) in H by tac).",
            "VernacExtend",
            "a8d9517a96a4020a44dd621ddd62fc57d16b5925"
        ],
        [
            "Tactic Notation \"push\" \"not\" \"using\" ident(db) := let dec := solve_decidable using db in unfold not, iff; repeat ( match goal with | |- context [True -> False] => rewrite not_true_iff | |- context [False -> False] => rewrite not_false_iff | |- context [(?P -> False) -> False] => rewrite (not_not_iff P) by dec | |- context [(?P -> False) -> (?Q -> False)] => rewrite (contrapositive P Q) by dec | |- context [(?P -> False) \\/ ?Q] => or_not_l_iff P Q dec | |- context [?P \\/ (?Q -> False)] => or_not_r_iff P Q dec | |- context [(?P -> False) -> ?Q] => rewrite (imp_not_l P Q) by dec | |- context [?P \\/ ?Q -> False] => rewrite (not_or_iff P Q) | |- context [?P /\\ ?Q -> False] => rewrite (not_and_iff P Q) | |- context [(?P -> ?Q) -> False] => rewrite (not_imp_iff P Q) by dec end); fold any not.",
            "VernacExtend",
            "772620fd9b0ddb583360259071a7888c9545b50f"
        ],
        [
            "Tactic Notation \"push\" \"not\" := push not using core.",
            "VernacExtend",
            "730138417d6fd397747320f37f5c9ccbb7a0ae9c"
        ],
        [
            "Tactic Notation \"push\" \"not\" \"in\" \"*\" \"|-\" \"using\" ident(db) := let dec := solve_decidable using db in unfold not, iff in * |-; repeat ( match goal with | H: context [True -> False] |- _ => rewrite not_true_iff in H | H: context [False -> False] |- _ => rewrite not_false_iff in H | H: context [(?P -> False) -> False] |- _ => rewrite (not_not_iff P) in H by dec | H: context [(?P -> False) -> (?Q -> False)] |- _ => rewrite (contrapositive P Q) in H by dec | H: context [(?P -> False) \\/ ?Q] |- _ => or_not_l_iff_in P Q H dec | H: context [?P \\/ (?Q -> False)] |- _ => or_not_r_iff_in P Q H dec | H: context [(?P -> False) -> ?Q] |- _ => rewrite (imp_not_l P Q) in H by dec | H: context [?P \\/ ?Q -> False] |- _ => rewrite (not_or_iff P Q) in H | H: context [?P /\\ ?Q -> False] |- _ => rewrite (not_and_iff P Q) in H | H: context [(?P -> ?Q) -> False] |- _ => rewrite (not_imp_iff P Q) in H by dec end); fold any not.",
            "VernacExtend",
            "aa00273eff36073328b0ee52dd8a9d572b773660"
        ],
        [
            "Tactic Notation \"push\" \"not\" \"in\" \"*\" \"|-\" := push not in * |- using core.",
            "VernacExtend",
            "2ac7bfc6b2f15c2d5d33e0c59e6357f30b35e332"
        ],
        [
            "Tactic Notation \"push\" \"not\" \"in\" \"*\" \"using\" ident(db) := push not using db; push not in * |- using db.",
            "VernacExtend",
            "58a0228ee9803018bd59ef59fe3f9f4f66d0510f"
        ],
        [
            "Tactic Notation \"push\" \"not\" \"in\" \"*\" := push not in * using core.",
            "VernacExtend",
            "01435164c4aea8b6f4d4b89c866649812ec68c34"
        ],
        [
            "Lemma test_push : forall P Q R : Prop, decidable P -> decidable Q -> (~ True) -> (~ False) -> (~ ~ P) -> (~ (P /\\ Q) -> ~ R) -> ((P /\\ Q) \\/ ~ R) -> (~ (P /\\ Q) \\/ R) -> (R \\/ ~ (P /\\ Q)) -> (~ R \\/ (P /\\ Q)) -> (~ P -> R) -> (~ ((R -> P) \\/ (Q -> R))) -> (~ (P /\\ R)) -> (~ (P -> R)) -> True.",
            "VernacStartTheoremProof",
            "40a89fea1f577e1e2da4d1d9f96052adaa5373b5"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "push not in *.",
            "VernacExtend",
            "3f9e5c9f2822345b66e06551f27767cc83741eef"
        ],
        [
            "tauto.",
            "VernacExtend",
            "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Tactic Notation \"pull\" \"not\" \"using\" ident(db) := let dec := solve_decidable using db in unfold not, iff; repeat ( match goal with | |- context [True -> False] => rewrite not_true_iff | |- context [False -> False] => rewrite not_false_iff | |- context [(?P -> False) -> False] => rewrite (not_not_iff P) by dec | |- context [(?P -> False) -> (?Q -> False)] => rewrite (contrapositive P Q) by dec | |- context [(?P -> False) \\/ ?Q] => or_not_l_iff P Q dec | |- context [?P \\/ (?Q -> False)] => or_not_r_iff P Q dec | |- context [(?P -> False) -> ?Q] => rewrite (imp_not_l P Q) by dec | |- context [(?P -> False) /\\ (?Q -> False)] => rewrite <- (not_or_iff P Q) | |- context [?P -> ?Q -> False] => rewrite <- (not_and_iff P Q) | |- context [?P /\\ (?Q -> False)] => rewrite <- (not_imp_iff P Q) by dec | |- context [(?Q -> False) /\\ ?P] => rewrite <- (not_imp_rev_iff P Q) by dec end); fold any not.",
            "VernacExtend",
            "9007bbc576f25c892139d359071da261a054e6ac"
        ],
        [
            "Tactic Notation \"pull\" \"not\" := pull not using core.",
            "VernacExtend",
            "a6f5d232b37101d53c267f877c2833563a1b622b"
        ],
        [
            "Tactic Notation \"pull\" \"not\" \"in\" \"*\" \"|-\" \"using\" ident(db) := let dec := solve_decidable using db in unfold not, iff in * |-; repeat ( match goal with | H: context [True -> False] |- _ => rewrite not_true_iff in H | H: context [False -> False] |- _ => rewrite not_false_iff in H | H: context [(?P -> False) -> False] |- _ => rewrite (not_not_iff P) in H by dec | H: context [(?P -> False) -> (?Q -> False)] |- _ => rewrite (contrapositive P Q) in H by dec | H: context [(?P -> False) \\/ ?Q] |- _ => or_not_l_iff_in P Q H dec | H: context [?P \\/ (?Q -> False)] |- _ => or_not_r_iff_in P Q H dec | H: context [(?P -> False) -> ?Q] |- _ => rewrite (imp_not_l P Q) in H by dec | H: context [(?P -> False) /\\ (?Q -> False)] |- _ => rewrite <- (not_or_iff P Q) in H | H: context [?P -> ?Q -> False] |- _ => rewrite <- (not_and_iff P Q) in H | H: context [?P /\\ (?Q -> False)] |- _ => rewrite <- (not_imp_iff P Q) in H by dec | H: context [(?Q -> False) /\\ ?P] |- _ => rewrite <- (not_imp_rev_iff P Q) in H by dec end); fold any not.",
            "VernacExtend",
            "a8a68336e073be3b324acd3f7e030b7b0815f846"
        ],
        [
            "Tactic Notation \"pull\" \"not\" \"in\" \"*\" \"|-\" := pull not in * |- using core.",
            "VernacExtend",
            "cc3f2694dbee7005d20e44315d76b5c621456ac6"
        ],
        [
            "Tactic Notation \"pull\" \"not\" \"in\" \"*\" \"using\" ident(db) := pull not using db; pull not in * |- using db.",
            "VernacExtend",
            "6cc3f82a62dd9ce4d5914f8bf878ddf9006f706a"
        ],
        [
            "Tactic Notation \"pull\" \"not\" \"in\" \"*\" := pull not in * using core.",
            "VernacExtend",
            "e3a255b6fb09b6623d77129db69631cceea5cc03"
        ],
        [
            "Lemma test_pull : forall P Q R : Prop, decidable P -> decidable Q -> (~ True) -> (~ False) -> (~ ~ P) -> (~ (P /\\ Q) -> ~ R) -> ((P /\\ Q) \\/ ~ R) -> (~ (P /\\ Q) \\/ R) -> (R \\/ ~ (P /\\ Q)) -> (~ R \\/ (P /\\ Q)) -> (~ P -> R) -> (~ (R -> P) /\\ ~ (Q -> R)) -> (~ P \\/ ~ R) -> (P /\\ ~ R) -> (~ R /\\ P) -> True.",
            "VernacStartTheoremProof",
            "feee83a8eed4c8ca9d63a63be0e0aa66831362b3"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "pull not in *.",
            "VernacExtend",
            "e1e4c9916bab4857646111104e6ab3f03332956d"
        ],
        [
            "tauto.",
            "VernacExtend",
            "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End MSetLogicalFacts.",
            "VernacEndSegment",
            "a1f1948fc3c94233d7a6cc1d81588c8124c2502f"
        ],
        [
            "Import MSetLogicalFacts.",
            "VernacImport",
            "f8e63bb0bb57146c21df83f22f0768e074f8c6fc"
        ],
        [
            "Module MSetDecideAuxiliary.",
            "VernacDefineModule",
            "c0c15458d3e9ffea018cae63f64ae4dcedd7190f"
        ],
        [
            "Ltac no_logical_interdep := match goal with | H : ?P |- _ => match type of P with | Prop => match goal with H' : context [ H ] |- _ => clear dependent H' end | _ => fail end; no_logical_interdep | _ => idtac end.",
            "VernacExtend",
            "fc0a540bdcd93400fcc9168a2292561fcbeea0e0"
        ],
        [
            "Ltac abstract_term t := tryif (is_var t) then fail \"no need to abstract a variable\" else (let x := fresh \"x\" in set (x := t) in *; try clearbody x).",
            "VernacExtend",
            "ecb337a33c4697dd44d3ffe6d25ee95f46064781"
        ],
        [
            "Ltac abstract_elements := repeat (match goal with | |- context [ singleton ?t ] => abstract_term t | _ : context [ singleton ?t ] |- _ => abstract_term t | |- context [ add ?t _ ] => abstract_term t | _ : context [ add ?t _ ] |- _ => abstract_term t | |- context [ remove ?t _ ] => abstract_term t | _ : context [ remove ?t _ ] |- _ => abstract_term t | |- context [ In ?t _ ] => abstract_term t | _ : context [ In ?t _ ] |- _ => abstract_term t end).",
            "VernacExtend",
            "95490225dfd57931fba91dd38b852c52dacfd623"
        ],
        [
            "Tactic Notation \"prop\" constr(P) \"holds\" \"by\" tactic(t) := let H := fresh in assert P as H by t; clear H.",
            "VernacExtend",
            "b35ebd44089b4b2fdd5a3f5e0887c9a9e6079151"
        ],
        [
            "Tactic Notation \"assert\" \"new\" constr(e) \"by\" tactic(t) := match goal with | H: e |- _ => fail 1 | _ => assert e by t end.",
            "VernacExtend",
            "80bcde5d8f81192e1fe017e4670ec0c405c2b4aa"
        ],
        [
            "Tactic Notation \"subst\" \"++\" := repeat ( match goal with | x : _ |- _ => subst x end); cbv zeta beta in *.",
            "VernacExtend",
            "0a74bf41e6f15559bb0ea7b55cf94d98fa1c5860"
        ],
        [
            "Tactic Notation \"decompose\" \"records\" := repeat ( match goal with | H: _ |- _ => progress (decompose record H); clear H end).",
            "VernacExtend",
            "e2fc9ea3f578ede0cc53f0dcbc90a56074bf8eed"
        ],
        [
            "Inductive MSet_elt_Prop : Prop -> Prop := | eq_Prop : forall (S : Type) (x y : S), MSet_elt_Prop (x = y) | eq_elt_prop : forall x y, MSet_elt_Prop (E.eq x y) | In_elt_prop : forall x s, MSet_elt_Prop (In x s) | True_elt_prop : MSet_elt_Prop True | False_elt_prop : MSet_elt_Prop False | conj_elt_prop : forall P Q, MSet_elt_Prop P -> MSet_elt_Prop Q -> MSet_elt_Prop (P /\\ Q) | disj_elt_prop : forall P Q, MSet_elt_Prop P -> MSet_elt_Prop Q -> MSet_elt_Prop (P \\/ Q) | impl_elt_prop : forall P Q, MSet_elt_Prop P -> MSet_elt_Prop Q -> MSet_elt_Prop (P -> Q) | not_elt_prop : forall P, MSet_elt_Prop P -> MSet_elt_Prop (~ P).",
            "VernacInductive",
            "286aa44ae1aa655e02962fd5769ece817cada195"
        ],
        [
            "Inductive MSet_Prop : Prop -> Prop := | elt_MSet_Prop : forall P, MSet_elt_Prop P -> MSet_Prop P | Empty_MSet_Prop : forall s, MSet_Prop (Empty s) | Subset_MSet_Prop : forall s1 s2, MSet_Prop (Subset s1 s2) | Equal_MSet_Prop : forall s1 s2, MSet_Prop (Equal s1 s2).",
            "VernacInductive",
            "19e0b5ea6b4b15289c73767dc908a78d1c6fba4b"
        ],
        [
            "Hint Constructors MSet_elt_Prop MSet_Prop : MSet_Prop.",
            "VernacHints",
            "e11a5146e6e3d5f86b132107c1b2fb09e184751a"
        ],
        [
            "Ltac discard_nonMSet := repeat ( match goal with | H : context [ @Logic.eq ?T ?x ?y ] |- _ => tryif (change T with E.t in H) then fail else tryif (change T with t in H) then fail else clear H | H : ?P |- _ => tryif prop (MSet_Prop P) holds by (auto 100 with MSet_Prop) then fail else clear H end).",
            "VernacExtend",
            "1f176b17ecf35dd7fa5d68b780f684f870f73127"
        ],
        [
            "Hint Rewrite F.empty_iff F.singleton_iff F.add_iff F.remove_iff F.union_iff F.inter_iff F.diff_iff : set_simpl.",
            "VernacExtend",
            "e3f02462aea79dd5a409aace2d43183fcb1a1c74"
        ],
        [
            "Lemma eq_refl_iff (x : E.t) : E.eq x x <-> True.",
            "VernacStartTheoremProof",
            "9ca7fdd235b42f2c9535fdf71d4ad6908eaddd3d"
        ],
        [
            "now split.",
            "VernacExtend",
            "1791b9ff1e86fc70e4ee1a32bce684778be25d40"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Rewrite eq_refl_iff : set_eq_simpl.",
            "VernacExtend",
            "aacc7e5d18cda8fa92b326d34ca0387a627971aa"
        ],
        [
            "Lemma dec_In : forall x s, decidable (In x s).",
            "VernacStartTheoremProof",
            "55da3e063fd87269135bb9a530fb614a77f4e99e"
        ],
        [
            "red; intros; generalize (F.mem_iff s x); case (mem x s); intuition.",
            "VernacExtend",
            "4e563fde95f98d9fdad2b36855e389c726396e51"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma dec_eq : forall (x y : E.t), decidable (E.eq x y).",
            "VernacStartTheoremProof",
            "78f3e8b142a007d245fca0d1404134531dce9273"
        ],
        [
            "red; intros x y; destruct (E.eq_dec x y); auto.",
            "VernacExtend",
            "9de6f04f85b297a2fd600ba2be5ae0304ea34c51"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Hint Resolve dec_In dec_eq : MSet_decidability.",
            "VernacHints",
            "c1db8676288191a7f346f47350f8fd84ced7a550"
        ],
        [
            "Ltac change_to_E_t := repeat ( match goal with | H : ?T |- _ => progress (change T with E.t in H); repeat ( match goal with | J : _ |- _ => progress (change T with E.t in J) | |- _ => progress (change T with E.t) end ) | H : forall x : ?T, _ |- _ => progress (change T with E.t in H); repeat ( match goal with | J : _ |- _ => progress (change T with E.t in J) | |- _ => progress (change T with E.t) end ) end).",
            "VernacExtend",
            "5547907826a3a546b1f4d8d1bfdfda4a0b70ffc5"
        ],
        [
            "Ltac Logic_eq_to_E_eq := repeat ( match goal with | H: _ |- _ => progress (change (@Logic.eq E.t) with E.eq in H) | |- _ => progress (change (@Logic.eq E.t) with E.eq) end).",
            "VernacExtend",
            "7ffe64fdf6635eb4af3044b497332b3bf26f27e4"
        ],
        [
            "Ltac E_eq_to_Logic_eq := repeat ( match goal with | H: _ |- _ => progress (change E.eq with (@Logic.eq E.t) in H) | |- _ => progress (change E.eq with (@Logic.eq E.t)) end).",
            "VernacExtend",
            "c7ce2be313846c4f81b7b7dc3dd3f418e918387d"
        ],
        [
            "Ltac substMSet := repeat ( match goal with | H: E.eq ?x ?x |- _ => clear H | H: E.eq ?x ?y |- _ => rewrite H in *; clear H end); autorewrite with set_eq_simpl in *.",
            "VernacExtend",
            "7f6825d8c615165808a87392922c82e2125fc08a"
        ],
        [
            "Ltac assert_decidability := repeat ( match goal with | H: context [~ E.eq ?x ?y] |- _ => assert new (E.eq x y \\/ ~ E.eq x y) by (apply dec_eq) | H: context [~ In ?x ?s] |- _ => assert new (In x s \\/ ~ In x s) by (apply dec_In) | |- context [~ E.eq ?x ?y] => assert new (E.eq x y \\/ ~ E.eq x y) by (apply dec_eq) | |- context [~ In ?x ?s] => assert new (In x s \\/ ~ In x s) by (apply dec_In) end); repeat ( match goal with | _: ~ ?P, H : ?P \\/ ~ ?P |- _ => clear H end).",
            "VernacExtend",
            "8e0253979dcdcb44bcc22685c531876c82e88691"
        ],
        [
            "Ltac inst_MSet_hypotheses := repeat ( match goal with | H : forall a : E.t, _, _ : context [ In ?x _ ] |- _ => let P := type of (H x) in assert new P by (exact (H x)) | H : forall a : E.t, _ |- context [ In ?x _ ] => let P := type of (H x) in assert new P by (exact (H x)) | H : forall a : E.t, _, _ : context [ E.eq ?x _ ] |- _ => let P := type of (H x) in assert new P by (exact (H x)) | H : forall a : E.t, _ |- context [ E.eq ?x _ ] => let P := type of (H x) in assert new P by (exact (H x)) | H : forall a : E.t, _, _ : context [ E.eq _ ?x ] |- _ => let P := type of (H x) in assert new P by (exact (H x)) | H : forall a : E.t, _ |- context [ E.eq _ ?x ] => let P := type of (H x) in assert new P by (exact (H x)) end); repeat ( match goal with | H : forall a : E.t, _ |- _ => clear H end).",
            "VernacExtend",
            "0d9e6b4cc0a190fa3289f747fd53e9cf77c79875"
        ],
        [
            "Ltac fsetdec_rec := progress substMSet; intuition fsetdec_rec.",
            "VernacExtend",
            "937bb21311fcaa50796685e44a362cc3d1a47888"
        ],
        [
            "Ltac fsetdec_body := autorewrite with set_eq_simpl in *; inst_MSet_hypotheses; autorewrite with set_simpl set_eq_simpl in *; push not in * using MSet_decidability; substMSet; assert_decidability; auto; (intuition fsetdec_rec) || fail 1 \"because the goal is beyond the scope of this tactic\".",
            "VernacExtend",
            "4af006d9052446a24e47d939d59729f1a657c461"
        ],
        [
            "End MSetDecideAuxiliary.",
            "VernacEndSegment",
            "fe24803fb54b9984ded90149c6cee3fb117f7ae9"
        ],
        [
            "Import MSetDecideAuxiliary.",
            "VernacImport",
            "9b96fe1bcb45797b77229f03344a0ac92a4271e9"
        ],
        [
            "Ltac fsetdec := unfold iff in *; fold any not; intros; abstract_elements; no_logical_interdep; decompose records; discard_nonMSet; unfold Empty, Subset, Equal in *; intros; change_to_E_t; E_eq_to_Logic_eq; subst++; Logic_eq_to_E_eq; pull not using MSet_decidability; unfold not in *; match goal with | H: (In ?x ?r) -> False |- (In ?x ?s) -> False => contradict H; fsetdec_body | H: (In ?x ?r) -> False |- (E.eq ?x ?y) -> False => contradict H; fsetdec_body | H: (In ?x ?r) -> False |- (E.eq ?y ?x) -> False => contradict H; fsetdec_body | H: ?P -> False |- ?Q -> False => tryif prop (MSet_elt_Prop P) holds by (auto 100 with MSet_Prop) then (contradict H; fsetdec_body) else fsetdec_body | |- _ => fsetdec_body end.",
            "VernacExtend",
            "3b25b8d1da398390fff9da521ebf28cf070c3a23"
        ],
        [
            "Module MSetDecideTestCases.",
            "VernacDefineModule",
            "d4fea844c397eb16847052becd68abe0842e252d"
        ],
        [
            "Lemma test_eq_trans_1 : forall x y z s, E.eq x y -> ~ ~ E.eq z y -> In x s -> In z s.",
            "VernacStartTheoremProof",
            "349d8ecf9512b45d13c2bfc91c540c0ac46eaa12"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_eq_trans_2 : forall x y z r s, In x (singleton y) -> ~ In z r -> ~ ~ In z (add y r) -> In x s -> In z s.",
            "VernacStartTheoremProof",
            "a67c5dc9d4ac5e225ca13830797a763fe8ab6f54"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_eq_neq_trans_1 : forall w x y z s, E.eq x w -> ~ ~ E.eq x y -> ~ E.eq y z -> In w s -> In w (remove z s).",
            "VernacStartTheoremProof",
            "ae26a0674a4aee413d7a28064384536937976026"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_eq_neq_trans_2 : forall w x y z r1 r2 s, In x (singleton w) -> ~ In x r1 -> In x (add y r1) -> In y r2 -> In y (remove z r2) -> In w s -> In w (remove z s).",
            "VernacStartTheoremProof",
            "d7c1a8a1509c7fc13ee245489ab5f428f214c9ed"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_In_singleton : forall x, In x (singleton x).",
            "VernacStartTheoremProof",
            "8bde1ea4e2280fa38548ae9e2f4430831086f32b"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_add_In : forall x y s, In x (add y s) -> ~ E.eq x y -> In x s.",
            "VernacStartTheoremProof",
            "1881f6ad61769dc71a9b7dafc9cee98278915141"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_Subset_add_remove : forall x s, s [<=] (add x (remove x s)).",
            "VernacStartTheoremProof",
            "dba7d8c51ec6ff72e126d85ac6d2a3028b111e67"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_eq_disjunction : forall w x y z, In w (add x (add y (singleton z))) -> E.eq w x \\/ E.eq w y \\/ E.eq w z.",
            "VernacStartTheoremProof",
            "df93beb320d370433468a22b9162b6456ac8c73c"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_not_In_disj : forall x y s1 s2 s3 s4, ~ In x (union s1 (union s2 (union s3 (add y s4)))) -> ~ (In x s1 \\/ In x s4 \\/ E.eq y x).",
            "VernacStartTheoremProof",
            "2f1f4390407abc227aee408d0b29a1236a3e8dc6"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_not_In_conj : forall x y s1 s2 s3 s4, ~ In x (union s1 (union s2 (union s3 (add y s4)))) -> ~ In x s1 /\\ ~ In x s4 /\\ ~ E.eq y x.",
            "VernacStartTheoremProof",
            "11b30a32f201612c718decad335fefd37f07c0b4"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_iff_conj : forall a x s s', (In a s' <-> E.eq x a \\/ In a s) -> (In a s' <-> In a (add x s)).",
            "VernacStartTheoremProof",
            "554be3ca98c1227ac32bb187e482063ee1a07855"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_set_ops_1 : forall x q r s, (singleton x) [<=] s -> Empty (union q r) -> Empty (inter (diff s q) (diff s r)) -> ~ In x s.",
            "VernacStartTheoremProof",
            "4b9a12432c166d93d1cad3f7889b40e9ed8d1f31"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma eq_chain_test : forall x1 x2 x3 x4 s1 s2 s3 s4, Empty s1 -> In x2 (add x1 s1) -> In x3 s2 -> ~ In x3 (remove x2 s2) -> ~ In x4 s3 -> In x4 (add x3 s3) -> In x1 s4 -> Subset (add x4 s4) s4.",
            "VernacStartTheoremProof",
            "69954225de7ad83272c5876cf9c29df23b586bd6"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_too_complex : forall x y z r s, E.eq x y -> (In x (singleton y) -> r [<=] s) -> In z r -> In z s.",
            "VernacStartTheoremProof",
            "457e2708f8fa5409ecae7ddd02e372da43e7be81"
        ],
        [
            "intros until s; intros Heq H Hr; lapply H; fsetdec.",
            "VernacExtend",
            "5f3dfb8e5d8f361bdc1d303df383a7419d8f490d"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma function_test_1 : forall (f : t -> t), forall (g : elt -> elt), forall (s1 s2 : t), forall (x1 x2 : elt), Equal s1 (f s2) -> E.eq x1 (g (g x2)) -> In x1 s1 -> In (g (g x2)) (f s2).",
            "VernacStartTheoremProof",
            "cf24c8326e6deb9247a54093a34958362e79d134"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma function_test_2 : forall (f : t -> t), forall (g : elt -> elt), forall (s1 s2 : t), forall (x1 x2 : elt), Equal s1 (f s2) -> E.eq x1 (g x2) -> In x1 s1 -> g x2 = g (g x2) -> In (g (g x2)) (f s2).",
            "VernacStartTheoremProof",
            "8871fb2060b52ca5a07900fa7ef1ae67803cd65d"
        ],
        [
            "intros until 3.",
            "VernacExtend",
            "ff302bf5852981d9e67cf7ae7bc83794cf9c9928"
        ],
        [
            "intros g_eq.",
            "VernacExtend",
            "55696e44b20b66eeaac24b77d39e82fed13a6313"
        ],
        [
            "rewrite <- g_eq.",
            "VernacExtend",
            "b52d44c50c258581b64de2e1db33a4ad8f5c52e4"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma test_baydemir : forall (f : t -> t), forall (s : t), forall (x y : elt), In x (add y (f s)) -> ~ E.eq x y -> In x (f s).",
            "VernacStartTheoremProof",
            "7a16127071c89f64d3e312052a598f090f99f886"
        ],
        [
            "fsetdec.",
            "VernacExtend",
            "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End MSetDecideTestCases.",
            "VernacEndSegment",
            "bfe5186e6e645db27eb232b2ea8470dfd6ba97a6"
        ],
        [
            "End WDecideOn.",
            "VernacEndSegment",
            "3d1d1b127dd91454a262d685e1a42abfd0120d92"
        ],
        [
            "Require Import MSetInterface.",
            "VernacRequire",
            "71f05bb644dbe27af65c4a527d8603037b58540a"
        ],
        [
            "Module WDecide (M:WSets) := !WDecideOn M.E M.",
            "VernacDefineModule",
            "e44c41ce7f20c75a03563412558523f0577f13bb"
        ],
        [
            "Module Decide := WDecide.",
            "VernacDefineModule",
            "a068faf23871022a52e4426dddb859cdf4f29a15"
        ]
    ],
    "proofs": [
        {
            "name": "test_push",
            "line_nb": 17,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "push not in *.",
                        "VernacExtend",
                        "3f9e5c9f2822345b66e06551f27767cc83741eef"
                    ]
                },
                {
                    "command": [
                        "tauto.",
                        "VernacExtend",
                        "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_pull",
            "line_nb": 28,
            "steps": [
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "pull not in *.",
                        "VernacExtend",
                        "e1e4c9916bab4857646111104e6ab3f03332956d"
                    ]
                },
                {
                    "command": [
                        "tauto.",
                        "VernacExtend",
                        "9bfafe84fb6724789bdf6cfd21cd721dd63fdabd"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_refl_iff",
            "line_nb": 48,
            "steps": [
                {
                    "command": [
                        "now split.",
                        "VernacExtend",
                        "1791b9ff1e86fc70e4ee1a32bce684778be25d40"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "dec_In",
            "line_nb": 52,
            "steps": [
                {
                    "command": [
                        "red; intros; generalize (F.mem_iff s x); case (mem x s); intuition.",
                        "VernacExtend",
                        "4e563fde95f98d9fdad2b36855e389c726396e51"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "dec_eq",
            "line_nb": 55,
            "steps": [
                {
                    "command": [
                        "red; intros x y; destruct (E.eq_dec x y); auto.",
                        "VernacExtend",
                        "9de6f04f85b297a2fd600ba2be5ae0304ea34c51"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_eq_trans_1",
            "line_nb": 71,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_eq_trans_2",
            "line_nb": 74,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_eq_neq_trans_1",
            "line_nb": 77,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_eq_neq_trans_2",
            "line_nb": 80,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_In_singleton",
            "line_nb": 83,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_add_In",
            "line_nb": 86,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_Subset_add_remove",
            "line_nb": 89,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_eq_disjunction",
            "line_nb": 92,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_not_In_disj",
            "line_nb": 95,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_not_In_conj",
            "line_nb": 98,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_iff_conj",
            "line_nb": 101,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_set_ops_1",
            "line_nb": 104,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "eq_chain_test",
            "line_nb": 107,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_too_complex",
            "line_nb": 110,
            "steps": [
                {
                    "command": [
                        "intros until s; intros Heq H Hr; lapply H; fsetdec.",
                        "VernacExtend",
                        "5f3dfb8e5d8f361bdc1d303df383a7419d8f490d"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "function_test_1",
            "line_nb": 113,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "function_test_2",
            "line_nb": 116,
            "steps": [
                {
                    "command": [
                        "intros until 3.",
                        "VernacExtend",
                        "ff302bf5852981d9e67cf7ae7bc83794cf9c9928"
                    ]
                },
                {
                    "command": [
                        "intros g_eq.",
                        "VernacExtend",
                        "55696e44b20b66eeaac24b77d39e82fed13a6313"
                    ]
                },
                {
                    "command": [
                        "rewrite <- g_eq.",
                        "VernacExtend",
                        "b52d44c50c258581b64de2e1db33a4ad8f5c52e4"
                    ]
                },
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "test_baydemir",
            "line_nb": 122,
            "steps": [
                {
                    "command": [
                        "fsetdec.",
                        "VernacExtend",
                        "d9651132b72f95a28a33945b2cbaaf1d88dd00d9"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}