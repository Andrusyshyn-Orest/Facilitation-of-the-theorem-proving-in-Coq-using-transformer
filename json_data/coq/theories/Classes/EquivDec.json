{
    "filename": "theories/Classes/EquivDec.v",
    "coq_project": "coq",
    "vernac_cmds": [
        [
            "Require Export Coq.Classes.Equivalence.",
            "VernacRequire",
            "c0de8a386e315a0ef032cbaf2d48f209d209cc36"
        ],
        [
            "Require Import Coq.Logic.Decidable.",
            "VernacRequire",
            "3dcfcf37067c1b8a5e2bb2d2e6e102b0fd9e0530"
        ],
        [
            "Require Import Coq.Bool.Bool.",
            "VernacRequire",
            "38f52b48f6f716417469716568252bf78819181b"
        ],
        [
            "Require Import Coq.Arith.Peano_dec.",
            "VernacRequire",
            "43d7e830c79c3009b46f18f21884e8095a97fa35"
        ],
        [
            "Require Import Coq.Program.Program.",
            "VernacRequire",
            "f0aaea5df52d8de8e090bb8f78148264c53bb6ee"
        ],
        [
            "Generalizable Variables A B R.",
            "VernacGeneralizable",
            "62d46fc10b6581429bfbe32b0fda07680bfb93c1"
        ],
        [
            "Open Scope equiv_scope.",
            "VernacOpenCloseScope",
            "4c6f47a6e6bf8aa18f1183050814096d5cd3434a"
        ],
        [
            "Class DecidableEquivalence `(equiv : Equivalence A) := setoid_decidable : forall x y : A, decidable (x === y).",
            "VernacInductive",
            "3b05db9c99232eaddaa9dd66c445eadf80105b5a"
        ],
        [
            "Class EqDec A R {equiv : Equivalence R} := equiv_dec : forall x y : A, { x === y } + { x =/= y }.",
            "VernacInductive",
            "696baa4ff2cc5d40b2d3ec2d55fd3c92476650d7"
        ],
        [
            "Notation \" x == y \" := (equiv_dec (x :>) (y :>)) (no associativity, at level 70) : equiv_scope.",
            "VernacNotation",
            "915971a6a60130a052ff082113b86d256bc4e4c2"
        ],
        [
            "Definition swap_sumbool {A B} (x : { A } + { B }) : { B } + { A } := match x with | left H => @right _ _ H | right H => @left _ _ H end.",
            "VernacDefinition",
            "3f06bdbbf5f32ad8f60c29cc744f54875cf8eb9d"
        ],
        [
            "Local Open Scope program_scope.",
            "VernacOpenCloseScope",
            "6bb21a93b668247e2dedc8ec6af2f052c3ec2a49"
        ],
        [
            "Program Definition nequiv_dec `{EqDec A} (x y : A) : { x =/= y } + { x === y } := swap_sumbool (x == y).",
            "VernacDefinition",
            "70a26889b85377b037c90bcf1c2d5757feeed3df"
        ],
        [
            "Infix \"<>\" := nequiv_dec (no associativity, at level 70) : equiv_scope.",
            "VernacInfix",
            "d3a12efef2a62f1bbe9b8ca06ec4e71043d40124"
        ],
        [
            "Definition equiv_decb `{EqDec A} (x y : A) : bool := if x == y then true else false.",
            "VernacDefinition",
            "fb72bd823ad3548b4de16b28ac3313b533c1e540"
        ],
        [
            "Definition nequiv_decb `{EqDec A} (x y : A) : bool := negb (equiv_decb x y).",
            "VernacDefinition",
            "fb40fb5850262a05c4e00aa1b7fbb302696b7721"
        ],
        [
            "Infix \"==b\" := equiv_decb (no associativity, at level 70).",
            "VernacInfix",
            "724a0156a6cf8468d89c689a8604a957be3e6a01"
        ],
        [
            "Infix \"<>b\" := nequiv_decb (no associativity, at level 70).",
            "VernacInfix",
            "5c56e63e2b5dfec818d17f4cdd87349b680eafff"
        ],
        [
            "Program Instance nat_eq_eqdec : EqDec nat eq := eq_nat_dec.",
            "VernacInstance",
            "bf780c39ac99b79504e194d15811d38d2fd4ae4f"
        ],
        [
            "Program Instance bool_eqdec : EqDec bool eq := bool_dec.",
            "VernacInstance",
            "c22c7002d882eb0439224ffc893092fd6ac8f40f"
        ],
        [
            "Program Instance unit_eqdec : EqDec unit eq := fun x y => in_left.",
            "VernacInstance",
            "75e742f37f14aae9adfa01cadea17d1bdc51cd9e"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "destruct x ; destruct y.",
            "VernacExtend",
            "66b6bbed80f19a7ddf75313e3d1e4cc780d5f91f"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Obligation Tactic := unfold complement, equiv ; program_simpl.",
            "VernacExtend",
            "4ee99e35b5cab10a5b69ea2df047e9130ffefd3f"
        ],
        [
            "Program Instance prod_eqdec `(EqDec A eq, EqDec B eq) : ! EqDec (prod A B) eq := { equiv_dec x y := let '(x1, x2) := x in let '(y1, y2) := y in if x1 == y1 then if x2 == y2 then in_left else in_right else in_right }.",
            "VernacInstance",
            "ff8ab7cb4869dfc38bb425897bd41dffe903b496"
        ],
        [
            "Program Instance sum_eqdec `(EqDec A eq, EqDec B eq) : EqDec (sum A B) eq := { equiv_dec x y := match x, y with | inl a, inl b => if a == b then in_left else in_right | inr a, inr b => if a == b then in_left else in_right | inl _, inr _ | inr _, inl _ => in_right end }.",
            "VernacInstance",
            "a422b34ba775198d3c2e8bec36aa62617eabf87e"
        ],
        [
            "Program Instance bool_function_eqdec `(EqDec A eq) : ! EqDec (bool -> A) eq := { equiv_dec f g := if f true == g true then if f false == g false then in_left else in_right else in_right }.",
            "VernacInstance",
            "41d17d133d5ccf36b7ae193d7cdb4dfe45d06103"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "extensionality x.",
            "VernacExtend",
            "a02a0d77f789b5337c65fc4009fcc8ebde3d5cef"
        ],
        [
            "destruct x ; auto.",
            "VernacExtend",
            "e693b97b98b28f6f305ce1b2e3d77ebaa690911c"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Require Import List.",
            "VernacRequire",
            "d9bcce4a390afeb160107bf87c6f7abe3d82c6d6"
        ],
        [
            "Program Instance list_eqdec `(eqa : EqDec A eq) : ! EqDec (list A) eq := { equiv_dec := fix aux (x y : list A) := match x, y with | nil, nil => in_left | cons hd tl, cons hd' tl' => if hd == hd' then if aux tl tl' then in_left else in_right else in_right | _, _ => in_right end }.",
            "VernacInstance",
            "6c802a8d9c729c8ebc83cfff51e362db578e6b6f"
        ],
        [
            "Next Obligation.",
            "VernacExtend",
            "de5e6a0a7a163af0d8463969c3ff4241d7d5bba0"
        ],
        [
            "destruct y ; unfold not in *; eauto.",
            "VernacExtend",
            "0eb6a0407e543d93e0fa45f60132f8e9e2d0b907"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Solve Obligations with unfold equiv, complement in * ; program_simpl ; intuition (discriminate || eauto).",
            "VernacExtend",
            "fe910fcdd07d8c301406d5921026843fcbb2f973"
        ]
    ],
    "proofs": [
        {
            "name": "unit_eqdec_obligation_1",
            "line_nb": 21,
            "steps": [
                {
                    "command": [
                        "destruct x ; destruct y.",
                        "VernacExtend",
                        "66b6bbed80f19a7ddf75313e3d1e4cc780d5f91f"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "bool_function_eqdec_obligation_1",
            "line_nb": 29,
            "steps": [
                {
                    "command": [
                        "extensionality x.",
                        "VernacExtend",
                        "a02a0d77f789b5337c65fc4009fcc8ebde3d5cef"
                    ]
                },
                {
                    "command": [
                        "destruct x ; auto.",
                        "VernacExtend",
                        "e693b97b98b28f6f305ce1b2e3d77ebaa690911c"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "list_eqdec_obligation_5",
            "line_nb": 35,
            "steps": [
                {
                    "command": [
                        "destruct y ; unfold not in *; eauto.",
                        "VernacExtend",
                        "0eb6a0407e543d93e0fa45f60132f8e9e2d0b907"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        }
    ]
}