{
    "filename": "theories/Sorting/Heap.v",
    "coq_project": "coq",
    "vernac_cmds": [
        [
            "Require Import List Multiset PermutSetoid Relations Sorting.",
            "VernacRequire",
            "8a5b8f837ecaa8f4710bb155c0b209d4155d593b"
        ],
        [
            "Section defs.",
            "VernacBeginSection",
            "7450751e0e2a4e9b02fc9335100ecf77a369020b"
        ],
        [
            "Variable A : Type.",
            "VernacAssumption",
            "8c1a433b6dc10de37f30039d70ed7113b3dab0e0"
        ],
        [
            "Variable leA : relation A.",
            "VernacAssumption",
            "2c3cf941ec2cc6875638f4228e01b3366f0750e2"
        ],
        [
            "Variable eqA : relation A.",
            "VernacAssumption",
            "da198f298e55e60b848c4c420437e9551e63866f"
        ],
        [
            "Let gtA (x y:A) := ~ leA x y.",
            "VernacDefinition",
            "80c915d5acdda92d0128af42dbda30d3413b7c3d"
        ],
        [
            "Hypothesis leA_dec : forall x y:A, {leA x y} + {leA y x}.",
            "VernacAssumption",
            "33ce200ef5a0df97531caa1e0a8afc957f95fce6"
        ],
        [
            "Hypothesis eqA_dec : forall x y:A, {eqA x y} + {~ eqA x y}.",
            "VernacAssumption",
            "e7467197fa59c2f7f5ecd872d3e324fca8875a7e"
        ],
        [
            "Hypothesis leA_refl : forall x y:A, eqA x y -> leA x y.",
            "VernacAssumption",
            "53d221128277a879c77cf25d91edbf42cc6ac2fb"
        ],
        [
            "Hypothesis leA_trans : forall x y z:A, leA x y -> leA y z -> leA x z.",
            "VernacAssumption",
            "66b6411590d8234bc77a710429b433de0d1a8266"
        ],
        [
            "Hypothesis leA_antisym : forall x y:A, leA x y -> leA y x -> eqA x y.",
            "VernacAssumption",
            "b44eb2fad01c37b4e22b9ac7062444e328317687"
        ],
        [
            "Hint Resolve leA_refl.",
            "VernacHints",
            "130df2c0e4c76f661ed0c702a45e91f682a6179d"
        ],
        [
            "Hint Immediate eqA_dec leA_dec leA_antisym.",
            "VernacHints",
            "c4c31d3dad7a92e8ef42790e1b17c7cb6e696348"
        ],
        [
            "Let emptyBag := EmptyBag A.",
            "VernacDefinition",
            "e22bc685861589c14bf3d6d76eb9c61b8059897e"
        ],
        [
            "Let singletonBag := SingletonBag _ eqA_dec.",
            "VernacDefinition",
            "80c6e7743da93d4bf61835a5e64c6a4cb40491c1"
        ],
        [
            "Inductive Tree := | Tree_Leaf : Tree | Tree_Node : A -> Tree -> Tree -> Tree.",
            "VernacInductive",
            "ac9982b3a5b8ef73e02550333bd3464695ff839a"
        ],
        [
            "Definition leA_Tree (a:A) (t:Tree) := match t with | Tree_Leaf => True | Tree_Node b T1 T2 => leA a b end.",
            "VernacDefinition",
            "a2c011fd91f1f37bdd3224149b4278708eec0a7b"
        ],
        [
            "Lemma leA_Tree_Leaf : forall a:A, leA_Tree a Tree_Leaf.",
            "VernacStartTheoremProof",
            "65b77f04e478a77a3734f02355880ae6083fea96"
        ],
        [
            "simpl; auto with datatypes.",
            "VernacExtend",
            "51538b4519a60126c6d1f66f99e6b1c1aa8da1f7"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma leA_Tree_Node : forall (a b:A) (G D:Tree), leA a b -> leA_Tree a (Tree_Node b G D).",
            "VernacStartTheoremProof",
            "72ce731a7913d01a9f02fe65bbab6dc9f29ff90e"
        ],
        [
            "simpl; auto with datatypes.",
            "VernacExtend",
            "51538b4519a60126c6d1f66f99e6b1c1aa8da1f7"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Inductive is_heap : Tree -> Prop := | nil_is_heap : is_heap Tree_Leaf | node_is_heap : forall (a:A) (T1 T2:Tree), leA_Tree a T1 -> leA_Tree a T2 -> is_heap T1 -> is_heap T2 -> is_heap (Tree_Node a T1 T2).",
            "VernacInductive",
            "85db69b15370e6d96e805522fe77ada793549844"
        ],
        [
            "Lemma invert_heap : forall (a:A) (T1 T2:Tree), is_heap (Tree_Node a T1 T2) -> leA_Tree a T1 /\\ leA_Tree a T2 /\\ is_heap T1 /\\ is_heap T2.",
            "VernacStartTheoremProof",
            "9d2b5f68f154bf25b0a405414de6fe04ca5c7840"
        ],
        [
            "intros; inversion H; auto with datatypes.",
            "VernacExtend",
            "c852946a05b3f8f99843addbe2c330050065193f"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma is_heap_rect : forall P:Tree -> Type, P Tree_Leaf -> (forall (a:A) (T1 T2:Tree), leA_Tree a T1 -> leA_Tree a T2 -> is_heap T1 -> P T1 -> is_heap T2 -> P T2 -> P (Tree_Node a T1 T2)) -> forall T:Tree, is_heap T -> P T.",
            "VernacStartTheoremProof",
            "cd428a03e3c3960a5af5a5fca3696c7064910839"
        ],
        [
            "simple induction T; auto with datatypes.",
            "VernacExtend",
            "6bd1d870167f25cdcf0defad1a901041d127737e"
        ],
        [
            "intros a G PG D PD PN.",
            "VernacExtend",
            "3b4c19887fdf8b95f89d0d40a3a48c26f9f40bcf"
        ],
        [
            "elim (invert_heap a G D); auto with datatypes.",
            "VernacExtend",
            "a53cc3478dfea1a9f43e0031a22a2f80785aa552"
        ],
        [
            "intros H1 H2; elim H2; intros H3 H4; elim H4; intros.",
            "VernacExtend",
            "cff1931f79883fc394378410d5d4a6e59616a65a"
        ],
        [
            "apply X0; auto with datatypes.",
            "VernacExtend",
            "4282e03de659422f3a1c28200d2b29fa700d09d7"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma is_heap_rec : forall P:Tree -> Set, P Tree_Leaf -> (forall (a:A) (T1 T2:Tree), leA_Tree a T1 -> leA_Tree a T2 -> is_heap T1 -> P T1 -> is_heap T2 -> P T2 -> P (Tree_Node a T1 T2)) -> forall T:Tree, is_heap T -> P T.",
            "VernacStartTheoremProof",
            "939202cabc51d909e26dd73afe529d98a59f4437"
        ],
        [
            "simple induction T; auto with datatypes.",
            "VernacExtend",
            "6bd1d870167f25cdcf0defad1a901041d127737e"
        ],
        [
            "intros a G PG D PD PN.",
            "VernacExtend",
            "3b4c19887fdf8b95f89d0d40a3a48c26f9f40bcf"
        ],
        [
            "elim (invert_heap a G D); auto with datatypes.",
            "VernacExtend",
            "a53cc3478dfea1a9f43e0031a22a2f80785aa552"
        ],
        [
            "intros H1 H2; elim H2; intros H3 H4; elim H4; intros.",
            "VernacExtend",
            "cff1931f79883fc394378410d5d4a6e59616a65a"
        ],
        [
            "apply X; auto with datatypes.",
            "VernacExtend",
            "72da4890ff9cd7136b6428fe2210c7a6ff5158e3"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma low_trans : forall (T:Tree) (a b:A), leA a b -> leA_Tree b T -> leA_Tree a T.",
            "VernacStartTheoremProof",
            "175e92b9ea4af97e45842b44bb202a08af4c9590"
        ],
        [
            "simple induction T; auto with datatypes.",
            "VernacExtend",
            "6bd1d870167f25cdcf0defad1a901041d127737e"
        ],
        [
            "intros; simpl; apply leA_trans with b; auto with datatypes.",
            "VernacExtend",
            "7aaaa1aa830f14910637ff1c9312d84518989c32"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Inductive merge_lem (l1 l2:list A) : Type := merge_exist : forall l:list A, Sorted leA l -> meq (list_contents _ eqA_dec l) (munion (list_contents _ eqA_dec l1) (list_contents _ eqA_dec l2)) -> (forall a, HdRel leA a l1 -> HdRel leA a l2 -> HdRel leA a l) -> merge_lem l1 l2.",
            "VernacInductive",
            "e254996a4e86add6a6d6b7aab4896c04a6d5c7ba"
        ],
        [
            "Import Morphisms.",
            "VernacImport",
            "eaaed0c213379e0c231df70b46c1fe69a463348f"
        ],
        [
            "Instance: Equivalence (@meq A).",
            "VernacInstance",
            "dae546bb58a723d7c52e7fc1419b56ca6474e5b7"
        ],
        [
            "constructor; auto with datatypes.",
            "VernacExtend",
            "e0e3bc33ebd13f0a395d8591fc2c15599b8c0499"
        ],
        [
            "red.",
            "VernacExtend",
            "95a3fb9e13ce19fdc8e335912fb83e57a9512b14"
        ],
        [
            "apply meq_trans.",
            "VernacExtend",
            "47b1d5d2c405bad2fd45577f70018490fe550b74"
        ],
        [
            "Defined.",
            "VernacEndProof",
            "88c0be54a50df4bb90276c075406fe442428eb9c"
        ],
        [
            "Instance: Proper (@meq A ++> @meq _ ++> @meq _) (@munion A).",
            "VernacInstance",
            "1638db7a50ee3ec66b8455f4ab5f00ecbd664ece"
        ],
        [
            "intros x y H x' y' H'.",
            "VernacExtend",
            "96523ae2313a6f87a5e8638f8de256193a710a75"
        ],
        [
            "now apply meq_congr.",
            "VernacExtend",
            "7b4583ccaf7bfae5ddc9da6d23d501f9c980542f"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Lemma merge : forall l1:list A, Sorted leA l1 -> forall l2:list A, Sorted leA l2 -> merge_lem l1 l2.",
            "VernacStartTheoremProof",
            "12da43a0d92d6812151d15beb260080abb2f7101"
        ],
        [
            "fix merge 1; intros; destruct l1.",
            "VernacExtend",
            "c0bbd7290e63695f6e0c5ffdbc8ac6bbd9b59191"
        ],
        [
            "apply merge_exist with l2; auto with datatypes.",
            "VernacExtend",
            "2d5a3ffca396a1bc1cfa38059470d8d0d274a28c"
        ],
        [
            "rename l1 into l.",
            "VernacExtend",
            "556ab81dbb9e197b6a16eec2af9fa17e73e843bd"
        ],
        [
            "revert l2 H0.",
            "VernacExtend",
            "f0c00d61b774afb29d838e9b538e88f7e6446fb3"
        ],
        [
            "fix merge0 1.",
            "VernacExtend",
            "4dadeb722f150de2258f9053780dc0f5a1c5b090"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "destruct l2 as [|a0 l0].",
            "VernacExtend",
            "06fa303ba0b40b4e0ce8ef985029e87e61b25958"
        ],
        [
            "apply merge_exist with (a :: l); simpl; auto with datatypes.",
            "VernacExtend",
            "9d42b6d1d48a3531fd7fa5bad8e0bc788170a083"
        ],
        [
            "induction (leA_dec a a0) as [Hle|Hle].",
            "VernacExtend",
            "ebd6177b773e69290fd49f23c5208a94d0558c10"
        ],
        [
            "apply Sorted_inv in H.",
            "VernacExtend",
            "359187b8f8350c90bc0e1605fce20efedb67c496"
        ],
        [
            "destruct H.",
            "VernacExtend",
            "8b2bca015429da94c456243b461e17a2a0582c40"
        ],
        [
            "destruct (merge l H (a0 :: l0) H0) as [l1 H2 H3 H4].",
            "VernacExtend",
            "34be9c392066cc1cba6855a8cf5e58a42b071296"
        ],
        [
            "apply merge_exist with (a :: l1).",
            "VernacExtend",
            "2673f4bb510ac75f8fc3d37d5f97cee6ed5f2f6a"
        ],
        [
            "clear merge merge0.",
            "VernacExtend",
            "0ab3deccef9998e3122342733be66de1962ef4fa"
        ],
        [
            "auto using cons_sort, cons_leA with datatypes.",
            "VernacExtend",
            "5a06670d23b8d4867ac3654cae8ebcb2dffef254"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "rewrite H3.",
            "VernacExtend",
            "c5485dd62873b0ea9ab7d37c26265fb7eea7e9ba"
        ],
        [
            "now rewrite munion_ass.",
            "VernacExtend",
            "ac6c041ca7efe652e4ab41757964de35abb9f0a7"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "apply cons_leA.",
            "VernacExtend",
            "ac435f755a046b9afb6ec10a93f98908ba850b77"
        ],
        [
            "apply (@HdRel_inv _ leA) with l; trivial with datatypes.",
            "VernacExtend",
            "8988a2a27cae0a106f01dba05723cc379ec14229"
        ],
        [
            "apply Sorted_inv in H0.",
            "VernacExtend",
            "bf4fb45fe3ead08b413ce11f90242b7e7cb60d18"
        ],
        [
            "destruct H0.",
            "VernacExtend",
            "5c8f6cb3dc303d56935d6ec271a1de04f6790225"
        ],
        [
            "destruct (merge0 l0 H0) as [l1 H2 H3 H4].",
            "VernacExtend",
            "7aa3b990c224cb9341d94a5600b87334447fa90d"
        ],
        [
            "clear merge merge0.",
            "VernacExtend",
            "0ab3deccef9998e3122342733be66de1962ef4fa"
        ],
        [
            "apply merge_exist with (a0 :: l1); auto using cons_sort, cons_leA with datatypes.",
            "VernacExtend",
            "5fbae99040def97f95c0c7e42929bba63911fe04"
        ],
        [
            "simpl; rewrite H3.",
            "VernacExtend",
            "8426c482ab0b17eabe6436a7378c74d9bfbffd9d"
        ],
        [
            "simpl.",
            "VernacExtend",
            "1b93169f4cf876d207c1fab22a2347202ab48d85"
        ],
        [
            "setoid_rewrite munion_ass at 1.",
            "VernacExtend",
            "465ff343ecaa1b769857dd9fdf2a5062265a84de"
        ],
        [
            "rewrite munion_comm.",
            "VernacExtend",
            "e68b0ecbd51147ead866843027c1dc76330dadd3"
        ],
        [
            "repeat rewrite munion_ass.",
            "VernacExtend",
            "2fc8930342da466e1d61f60ae8522ec609beb046"
        ],
        [
            "setoid_rewrite munion_comm at 3.",
            "VernacExtend",
            "6d2258308e8c4cb9bfcf63f1e110739757250955"
        ],
        [
            "reflexivity.",
            "VernacExtend",
            "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "apply cons_leA.",
            "VernacExtend",
            "ac435f755a046b9afb6ec10a93f98908ba850b77"
        ],
        [
            "apply (@HdRel_inv _ leA) with l0; trivial with datatypes.",
            "VernacExtend",
            "9a0a65ee8c0575920b4c810cd863f0523f5ea361"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Fixpoint contents (t:Tree) : multiset A := match t with | Tree_Leaf => emptyBag | Tree_Node a t1 t2 => munion (contents t1) (munion (contents t2) (singletonBag a)) end.",
            "VernacFixpoint",
            "aa6d466913bc2de68e65e4e32d18c9efece8240f"
        ],
        [
            "Definition equiv_Tree (t1 t2:Tree) := meq (contents t1) (contents t2).",
            "VernacDefinition",
            "1473dd6e7535c55e06a147677e8af74bc6edd855"
        ],
        [
            "Inductive insert_spec (a:A) (T:Tree) : Type := insert_exist : forall T1:Tree, is_heap T1 -> meq (contents T1) (munion (contents T) (singletonBag a)) -> (forall b:A, leA b a -> leA_Tree b T -> leA_Tree b T1) -> insert_spec a T.",
            "VernacInductive",
            "39aaa2d0b14e337dffadb0801fdf22f63c7b193a"
        ],
        [
            "Lemma insert : forall T:Tree, is_heap T -> forall a:A, insert_spec a T.",
            "VernacStartTheoremProof",
            "a89e2dd423aedf68cbb8ccc9194de0518124cdfd"
        ],
        [
            "simple induction 1; intros.",
            "VernacExtend",
            "8b54c80df1b4890684639c3f84a62f176fb57476"
        ],
        [
            "apply insert_exist with (Tree_Node a Tree_Leaf Tree_Leaf); auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
            "VernacExtend",
            "431809ed91e7548d0ceee406d51a7eb71f2cfe0e"
        ],
        [
            "simpl; unfold meq, munion; auto using node_is_heap with datatypes.",
            "VernacExtend",
            "a478f643ab171e69345f6ad73a4d723732ad6608"
        ],
        [
            "elim (leA_dec a a0); intros.",
            "VernacExtend",
            "e43f9ecc1a22a2c87d13a03fcc69865329820b78"
        ],
        [
            "elim (X a0); intros.",
            "VernacExtend",
            "76aa10c0ac9895d64d53d7464f249df67e091709"
        ],
        [
            "apply insert_exist with (Tree_Node a T2 T0); auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
            "VernacExtend",
            "140289180637be00c5ed2d52b24900465420c471"
        ],
        [
            "simpl; apply treesort_twist1; trivial with datatypes.",
            "VernacExtend",
            "9587f5840c4978bfd4f2f8031a84849ec9ddfad0"
        ],
        [
            "elim (X a); intros T3 HeapT3 ConT3 LeA.",
            "VernacExtend",
            "3a207a6c56ebcfd38e88b97541dc828fd9a5c45b"
        ],
        [
            "apply insert_exist with (Tree_Node a0 T2 T3); auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
            "VernacExtend",
            "db4f4951e952cbf43d4e1babce9ded69c12355fb"
        ],
        [
            "apply node_is_heap; auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
            "VernacExtend",
            "6f0600709b157e4866d737fb2a5ef542a8e56371"
        ],
        [
            "apply low_trans with a; auto with datatypes.",
            "VernacExtend",
            "7d826aa7c5c6700a6e78d399db2447af08908ceb"
        ],
        [
            "apply LeA; auto with datatypes.",
            "VernacExtend",
            "c46a295f6e1af7c28b8f0ed6c817e0b5325c4358"
        ],
        [
            "apply low_trans with a; auto with datatypes.",
            "VernacExtend",
            "7d826aa7c5c6700a6e78d399db2447af08908ceb"
        ],
        [
            "simpl; apply treesort_twist2; trivial with datatypes.",
            "VernacExtend",
            "aff85cef3dee7424db4a108de5a5037cd8781e0e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Inductive build_heap (l:list A) : Type := heap_exist : forall T:Tree, is_heap T -> meq (list_contents _ eqA_dec l) (contents T) -> build_heap l.",
            "VernacInductive",
            "ad65cdb14d4ad56b480fde37a42ce3bb8f8f3769"
        ],
        [
            "Lemma list_to_heap : forall l:list A, build_heap l.",
            "VernacStartTheoremProof",
            "52315d2d9577532cd177e71f8d9b876a6738e35f"
        ],
        [
            "simple induction l.",
            "VernacExtend",
            "baf54048118103088e518cfa16c3b5327b3c1c28"
        ],
        [
            "apply (heap_exist nil Tree_Leaf); auto with datatypes.",
            "VernacExtend",
            "ca93575a99b47cdac9244c96b33bbda69568b737"
        ],
        [
            "simpl; unfold meq; exact nil_is_heap.",
            "VernacExtend",
            "10922a8272cdbd659b2e5a8a874e1a097752d6b3"
        ],
        [
            "simple induction 1.",
            "VernacExtend",
            "b1f838dd75029717483785a8785c7867663c75bc"
        ],
        [
            "intros T i m; elim (insert T i a).",
            "VernacExtend",
            "1e5ffc83041341d7bdeb50e4953c87333639117e"
        ],
        [
            "intros; apply heap_exist with T1; simpl; auto with datatypes.",
            "VernacExtend",
            "2032e9685b55b137dcdad2f42e609f4e0eb8aca2"
        ],
        [
            "apply meq_trans with (munion (contents T) (singletonBag a)).",
            "VernacExtend",
            "d6853ad1345e97d44f57b417d89508415d4e4d10"
        ],
        [
            "apply meq_trans with (munion (singletonBag a) (contents T)).",
            "VernacExtend",
            "d7fb3336d3200125e05d0f4a2e014017e8e336f4"
        ],
        [
            "apply meq_right; trivial with datatypes.",
            "VernacExtend",
            "aacf9dd8dedb0dff63d10cab1adc0c05b7d98286"
        ],
        [
            "apply munion_comm.",
            "VernacExtend",
            "5b5779953d3e168df6211ef1d5f1909d4107ae99"
        ],
        [
            "apply meq_sym; trivial with datatypes.",
            "VernacExtend",
            "f882bb7206bd4479f43d67d58764c0cb976d7452"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Inductive flat_spec (T:Tree) : Type := flat_exist : forall l:list A, Sorted leA l -> (forall a:A, leA_Tree a T -> HdRel leA a l) -> meq (contents T) (list_contents _ eqA_dec l) -> flat_spec T.",
            "VernacInductive",
            "137ee35429eb95d6e9562318d741085f1629d29d"
        ],
        [
            "Lemma heap_to_list : forall T:Tree, is_heap T -> flat_spec T.",
            "VernacStartTheoremProof",
            "39ca9620f9c54e993998355ef15780e42368c19b"
        ],
        [
            "intros T h; elim h; intros.",
            "VernacExtend",
            "6ba224bc357443deec68a636ab6f9a49a0d64981"
        ],
        [
            "apply flat_exist with (nil (A:=A)); auto with datatypes.",
            "VernacExtend",
            "11e3ca7679add9ee2f30203e785ebde0575668b1"
        ],
        [
            "elim X; intros l1 s1 i1 m1; elim X0; intros l2 s2 i2 m2.",
            "VernacExtend",
            "bc088a5bef48cb7e56738a2dfa51c80aa44ec6dd"
        ],
        [
            "elim (merge _ s1 _ s2); intros.",
            "VernacExtend",
            "2a2a502cdcf860433f3e97c6b15187411cd70a55"
        ],
        [
            "apply flat_exist with (a :: l); simpl; auto with datatypes.",
            "VernacExtend",
            "9043257785e48f3979270f7e35b6b112fd1e3f7f"
        ],
        [
            "apply meq_trans with (munion (list_contents _ eqA_dec l1) (munion (list_contents _ eqA_dec l2) (singletonBag a))).",
            "VernacExtend",
            "c911bf3fd8d132a88002ae45060cb4acf8614184"
        ],
        [
            "apply meq_congr; auto with datatypes.",
            "VernacExtend",
            "0b66bc7fb621ca206b6412bd0f63a423412637b7"
        ],
        [
            "apply meq_trans with (munion (singletonBag a) (munion (list_contents _ eqA_dec l1) (list_contents _ eqA_dec l2))).",
            "VernacExtend",
            "f5ed0b51b892a6e021b7cca5fd229a61d610dc51"
        ],
        [
            "apply munion_rotate.",
            "VernacExtend",
            "45499f42bc97b5d467bb6e0e4a643348242fa9fc"
        ],
        [
            "apply meq_right; apply meq_sym; trivial with datatypes.",
            "VernacExtend",
            "7e7097d12558be86003668b21e8414750c8d9978"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "Theorem treesort : forall l:list A, {m : list A | Sorted leA m & permutation _ eqA_dec l m}.",
            "VernacStartTheoremProof",
            "da2c65eaf03bbb574a90e3f115d0ca24b854deaf"
        ],
        [
            "intro l; unfold permutation.",
            "VernacExtend",
            "f7a4ee0c1c2d76e43656e8bd45c51c59c283efca"
        ],
        [
            "elim (list_to_heap l).",
            "VernacExtend",
            "ad32fb7212579f78c31704483e6d7d07362dcb98"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "elim (heap_to_list T); auto with datatypes.",
            "VernacExtend",
            "d562a863a959710e847213de443f55d69a82266b"
        ],
        [
            "intros.",
            "VernacExtend",
            "1b4df911c5412d25278e46f48402870ba987996b"
        ],
        [
            "exists l0; auto with datatypes.",
            "VernacExtend",
            "2ec4fdd7a9353e600c8a49ad2f9cbacc6eb621cb"
        ],
        [
            "apply meq_trans with (contents T); trivial with datatypes.",
            "VernacExtend",
            "e7bddd4d61e3324b2a06d9c173015232e963069e"
        ],
        [
            "Qed.",
            "VernacEndProof",
            "6eee6c55dea8e22a11abc36404343a43e520a888"
        ],
        [
            "End defs.",
            "VernacEndSegment",
            "87576c6333190ed552d0c65e1ba8ba7213ced428"
        ]
    ],
    "proofs": [
        {
            "name": "leA_Tree_Leaf",
            "line_nb": 17,
            "steps": [
                {
                    "command": [
                        "simpl; auto with datatypes.",
                        "VernacExtend",
                        "51538b4519a60126c6d1f66f99e6b1c1aa8da1f7"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "leA_Tree_Node",
            "line_nb": 20,
            "steps": [
                {
                    "command": [
                        "simpl; auto with datatypes.",
                        "VernacExtend",
                        "51538b4519a60126c6d1f66f99e6b1c1aa8da1f7"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "invert_heap",
            "line_nb": 24,
            "steps": [
                {
                    "command": [
                        "intros; inversion H; auto with datatypes.",
                        "VernacExtend",
                        "c852946a05b3f8f99843addbe2c330050065193f"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "is_heap_rect",
            "line_nb": 27,
            "steps": [
                {
                    "command": [
                        "simple induction T; auto with datatypes.",
                        "VernacExtend",
                        "6bd1d870167f25cdcf0defad1a901041d127737e"
                    ]
                },
                {
                    "command": [
                        "intros a G PG D PD PN.",
                        "VernacExtend",
                        "3b4c19887fdf8b95f89d0d40a3a48c26f9f40bcf"
                    ]
                },
                {
                    "command": [
                        "elim (invert_heap a G D); auto with datatypes.",
                        "VernacExtend",
                        "a53cc3478dfea1a9f43e0031a22a2f80785aa552"
                    ]
                },
                {
                    "command": [
                        "intros H1 H2; elim H2; intros H3 H4; elim H4; intros.",
                        "VernacExtend",
                        "cff1931f79883fc394378410d5d4a6e59616a65a"
                    ]
                },
                {
                    "command": [
                        "apply X0; auto with datatypes.",
                        "VernacExtend",
                        "4282e03de659422f3a1c28200d2b29fa700d09d7"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "is_heap_rec",
            "line_nb": 34,
            "steps": [
                {
                    "command": [
                        "simple induction T; auto with datatypes.",
                        "VernacExtend",
                        "6bd1d870167f25cdcf0defad1a901041d127737e"
                    ]
                },
                {
                    "command": [
                        "intros a G PG D PD PN.",
                        "VernacExtend",
                        "3b4c19887fdf8b95f89d0d40a3a48c26f9f40bcf"
                    ]
                },
                {
                    "command": [
                        "elim (invert_heap a G D); auto with datatypes.",
                        "VernacExtend",
                        "a53cc3478dfea1a9f43e0031a22a2f80785aa552"
                    ]
                },
                {
                    "command": [
                        "intros H1 H2; elim H2; intros H3 H4; elim H4; intros.",
                        "VernacExtend",
                        "cff1931f79883fc394378410d5d4a6e59616a65a"
                    ]
                },
                {
                    "command": [
                        "apply X; auto with datatypes.",
                        "VernacExtend",
                        "72da4890ff9cd7136b6428fe2210c7a6ff5158e3"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "low_trans",
            "line_nb": 41,
            "steps": [
                {
                    "command": [
                        "simple induction T; auto with datatypes.",
                        "VernacExtend",
                        "6bd1d870167f25cdcf0defad1a901041d127737e"
                    ]
                },
                {
                    "command": [
                        "intros; simpl; apply leA_trans with b; auto with datatypes.",
                        "VernacExtend",
                        "7aaaa1aa830f14910637ff1c9312d84518989c32"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "Equivalence_instance_0",
            "line_nb": 47,
            "steps": [
                {
                    "command": [
                        "constructor; auto with datatypes.",
                        "VernacExtend",
                        "e0e3bc33ebd13f0a395d8591fc2c15599b8c0499"
                    ]
                },
                {
                    "command": [
                        "red.",
                        "VernacExtend",
                        "95a3fb9e13ce19fdc8e335912fb83e57a9512b14"
                    ]
                },
                {
                    "command": [
                        "apply meq_trans.",
                        "VernacExtend",
                        "47b1d5d2c405bad2fd45577f70018490fe550b74"
                    ]
                },
                {
                    "command": [
                        "Defined.",
                        "VernacEndProof",
                        "88c0be54a50df4bb90276c075406fe442428eb9c"
                    ]
                }
            ]
        },
        {
            "name": "Proper_instance_0",
            "line_nb": 52,
            "steps": [
                {
                    "command": [
                        "intros x y H x' y' H'.",
                        "VernacExtend",
                        "96523ae2313a6f87a5e8638f8de256193a710a75"
                    ]
                },
                {
                    "command": [
                        "now apply meq_congr.",
                        "VernacExtend",
                        "7b4583ccaf7bfae5ddc9da6d23d501f9c980542f"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "merge",
            "line_nb": 56,
            "steps": [
                {
                    "command": [
                        "fix merge 1; intros; destruct l1.",
                        "VernacExtend",
                        "c0bbd7290e63695f6e0c5ffdbc8ac6bbd9b59191"
                    ]
                },
                {
                    "command": [
                        "apply merge_exist with l2; auto with datatypes.",
                        "VernacExtend",
                        "2d5a3ffca396a1bc1cfa38059470d8d0d274a28c"
                    ]
                },
                {
                    "command": [
                        "rename l1 into l.",
                        "VernacExtend",
                        "556ab81dbb9e197b6a16eec2af9fa17e73e843bd"
                    ]
                },
                {
                    "command": [
                        "revert l2 H0.",
                        "VernacExtend",
                        "f0c00d61b774afb29d838e9b538e88f7e6446fb3"
                    ]
                },
                {
                    "command": [
                        "fix merge0 1.",
                        "VernacExtend",
                        "4dadeb722f150de2258f9053780dc0f5a1c5b090"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "destruct l2 as [|a0 l0].",
                        "VernacExtend",
                        "06fa303ba0b40b4e0ce8ef985029e87e61b25958"
                    ]
                },
                {
                    "command": [
                        "apply merge_exist with (a :: l); simpl; auto with datatypes.",
                        "VernacExtend",
                        "9d42b6d1d48a3531fd7fa5bad8e0bc788170a083"
                    ]
                },
                {
                    "command": [
                        "induction (leA_dec a a0) as [Hle|Hle].",
                        "VernacExtend",
                        "ebd6177b773e69290fd49f23c5208a94d0558c10"
                    ]
                },
                {
                    "command": [
                        "apply Sorted_inv in H.",
                        "VernacExtend",
                        "359187b8f8350c90bc0e1605fce20efedb67c496"
                    ]
                },
                {
                    "command": [
                        "destruct H.",
                        "VernacExtend",
                        "8b2bca015429da94c456243b461e17a2a0582c40"
                    ]
                },
                {
                    "command": [
                        "destruct (merge l H (a0 :: l0) H0) as [l1 H2 H3 H4].",
                        "VernacExtend",
                        "34be9c392066cc1cba6855a8cf5e58a42b071296"
                    ]
                },
                {
                    "command": [
                        "apply merge_exist with (a :: l1).",
                        "VernacExtend",
                        "2673f4bb510ac75f8fc3d37d5f97cee6ed5f2f6a"
                    ]
                },
                {
                    "command": [
                        "clear merge merge0.",
                        "VernacExtend",
                        "0ab3deccef9998e3122342733be66de1962ef4fa"
                    ]
                },
                {
                    "command": [
                        "auto using cons_sort, cons_leA with datatypes.",
                        "VernacExtend",
                        "5a06670d23b8d4867ac3654cae8ebcb2dffef254"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "rewrite H3.",
                        "VernacExtend",
                        "c5485dd62873b0ea9ab7d37c26265fb7eea7e9ba"
                    ]
                },
                {
                    "command": [
                        "now rewrite munion_ass.",
                        "VernacExtend",
                        "ac6c041ca7efe652e4ab41757964de35abb9f0a7"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "apply cons_leA.",
                        "VernacExtend",
                        "ac435f755a046b9afb6ec10a93f98908ba850b77"
                    ]
                },
                {
                    "command": [
                        "apply (@HdRel_inv _ leA) with l; trivial with datatypes.",
                        "VernacExtend",
                        "8988a2a27cae0a106f01dba05723cc379ec14229"
                    ]
                },
                {
                    "command": [
                        "apply Sorted_inv in H0.",
                        "VernacExtend",
                        "bf4fb45fe3ead08b413ce11f90242b7e7cb60d18"
                    ]
                },
                {
                    "command": [
                        "destruct H0.",
                        "VernacExtend",
                        "5c8f6cb3dc303d56935d6ec271a1de04f6790225"
                    ]
                },
                {
                    "command": [
                        "destruct (merge0 l0 H0) as [l1 H2 H3 H4].",
                        "VernacExtend",
                        "7aa3b990c224cb9341d94a5600b87334447fa90d"
                    ]
                },
                {
                    "command": [
                        "clear merge merge0.",
                        "VernacExtend",
                        "0ab3deccef9998e3122342733be66de1962ef4fa"
                    ]
                },
                {
                    "command": [
                        "apply merge_exist with (a0 :: l1); auto using cons_sort, cons_leA with datatypes.",
                        "VernacExtend",
                        "5fbae99040def97f95c0c7e42929bba63911fe04"
                    ]
                },
                {
                    "command": [
                        "simpl; rewrite H3.",
                        "VernacExtend",
                        "8426c482ab0b17eabe6436a7378c74d9bfbffd9d"
                    ]
                },
                {
                    "command": [
                        "simpl.",
                        "VernacExtend",
                        "1b93169f4cf876d207c1fab22a2347202ab48d85"
                    ]
                },
                {
                    "command": [
                        "setoid_rewrite munion_ass at 1.",
                        "VernacExtend",
                        "465ff343ecaa1b769857dd9fdf2a5062265a84de"
                    ]
                },
                {
                    "command": [
                        "rewrite munion_comm.",
                        "VernacExtend",
                        "e68b0ecbd51147ead866843027c1dc76330dadd3"
                    ]
                },
                {
                    "command": [
                        "repeat rewrite munion_ass.",
                        "VernacExtend",
                        "2fc8930342da466e1d61f60ae8522ec609beb046"
                    ]
                },
                {
                    "command": [
                        "setoid_rewrite munion_comm at 3.",
                        "VernacExtend",
                        "6d2258308e8c4cb9bfcf63f1e110739757250955"
                    ]
                },
                {
                    "command": [
                        "reflexivity.",
                        "VernacExtend",
                        "5cd1ae044f26cd6d89a5a5147c1d4fc5fc719d83"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "apply cons_leA.",
                        "VernacExtend",
                        "ac435f755a046b9afb6ec10a93f98908ba850b77"
                    ]
                },
                {
                    "command": [
                        "apply (@HdRel_inv _ leA) with l0; trivial with datatypes.",
                        "VernacExtend",
                        "9a0a65ee8c0575920b4c810cd863f0523f5ea361"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "insert",
            "line_nb": 97,
            "steps": [
                {
                    "command": [
                        "simple induction 1; intros.",
                        "VernacExtend",
                        "8b54c80df1b4890684639c3f84a62f176fb57476"
                    ]
                },
                {
                    "command": [
                        "apply insert_exist with (Tree_Node a Tree_Leaf Tree_Leaf); auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
                        "VernacExtend",
                        "431809ed91e7548d0ceee406d51a7eb71f2cfe0e"
                    ]
                },
                {
                    "command": [
                        "simpl; unfold meq, munion; auto using node_is_heap with datatypes.",
                        "VernacExtend",
                        "a478f643ab171e69345f6ad73a4d723732ad6608"
                    ]
                },
                {
                    "command": [
                        "elim (leA_dec a a0); intros.",
                        "VernacExtend",
                        "e43f9ecc1a22a2c87d13a03fcc69865329820b78"
                    ]
                },
                {
                    "command": [
                        "elim (X a0); intros.",
                        "VernacExtend",
                        "76aa10c0ac9895d64d53d7464f249df67e091709"
                    ]
                },
                {
                    "command": [
                        "apply insert_exist with (Tree_Node a T2 T0); auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
                        "VernacExtend",
                        "140289180637be00c5ed2d52b24900465420c471"
                    ]
                },
                {
                    "command": [
                        "simpl; apply treesort_twist1; trivial with datatypes.",
                        "VernacExtend",
                        "9587f5840c4978bfd4f2f8031a84849ec9ddfad0"
                    ]
                },
                {
                    "command": [
                        "elim (X a); intros T3 HeapT3 ConT3 LeA.",
                        "VernacExtend",
                        "3a207a6c56ebcfd38e88b97541dc828fd9a5c45b"
                    ]
                },
                {
                    "command": [
                        "apply insert_exist with (Tree_Node a0 T2 T3); auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
                        "VernacExtend",
                        "db4f4951e952cbf43d4e1babce9ded69c12355fb"
                    ]
                },
                {
                    "command": [
                        "apply node_is_heap; auto using node_is_heap, nil_is_heap, leA_Tree_Leaf with datatypes.",
                        "VernacExtend",
                        "6f0600709b157e4866d737fb2a5ef542a8e56371"
                    ]
                },
                {
                    "command": [
                        "apply low_trans with a; auto with datatypes.",
                        "VernacExtend",
                        "7d826aa7c5c6700a6e78d399db2447af08908ceb"
                    ]
                },
                {
                    "command": [
                        "apply LeA; auto with datatypes.",
                        "VernacExtend",
                        "c46a295f6e1af7c28b8f0ed6c817e0b5325c4358"
                    ]
                },
                {
                    "command": [
                        "apply low_trans with a; auto with datatypes.",
                        "VernacExtend",
                        "7d826aa7c5c6700a6e78d399db2447af08908ceb"
                    ]
                },
                {
                    "command": [
                        "simpl; apply treesort_twist2; trivial with datatypes.",
                        "VernacExtend",
                        "aff85cef3dee7424db4a108de5a5037cd8781e0e"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "list_to_heap",
            "line_nb": 114,
            "steps": [
                {
                    "command": [
                        "simple induction l.",
                        "VernacExtend",
                        "baf54048118103088e518cfa16c3b5327b3c1c28"
                    ]
                },
                {
                    "command": [
                        "apply (heap_exist nil Tree_Leaf); auto with datatypes.",
                        "VernacExtend",
                        "ca93575a99b47cdac9244c96b33bbda69568b737"
                    ]
                },
                {
                    "command": [
                        "simpl; unfold meq; exact nil_is_heap.",
                        "VernacExtend",
                        "10922a8272cdbd659b2e5a8a874e1a097752d6b3"
                    ]
                },
                {
                    "command": [
                        "simple induction 1.",
                        "VernacExtend",
                        "b1f838dd75029717483785a8785c7867663c75bc"
                    ]
                },
                {
                    "command": [
                        "intros T i m; elim (insert T i a).",
                        "VernacExtend",
                        "1e5ffc83041341d7bdeb50e4953c87333639117e"
                    ]
                },
                {
                    "command": [
                        "intros; apply heap_exist with T1; simpl; auto with datatypes.",
                        "VernacExtend",
                        "2032e9685b55b137dcdad2f42e609f4e0eb8aca2"
                    ]
                },
                {
                    "command": [
                        "apply meq_trans with (munion (contents T) (singletonBag a)).",
                        "VernacExtend",
                        "d6853ad1345e97d44f57b417d89508415d4e4d10"
                    ]
                },
                {
                    "command": [
                        "apply meq_trans with (munion (singletonBag a) (contents T)).",
                        "VernacExtend",
                        "d7fb3336d3200125e05d0f4a2e014017e8e336f4"
                    ]
                },
                {
                    "command": [
                        "apply meq_right; trivial with datatypes.",
                        "VernacExtend",
                        "aacf9dd8dedb0dff63d10cab1adc0c05b7d98286"
                    ]
                },
                {
                    "command": [
                        "apply munion_comm.",
                        "VernacExtend",
                        "5b5779953d3e168df6211ef1d5f1909d4107ae99"
                    ]
                },
                {
                    "command": [
                        "apply meq_sym; trivial with datatypes.",
                        "VernacExtend",
                        "f882bb7206bd4479f43d67d58764c0cb976d7452"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "heap_to_list",
            "line_nb": 128,
            "steps": [
                {
                    "command": [
                        "intros T h; elim h; intros.",
                        "VernacExtend",
                        "6ba224bc357443deec68a636ab6f9a49a0d64981"
                    ]
                },
                {
                    "command": [
                        "apply flat_exist with (nil (A:=A)); auto with datatypes.",
                        "VernacExtend",
                        "11e3ca7679add9ee2f30203e785ebde0575668b1"
                    ]
                },
                {
                    "command": [
                        "elim X; intros l1 s1 i1 m1; elim X0; intros l2 s2 i2 m2.",
                        "VernacExtend",
                        "bc088a5bef48cb7e56738a2dfa51c80aa44ec6dd"
                    ]
                },
                {
                    "command": [
                        "elim (merge _ s1 _ s2); intros.",
                        "VernacExtend",
                        "2a2a502cdcf860433f3e97c6b15187411cd70a55"
                    ]
                },
                {
                    "command": [
                        "apply flat_exist with (a :: l); simpl; auto with datatypes.",
                        "VernacExtend",
                        "9043257785e48f3979270f7e35b6b112fd1e3f7f"
                    ]
                },
                {
                    "command": [
                        "apply meq_trans with (munion (list_contents _ eqA_dec l1) (munion (list_contents _ eqA_dec l2) (singletonBag a))).",
                        "VernacExtend",
                        "c911bf3fd8d132a88002ae45060cb4acf8614184"
                    ]
                },
                {
                    "command": [
                        "apply meq_congr; auto with datatypes.",
                        "VernacExtend",
                        "0b66bc7fb621ca206b6412bd0f63a423412637b7"
                    ]
                },
                {
                    "command": [
                        "apply meq_trans with (munion (singletonBag a) (munion (list_contents _ eqA_dec l1) (list_contents _ eqA_dec l2))).",
                        "VernacExtend",
                        "f5ed0b51b892a6e021b7cca5fd229a61d610dc51"
                    ]
                },
                {
                    "command": [
                        "apply munion_rotate.",
                        "VernacExtend",
                        "45499f42bc97b5d467bb6e0e4a643348242fa9fc"
                    ]
                },
                {
                    "command": [
                        "apply meq_right; apply meq_sym; trivial with datatypes.",
                        "VernacExtend",
                        "7e7097d12558be86003668b21e8414750c8d9978"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        },
        {
            "name": "treesort",
            "line_nb": 140,
            "steps": [
                {
                    "command": [
                        "intro l; unfold permutation.",
                        "VernacExtend",
                        "f7a4ee0c1c2d76e43656e8bd45c51c59c283efca"
                    ]
                },
                {
                    "command": [
                        "elim (list_to_heap l).",
                        "VernacExtend",
                        "ad32fb7212579f78c31704483e6d7d07362dcb98"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "elim (heap_to_list T); auto with datatypes.",
                        "VernacExtend",
                        "d562a863a959710e847213de443f55d69a82266b"
                    ]
                },
                {
                    "command": [
                        "intros.",
                        "VernacExtend",
                        "1b4df911c5412d25278e46f48402870ba987996b"
                    ]
                },
                {
                    "command": [
                        "exists l0; auto with datatypes.",
                        "VernacExtend",
                        "2ec4fdd7a9353e600c8a49ad2f9cbacc6eb621cb"
                    ]
                },
                {
                    "command": [
                        "apply meq_trans with (contents T); trivial with datatypes.",
                        "VernacExtend",
                        "e7bddd4d61e3324b2a06d9c173015232e963069e"
                    ]
                },
                {
                    "command": [
                        "Qed.",
                        "VernacEndProof",
                        "6eee6c55dea8e22a11abc36404343a43e520a888"
                    ]
                }
            ]
        }
    ]
}